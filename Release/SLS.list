
SLS.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000001d8  08020000  08020000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000aaf8  080201e0  080201e0  000011e0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       000175d4  0802acd8  0802acd8  0000bcd8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM          00000008  080422ac  080422ac  000232ac  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .init_array   00000004  080422b4  080422b4  000232b4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .fini_array   00000004  080422b8  080422b8  000232b8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .data         00000190  20000000  080422bc  00024000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          00023e28  20000190  0804244c  00024190  2**3
                  ALLOC
  8 ._user_heap_stack 00000800  20023fb8  0804244c  00024fb8  2**0
                  ALLOC
  9 .ARM.attributes 00000030  00000000  00000000  00024190  2**0
                  CONTENTS, READONLY
 10 .debug_info   000264c0  00000000  00000000  000241c0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_abbrev 00007b76  00000000  00000000  0004a680  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_loclists 0000edec  00000000  00000000  000521f6  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_aranges 000016f8  00000000  00000000  00060fe8  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_rnglists 000020c7  00000000  00000000  000626e0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_macro  00028456  00000000  00000000  000647a7  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_line   0002ec9a  00000000  00000000  0008cbfd  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_str    000dad11  00000000  00000000  000bb897  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .comment      000000b1  00000000  00000000  001965a8  2**0
                  CONTENTS, READONLY
 19 .debug_frame  00004d2c  00000000  00000000  0019665c  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_loc    00002eea  00000000  00000000  0019b388  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_ranges 00000080  00000000  00000000  0019e272  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

080201e0 <__do_global_dtors_aux>:
 80201e0:	b510      	push	{r4, lr}
 80201e2:	4c05      	ldr	r4, [pc, #20]	@ (80201f8 <__do_global_dtors_aux+0x18>)
 80201e4:	7823      	ldrb	r3, [r4, #0]
 80201e6:	b933      	cbnz	r3, 80201f6 <__do_global_dtors_aux+0x16>
 80201e8:	4b04      	ldr	r3, [pc, #16]	@ (80201fc <__do_global_dtors_aux+0x1c>)
 80201ea:	b113      	cbz	r3, 80201f2 <__do_global_dtors_aux+0x12>
 80201ec:	4804      	ldr	r0, [pc, #16]	@ (8020200 <__do_global_dtors_aux+0x20>)
 80201ee:	f3af 8000 	nop.w
 80201f2:	2301      	movs	r3, #1
 80201f4:	7023      	strb	r3, [r4, #0]
 80201f6:	bd10      	pop	{r4, pc}
 80201f8:	20000190 	.word	0x20000190
 80201fc:	00000000 	.word	0x00000000
 8020200:	0802acc0 	.word	0x0802acc0

08020204 <frame_dummy>:
 8020204:	b508      	push	{r3, lr}
 8020206:	4b03      	ldr	r3, [pc, #12]	@ (8020214 <frame_dummy+0x10>)
 8020208:	b11b      	cbz	r3, 8020212 <frame_dummy+0xe>
 802020a:	4903      	ldr	r1, [pc, #12]	@ (8020218 <frame_dummy+0x14>)
 802020c:	4803      	ldr	r0, [pc, #12]	@ (802021c <frame_dummy+0x18>)
 802020e:	f3af 8000 	nop.w
 8020212:	bd08      	pop	{r3, pc}
 8020214:	00000000 	.word	0x00000000
 8020218:	20000194 	.word	0x20000194
 802021c:	0802acc0 	.word	0x0802acc0

08020220 <arm_bitreversal_32>:
 8020220:	1c4b      	adds	r3, r1, #1
 8020222:	2b01      	cmp	r3, #1
 8020224:	bf98      	it	ls
 8020226:	4770      	bxls	lr
 8020228:	e92d 03f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9}
 802022c:	1c91      	adds	r1, r2, #2
 802022e:	089b      	lsrs	r3, r3, #2

08020230 <arm_bitreversal_32_0>:
 8020230:	f8b1 8004 	ldrh.w	r8, [r1, #4]
 8020234:	f8b1 9002 	ldrh.w	r9, [r1, #2]
 8020238:	880a      	ldrh	r2, [r1, #0]
 802023a:	f831 cc02 	ldrh.w	ip, [r1, #-2]
 802023e:	4480      	add	r8, r0
 8020240:	4481      	add	r9, r0
 8020242:	4402      	add	r2, r0
 8020244:	4484      	add	ip, r0
 8020246:	f8d9 7000 	ldr.w	r7, [r9]
 802024a:	f8d8 6000 	ldr.w	r6, [r8]
 802024e:	6815      	ldr	r5, [r2, #0]
 8020250:	f8dc 4000 	ldr.w	r4, [ip]
 8020254:	f8c9 6000 	str.w	r6, [r9]
 8020258:	f8c8 7000 	str.w	r7, [r8]
 802025c:	f8cc 5000 	str.w	r5, [ip]
 8020260:	6014      	str	r4, [r2, #0]
 8020262:	f8d9 7004 	ldr.w	r7, [r9, #4]
 8020266:	f8d8 6004 	ldr.w	r6, [r8, #4]
 802026a:	6855      	ldr	r5, [r2, #4]
 802026c:	f8dc 4004 	ldr.w	r4, [ip, #4]
 8020270:	f8c9 6004 	str.w	r6, [r9, #4]
 8020274:	f8c8 7004 	str.w	r7, [r8, #4]
 8020278:	f8cc 5004 	str.w	r5, [ip, #4]
 802027c:	6054      	str	r4, [r2, #4]
 802027e:	3108      	adds	r1, #8
 8020280:	3b01      	subs	r3, #1
 8020282:	d1d5      	bne.n	8020230 <arm_bitreversal_32_0>
 8020284:	e8bd 03f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9}
 8020288:	4770      	bx	lr

0802028a <arm_bitreversal_16>:
 802028a:	1c4b      	adds	r3, r1, #1
 802028c:	2b01      	cmp	r3, #1
 802028e:	bf98      	it	ls
 8020290:	4770      	bxls	lr
 8020292:	e92d 03f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9}
 8020296:	1c91      	adds	r1, r2, #2
 8020298:	089b      	lsrs	r3, r3, #2

0802029a <arm_bitreversal_16_0>:
 802029a:	f8b1 8004 	ldrh.w	r8, [r1, #4]
 802029e:	f8b1 9002 	ldrh.w	r9, [r1, #2]
 80202a2:	880a      	ldrh	r2, [r1, #0]
 80202a4:	f831 cc02 	ldrh.w	ip, [r1, #-2]
 80202a8:	eb00 0858 	add.w	r8, r0, r8, lsr #1
 80202ac:	eb00 0959 	add.w	r9, r0, r9, lsr #1
 80202b0:	eb00 0252 	add.w	r2, r0, r2, lsr #1
 80202b4:	eb00 0c5c 	add.w	ip, r0, ip, lsr #1
 80202b8:	f8d9 7000 	ldr.w	r7, [r9]
 80202bc:	f8d8 6000 	ldr.w	r6, [r8]
 80202c0:	6815      	ldr	r5, [r2, #0]
 80202c2:	f8dc 4000 	ldr.w	r4, [ip]
 80202c6:	f8c9 6000 	str.w	r6, [r9]
 80202ca:	f8c8 7000 	str.w	r7, [r8]
 80202ce:	f8cc 5000 	str.w	r5, [ip]
 80202d2:	6014      	str	r4, [r2, #0]
 80202d4:	3108      	adds	r1, #8
 80202d6:	3b01      	subs	r3, #1
 80202d8:	d1df      	bne.n	802029a <arm_bitreversal_16_0>
 80202da:	e8bd 03f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9}
 80202de:	4770      	bx	lr

080202e0 <strlen>:
 80202e0:	4603      	mov	r3, r0
 80202e2:	f813 2b01 	ldrb.w	r2, [r3], #1
 80202e6:	2a00      	cmp	r2, #0
 80202e8:	d1fb      	bne.n	80202e2 <strlen+0x2>
 80202ea:	1a18      	subs	r0, r3, r0
 80202ec:	3801      	subs	r0, #1
 80202ee:	4770      	bx	lr

080202f0 <memchr>:
 80202f0:	f001 01ff 	and.w	r1, r1, #255	@ 0xff
 80202f4:	2a10      	cmp	r2, #16
 80202f6:	db2b      	blt.n	8020350 <memchr+0x60>
 80202f8:	f010 0f07 	tst.w	r0, #7
 80202fc:	d008      	beq.n	8020310 <memchr+0x20>
 80202fe:	f810 3b01 	ldrb.w	r3, [r0], #1
 8020302:	3a01      	subs	r2, #1
 8020304:	428b      	cmp	r3, r1
 8020306:	d02d      	beq.n	8020364 <memchr+0x74>
 8020308:	f010 0f07 	tst.w	r0, #7
 802030c:	b342      	cbz	r2, 8020360 <memchr+0x70>
 802030e:	d1f6      	bne.n	80202fe <memchr+0xe>
 8020310:	b4f0      	push	{r4, r5, r6, r7}
 8020312:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 8020316:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 802031a:	f022 0407 	bic.w	r4, r2, #7
 802031e:	f07f 0700 	mvns.w	r7, #0
 8020322:	2300      	movs	r3, #0
 8020324:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8020328:	3c08      	subs	r4, #8
 802032a:	ea85 0501 	eor.w	r5, r5, r1
 802032e:	ea86 0601 	eor.w	r6, r6, r1
 8020332:	fa85 f547 	uadd8	r5, r5, r7
 8020336:	faa3 f587 	sel	r5, r3, r7
 802033a:	fa86 f647 	uadd8	r6, r6, r7
 802033e:	faa5 f687 	sel	r6, r5, r7
 8020342:	b98e      	cbnz	r6, 8020368 <memchr+0x78>
 8020344:	d1ee      	bne.n	8020324 <memchr+0x34>
 8020346:	bcf0      	pop	{r4, r5, r6, r7}
 8020348:	f001 01ff 	and.w	r1, r1, #255	@ 0xff
 802034c:	f002 0207 	and.w	r2, r2, #7
 8020350:	b132      	cbz	r2, 8020360 <memchr+0x70>
 8020352:	f810 3b01 	ldrb.w	r3, [r0], #1
 8020356:	3a01      	subs	r2, #1
 8020358:	ea83 0301 	eor.w	r3, r3, r1
 802035c:	b113      	cbz	r3, 8020364 <memchr+0x74>
 802035e:	d1f8      	bne.n	8020352 <memchr+0x62>
 8020360:	2000      	movs	r0, #0
 8020362:	4770      	bx	lr
 8020364:	3801      	subs	r0, #1
 8020366:	4770      	bx	lr
 8020368:	2d00      	cmp	r5, #0
 802036a:	bf06      	itte	eq
 802036c:	4635      	moveq	r5, r6
 802036e:	3803      	subeq	r0, #3
 8020370:	3807      	subne	r0, #7
 8020372:	f015 0f01 	tst.w	r5, #1
 8020376:	d107      	bne.n	8020388 <memchr+0x98>
 8020378:	3001      	adds	r0, #1
 802037a:	f415 7f80 	tst.w	r5, #256	@ 0x100
 802037e:	bf02      	ittt	eq
 8020380:	3001      	addeq	r0, #1
 8020382:	f415 3fc0 	tsteq.w	r5, #98304	@ 0x18000
 8020386:	3001      	addeq	r0, #1
 8020388:	bcf0      	pop	{r4, r5, r6, r7}
 802038a:	3801      	subs	r0, #1
 802038c:	4770      	bx	lr
 802038e:	bf00      	nop

08020390 <__aeabi_drsub>:
 8020390:	f081 4100 	eor.w	r1, r1, #2147483648	@ 0x80000000
 8020394:	e002      	b.n	802039c <__adddf3>
 8020396:	bf00      	nop

08020398 <__aeabi_dsub>:
 8020398:	f083 4300 	eor.w	r3, r3, #2147483648	@ 0x80000000

0802039c <__adddf3>:
 802039c:	b530      	push	{r4, r5, lr}
 802039e:	ea4f 0441 	mov.w	r4, r1, lsl #1
 80203a2:	ea4f 0543 	mov.w	r5, r3, lsl #1
 80203a6:	ea94 0f05 	teq	r4, r5
 80203aa:	bf08      	it	eq
 80203ac:	ea90 0f02 	teqeq	r0, r2
 80203b0:	bf1f      	itttt	ne
 80203b2:	ea54 0c00 	orrsne.w	ip, r4, r0
 80203b6:	ea55 0c02 	orrsne.w	ip, r5, r2
 80203ba:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 80203be:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80203c2:	f000 80e2 	beq.w	802058a <__adddf3+0x1ee>
 80203c6:	ea4f 5454 	mov.w	r4, r4, lsr #21
 80203ca:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 80203ce:	bfb8      	it	lt
 80203d0:	426d      	neglt	r5, r5
 80203d2:	dd0c      	ble.n	80203ee <__adddf3+0x52>
 80203d4:	442c      	add	r4, r5
 80203d6:	ea80 0202 	eor.w	r2, r0, r2
 80203da:	ea81 0303 	eor.w	r3, r1, r3
 80203de:	ea82 0000 	eor.w	r0, r2, r0
 80203e2:	ea83 0101 	eor.w	r1, r3, r1
 80203e6:	ea80 0202 	eor.w	r2, r0, r2
 80203ea:	ea81 0303 	eor.w	r3, r1, r3
 80203ee:	2d36      	cmp	r5, #54	@ 0x36
 80203f0:	bf88      	it	hi
 80203f2:	bd30      	pophi	{r4, r5, pc}
 80203f4:	f011 4f00 	tst.w	r1, #2147483648	@ 0x80000000
 80203f8:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80203fc:	f44f 1c80 	mov.w	ip, #1048576	@ 0x100000
 8020400:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 8020404:	d002      	beq.n	802040c <__adddf3+0x70>
 8020406:	4240      	negs	r0, r0
 8020408:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 802040c:	f013 4f00 	tst.w	r3, #2147483648	@ 0x80000000
 8020410:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8020414:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8020418:	d002      	beq.n	8020420 <__adddf3+0x84>
 802041a:	4252      	negs	r2, r2
 802041c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8020420:	ea94 0f05 	teq	r4, r5
 8020424:	f000 80a7 	beq.w	8020576 <__adddf3+0x1da>
 8020428:	f1a4 0401 	sub.w	r4, r4, #1
 802042c:	f1d5 0e20 	rsbs	lr, r5, #32
 8020430:	db0d      	blt.n	802044e <__adddf3+0xb2>
 8020432:	fa02 fc0e 	lsl.w	ip, r2, lr
 8020436:	fa22 f205 	lsr.w	r2, r2, r5
 802043a:	1880      	adds	r0, r0, r2
 802043c:	f141 0100 	adc.w	r1, r1, #0
 8020440:	fa03 f20e 	lsl.w	r2, r3, lr
 8020444:	1880      	adds	r0, r0, r2
 8020446:	fa43 f305 	asr.w	r3, r3, r5
 802044a:	4159      	adcs	r1, r3
 802044c:	e00e      	b.n	802046c <__adddf3+0xd0>
 802044e:	f1a5 0520 	sub.w	r5, r5, #32
 8020452:	f10e 0e20 	add.w	lr, lr, #32
 8020456:	2a01      	cmp	r2, #1
 8020458:	fa03 fc0e 	lsl.w	ip, r3, lr
 802045c:	bf28      	it	cs
 802045e:	f04c 0c02 	orrcs.w	ip, ip, #2
 8020462:	fa43 f305 	asr.w	r3, r3, r5
 8020466:	18c0      	adds	r0, r0, r3
 8020468:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 802046c:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
 8020470:	d507      	bpl.n	8020482 <__adddf3+0xe6>
 8020472:	f04f 0e00 	mov.w	lr, #0
 8020476:	f1dc 0c00 	rsbs	ip, ip, #0
 802047a:	eb7e 0000 	sbcs.w	r0, lr, r0
 802047e:	eb6e 0101 	sbc.w	r1, lr, r1
 8020482:	f5b1 1f80 	cmp.w	r1, #1048576	@ 0x100000
 8020486:	d31b      	bcc.n	80204c0 <__adddf3+0x124>
 8020488:	f5b1 1f00 	cmp.w	r1, #2097152	@ 0x200000
 802048c:	d30c      	bcc.n	80204a8 <__adddf3+0x10c>
 802048e:	0849      	lsrs	r1, r1, #1
 8020490:	ea5f 0030 	movs.w	r0, r0, rrx
 8020494:	ea4f 0c3c 	mov.w	ip, ip, rrx
 8020498:	f104 0401 	add.w	r4, r4, #1
 802049c:	ea4f 5244 	mov.w	r2, r4, lsl #21
 80204a0:	f512 0f80 	cmn.w	r2, #4194304	@ 0x400000
 80204a4:	f080 809a 	bcs.w	80205dc <__adddf3+0x240>
 80204a8:	f1bc 4f00 	cmp.w	ip, #2147483648	@ 0x80000000
 80204ac:	bf08      	it	eq
 80204ae:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80204b2:	f150 0000 	adcs.w	r0, r0, #0
 80204b6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80204ba:	ea41 0105 	orr.w	r1, r1, r5
 80204be:	bd30      	pop	{r4, r5, pc}
 80204c0:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 80204c4:	4140      	adcs	r0, r0
 80204c6:	eb41 0101 	adc.w	r1, r1, r1
 80204ca:	3c01      	subs	r4, #1
 80204cc:	bf28      	it	cs
 80204ce:	f5b1 1f80 	cmpcs.w	r1, #1048576	@ 0x100000
 80204d2:	d2e9      	bcs.n	80204a8 <__adddf3+0x10c>
 80204d4:	f091 0f00 	teq	r1, #0
 80204d8:	bf04      	itt	eq
 80204da:	4601      	moveq	r1, r0
 80204dc:	2000      	moveq	r0, #0
 80204de:	fab1 f381 	clz	r3, r1
 80204e2:	bf08      	it	eq
 80204e4:	3320      	addeq	r3, #32
 80204e6:	f1a3 030b 	sub.w	r3, r3, #11
 80204ea:	f1b3 0220 	subs.w	r2, r3, #32
 80204ee:	da0c      	bge.n	802050a <__adddf3+0x16e>
 80204f0:	320c      	adds	r2, #12
 80204f2:	dd08      	ble.n	8020506 <__adddf3+0x16a>
 80204f4:	f102 0c14 	add.w	ip, r2, #20
 80204f8:	f1c2 020c 	rsb	r2, r2, #12
 80204fc:	fa01 f00c 	lsl.w	r0, r1, ip
 8020500:	fa21 f102 	lsr.w	r1, r1, r2
 8020504:	e00c      	b.n	8020520 <__adddf3+0x184>
 8020506:	f102 0214 	add.w	r2, r2, #20
 802050a:	bfd8      	it	le
 802050c:	f1c2 0c20 	rsble	ip, r2, #32
 8020510:	fa01 f102 	lsl.w	r1, r1, r2
 8020514:	fa20 fc0c 	lsr.w	ip, r0, ip
 8020518:	bfdc      	itt	le
 802051a:	ea41 010c 	orrle.w	r1, r1, ip
 802051e:	4090      	lslle	r0, r2
 8020520:	1ae4      	subs	r4, r4, r3
 8020522:	bfa2      	ittt	ge
 8020524:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8020528:	4329      	orrge	r1, r5
 802052a:	bd30      	popge	{r4, r5, pc}
 802052c:	ea6f 0404 	mvn.w	r4, r4
 8020530:	3c1f      	subs	r4, #31
 8020532:	da1c      	bge.n	802056e <__adddf3+0x1d2>
 8020534:	340c      	adds	r4, #12
 8020536:	dc0e      	bgt.n	8020556 <__adddf3+0x1ba>
 8020538:	f104 0414 	add.w	r4, r4, #20
 802053c:	f1c4 0220 	rsb	r2, r4, #32
 8020540:	fa20 f004 	lsr.w	r0, r0, r4
 8020544:	fa01 f302 	lsl.w	r3, r1, r2
 8020548:	ea40 0003 	orr.w	r0, r0, r3
 802054c:	fa21 f304 	lsr.w	r3, r1, r4
 8020550:	ea45 0103 	orr.w	r1, r5, r3
 8020554:	bd30      	pop	{r4, r5, pc}
 8020556:	f1c4 040c 	rsb	r4, r4, #12
 802055a:	f1c4 0220 	rsb	r2, r4, #32
 802055e:	fa20 f002 	lsr.w	r0, r0, r2
 8020562:	fa01 f304 	lsl.w	r3, r1, r4
 8020566:	ea40 0003 	orr.w	r0, r0, r3
 802056a:	4629      	mov	r1, r5
 802056c:	bd30      	pop	{r4, r5, pc}
 802056e:	fa21 f004 	lsr.w	r0, r1, r4
 8020572:	4629      	mov	r1, r5
 8020574:	bd30      	pop	{r4, r5, pc}
 8020576:	f094 0f00 	teq	r4, #0
 802057a:	f483 1380 	eor.w	r3, r3, #1048576	@ 0x100000
 802057e:	bf06      	itte	eq
 8020580:	f481 1180 	eoreq.w	r1, r1, #1048576	@ 0x100000
 8020584:	3401      	addeq	r4, #1
 8020586:	3d01      	subne	r5, #1
 8020588:	e74e      	b.n	8020428 <__adddf3+0x8c>
 802058a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 802058e:	bf18      	it	ne
 8020590:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8020594:	d029      	beq.n	80205ea <__adddf3+0x24e>
 8020596:	ea94 0f05 	teq	r4, r5
 802059a:	bf08      	it	eq
 802059c:	ea90 0f02 	teqeq	r0, r2
 80205a0:	d005      	beq.n	80205ae <__adddf3+0x212>
 80205a2:	ea54 0c00 	orrs.w	ip, r4, r0
 80205a6:	bf04      	itt	eq
 80205a8:	4619      	moveq	r1, r3
 80205aa:	4610      	moveq	r0, r2
 80205ac:	bd30      	pop	{r4, r5, pc}
 80205ae:	ea91 0f03 	teq	r1, r3
 80205b2:	bf1e      	ittt	ne
 80205b4:	2100      	movne	r1, #0
 80205b6:	2000      	movne	r0, #0
 80205b8:	bd30      	popne	{r4, r5, pc}
 80205ba:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 80205be:	d105      	bne.n	80205cc <__adddf3+0x230>
 80205c0:	0040      	lsls	r0, r0, #1
 80205c2:	4149      	adcs	r1, r1
 80205c4:	bf28      	it	cs
 80205c6:	f041 4100 	orrcs.w	r1, r1, #2147483648	@ 0x80000000
 80205ca:	bd30      	pop	{r4, r5, pc}
 80205cc:	f514 0480 	adds.w	r4, r4, #4194304	@ 0x400000
 80205d0:	bf3c      	itt	cc
 80205d2:	f501 1180 	addcc.w	r1, r1, #1048576	@ 0x100000
 80205d6:	bd30      	popcc	{r4, r5, pc}
 80205d8:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
 80205dc:	f045 41fe 	orr.w	r1, r5, #2130706432	@ 0x7f000000
 80205e0:	f441 0170 	orr.w	r1, r1, #15728640	@ 0xf00000
 80205e4:	f04f 0000 	mov.w	r0, #0
 80205e8:	bd30      	pop	{r4, r5, pc}
 80205ea:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80205ee:	bf1a      	itte	ne
 80205f0:	4619      	movne	r1, r3
 80205f2:	4610      	movne	r0, r2
 80205f4:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 80205f8:	bf1c      	itt	ne
 80205fa:	460b      	movne	r3, r1
 80205fc:	4602      	movne	r2, r0
 80205fe:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8020602:	bf06      	itte	eq
 8020604:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 8020608:	ea91 0f03 	teqeq	r1, r3
 802060c:	f441 2100 	orrne.w	r1, r1, #524288	@ 0x80000
 8020610:	bd30      	pop	{r4, r5, pc}
 8020612:	bf00      	nop

08020614 <__aeabi_ui2d>:
 8020614:	f090 0f00 	teq	r0, #0
 8020618:	bf04      	itt	eq
 802061a:	2100      	moveq	r1, #0
 802061c:	4770      	bxeq	lr
 802061e:	b530      	push	{r4, r5, lr}
 8020620:	f44f 6480 	mov.w	r4, #1024	@ 0x400
 8020624:	f104 0432 	add.w	r4, r4, #50	@ 0x32
 8020628:	f04f 0500 	mov.w	r5, #0
 802062c:	f04f 0100 	mov.w	r1, #0
 8020630:	e750      	b.n	80204d4 <__adddf3+0x138>
 8020632:	bf00      	nop

08020634 <__aeabi_i2d>:
 8020634:	f090 0f00 	teq	r0, #0
 8020638:	bf04      	itt	eq
 802063a:	2100      	moveq	r1, #0
 802063c:	4770      	bxeq	lr
 802063e:	b530      	push	{r4, r5, lr}
 8020640:	f44f 6480 	mov.w	r4, #1024	@ 0x400
 8020644:	f104 0432 	add.w	r4, r4, #50	@ 0x32
 8020648:	f010 4500 	ands.w	r5, r0, #2147483648	@ 0x80000000
 802064c:	bf48      	it	mi
 802064e:	4240      	negmi	r0, r0
 8020650:	f04f 0100 	mov.w	r1, #0
 8020654:	e73e      	b.n	80204d4 <__adddf3+0x138>
 8020656:	bf00      	nop

08020658 <__aeabi_f2d>:
 8020658:	0042      	lsls	r2, r0, #1
 802065a:	ea4f 01e2 	mov.w	r1, r2, asr #3
 802065e:	ea4f 0131 	mov.w	r1, r1, rrx
 8020662:	ea4f 7002 	mov.w	r0, r2, lsl #28
 8020666:	bf1f      	itttt	ne
 8020668:	f012 437f 	andsne.w	r3, r2, #4278190080	@ 0xff000000
 802066c:	f093 4f7f 	teqne	r3, #4278190080	@ 0xff000000
 8020670:	f081 5160 	eorne.w	r1, r1, #939524096	@ 0x38000000
 8020674:	4770      	bxne	lr
 8020676:	f032 427f 	bics.w	r2, r2, #4278190080	@ 0xff000000
 802067a:	bf08      	it	eq
 802067c:	4770      	bxeq	lr
 802067e:	f093 4f7f 	teq	r3, #4278190080	@ 0xff000000
 8020682:	bf04      	itt	eq
 8020684:	f441 2100 	orreq.w	r1, r1, #524288	@ 0x80000
 8020688:	4770      	bxeq	lr
 802068a:	b530      	push	{r4, r5, lr}
 802068c:	f44f 7460 	mov.w	r4, #896	@ 0x380
 8020690:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
 8020694:	f021 4100 	bic.w	r1, r1, #2147483648	@ 0x80000000
 8020698:	e71c      	b.n	80204d4 <__adddf3+0x138>
 802069a:	bf00      	nop

0802069c <__aeabi_ul2d>:
 802069c:	ea50 0201 	orrs.w	r2, r0, r1
 80206a0:	bf08      	it	eq
 80206a2:	4770      	bxeq	lr
 80206a4:	b530      	push	{r4, r5, lr}
 80206a6:	f04f 0500 	mov.w	r5, #0
 80206aa:	e00a      	b.n	80206c2 <__aeabi_l2d+0x16>

080206ac <__aeabi_l2d>:
 80206ac:	ea50 0201 	orrs.w	r2, r0, r1
 80206b0:	bf08      	it	eq
 80206b2:	4770      	bxeq	lr
 80206b4:	b530      	push	{r4, r5, lr}
 80206b6:	f011 4500 	ands.w	r5, r1, #2147483648	@ 0x80000000
 80206ba:	d502      	bpl.n	80206c2 <__aeabi_l2d+0x16>
 80206bc:	4240      	negs	r0, r0
 80206be:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80206c2:	f44f 6480 	mov.w	r4, #1024	@ 0x400
 80206c6:	f104 0432 	add.w	r4, r4, #50	@ 0x32
 80206ca:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 80206ce:	f43f aed8 	beq.w	8020482 <__adddf3+0xe6>
 80206d2:	f04f 0203 	mov.w	r2, #3
 80206d6:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80206da:	bf18      	it	ne
 80206dc:	3203      	addne	r2, #3
 80206de:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80206e2:	bf18      	it	ne
 80206e4:	3203      	addne	r2, #3
 80206e6:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 80206ea:	f1c2 0320 	rsb	r3, r2, #32
 80206ee:	fa00 fc03 	lsl.w	ip, r0, r3
 80206f2:	fa20 f002 	lsr.w	r0, r0, r2
 80206f6:	fa01 fe03 	lsl.w	lr, r1, r3
 80206fa:	ea40 000e 	orr.w	r0, r0, lr
 80206fe:	fa21 f102 	lsr.w	r1, r1, r2
 8020702:	4414      	add	r4, r2
 8020704:	e6bd      	b.n	8020482 <__adddf3+0xe6>
 8020706:	bf00      	nop

08020708 <__aeabi_dmul>:
 8020708:	b570      	push	{r4, r5, r6, lr}
 802070a:	f04f 0cff 	mov.w	ip, #255	@ 0xff
 802070e:	f44c 6ce0 	orr.w	ip, ip, #1792	@ 0x700
 8020712:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8020716:	bf1d      	ittte	ne
 8020718:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 802071c:	ea94 0f0c 	teqne	r4, ip
 8020720:	ea95 0f0c 	teqne	r5, ip
 8020724:	f000 f8de 	bleq	80208e4 <__aeabi_dmul+0x1dc>
 8020728:	442c      	add	r4, r5
 802072a:	ea81 0603 	eor.w	r6, r1, r3
 802072e:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 8020732:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 8020736:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 802073a:	bf18      	it	ne
 802073c:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 8020740:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 8020744:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
 8020748:	d038      	beq.n	80207bc <__aeabi_dmul+0xb4>
 802074a:	fba0 ce02 	umull	ip, lr, r0, r2
 802074e:	f04f 0500 	mov.w	r5, #0
 8020752:	fbe1 e502 	umlal	lr, r5, r1, r2
 8020756:	f006 4200 	and.w	r2, r6, #2147483648	@ 0x80000000
 802075a:	fbe0 e503 	umlal	lr, r5, r0, r3
 802075e:	f04f 0600 	mov.w	r6, #0
 8020762:	fbe1 5603 	umlal	r5, r6, r1, r3
 8020766:	f09c 0f00 	teq	ip, #0
 802076a:	bf18      	it	ne
 802076c:	f04e 0e01 	orrne.w	lr, lr, #1
 8020770:	f1a4 04ff 	sub.w	r4, r4, #255	@ 0xff
 8020774:	f5b6 7f00 	cmp.w	r6, #512	@ 0x200
 8020778:	f564 7440 	sbc.w	r4, r4, #768	@ 0x300
 802077c:	d204      	bcs.n	8020788 <__aeabi_dmul+0x80>
 802077e:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 8020782:	416d      	adcs	r5, r5
 8020784:	eb46 0606 	adc.w	r6, r6, r6
 8020788:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 802078c:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 8020790:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 8020794:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 8020798:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 802079c:	f1b4 0cfd 	subs.w	ip, r4, #253	@ 0xfd
 80207a0:	bf88      	it	hi
 80207a2:	f5bc 6fe0 	cmphi.w	ip, #1792	@ 0x700
 80207a6:	d81e      	bhi.n	80207e6 <__aeabi_dmul+0xde>
 80207a8:	f1be 4f00 	cmp.w	lr, #2147483648	@ 0x80000000
 80207ac:	bf08      	it	eq
 80207ae:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 80207b2:	f150 0000 	adcs.w	r0, r0, #0
 80207b6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80207ba:	bd70      	pop	{r4, r5, r6, pc}
 80207bc:	f006 4600 	and.w	r6, r6, #2147483648	@ 0x80000000
 80207c0:	ea46 0101 	orr.w	r1, r6, r1
 80207c4:	ea40 0002 	orr.w	r0, r0, r2
 80207c8:	ea81 0103 	eor.w	r1, r1, r3
 80207cc:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 80207d0:	bfc2      	ittt	gt
 80207d2:	ebd4 050c 	rsbsgt	r5, r4, ip
 80207d6:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80207da:	bd70      	popgt	{r4, r5, r6, pc}
 80207dc:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 80207e0:	f04f 0e00 	mov.w	lr, #0
 80207e4:	3c01      	subs	r4, #1
 80207e6:	f300 80ab 	bgt.w	8020940 <__aeabi_dmul+0x238>
 80207ea:	f114 0f36 	cmn.w	r4, #54	@ 0x36
 80207ee:	bfde      	ittt	le
 80207f0:	2000      	movle	r0, #0
 80207f2:	f001 4100 	andle.w	r1, r1, #2147483648	@ 0x80000000
 80207f6:	bd70      	pople	{r4, r5, r6, pc}
 80207f8:	f1c4 0400 	rsb	r4, r4, #0
 80207fc:	3c20      	subs	r4, #32
 80207fe:	da35      	bge.n	802086c <__aeabi_dmul+0x164>
 8020800:	340c      	adds	r4, #12
 8020802:	dc1b      	bgt.n	802083c <__aeabi_dmul+0x134>
 8020804:	f104 0414 	add.w	r4, r4, #20
 8020808:	f1c4 0520 	rsb	r5, r4, #32
 802080c:	fa00 f305 	lsl.w	r3, r0, r5
 8020810:	fa20 f004 	lsr.w	r0, r0, r4
 8020814:	fa01 f205 	lsl.w	r2, r1, r5
 8020818:	ea40 0002 	orr.w	r0, r0, r2
 802081c:	f001 4200 	and.w	r2, r1, #2147483648	@ 0x80000000
 8020820:	f021 4100 	bic.w	r1, r1, #2147483648	@ 0x80000000
 8020824:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8020828:	fa21 f604 	lsr.w	r6, r1, r4
 802082c:	eb42 0106 	adc.w	r1, r2, r6
 8020830:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8020834:	bf08      	it	eq
 8020836:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 802083a:	bd70      	pop	{r4, r5, r6, pc}
 802083c:	f1c4 040c 	rsb	r4, r4, #12
 8020840:	f1c4 0520 	rsb	r5, r4, #32
 8020844:	fa00 f304 	lsl.w	r3, r0, r4
 8020848:	fa20 f005 	lsr.w	r0, r0, r5
 802084c:	fa01 f204 	lsl.w	r2, r1, r4
 8020850:	ea40 0002 	orr.w	r0, r0, r2
 8020854:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
 8020858:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 802085c:	f141 0100 	adc.w	r1, r1, #0
 8020860:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8020864:	bf08      	it	eq
 8020866:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 802086a:	bd70      	pop	{r4, r5, r6, pc}
 802086c:	f1c4 0520 	rsb	r5, r4, #32
 8020870:	fa00 f205 	lsl.w	r2, r0, r5
 8020874:	ea4e 0e02 	orr.w	lr, lr, r2
 8020878:	fa20 f304 	lsr.w	r3, r0, r4
 802087c:	fa01 f205 	lsl.w	r2, r1, r5
 8020880:	ea43 0302 	orr.w	r3, r3, r2
 8020884:	fa21 f004 	lsr.w	r0, r1, r4
 8020888:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
 802088c:	fa21 f204 	lsr.w	r2, r1, r4
 8020890:	ea20 0002 	bic.w	r0, r0, r2
 8020894:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 8020898:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 802089c:	bf08      	it	eq
 802089e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80208a2:	bd70      	pop	{r4, r5, r6, pc}
 80208a4:	f094 0f00 	teq	r4, #0
 80208a8:	d10f      	bne.n	80208ca <__aeabi_dmul+0x1c2>
 80208aa:	f001 4600 	and.w	r6, r1, #2147483648	@ 0x80000000
 80208ae:	0040      	lsls	r0, r0, #1
 80208b0:	eb41 0101 	adc.w	r1, r1, r1
 80208b4:	f411 1f80 	tst.w	r1, #1048576	@ 0x100000
 80208b8:	bf08      	it	eq
 80208ba:	3c01      	subeq	r4, #1
 80208bc:	d0f7      	beq.n	80208ae <__aeabi_dmul+0x1a6>
 80208be:	ea41 0106 	orr.w	r1, r1, r6
 80208c2:	f095 0f00 	teq	r5, #0
 80208c6:	bf18      	it	ne
 80208c8:	4770      	bxne	lr
 80208ca:	f003 4600 	and.w	r6, r3, #2147483648	@ 0x80000000
 80208ce:	0052      	lsls	r2, r2, #1
 80208d0:	eb43 0303 	adc.w	r3, r3, r3
 80208d4:	f413 1f80 	tst.w	r3, #1048576	@ 0x100000
 80208d8:	bf08      	it	eq
 80208da:	3d01      	subeq	r5, #1
 80208dc:	d0f7      	beq.n	80208ce <__aeabi_dmul+0x1c6>
 80208de:	ea43 0306 	orr.w	r3, r3, r6
 80208e2:	4770      	bx	lr
 80208e4:	ea94 0f0c 	teq	r4, ip
 80208e8:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80208ec:	bf18      	it	ne
 80208ee:	ea95 0f0c 	teqne	r5, ip
 80208f2:	d00c      	beq.n	802090e <__aeabi_dmul+0x206>
 80208f4:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80208f8:	bf18      	it	ne
 80208fa:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80208fe:	d1d1      	bne.n	80208a4 <__aeabi_dmul+0x19c>
 8020900:	ea81 0103 	eor.w	r1, r1, r3
 8020904:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
 8020908:	f04f 0000 	mov.w	r0, #0
 802090c:	bd70      	pop	{r4, r5, r6, pc}
 802090e:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8020912:	bf06      	itte	eq
 8020914:	4610      	moveq	r0, r2
 8020916:	4619      	moveq	r1, r3
 8020918:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 802091c:	d019      	beq.n	8020952 <__aeabi_dmul+0x24a>
 802091e:	ea94 0f0c 	teq	r4, ip
 8020922:	d102      	bne.n	802092a <__aeabi_dmul+0x222>
 8020924:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 8020928:	d113      	bne.n	8020952 <__aeabi_dmul+0x24a>
 802092a:	ea95 0f0c 	teq	r5, ip
 802092e:	d105      	bne.n	802093c <__aeabi_dmul+0x234>
 8020930:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 8020934:	bf1c      	itt	ne
 8020936:	4610      	movne	r0, r2
 8020938:	4619      	movne	r1, r3
 802093a:	d10a      	bne.n	8020952 <__aeabi_dmul+0x24a>
 802093c:	ea81 0103 	eor.w	r1, r1, r3
 8020940:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
 8020944:	f041 41fe 	orr.w	r1, r1, #2130706432	@ 0x7f000000
 8020948:	f441 0170 	orr.w	r1, r1, #15728640	@ 0xf00000
 802094c:	f04f 0000 	mov.w	r0, #0
 8020950:	bd70      	pop	{r4, r5, r6, pc}
 8020952:	f041 41fe 	orr.w	r1, r1, #2130706432	@ 0x7f000000
 8020956:	f441 0178 	orr.w	r1, r1, #16252928	@ 0xf80000
 802095a:	bd70      	pop	{r4, r5, r6, pc}

0802095c <__aeabi_ddiv>:
 802095c:	b570      	push	{r4, r5, r6, lr}
 802095e:	f04f 0cff 	mov.w	ip, #255	@ 0xff
 8020962:	f44c 6ce0 	orr.w	ip, ip, #1792	@ 0x700
 8020966:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 802096a:	bf1d      	ittte	ne
 802096c:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8020970:	ea94 0f0c 	teqne	r4, ip
 8020974:	ea95 0f0c 	teqne	r5, ip
 8020978:	f000 f8a7 	bleq	8020aca <__aeabi_ddiv+0x16e>
 802097c:	eba4 0405 	sub.w	r4, r4, r5
 8020980:	ea81 0e03 	eor.w	lr, r1, r3
 8020984:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8020988:	ea4f 3101 	mov.w	r1, r1, lsl #12
 802098c:	f000 8088 	beq.w	8020aa0 <__aeabi_ddiv+0x144>
 8020990:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8020994:	f04f 5580 	mov.w	r5, #268435456	@ 0x10000000
 8020998:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 802099c:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 80209a0:	ea4f 2202 	mov.w	r2, r2, lsl #8
 80209a4:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 80209a8:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 80209ac:	ea4f 2600 	mov.w	r6, r0, lsl #8
 80209b0:	f00e 4100 	and.w	r1, lr, #2147483648	@ 0x80000000
 80209b4:	429d      	cmp	r5, r3
 80209b6:	bf08      	it	eq
 80209b8:	4296      	cmpeq	r6, r2
 80209ba:	f144 04fd 	adc.w	r4, r4, #253	@ 0xfd
 80209be:	f504 7440 	add.w	r4, r4, #768	@ 0x300
 80209c2:	d202      	bcs.n	80209ca <__aeabi_ddiv+0x6e>
 80209c4:	085b      	lsrs	r3, r3, #1
 80209c6:	ea4f 0232 	mov.w	r2, r2, rrx
 80209ca:	1ab6      	subs	r6, r6, r2
 80209cc:	eb65 0503 	sbc.w	r5, r5, r3
 80209d0:	085b      	lsrs	r3, r3, #1
 80209d2:	ea4f 0232 	mov.w	r2, r2, rrx
 80209d6:	f44f 1080 	mov.w	r0, #1048576	@ 0x100000
 80209da:	f44f 2c00 	mov.w	ip, #524288	@ 0x80000
 80209de:	ebb6 0e02 	subs.w	lr, r6, r2
 80209e2:	eb75 0e03 	sbcs.w	lr, r5, r3
 80209e6:	bf22      	ittt	cs
 80209e8:	1ab6      	subcs	r6, r6, r2
 80209ea:	4675      	movcs	r5, lr
 80209ec:	ea40 000c 	orrcs.w	r0, r0, ip
 80209f0:	085b      	lsrs	r3, r3, #1
 80209f2:	ea4f 0232 	mov.w	r2, r2, rrx
 80209f6:	ebb6 0e02 	subs.w	lr, r6, r2
 80209fa:	eb75 0e03 	sbcs.w	lr, r5, r3
 80209fe:	bf22      	ittt	cs
 8020a00:	1ab6      	subcs	r6, r6, r2
 8020a02:	4675      	movcs	r5, lr
 8020a04:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8020a08:	085b      	lsrs	r3, r3, #1
 8020a0a:	ea4f 0232 	mov.w	r2, r2, rrx
 8020a0e:	ebb6 0e02 	subs.w	lr, r6, r2
 8020a12:	eb75 0e03 	sbcs.w	lr, r5, r3
 8020a16:	bf22      	ittt	cs
 8020a18:	1ab6      	subcs	r6, r6, r2
 8020a1a:	4675      	movcs	r5, lr
 8020a1c:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8020a20:	085b      	lsrs	r3, r3, #1
 8020a22:	ea4f 0232 	mov.w	r2, r2, rrx
 8020a26:	ebb6 0e02 	subs.w	lr, r6, r2
 8020a2a:	eb75 0e03 	sbcs.w	lr, r5, r3
 8020a2e:	bf22      	ittt	cs
 8020a30:	1ab6      	subcs	r6, r6, r2
 8020a32:	4675      	movcs	r5, lr
 8020a34:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8020a38:	ea55 0e06 	orrs.w	lr, r5, r6
 8020a3c:	d018      	beq.n	8020a70 <__aeabi_ddiv+0x114>
 8020a3e:	ea4f 1505 	mov.w	r5, r5, lsl #4
 8020a42:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 8020a46:	ea4f 1606 	mov.w	r6, r6, lsl #4
 8020a4a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8020a4e:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 8020a52:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 8020a56:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 8020a5a:	d1c0      	bne.n	80209de <__aeabi_ddiv+0x82>
 8020a5c:	f411 1f80 	tst.w	r1, #1048576	@ 0x100000
 8020a60:	d10b      	bne.n	8020a7a <__aeabi_ddiv+0x11e>
 8020a62:	ea41 0100 	orr.w	r1, r1, r0
 8020a66:	f04f 0000 	mov.w	r0, #0
 8020a6a:	f04f 4c00 	mov.w	ip, #2147483648	@ 0x80000000
 8020a6e:	e7b6      	b.n	80209de <__aeabi_ddiv+0x82>
 8020a70:	f411 1f80 	tst.w	r1, #1048576	@ 0x100000
 8020a74:	bf04      	itt	eq
 8020a76:	4301      	orreq	r1, r0
 8020a78:	2000      	moveq	r0, #0
 8020a7a:	f1b4 0cfd 	subs.w	ip, r4, #253	@ 0xfd
 8020a7e:	bf88      	it	hi
 8020a80:	f5bc 6fe0 	cmphi.w	ip, #1792	@ 0x700
 8020a84:	f63f aeaf 	bhi.w	80207e6 <__aeabi_dmul+0xde>
 8020a88:	ebb5 0c03 	subs.w	ip, r5, r3
 8020a8c:	bf04      	itt	eq
 8020a8e:	ebb6 0c02 	subseq.w	ip, r6, r2
 8020a92:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8020a96:	f150 0000 	adcs.w	r0, r0, #0
 8020a9a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8020a9e:	bd70      	pop	{r4, r5, r6, pc}
 8020aa0:	f00e 4e00 	and.w	lr, lr, #2147483648	@ 0x80000000
 8020aa4:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 8020aa8:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 8020aac:	bfc2      	ittt	gt
 8020aae:	ebd4 050c 	rsbsgt	r5, r4, ip
 8020ab2:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 8020ab6:	bd70      	popgt	{r4, r5, r6, pc}
 8020ab8:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 8020abc:	f04f 0e00 	mov.w	lr, #0
 8020ac0:	3c01      	subs	r4, #1
 8020ac2:	e690      	b.n	80207e6 <__aeabi_dmul+0xde>
 8020ac4:	ea45 0e06 	orr.w	lr, r5, r6
 8020ac8:	e68d      	b.n	80207e6 <__aeabi_dmul+0xde>
 8020aca:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8020ace:	ea94 0f0c 	teq	r4, ip
 8020ad2:	bf08      	it	eq
 8020ad4:	ea95 0f0c 	teqeq	r5, ip
 8020ad8:	f43f af3b 	beq.w	8020952 <__aeabi_dmul+0x24a>
 8020adc:	ea94 0f0c 	teq	r4, ip
 8020ae0:	d10a      	bne.n	8020af8 <__aeabi_ddiv+0x19c>
 8020ae2:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8020ae6:	f47f af34 	bne.w	8020952 <__aeabi_dmul+0x24a>
 8020aea:	ea95 0f0c 	teq	r5, ip
 8020aee:	f47f af25 	bne.w	802093c <__aeabi_dmul+0x234>
 8020af2:	4610      	mov	r0, r2
 8020af4:	4619      	mov	r1, r3
 8020af6:	e72c      	b.n	8020952 <__aeabi_dmul+0x24a>
 8020af8:	ea95 0f0c 	teq	r5, ip
 8020afc:	d106      	bne.n	8020b0c <__aeabi_ddiv+0x1b0>
 8020afe:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8020b02:	f43f aefd 	beq.w	8020900 <__aeabi_dmul+0x1f8>
 8020b06:	4610      	mov	r0, r2
 8020b08:	4619      	mov	r1, r3
 8020b0a:	e722      	b.n	8020952 <__aeabi_dmul+0x24a>
 8020b0c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8020b10:	bf18      	it	ne
 8020b12:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8020b16:	f47f aec5 	bne.w	80208a4 <__aeabi_dmul+0x19c>
 8020b1a:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 8020b1e:	f47f af0d 	bne.w	802093c <__aeabi_dmul+0x234>
 8020b22:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 8020b26:	f47f aeeb 	bne.w	8020900 <__aeabi_dmul+0x1f8>
 8020b2a:	e712      	b.n	8020952 <__aeabi_dmul+0x24a>

08020b2c <__gedf2>:
 8020b2c:	f04f 3cff 	mov.w	ip, #4294967295
 8020b30:	e006      	b.n	8020b40 <__cmpdf2+0x4>
 8020b32:	bf00      	nop

08020b34 <__ledf2>:
 8020b34:	f04f 0c01 	mov.w	ip, #1
 8020b38:	e002      	b.n	8020b40 <__cmpdf2+0x4>
 8020b3a:	bf00      	nop

08020b3c <__cmpdf2>:
 8020b3c:	f04f 0c01 	mov.w	ip, #1
 8020b40:	f84d cd04 	str.w	ip, [sp, #-4]!
 8020b44:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8020b48:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8020b4c:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8020b50:	bf18      	it	ne
 8020b52:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 8020b56:	d01b      	beq.n	8020b90 <__cmpdf2+0x54>
 8020b58:	b001      	add	sp, #4
 8020b5a:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 8020b5e:	bf0c      	ite	eq
 8020b60:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 8020b64:	ea91 0f03 	teqne	r1, r3
 8020b68:	bf02      	ittt	eq
 8020b6a:	ea90 0f02 	teqeq	r0, r2
 8020b6e:	2000      	moveq	r0, #0
 8020b70:	4770      	bxeq	lr
 8020b72:	f110 0f00 	cmn.w	r0, #0
 8020b76:	ea91 0f03 	teq	r1, r3
 8020b7a:	bf58      	it	pl
 8020b7c:	4299      	cmppl	r1, r3
 8020b7e:	bf08      	it	eq
 8020b80:	4290      	cmpeq	r0, r2
 8020b82:	bf2c      	ite	cs
 8020b84:	17d8      	asrcs	r0, r3, #31
 8020b86:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 8020b8a:	f040 0001 	orr.w	r0, r0, #1
 8020b8e:	4770      	bx	lr
 8020b90:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8020b94:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8020b98:	d102      	bne.n	8020ba0 <__cmpdf2+0x64>
 8020b9a:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 8020b9e:	d107      	bne.n	8020bb0 <__cmpdf2+0x74>
 8020ba0:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8020ba4:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8020ba8:	d1d6      	bne.n	8020b58 <__cmpdf2+0x1c>
 8020baa:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 8020bae:	d0d3      	beq.n	8020b58 <__cmpdf2+0x1c>
 8020bb0:	f85d 0b04 	ldr.w	r0, [sp], #4
 8020bb4:	4770      	bx	lr
 8020bb6:	bf00      	nop

08020bb8 <__aeabi_cdrcmple>:
 8020bb8:	4684      	mov	ip, r0
 8020bba:	4610      	mov	r0, r2
 8020bbc:	4662      	mov	r2, ip
 8020bbe:	468c      	mov	ip, r1
 8020bc0:	4619      	mov	r1, r3
 8020bc2:	4663      	mov	r3, ip
 8020bc4:	e000      	b.n	8020bc8 <__aeabi_cdcmpeq>
 8020bc6:	bf00      	nop

08020bc8 <__aeabi_cdcmpeq>:
 8020bc8:	b501      	push	{r0, lr}
 8020bca:	f7ff ffb7 	bl	8020b3c <__cmpdf2>
 8020bce:	2800      	cmp	r0, #0
 8020bd0:	bf48      	it	mi
 8020bd2:	f110 0f00 	cmnmi.w	r0, #0
 8020bd6:	bd01      	pop	{r0, pc}

08020bd8 <__aeabi_dcmpeq>:
 8020bd8:	f84d ed08 	str.w	lr, [sp, #-8]!
 8020bdc:	f7ff fff4 	bl	8020bc8 <__aeabi_cdcmpeq>
 8020be0:	bf0c      	ite	eq
 8020be2:	2001      	moveq	r0, #1
 8020be4:	2000      	movne	r0, #0
 8020be6:	f85d fb08 	ldr.w	pc, [sp], #8
 8020bea:	bf00      	nop

08020bec <__aeabi_dcmplt>:
 8020bec:	f84d ed08 	str.w	lr, [sp, #-8]!
 8020bf0:	f7ff ffea 	bl	8020bc8 <__aeabi_cdcmpeq>
 8020bf4:	bf34      	ite	cc
 8020bf6:	2001      	movcc	r0, #1
 8020bf8:	2000      	movcs	r0, #0
 8020bfa:	f85d fb08 	ldr.w	pc, [sp], #8
 8020bfe:	bf00      	nop

08020c00 <__aeabi_dcmple>:
 8020c00:	f84d ed08 	str.w	lr, [sp, #-8]!
 8020c04:	f7ff ffe0 	bl	8020bc8 <__aeabi_cdcmpeq>
 8020c08:	bf94      	ite	ls
 8020c0a:	2001      	movls	r0, #1
 8020c0c:	2000      	movhi	r0, #0
 8020c0e:	f85d fb08 	ldr.w	pc, [sp], #8
 8020c12:	bf00      	nop

08020c14 <__aeabi_dcmpge>:
 8020c14:	f84d ed08 	str.w	lr, [sp, #-8]!
 8020c18:	f7ff ffce 	bl	8020bb8 <__aeabi_cdrcmple>
 8020c1c:	bf94      	ite	ls
 8020c1e:	2001      	movls	r0, #1
 8020c20:	2000      	movhi	r0, #0
 8020c22:	f85d fb08 	ldr.w	pc, [sp], #8
 8020c26:	bf00      	nop

08020c28 <__aeabi_dcmpgt>:
 8020c28:	f84d ed08 	str.w	lr, [sp, #-8]!
 8020c2c:	f7ff ffc4 	bl	8020bb8 <__aeabi_cdrcmple>
 8020c30:	bf34      	ite	cc
 8020c32:	2001      	movcc	r0, #1
 8020c34:	2000      	movcs	r0, #0
 8020c36:	f85d fb08 	ldr.w	pc, [sp], #8
 8020c3a:	bf00      	nop

08020c3c <__aeabi_d2uiz>:
 8020c3c:	004a      	lsls	r2, r1, #1
 8020c3e:	d211      	bcs.n	8020c64 <__aeabi_d2uiz+0x28>
 8020c40:	f512 1200 	adds.w	r2, r2, #2097152	@ 0x200000
 8020c44:	d211      	bcs.n	8020c6a <__aeabi_d2uiz+0x2e>
 8020c46:	d50d      	bpl.n	8020c64 <__aeabi_d2uiz+0x28>
 8020c48:	f46f 7378 	mvn.w	r3, #992	@ 0x3e0
 8020c4c:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 8020c50:	d40e      	bmi.n	8020c70 <__aeabi_d2uiz+0x34>
 8020c52:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8020c56:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 8020c5a:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 8020c5e:	fa23 f002 	lsr.w	r0, r3, r2
 8020c62:	4770      	bx	lr
 8020c64:	f04f 0000 	mov.w	r0, #0
 8020c68:	4770      	bx	lr
 8020c6a:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 8020c6e:	d102      	bne.n	8020c76 <__aeabi_d2uiz+0x3a>
 8020c70:	f04f 30ff 	mov.w	r0, #4294967295
 8020c74:	4770      	bx	lr
 8020c76:	f04f 0000 	mov.w	r0, #0
 8020c7a:	4770      	bx	lr

08020c7c <__aeabi_d2f>:
 8020c7c:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8020c80:	f1b2 43e0 	subs.w	r3, r2, #1879048192	@ 0x70000000
 8020c84:	bf24      	itt	cs
 8020c86:	f5b3 1c00 	subscs.w	ip, r3, #2097152	@ 0x200000
 8020c8a:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	@ 0x1fc00000
 8020c8e:	d90d      	bls.n	8020cac <__aeabi_d2f+0x30>
 8020c90:	f001 4c00 	and.w	ip, r1, #2147483648	@ 0x80000000
 8020c94:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 8020c98:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 8020c9c:	f1b2 4f00 	cmp.w	r2, #2147483648	@ 0x80000000
 8020ca0:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 8020ca4:	bf08      	it	eq
 8020ca6:	f020 0001 	biceq.w	r0, r0, #1
 8020caa:	4770      	bx	lr
 8020cac:	f011 4f80 	tst.w	r1, #1073741824	@ 0x40000000
 8020cb0:	d121      	bne.n	8020cf6 <__aeabi_d2f+0x7a>
 8020cb2:	f113 7238 	adds.w	r2, r3, #48234496	@ 0x2e00000
 8020cb6:	bfbc      	itt	lt
 8020cb8:	f001 4000 	andlt.w	r0, r1, #2147483648	@ 0x80000000
 8020cbc:	4770      	bxlt	lr
 8020cbe:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 8020cc2:	ea4f 5252 	mov.w	r2, r2, lsr #21
 8020cc6:	f1c2 0218 	rsb	r2, r2, #24
 8020cca:	f1c2 0c20 	rsb	ip, r2, #32
 8020cce:	fa10 f30c 	lsls.w	r3, r0, ip
 8020cd2:	fa20 f002 	lsr.w	r0, r0, r2
 8020cd6:	bf18      	it	ne
 8020cd8:	f040 0001 	orrne.w	r0, r0, #1
 8020cdc:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8020ce0:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 8020ce4:	fa03 fc0c 	lsl.w	ip, r3, ip
 8020ce8:	ea40 000c 	orr.w	r0, r0, ip
 8020cec:	fa23 f302 	lsr.w	r3, r3, r2
 8020cf0:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8020cf4:	e7cc      	b.n	8020c90 <__aeabi_d2f+0x14>
 8020cf6:	ea7f 5362 	mvns.w	r3, r2, asr #21
 8020cfa:	d107      	bne.n	8020d0c <__aeabi_d2f+0x90>
 8020cfc:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 8020d00:	bf1e      	ittt	ne
 8020d02:	f04f 40fe 	movne.w	r0, #2130706432	@ 0x7f000000
 8020d06:	f440 0040 	orrne.w	r0, r0, #12582912	@ 0xc00000
 8020d0a:	4770      	bxne	lr
 8020d0c:	f001 4000 	and.w	r0, r1, #2147483648	@ 0x80000000
 8020d10:	f040 40fe 	orr.w	r0, r0, #2130706432	@ 0x7f000000
 8020d14:	f440 0000 	orr.w	r0, r0, #8388608	@ 0x800000
 8020d18:	4770      	bx	lr
 8020d1a:	bf00      	nop

08020d1c <__aeabi_uldivmod>:
 8020d1c:	b953      	cbnz	r3, 8020d34 <__aeabi_uldivmod+0x18>
 8020d1e:	b94a      	cbnz	r2, 8020d34 <__aeabi_uldivmod+0x18>
 8020d20:	2900      	cmp	r1, #0
 8020d22:	bf08      	it	eq
 8020d24:	2800      	cmpeq	r0, #0
 8020d26:	bf1c      	itt	ne
 8020d28:	f04f 31ff 	movne.w	r1, #4294967295
 8020d2c:	f04f 30ff 	movne.w	r0, #4294967295
 8020d30:	f000 b988 	b.w	8021044 <__aeabi_idiv0>
 8020d34:	f1ad 0c08 	sub.w	ip, sp, #8
 8020d38:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8020d3c:	f000 f806 	bl	8020d4c <__udivmoddi4>
 8020d40:	f8dd e004 	ldr.w	lr, [sp, #4]
 8020d44:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8020d48:	b004      	add	sp, #16
 8020d4a:	4770      	bx	lr

08020d4c <__udivmoddi4>:
 8020d4c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8020d50:	9d08      	ldr	r5, [sp, #32]
 8020d52:	468e      	mov	lr, r1
 8020d54:	4604      	mov	r4, r0
 8020d56:	4688      	mov	r8, r1
 8020d58:	2b00      	cmp	r3, #0
 8020d5a:	d14a      	bne.n	8020df2 <__udivmoddi4+0xa6>
 8020d5c:	428a      	cmp	r2, r1
 8020d5e:	4617      	mov	r7, r2
 8020d60:	d962      	bls.n	8020e28 <__udivmoddi4+0xdc>
 8020d62:	fab2 f682 	clz	r6, r2
 8020d66:	b14e      	cbz	r6, 8020d7c <__udivmoddi4+0x30>
 8020d68:	f1c6 0320 	rsb	r3, r6, #32
 8020d6c:	fa01 f806 	lsl.w	r8, r1, r6
 8020d70:	fa20 f303 	lsr.w	r3, r0, r3
 8020d74:	40b7      	lsls	r7, r6
 8020d76:	ea43 0808 	orr.w	r8, r3, r8
 8020d7a:	40b4      	lsls	r4, r6
 8020d7c:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 8020d80:	fa1f fc87 	uxth.w	ip, r7
 8020d84:	fbb8 f1fe 	udiv	r1, r8, lr
 8020d88:	0c23      	lsrs	r3, r4, #16
 8020d8a:	fb0e 8811 	mls	r8, lr, r1, r8
 8020d8e:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 8020d92:	fb01 f20c 	mul.w	r2, r1, ip
 8020d96:	429a      	cmp	r2, r3
 8020d98:	d909      	bls.n	8020dae <__udivmoddi4+0x62>
 8020d9a:	18fb      	adds	r3, r7, r3
 8020d9c:	f101 30ff 	add.w	r0, r1, #4294967295
 8020da0:	f080 80ea 	bcs.w	8020f78 <__udivmoddi4+0x22c>
 8020da4:	429a      	cmp	r2, r3
 8020da6:	f240 80e7 	bls.w	8020f78 <__udivmoddi4+0x22c>
 8020daa:	3902      	subs	r1, #2
 8020dac:	443b      	add	r3, r7
 8020dae:	1a9a      	subs	r2, r3, r2
 8020db0:	b2a3      	uxth	r3, r4
 8020db2:	fbb2 f0fe 	udiv	r0, r2, lr
 8020db6:	fb0e 2210 	mls	r2, lr, r0, r2
 8020dba:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8020dbe:	fb00 fc0c 	mul.w	ip, r0, ip
 8020dc2:	459c      	cmp	ip, r3
 8020dc4:	d909      	bls.n	8020dda <__udivmoddi4+0x8e>
 8020dc6:	18fb      	adds	r3, r7, r3
 8020dc8:	f100 32ff 	add.w	r2, r0, #4294967295
 8020dcc:	f080 80d6 	bcs.w	8020f7c <__udivmoddi4+0x230>
 8020dd0:	459c      	cmp	ip, r3
 8020dd2:	f240 80d3 	bls.w	8020f7c <__udivmoddi4+0x230>
 8020dd6:	443b      	add	r3, r7
 8020dd8:	3802      	subs	r0, #2
 8020dda:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
 8020dde:	eba3 030c 	sub.w	r3, r3, ip
 8020de2:	2100      	movs	r1, #0
 8020de4:	b11d      	cbz	r5, 8020dee <__udivmoddi4+0xa2>
 8020de6:	40f3      	lsrs	r3, r6
 8020de8:	2200      	movs	r2, #0
 8020dea:	e9c5 3200 	strd	r3, r2, [r5]
 8020dee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8020df2:	428b      	cmp	r3, r1
 8020df4:	d905      	bls.n	8020e02 <__udivmoddi4+0xb6>
 8020df6:	b10d      	cbz	r5, 8020dfc <__udivmoddi4+0xb0>
 8020df8:	e9c5 0100 	strd	r0, r1, [r5]
 8020dfc:	2100      	movs	r1, #0
 8020dfe:	4608      	mov	r0, r1
 8020e00:	e7f5      	b.n	8020dee <__udivmoddi4+0xa2>
 8020e02:	fab3 f183 	clz	r1, r3
 8020e06:	2900      	cmp	r1, #0
 8020e08:	d146      	bne.n	8020e98 <__udivmoddi4+0x14c>
 8020e0a:	4573      	cmp	r3, lr
 8020e0c:	d302      	bcc.n	8020e14 <__udivmoddi4+0xc8>
 8020e0e:	4282      	cmp	r2, r0
 8020e10:	f200 8105 	bhi.w	802101e <__udivmoddi4+0x2d2>
 8020e14:	1a84      	subs	r4, r0, r2
 8020e16:	eb6e 0203 	sbc.w	r2, lr, r3
 8020e1a:	2001      	movs	r0, #1
 8020e1c:	4690      	mov	r8, r2
 8020e1e:	2d00      	cmp	r5, #0
 8020e20:	d0e5      	beq.n	8020dee <__udivmoddi4+0xa2>
 8020e22:	e9c5 4800 	strd	r4, r8, [r5]
 8020e26:	e7e2      	b.n	8020dee <__udivmoddi4+0xa2>
 8020e28:	2a00      	cmp	r2, #0
 8020e2a:	f000 8090 	beq.w	8020f4e <__udivmoddi4+0x202>
 8020e2e:	fab2 f682 	clz	r6, r2
 8020e32:	2e00      	cmp	r6, #0
 8020e34:	f040 80a4 	bne.w	8020f80 <__udivmoddi4+0x234>
 8020e38:	1a8a      	subs	r2, r1, r2
 8020e3a:	0c03      	lsrs	r3, r0, #16
 8020e3c:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 8020e40:	b280      	uxth	r0, r0
 8020e42:	b2bc      	uxth	r4, r7
 8020e44:	2101      	movs	r1, #1
 8020e46:	fbb2 fcfe 	udiv	ip, r2, lr
 8020e4a:	fb0e 221c 	mls	r2, lr, ip, r2
 8020e4e:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8020e52:	fb04 f20c 	mul.w	r2, r4, ip
 8020e56:	429a      	cmp	r2, r3
 8020e58:	d907      	bls.n	8020e6a <__udivmoddi4+0x11e>
 8020e5a:	18fb      	adds	r3, r7, r3
 8020e5c:	f10c 38ff 	add.w	r8, ip, #4294967295
 8020e60:	d202      	bcs.n	8020e68 <__udivmoddi4+0x11c>
 8020e62:	429a      	cmp	r2, r3
 8020e64:	f200 80e0 	bhi.w	8021028 <__udivmoddi4+0x2dc>
 8020e68:	46c4      	mov	ip, r8
 8020e6a:	1a9b      	subs	r3, r3, r2
 8020e6c:	fbb3 f2fe 	udiv	r2, r3, lr
 8020e70:	fb0e 3312 	mls	r3, lr, r2, r3
 8020e74:	ea40 4303 	orr.w	r3, r0, r3, lsl #16
 8020e78:	fb02 f404 	mul.w	r4, r2, r4
 8020e7c:	429c      	cmp	r4, r3
 8020e7e:	d907      	bls.n	8020e90 <__udivmoddi4+0x144>
 8020e80:	18fb      	adds	r3, r7, r3
 8020e82:	f102 30ff 	add.w	r0, r2, #4294967295
 8020e86:	d202      	bcs.n	8020e8e <__udivmoddi4+0x142>
 8020e88:	429c      	cmp	r4, r3
 8020e8a:	f200 80ca 	bhi.w	8021022 <__udivmoddi4+0x2d6>
 8020e8e:	4602      	mov	r2, r0
 8020e90:	1b1b      	subs	r3, r3, r4
 8020e92:	ea42 400c 	orr.w	r0, r2, ip, lsl #16
 8020e96:	e7a5      	b.n	8020de4 <__udivmoddi4+0x98>
 8020e98:	f1c1 0620 	rsb	r6, r1, #32
 8020e9c:	408b      	lsls	r3, r1
 8020e9e:	fa22 f706 	lsr.w	r7, r2, r6
 8020ea2:	431f      	orrs	r7, r3
 8020ea4:	fa0e f401 	lsl.w	r4, lr, r1
 8020ea8:	fa20 f306 	lsr.w	r3, r0, r6
 8020eac:	fa2e fe06 	lsr.w	lr, lr, r6
 8020eb0:	ea4f 4917 	mov.w	r9, r7, lsr #16
 8020eb4:	4323      	orrs	r3, r4
 8020eb6:	fa00 f801 	lsl.w	r8, r0, r1
 8020eba:	fa1f fc87 	uxth.w	ip, r7
 8020ebe:	fbbe f0f9 	udiv	r0, lr, r9
 8020ec2:	0c1c      	lsrs	r4, r3, #16
 8020ec4:	fb09 ee10 	mls	lr, r9, r0, lr
 8020ec8:	ea44 440e 	orr.w	r4, r4, lr, lsl #16
 8020ecc:	fb00 fe0c 	mul.w	lr, r0, ip
 8020ed0:	45a6      	cmp	lr, r4
 8020ed2:	fa02 f201 	lsl.w	r2, r2, r1
 8020ed6:	d909      	bls.n	8020eec <__udivmoddi4+0x1a0>
 8020ed8:	193c      	adds	r4, r7, r4
 8020eda:	f100 3aff 	add.w	sl, r0, #4294967295
 8020ede:	f080 809c 	bcs.w	802101a <__udivmoddi4+0x2ce>
 8020ee2:	45a6      	cmp	lr, r4
 8020ee4:	f240 8099 	bls.w	802101a <__udivmoddi4+0x2ce>
 8020ee8:	3802      	subs	r0, #2
 8020eea:	443c      	add	r4, r7
 8020eec:	eba4 040e 	sub.w	r4, r4, lr
 8020ef0:	fa1f fe83 	uxth.w	lr, r3
 8020ef4:	fbb4 f3f9 	udiv	r3, r4, r9
 8020ef8:	fb09 4413 	mls	r4, r9, r3, r4
 8020efc:	ea4e 4404 	orr.w	r4, lr, r4, lsl #16
 8020f00:	fb03 fc0c 	mul.w	ip, r3, ip
 8020f04:	45a4      	cmp	ip, r4
 8020f06:	d908      	bls.n	8020f1a <__udivmoddi4+0x1ce>
 8020f08:	193c      	adds	r4, r7, r4
 8020f0a:	f103 3eff 	add.w	lr, r3, #4294967295
 8020f0e:	f080 8082 	bcs.w	8021016 <__udivmoddi4+0x2ca>
 8020f12:	45a4      	cmp	ip, r4
 8020f14:	d97f      	bls.n	8021016 <__udivmoddi4+0x2ca>
 8020f16:	3b02      	subs	r3, #2
 8020f18:	443c      	add	r4, r7
 8020f1a:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 8020f1e:	eba4 040c 	sub.w	r4, r4, ip
 8020f22:	fba0 ec02 	umull	lr, ip, r0, r2
 8020f26:	4564      	cmp	r4, ip
 8020f28:	4673      	mov	r3, lr
 8020f2a:	46e1      	mov	r9, ip
 8020f2c:	d362      	bcc.n	8020ff4 <__udivmoddi4+0x2a8>
 8020f2e:	d05f      	beq.n	8020ff0 <__udivmoddi4+0x2a4>
 8020f30:	b15d      	cbz	r5, 8020f4a <__udivmoddi4+0x1fe>
 8020f32:	ebb8 0203 	subs.w	r2, r8, r3
 8020f36:	eb64 0409 	sbc.w	r4, r4, r9
 8020f3a:	fa04 f606 	lsl.w	r6, r4, r6
 8020f3e:	fa22 f301 	lsr.w	r3, r2, r1
 8020f42:	431e      	orrs	r6, r3
 8020f44:	40cc      	lsrs	r4, r1
 8020f46:	e9c5 6400 	strd	r6, r4, [r5]
 8020f4a:	2100      	movs	r1, #0
 8020f4c:	e74f      	b.n	8020dee <__udivmoddi4+0xa2>
 8020f4e:	fbb1 fcf2 	udiv	ip, r1, r2
 8020f52:	0c01      	lsrs	r1, r0, #16
 8020f54:	ea41 410e 	orr.w	r1, r1, lr, lsl #16
 8020f58:	b280      	uxth	r0, r0
 8020f5a:	ea40 4201 	orr.w	r2, r0, r1, lsl #16
 8020f5e:	463b      	mov	r3, r7
 8020f60:	4638      	mov	r0, r7
 8020f62:	463c      	mov	r4, r7
 8020f64:	46b8      	mov	r8, r7
 8020f66:	46be      	mov	lr, r7
 8020f68:	2620      	movs	r6, #32
 8020f6a:	fbb1 f1f7 	udiv	r1, r1, r7
 8020f6e:	eba2 0208 	sub.w	r2, r2, r8
 8020f72:	ea41 410c 	orr.w	r1, r1, ip, lsl #16
 8020f76:	e766      	b.n	8020e46 <__udivmoddi4+0xfa>
 8020f78:	4601      	mov	r1, r0
 8020f7a:	e718      	b.n	8020dae <__udivmoddi4+0x62>
 8020f7c:	4610      	mov	r0, r2
 8020f7e:	e72c      	b.n	8020dda <__udivmoddi4+0x8e>
 8020f80:	f1c6 0220 	rsb	r2, r6, #32
 8020f84:	fa2e f302 	lsr.w	r3, lr, r2
 8020f88:	40b7      	lsls	r7, r6
 8020f8a:	40b1      	lsls	r1, r6
 8020f8c:	fa20 f202 	lsr.w	r2, r0, r2
 8020f90:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 8020f94:	430a      	orrs	r2, r1
 8020f96:	fbb3 f8fe 	udiv	r8, r3, lr
 8020f9a:	b2bc      	uxth	r4, r7
 8020f9c:	fb0e 3318 	mls	r3, lr, r8, r3
 8020fa0:	0c11      	lsrs	r1, r2, #16
 8020fa2:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 8020fa6:	fb08 f904 	mul.w	r9, r8, r4
 8020faa:	40b0      	lsls	r0, r6
 8020fac:	4589      	cmp	r9, r1
 8020fae:	ea4f 4310 	mov.w	r3, r0, lsr #16
 8020fb2:	b280      	uxth	r0, r0
 8020fb4:	d93e      	bls.n	8021034 <__udivmoddi4+0x2e8>
 8020fb6:	1879      	adds	r1, r7, r1
 8020fb8:	f108 3cff 	add.w	ip, r8, #4294967295
 8020fbc:	d201      	bcs.n	8020fc2 <__udivmoddi4+0x276>
 8020fbe:	4589      	cmp	r9, r1
 8020fc0:	d81f      	bhi.n	8021002 <__udivmoddi4+0x2b6>
 8020fc2:	eba1 0109 	sub.w	r1, r1, r9
 8020fc6:	fbb1 f9fe 	udiv	r9, r1, lr
 8020fca:	fb09 f804 	mul.w	r8, r9, r4
 8020fce:	fb0e 1119 	mls	r1, lr, r9, r1
 8020fd2:	b292      	uxth	r2, r2
 8020fd4:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 8020fd8:	4542      	cmp	r2, r8
 8020fda:	d229      	bcs.n	8021030 <__udivmoddi4+0x2e4>
 8020fdc:	18ba      	adds	r2, r7, r2
 8020fde:	f109 31ff 	add.w	r1, r9, #4294967295
 8020fe2:	d2c4      	bcs.n	8020f6e <__udivmoddi4+0x222>
 8020fe4:	4542      	cmp	r2, r8
 8020fe6:	d2c2      	bcs.n	8020f6e <__udivmoddi4+0x222>
 8020fe8:	f1a9 0102 	sub.w	r1, r9, #2
 8020fec:	443a      	add	r2, r7
 8020fee:	e7be      	b.n	8020f6e <__udivmoddi4+0x222>
 8020ff0:	45f0      	cmp	r8, lr
 8020ff2:	d29d      	bcs.n	8020f30 <__udivmoddi4+0x1e4>
 8020ff4:	ebbe 0302 	subs.w	r3, lr, r2
 8020ff8:	eb6c 0c07 	sbc.w	ip, ip, r7
 8020ffc:	3801      	subs	r0, #1
 8020ffe:	46e1      	mov	r9, ip
 8021000:	e796      	b.n	8020f30 <__udivmoddi4+0x1e4>
 8021002:	eba7 0909 	sub.w	r9, r7, r9
 8021006:	4449      	add	r1, r9
 8021008:	f1a8 0c02 	sub.w	ip, r8, #2
 802100c:	fbb1 f9fe 	udiv	r9, r1, lr
 8021010:	fb09 f804 	mul.w	r8, r9, r4
 8021014:	e7db      	b.n	8020fce <__udivmoddi4+0x282>
 8021016:	4673      	mov	r3, lr
 8021018:	e77f      	b.n	8020f1a <__udivmoddi4+0x1ce>
 802101a:	4650      	mov	r0, sl
 802101c:	e766      	b.n	8020eec <__udivmoddi4+0x1a0>
 802101e:	4608      	mov	r0, r1
 8021020:	e6fd      	b.n	8020e1e <__udivmoddi4+0xd2>
 8021022:	443b      	add	r3, r7
 8021024:	3a02      	subs	r2, #2
 8021026:	e733      	b.n	8020e90 <__udivmoddi4+0x144>
 8021028:	f1ac 0c02 	sub.w	ip, ip, #2
 802102c:	443b      	add	r3, r7
 802102e:	e71c      	b.n	8020e6a <__udivmoddi4+0x11e>
 8021030:	4649      	mov	r1, r9
 8021032:	e79c      	b.n	8020f6e <__udivmoddi4+0x222>
 8021034:	eba1 0109 	sub.w	r1, r1, r9
 8021038:	46c4      	mov	ip, r8
 802103a:	fbb1 f9fe 	udiv	r9, r1, lr
 802103e:	fb09 f804 	mul.w	r8, r9, r4
 8021042:	e7c4      	b.n	8020fce <__udivmoddi4+0x282>

08021044 <__aeabi_idiv0>:
 8021044:	4770      	bx	lr
 8021046:	bf00      	nop

08021048 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8021048:	b570      	push	{r4, r5, r6, lr}
  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 802104a:	4b0e      	ldr	r3, [pc, #56]	@ (8021084 <HAL_InitTick+0x3c>)
 802104c:	4e0e      	ldr	r6, [pc, #56]	@ (8021088 <HAL_InitTick+0x40>)
{
 802104e:	4605      	mov	r5, r0
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 8021050:	7832      	ldrb	r2, [r6, #0]
 8021052:	6818      	ldr	r0, [r3, #0]
 8021054:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
 8021058:	fbb3 f3f2 	udiv	r3, r3, r2
 802105c:	fbb0 f0f3 	udiv	r0, r0, r3
 8021060:	f000 fb54 	bl	802170c <HAL_SYSTICK_Config>
 8021064:	b908      	cbnz	r0, 802106a <HAL_InitTick+0x22>
  {
    return HAL_ERROR;
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8021066:	2d0f      	cmp	r5, #15
 8021068:	d901      	bls.n	802106e <HAL_InitTick+0x26>
    return HAL_ERROR;
 802106a:	2001      	movs	r0, #1
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
}
 802106c:	bd70      	pop	{r4, r5, r6, pc}
 802106e:	4604      	mov	r4, r0
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 8021070:	4602      	mov	r2, r0
 8021072:	4629      	mov	r1, r5
 8021074:	f04f 30ff 	mov.w	r0, #4294967295
 8021078:	f000 fada 	bl	8021630 <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 802107c:	6075      	str	r5, [r6, #4]
 802107e:	4620      	mov	r0, r4
}
 8021080:	bd70      	pop	{r4, r5, r6, pc}
 8021082:	bf00      	nop
 8021084:	20000130 	.word	0x20000130
 8021088:	20000000 	.word	0x20000000

0802108c <HAL_Init>:
{
 802108c:	b508      	push	{r3, lr}
  __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 802108e:	4b0b      	ldr	r3, [pc, #44]	@ (80210bc <HAL_Init+0x30>)
 8021090:	681a      	ldr	r2, [r3, #0]
 8021092:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 8021096:	601a      	str	r2, [r3, #0]
  __HAL_FLASH_DATA_CACHE_ENABLE();
 8021098:	681a      	ldr	r2, [r3, #0]
 802109a:	f442 6280 	orr.w	r2, r2, #1024	@ 0x400
 802109e:	601a      	str	r2, [r3, #0]
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 80210a0:	681a      	ldr	r2, [r3, #0]
 80210a2:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
 80210a6:	601a      	str	r2, [r3, #0]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80210a8:	2003      	movs	r0, #3
 80210aa:	f000 faaf 	bl	802160c <HAL_NVIC_SetPriorityGrouping>
  HAL_InitTick(TICK_INT_PRIORITY);
 80210ae:	2000      	movs	r0, #0
 80210b0:	f7ff ffca 	bl	8021048 <HAL_InitTick>
  HAL_MspInit();
 80210b4:	f007 f9b4 	bl	8028420 <HAL_MspInit>
}
 80210b8:	2000      	movs	r0, #0
 80210ba:	bd08      	pop	{r3, pc}
 80210bc:	40023c00 	.word	0x40023c00

080210c0 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
 80210c0:	4a03      	ldr	r2, [pc, #12]	@ (80210d0 <HAL_IncTick+0x10>)
 80210c2:	4b04      	ldr	r3, [pc, #16]	@ (80210d4 <HAL_IncTick+0x14>)
 80210c4:	6811      	ldr	r1, [r2, #0]
 80210c6:	781b      	ldrb	r3, [r3, #0]
 80210c8:	440b      	add	r3, r1
 80210ca:	6013      	str	r3, [r2, #0]
}
 80210cc:	4770      	bx	lr
 80210ce:	bf00      	nop
 80210d0:	200001ac 	.word	0x200001ac
 80210d4:	20000000 	.word	0x20000000

080210d8 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 80210d8:	4b01      	ldr	r3, [pc, #4]	@ (80210e0 <HAL_GetTick+0x8>)
 80210da:	6818      	ldr	r0, [r3, #0]
}
 80210dc:	4770      	bx	lr
 80210de:	bf00      	nop
 80210e0:	200001ac 	.word	0x200001ac

080210e4 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 80210e4:	b538      	push	{r3, r4, r5, lr}
 80210e6:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 80210e8:	f7ff fff6 	bl	80210d8 <HAL_GetTick>
  uint32_t wait = Delay;

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 80210ec:	1c63      	adds	r3, r4, #1
  uint32_t tickstart = HAL_GetTick();
 80210ee:	4605      	mov	r5, r0
  if (wait < HAL_MAX_DELAY)
 80210f0:	d002      	beq.n	80210f8 <HAL_Delay+0x14>
  {
    wait += (uint32_t)(uwTickFreq);
 80210f2:	4b04      	ldr	r3, [pc, #16]	@ (8021104 <HAL_Delay+0x20>)
 80210f4:	781b      	ldrb	r3, [r3, #0]
 80210f6:	441c      	add	r4, r3
  }

  while((HAL_GetTick() - tickstart) < wait)
 80210f8:	f7ff ffee 	bl	80210d8 <HAL_GetTick>
 80210fc:	1b40      	subs	r0, r0, r5
 80210fe:	42a0      	cmp	r0, r4
 8021100:	d3fa      	bcc.n	80210f8 <HAL_Delay+0x14>
  {
  }
}
 8021102:	bd38      	pop	{r3, r4, r5, pc}
 8021104:	20000000 	.word	0x20000000

08021108 <HAL_GetUIDw0>:
  * @brief  Returns first word of the unique device identifier (UID based on 96 bits)
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw0(void)
{
  return (READ_REG(*((uint32_t *)UID_BASE)));
 8021108:	4b01      	ldr	r3, [pc, #4]	@ (8021110 <HAL_GetUIDw0+0x8>)
}
 802110a:	f8d3 0a10 	ldr.w	r0, [r3, #2576]	@ 0xa10
 802110e:	4770      	bx	lr
 8021110:	1fff7000 	.word	0x1fff7000

08021114 <HAL_GetUIDw1>:
  * @brief  Returns second word of the unique device identifier (UID based on 96 bits)
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw1(void)
{
  return (READ_REG(*((uint32_t *)(UID_BASE + 4U))));
 8021114:	4b01      	ldr	r3, [pc, #4]	@ (802111c <HAL_GetUIDw1+0x8>)
}
 8021116:	f8d3 0a14 	ldr.w	r0, [r3, #2580]	@ 0xa14
 802111a:	4770      	bx	lr
 802111c:	1fff7000 	.word	0x1fff7000

08021120 <HAL_GetUIDw2>:
  * @brief  Returns third word of the unique device identifier (UID based on 96 bits)
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw2(void)
{
  return (READ_REG(*((uint32_t *)(UID_BASE + 8U))));
 8021120:	4b01      	ldr	r3, [pc, #4]	@ (8021128 <HAL_GetUIDw2+0x8>)
}
 8021122:	f8d3 0a18 	ldr.w	r0, [r3, #2584]	@ 0xa18
 8021126:	4770      	bx	lr
 8021128:	1fff7000 	.word	0x1fff7000

0802112c <HAL_ADC_Init>:
HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef* hadc)
{
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
  
  /* Check ADC handle */
  if(hadc == NULL)
 802112c:	2800      	cmp	r0, #0
 802112e:	f000 809e 	beq.w	802126e <HAL_ADC_Init+0x142>
{
 8021132:	b538      	push	{r3, r4, r5, lr}
  if(hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
  {
    assert_param(IS_ADC_EXT_TRIG_EDGE(hadc->Init.ExternalTrigConvEdge));
  }
  
  if(hadc->State == HAL_ADC_STATE_RESET)
 8021134:	6c05      	ldr	r5, [r0, #64]	@ 0x40
 8021136:	4604      	mov	r4, r0
 8021138:	b13d      	cbz	r5, 802114a <HAL_ADC_Init+0x1e>
    hadc->Lock = HAL_UNLOCKED;
  }
  
  /* Configuration of ADC parameters if previous preliminary actions are      */ 
  /* correctly completed.                                                     */
  if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))
 802113a:	6c23      	ldr	r3, [r4, #64]	@ 0x40
 802113c:	06db      	lsls	r3, r3, #27
 802113e:	d50c      	bpl.n	802115a <HAL_ADC_Init+0x2e>
  {
    tmp_hal_status = HAL_ERROR;
  }
  
  /* Release Lock */
  __HAL_UNLOCK(hadc);
 8021140:	2300      	movs	r3, #0
 8021142:	f884 303c 	strb.w	r3, [r4, #60]	@ 0x3c
    tmp_hal_status = HAL_ERROR;
 8021146:	2001      	movs	r0, #1

  /* Return function status */
  return tmp_hal_status;
}
 8021148:	bd38      	pop	{r3, r4, r5, pc}
    HAL_ADC_MspInit(hadc);
 802114a:	f004 fde3 	bl	8025d14 <HAL_ADC_MspInit>
    ADC_CLEAR_ERRORCODE(hadc);
 802114e:	6465      	str	r5, [r4, #68]	@ 0x44
  if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))
 8021150:	6c23      	ldr	r3, [r4, #64]	@ 0x40
    hadc->Lock = HAL_UNLOCKED;
 8021152:	f884 503c 	strb.w	r5, [r4, #60]	@ 0x3c
  if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))
 8021156:	06db      	lsls	r3, r3, #27
 8021158:	d4f2      	bmi.n	8021140 <HAL_ADC_Init+0x14>
    ADC_STATE_CLR_SET(hadc->State,
 802115a:	6c23      	ldr	r3, [r4, #64]	@ 0x40
  /* (Depending on STM32F4 product, there may be up to 3 ADCs and 1 common */
  /* control register)                                                    */
  tmpADC_Common = ADC_COMMON_REGISTER(hadc);
  
  /* Set the ADC clock prescaler */
  tmpADC_Common->CCR &= ~(ADC_CCR_ADCPRE);
 802115c:	4a47      	ldr	r2, [pc, #284]	@ (802127c <HAL_ADC_Init+0x150>)
    ADC_STATE_CLR_SET(hadc->State,
 802115e:	f423 5388 	bic.w	r3, r3, #4352	@ 0x1100
 8021162:	f023 0302 	bic.w	r3, r3, #2
 8021166:	f043 0302 	orr.w	r3, r3, #2
 802116a:	6423      	str	r3, [r4, #64]	@ 0x40
  tmpADC_Common->CCR &= ~(ADC_CCR_ADCPRE);
 802116c:	6851      	ldr	r1, [r2, #4]
  tmpADC_Common->CCR |=  hadc->Init.ClockPrescaler;
  
  /* Set ADC scan mode */
  hadc->Instance->CR1 &= ~(ADC_CR1_SCAN);
 802116e:	6823      	ldr	r3, [r4, #0]
  tmpADC_Common->CCR &= ~(ADC_CCR_ADCPRE);
 8021170:	f421 3140 	bic.w	r1, r1, #196608	@ 0x30000
 8021174:	6051      	str	r1, [r2, #4]
  tmpADC_Common->CCR |=  hadc->Init.ClockPrescaler;
 8021176:	6851      	ldr	r1, [r2, #4]
 8021178:	6860      	ldr	r0, [r4, #4]
 802117a:	4301      	orrs	r1, r0
 802117c:	6051      	str	r1, [r2, #4]
  hadc->Instance->CR1 &= ~(ADC_CR1_SCAN);
 802117e:	685a      	ldr	r2, [r3, #4]
  hadc->Instance->CR1 |=  ADC_CR1_SCANCONV(hadc->Init.ScanConvMode);
 8021180:	6920      	ldr	r0, [r4, #16]
  
  /* Set ADC resolution */
  hadc->Instance->CR1 &= ~(ADC_CR1_RES);
  hadc->Instance->CR1 |=  hadc->Init.Resolution;
 8021182:	68a1      	ldr	r1, [r4, #8]
  hadc->Instance->CR1 &= ~(ADC_CR1_SCAN);
 8021184:	f422 7280 	bic.w	r2, r2, #256	@ 0x100
 8021188:	605a      	str	r2, [r3, #4]
  hadc->Instance->CR1 |=  ADC_CR1_SCANCONV(hadc->Init.ScanConvMode);
 802118a:	685a      	ldr	r2, [r3, #4]
 802118c:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
 8021190:	605a      	str	r2, [r3, #4]
  hadc->Instance->CR1 &= ~(ADC_CR1_RES);
 8021192:	685a      	ldr	r2, [r3, #4]
  
  /* Set ADC data alignment */
  hadc->Instance->CR2 &= ~(ADC_CR2_ALIGN);
  hadc->Instance->CR2 |= hadc->Init.DataAlign;
 8021194:	68e0      	ldr	r0, [r4, #12]
  hadc->Instance->CR1 &= ~(ADC_CR1_RES);
 8021196:	f022 7240 	bic.w	r2, r2, #50331648	@ 0x3000000
 802119a:	605a      	str	r2, [r3, #4]
  hadc->Instance->CR1 |=  hadc->Init.Resolution;
 802119c:	685a      	ldr	r2, [r3, #4]
 802119e:	430a      	orrs	r2, r1
 80211a0:	605a      	str	r2, [r3, #4]
  hadc->Instance->CR2 &= ~(ADC_CR2_ALIGN);
 80211a2:	689a      	ldr	r2, [r3, #8]
  /* Enable external trigger if trigger selection is different of software  */
  /* start.                                                                 */
  /* Note: This configuration keeps the hardware feature of parameter       */
  /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
  /*       software start.                                                  */
  if(hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 80211a4:	6aa1      	ldr	r1, [r4, #40]	@ 0x28
  hadc->Instance->CR2 &= ~(ADC_CR2_ALIGN);
 80211a6:	f422 6200 	bic.w	r2, r2, #2048	@ 0x800
 80211aa:	609a      	str	r2, [r3, #8]
  hadc->Instance->CR2 |= hadc->Init.DataAlign;
 80211ac:	689a      	ldr	r2, [r3, #8]
 80211ae:	4302      	orrs	r2, r0
 80211b0:	609a      	str	r2, [r3, #8]
  if(hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 80211b2:	4a33      	ldr	r2, [pc, #204]	@ (8021280 <HAL_ADC_Init+0x154>)
 80211b4:	4291      	cmp	r1, r2
  {
    /* Select external trigger to start conversion */
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTSEL);
 80211b6:	689a      	ldr	r2, [r3, #8]
  if(hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 80211b8:	d051      	beq.n	802125e <HAL_ADC_Init+0x132>
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTSEL);
 80211ba:	f022 6270 	bic.w	r2, r2, #251658240	@ 0xf000000
    hadc->Instance->CR2 |= hadc->Init.ExternalTrigConv;
    
    /* Select external trigger polarity */
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTEN);
    hadc->Instance->CR2 |= hadc->Init.ExternalTrigConvEdge;
 80211be:	6ae0      	ldr	r0, [r4, #44]	@ 0x2c
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTSEL);
 80211c0:	609a      	str	r2, [r3, #8]
    hadc->Instance->CR2 |= hadc->Init.ExternalTrigConv;
 80211c2:	689a      	ldr	r2, [r3, #8]
 80211c4:	4311      	orrs	r1, r2
 80211c6:	6099      	str	r1, [r3, #8]
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTEN);
 80211c8:	689a      	ldr	r2, [r3, #8]
 80211ca:	f022 5240 	bic.w	r2, r2, #805306368	@ 0x30000000
 80211ce:	609a      	str	r2, [r3, #8]
    hadc->Instance->CR2 |= hadc->Init.ExternalTrigConvEdge;
 80211d0:	689a      	ldr	r2, [r3, #8]
 80211d2:	4302      	orrs	r2, r0
 80211d4:	609a      	str	r2, [r3, #8]
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTSEL);
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTEN);
  }
  
  /* Enable or disable ADC continuous conversion mode */
  hadc->Instance->CR2 &= ~(ADC_CR2_CONT);
 80211d6:	689a      	ldr	r2, [r3, #8]
 80211d8:	f022 0202 	bic.w	r2, r2, #2
 80211dc:	609a      	str	r2, [r3, #8]
  hadc->Instance->CR2 |= ADC_CR2_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode);
 80211de:	689a      	ldr	r2, [r3, #8]
 80211e0:	7e21      	ldrb	r1, [r4, #24]
 80211e2:	ea42 0241 	orr.w	r2, r2, r1, lsl #1
 80211e6:	609a      	str	r2, [r3, #8]
  
  if(hadc->Init.DiscontinuousConvMode != DISABLE)
 80211e8:	f894 2020 	ldrb.w	r2, [r4, #32]
 80211ec:	2a00      	cmp	r2, #0
 80211ee:	d040      	beq.n	8021272 <HAL_ADC_Init+0x146>
  {
    assert_param(IS_ADC_REGULAR_DISC_NUMBER(hadc->Init.NbrOfDiscConversion));
  
    /* Enable the selected ADC regular discontinuous mode */
    hadc->Instance->CR1 |= (uint32_t)ADC_CR1_DISCEN;
 80211f0:	685a      	ldr	r2, [r3, #4]
    
    /* Set the number of channels to be converted in discontinuous mode */
    hadc->Instance->CR1 &= ~(ADC_CR1_DISCNUM);
    hadc->Instance->CR1 |=  ADC_CR1_DISCONTINUOUS(hadc->Init.NbrOfDiscConversion);
 80211f2:	6a61      	ldr	r1, [r4, #36]	@ 0x24
    hadc->Instance->CR1 |= (uint32_t)ADC_CR1_DISCEN;
 80211f4:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
 80211f8:	605a      	str	r2, [r3, #4]
    hadc->Instance->CR1 &= ~(ADC_CR1_DISCNUM);
 80211fa:	685a      	ldr	r2, [r3, #4]
 80211fc:	f422 4260 	bic.w	r2, r2, #57344	@ 0xe000
 8021200:	605a      	str	r2, [r3, #4]
    hadc->Instance->CR1 |=  ADC_CR1_DISCONTINUOUS(hadc->Init.NbrOfDiscConversion);
 8021202:	685a      	ldr	r2, [r3, #4]
 8021204:	3901      	subs	r1, #1
 8021206:	ea42 3241 	orr.w	r2, r2, r1, lsl #13
 802120a:	605a      	str	r2, [r3, #4]
    /* Disable the selected ADC regular discontinuous mode */
    hadc->Instance->CR1 &= ~(ADC_CR1_DISCEN);
  }
  
  /* Set ADC number of conversion */
  hadc->Instance->SQR1 &= ~(ADC_SQR1_L);
 802120c:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
  hadc->Instance->SQR1 |=  ADC_SQR1(hadc->Init.NbrOfConversion);
 802120e:	69e1      	ldr	r1, [r4, #28]
  hadc->Instance->SQR1 &= ~(ADC_SQR1_L);
 8021210:	f422 0270 	bic.w	r2, r2, #15728640	@ 0xf00000
 8021214:	62da      	str	r2, [r3, #44]	@ 0x2c
  hadc->Instance->SQR1 |=  ADC_SQR1(hadc->Init.NbrOfConversion);
 8021216:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 8021218:	3901      	subs	r1, #1
 802121a:	ea42 5201 	orr.w	r2, r2, r1, lsl #20
 802121e:	62da      	str	r2, [r3, #44]	@ 0x2c
  
  /* Enable or disable ADC DMA continuous request */
  hadc->Instance->CR2 &= ~(ADC_CR2_DDS);
 8021220:	689a      	ldr	r2, [r3, #8]
  hadc->Instance->CR2 |= ADC_CR2_DMAContReq((uint32_t)hadc->Init.DMAContinuousRequests);
  
  /* Enable or disable ADC end of conversion selection */
  hadc->Instance->CR2 &= ~(ADC_CR2_EOCS);
  hadc->Instance->CR2 |= ADC_CR2_EOCSelection(hadc->Init.EOCSelection);
 8021222:	6961      	ldr	r1, [r4, #20]
  hadc->Instance->CR2 &= ~(ADC_CR2_DDS);
 8021224:	f422 7200 	bic.w	r2, r2, #512	@ 0x200
 8021228:	609a      	str	r2, [r3, #8]
  hadc->Instance->CR2 |= ADC_CR2_DMAContReq((uint32_t)hadc->Init.DMAContinuousRequests);
 802122a:	689a      	ldr	r2, [r3, #8]
 802122c:	f894 0030 	ldrb.w	r0, [r4, #48]	@ 0x30
 8021230:	ea42 2240 	orr.w	r2, r2, r0, lsl #9
 8021234:	609a      	str	r2, [r3, #8]
  hadc->Instance->CR2 &= ~(ADC_CR2_EOCS);
 8021236:	689a      	ldr	r2, [r3, #8]
 8021238:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 802123c:	609a      	str	r2, [r3, #8]
  hadc->Instance->CR2 |= ADC_CR2_EOCSelection(hadc->Init.EOCSelection);
 802123e:	689a      	ldr	r2, [r3, #8]
    ADC_CLEAR_ERRORCODE(hadc);
 8021240:	2000      	movs	r0, #0
  hadc->Instance->CR2 |= ADC_CR2_EOCSelection(hadc->Init.EOCSelection);
 8021242:	ea42 2281 	orr.w	r2, r2, r1, lsl #10
 8021246:	609a      	str	r2, [r3, #8]
    ADC_CLEAR_ERRORCODE(hadc);
 8021248:	6460      	str	r0, [r4, #68]	@ 0x44
    ADC_STATE_CLR_SET(hadc->State,
 802124a:	6c23      	ldr	r3, [r4, #64]	@ 0x40
 802124c:	f023 0303 	bic.w	r3, r3, #3
 8021250:	f043 0301 	orr.w	r3, r3, #1
 8021254:	6423      	str	r3, [r4, #64]	@ 0x40
  __HAL_UNLOCK(hadc);
 8021256:	2300      	movs	r3, #0
 8021258:	f884 303c 	strb.w	r3, [r4, #60]	@ 0x3c
}
 802125c:	bd38      	pop	{r3, r4, r5, pc}
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTSEL);
 802125e:	f022 6270 	bic.w	r2, r2, #251658240	@ 0xf000000
 8021262:	609a      	str	r2, [r3, #8]
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTEN);
 8021264:	689a      	ldr	r2, [r3, #8]
 8021266:	f022 5240 	bic.w	r2, r2, #805306368	@ 0x30000000
 802126a:	609a      	str	r2, [r3, #8]
 802126c:	e7b3      	b.n	80211d6 <HAL_ADC_Init+0xaa>
    return HAL_ERROR;
 802126e:	2001      	movs	r0, #1
}
 8021270:	4770      	bx	lr
    hadc->Instance->CR1 &= ~(ADC_CR1_DISCEN);
 8021272:	685a      	ldr	r2, [r3, #4]
 8021274:	f422 6200 	bic.w	r2, r2, #2048	@ 0x800
 8021278:	605a      	str	r2, [r3, #4]
 802127a:	e7c7      	b.n	802120c <HAL_ADC_Init+0xe0>
 802127c:	40012300 	.word	0x40012300
 8021280:	0f000001 	.word	0x0f000001

08021284 <HAL_ADC_Start_IT>:
{
 8021284:	b410      	push	{r4}
  __HAL_LOCK(hadc);
 8021286:	f890 303c 	ldrb.w	r3, [r0, #60]	@ 0x3c
{
 802128a:	b083      	sub	sp, #12
  __IO uint32_t counter = 0U;
 802128c:	2200      	movs	r2, #0
  __HAL_LOCK(hadc);
 802128e:	2b01      	cmp	r3, #1
  __IO uint32_t counter = 0U;
 8021290:	9201      	str	r2, [sp, #4]
  __HAL_LOCK(hadc);
 8021292:	d058      	beq.n	8021346 <HAL_ADC_Start_IT+0xc2>
 8021294:	2301      	movs	r3, #1
  if((hadc->Instance->CR2 & ADC_CR2_ADON) != ADC_CR2_ADON)
 8021296:	6802      	ldr	r2, [r0, #0]
  __HAL_LOCK(hadc);
 8021298:	f880 303c 	strb.w	r3, [r0, #60]	@ 0x3c
  if((hadc->Instance->CR2 & ADC_CR2_ADON) != ADC_CR2_ADON)
 802129c:	6893      	ldr	r3, [r2, #8]
 802129e:	07db      	lsls	r3, r3, #31
 80212a0:	d414      	bmi.n	80212cc <HAL_ADC_Start_IT+0x48>
    counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000U));
 80212a2:	4b2b      	ldr	r3, [pc, #172]	@ (8021350 <HAL_ADC_Start_IT+0xcc>)
 80212a4:	4c2b      	ldr	r4, [pc, #172]	@ (8021354 <HAL_ADC_Start_IT+0xd0>)
 80212a6:	681b      	ldr	r3, [r3, #0]
    __HAL_ADC_ENABLE(hadc);
 80212a8:	6891      	ldr	r1, [r2, #8]
    counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000U));
 80212aa:	fba4 4303 	umull	r4, r3, r4, r3
 80212ae:	0c9b      	lsrs	r3, r3, #18
 80212b0:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    __HAL_ADC_ENABLE(hadc);
 80212b4:	f041 0101 	orr.w	r1, r1, #1
 80212b8:	6091      	str	r1, [r2, #8]
    counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000U));
 80212ba:	9301      	str	r3, [sp, #4]
    while(counter != 0U)
 80212bc:	9b01      	ldr	r3, [sp, #4]
 80212be:	b12b      	cbz	r3, 80212cc <HAL_ADC_Start_IT+0x48>
      counter--;
 80212c0:	9b01      	ldr	r3, [sp, #4]
 80212c2:	3b01      	subs	r3, #1
 80212c4:	9301      	str	r3, [sp, #4]
    while(counter != 0U)
 80212c6:	9b01      	ldr	r3, [sp, #4]
 80212c8:	2b00      	cmp	r3, #0
 80212ca:	d1f9      	bne.n	80212c0 <HAL_ADC_Start_IT+0x3c>
  if(HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_ADON))
 80212cc:	6893      	ldr	r3, [r2, #8]
 80212ce:	07dc      	lsls	r4, r3, #31
 80212d0:	d52b      	bpl.n	802132a <HAL_ADC_Start_IT+0xa6>
    ADC_STATE_CLR_SET(hadc->State,
 80212d2:	6c03      	ldr	r3, [r0, #64]	@ 0x40
 80212d4:	f423 63e0 	bic.w	r3, r3, #1792	@ 0x700
 80212d8:	f023 0301 	bic.w	r3, r3, #1
 80212dc:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 80212e0:	6403      	str	r3, [r0, #64]	@ 0x40
    if (READ_BIT(hadc->Instance->CR1, ADC_CR1_JAUTO) != RESET)
 80212e2:	6853      	ldr	r3, [r2, #4]
 80212e4:	0559      	lsls	r1, r3, #21
 80212e6:	d505      	bpl.n	80212f4 <HAL_ADC_Start_IT+0x70>
      ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);  
 80212e8:	6c03      	ldr	r3, [r0, #64]	@ 0x40
 80212ea:	f423 5340 	bic.w	r3, r3, #12288	@ 0x3000
 80212ee:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
 80212f2:	6403      	str	r3, [r0, #64]	@ 0x40
    if (HAL_IS_BIT_SET(hadc->State, HAL_ADC_STATE_INJ_BUSY))
 80212f4:	6c03      	ldr	r3, [r0, #64]	@ 0x40
 80212f6:	f413 5380 	ands.w	r3, r3, #4096	@ 0x1000
      CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));         
 80212fa:	bf1c      	itt	ne
 80212fc:	6c43      	ldrne	r3, [r0, #68]	@ 0x44
 80212fe:	f023 0306 	bicne.w	r3, r3, #6
      ADC_CLEAR_ERRORCODE(hadc);
 8021302:	6443      	str	r3, [r0, #68]	@ 0x44
    __HAL_UNLOCK(hadc);
 8021304:	2100      	movs	r1, #0
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOC | ADC_FLAG_OVR);
 8021306:	f06f 0322 	mvn.w	r3, #34	@ 0x22
    __HAL_UNLOCK(hadc);
 802130a:	f880 103c 	strb.w	r1, [r0, #60]	@ 0x3c
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOC | ADC_FLAG_OVR);
 802130e:	6013      	str	r3, [r2, #0]
    __HAL_ADC_ENABLE_IT(hadc, (ADC_IT_EOC | ADC_IT_OVR));
 8021310:	6853      	ldr	r3, [r2, #4]
    if(HAL_IS_BIT_CLR(tmpADC_Common->CCR, ADC_CCR_MULTI))
 8021312:	4911      	ldr	r1, [pc, #68]	@ (8021358 <HAL_ADC_Start_IT+0xd4>)
    __HAL_ADC_ENABLE_IT(hadc, (ADC_IT_EOC | ADC_IT_OVR));
 8021314:	f043 6380 	orr.w	r3, r3, #67108864	@ 0x4000000
 8021318:	f043 0320 	orr.w	r3, r3, #32
 802131c:	6053      	str	r3, [r2, #4]
    if(HAL_IS_BIT_CLR(tmpADC_Common->CCR, ADC_CCR_MULTI))
 802131e:	684b      	ldr	r3, [r1, #4]
 8021320:	06db      	lsls	r3, r3, #27
 8021322:	d007      	beq.n	8021334 <HAL_ADC_Start_IT+0xb0>
      if((hadc->Instance == ADC1) && ((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET))
 8021324:	4b0d      	ldr	r3, [pc, #52]	@ (802135c <HAL_ADC_Start_IT+0xd8>)
 8021326:	429a      	cmp	r2, r3
 8021328:	d004      	beq.n	8021334 <HAL_ADC_Start_IT+0xb0>
  return HAL_OK;
 802132a:	2000      	movs	r0, #0
}
 802132c:	b003      	add	sp, #12
 802132e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8021332:	4770      	bx	lr
      if((hadc->Instance == ADC1) && ((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET))
 8021334:	6893      	ldr	r3, [r2, #8]
 8021336:	f013 5f40 	tst.w	r3, #805306368	@ 0x30000000
 802133a:	d1f6      	bne.n	802132a <HAL_ADC_Start_IT+0xa6>
          hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
 802133c:	6893      	ldr	r3, [r2, #8]
 802133e:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 8021342:	6093      	str	r3, [r2, #8]
 8021344:	e7f1      	b.n	802132a <HAL_ADC_Start_IT+0xa6>
  __HAL_LOCK(hadc);
 8021346:	2002      	movs	r0, #2
}
 8021348:	b003      	add	sp, #12
 802134a:	f85d 4b04 	ldr.w	r4, [sp], #4
 802134e:	4770      	bx	lr
 8021350:	20000130 	.word	0x20000130
 8021354:	431bde83 	.word	0x431bde83
 8021358:	40012300 	.word	0x40012300
 802135c:	40012000 	.word	0x40012000

08021360 <HAL_ADC_GetValue>:
  return hadc->Instance->DR;
 8021360:	6803      	ldr	r3, [r0, #0]
 8021362:	6cd8      	ldr	r0, [r3, #76]	@ 0x4c
}
 8021364:	4770      	bx	lr
 8021366:	bf00      	nop

08021368 <HAL_ADC_LevelOutOfWindowCallback>:
__weak void HAL_ADC_LevelOutOfWindowCallback(ADC_HandleTypeDef* hadc)
 8021368:	4770      	bx	lr
 802136a:	bf00      	nop

0802136c <HAL_ADC_ErrorCallback>:
__weak void HAL_ADC_ErrorCallback(ADC_HandleTypeDef *hadc)
 802136c:	4770      	bx	lr
 802136e:	bf00      	nop

08021370 <HAL_ADC_IRQHandler>:
{
 8021370:	b538      	push	{r3, r4, r5, lr}
  tmp1 = __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC);
 8021372:	6803      	ldr	r3, [r0, #0]
 8021374:	681a      	ldr	r2, [r3, #0]
  tmp2 = __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_EOC);
 8021376:	6859      	ldr	r1, [r3, #4]
{
 8021378:	4604      	mov	r4, r0
  if(tmp1 && tmp2)
 802137a:	0790      	lsls	r0, r2, #30
 802137c:	d501      	bpl.n	8021382 <HAL_ADC_IRQHandler+0x12>
 802137e:	068a      	lsls	r2, r1, #26
 8021380:	d453      	bmi.n	802142a <HAL_ADC_IRQHandler+0xba>
  tmp1 = __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_JEOC);
 8021382:	681a      	ldr	r2, [r3, #0]
  tmp2 = __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_JEOC);                               
 8021384:	6859      	ldr	r1, [r3, #4]
  if(tmp1 && tmp2)
 8021386:	0752      	lsls	r2, r2, #29
 8021388:	d501      	bpl.n	802138e <HAL_ADC_IRQHandler+0x1e>
 802138a:	060d      	lsls	r5, r1, #24
 802138c:	d41b      	bmi.n	80213c6 <HAL_ADC_IRQHandler+0x56>
  tmp1 = __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_AWD);
 802138e:	681a      	ldr	r2, [r3, #0]
  tmp2 = __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_AWD);                          
 8021390:	6859      	ldr	r1, [r3, #4]
  if(tmp1 && tmp2)
 8021392:	07d0      	lsls	r0, r2, #31
 8021394:	d501      	bpl.n	802139a <HAL_ADC_IRQHandler+0x2a>
 8021396:	064a      	lsls	r2, r1, #25
 8021398:	d406      	bmi.n	80213a8 <HAL_ADC_IRQHandler+0x38>
  tmp1 = __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_OVR);
 802139a:	681a      	ldr	r2, [r3, #0]
  tmp2 = __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_OVR);
 802139c:	6859      	ldr	r1, [r3, #4]
  if(tmp1 && tmp2)
 802139e:	0690      	lsls	r0, r2, #26
 80213a0:	d501      	bpl.n	80213a6 <HAL_ADC_IRQHandler+0x36>
 80213a2:	014a      	lsls	r2, r1, #5
 80213a4:	d469      	bmi.n	802147a <HAL_ADC_IRQHandler+0x10a>
}
 80213a6:	bd38      	pop	{r3, r4, r5, pc}
    if(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_AWD))
 80213a8:	681a      	ldr	r2, [r3, #0]
 80213aa:	07d5      	lsls	r5, r2, #31
 80213ac:	d5f5      	bpl.n	802139a <HAL_ADC_IRQHandler+0x2a>
      SET_BIT(hadc->State, HAL_ADC_STATE_AWD1);
 80213ae:	6c23      	ldr	r3, [r4, #64]	@ 0x40
 80213b0:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 80213b4:	6423      	str	r3, [r4, #64]	@ 0x40
      HAL_ADC_LevelOutOfWindowCallback(hadc);
 80213b6:	4620      	mov	r0, r4
 80213b8:	f7ff ffd6 	bl	8021368 <HAL_ADC_LevelOutOfWindowCallback>
      __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD);
 80213bc:	6823      	ldr	r3, [r4, #0]
 80213be:	f06f 0201 	mvn.w	r2, #1
 80213c2:	601a      	str	r2, [r3, #0]
 80213c4:	e7e9      	b.n	802139a <HAL_ADC_IRQHandler+0x2a>
    if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))
 80213c6:	6c22      	ldr	r2, [r4, #64]	@ 0x40
 80213c8:	06d0      	lsls	r0, r2, #27
 80213ca:	d403      	bmi.n	80213d4 <HAL_ADC_IRQHandler+0x64>
      SET_BIT(hadc->State, HAL_ADC_STATE_INJ_EOC);
 80213cc:	6c22      	ldr	r2, [r4, #64]	@ 0x40
 80213ce:	f442 5200 	orr.w	r2, r2, #8192	@ 0x2000
 80213d2:	6422      	str	r2, [r4, #64]	@ 0x40
    if(ADC_IS_SOFTWARE_START_INJECTED(hadc)                    &&
 80213d4:	689a      	ldr	r2, [r3, #8]
 80213d6:	f412 1f40 	tst.w	r2, #3145728	@ 0x300000
 80213da:	d11e      	bne.n	802141a <HAL_ADC_IRQHandler+0xaa>
       (HAL_IS_BIT_CLR(hadc->Instance->JSQR, ADC_JSQR_JL)  ||
 80213dc:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
    if(ADC_IS_SOFTWARE_START_INJECTED(hadc)                    &&
 80213de:	f412 1f40 	tst.w	r2, #3145728	@ 0x300000
 80213e2:	d002      	beq.n	80213ea <HAL_ADC_IRQHandler+0x7a>
        HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_EOCS)    ) &&
 80213e4:	689a      	ldr	r2, [r3, #8]
       (HAL_IS_BIT_CLR(hadc->Instance->JSQR, ADC_JSQR_JL)  ||
 80213e6:	0551      	lsls	r1, r2, #21
 80213e8:	d417      	bmi.n	802141a <HAL_ADC_IRQHandler+0xaa>
       (HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO) &&
 80213ea:	685a      	ldr	r2, [r3, #4]
        HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_EOCS)    ) &&
 80213ec:	0552      	lsls	r2, r2, #21
 80213ee:	d414      	bmi.n	802141a <HAL_ADC_IRQHandler+0xaa>
        (ADC_IS_SOFTWARE_START_REGULAR(hadc)       &&
 80213f0:	689a      	ldr	r2, [r3, #8]
       (HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO) &&
 80213f2:	f012 5f40 	tst.w	r2, #805306368	@ 0x30000000
 80213f6:	d110      	bne.n	802141a <HAL_ADC_IRQHandler+0xaa>
        (ADC_IS_SOFTWARE_START_REGULAR(hadc)       &&
 80213f8:	7e22      	ldrb	r2, [r4, #24]
 80213fa:	b972      	cbnz	r2, 802141a <HAL_ADC_IRQHandler+0xaa>
      __HAL_ADC_DISABLE_IT(hadc, ADC_IT_JEOC);
 80213fc:	685a      	ldr	r2, [r3, #4]
 80213fe:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
 8021402:	605a      	str	r2, [r3, #4]
      CLEAR_BIT(hadc->State, HAL_ADC_STATE_INJ_BUSY);   
 8021404:	6c23      	ldr	r3, [r4, #64]	@ 0x40
 8021406:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
 802140a:	6423      	str	r3, [r4, #64]	@ 0x40
      if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_REG_BUSY))
 802140c:	6c23      	ldr	r3, [r4, #64]	@ 0x40
 802140e:	05dd      	lsls	r5, r3, #23
 8021410:	d403      	bmi.n	802141a <HAL_ADC_IRQHandler+0xaa>
        SET_BIT(hadc->State, HAL_ADC_STATE_READY);
 8021412:	6c23      	ldr	r3, [r4, #64]	@ 0x40
 8021414:	f043 0301 	orr.w	r3, r3, #1
 8021418:	6423      	str	r3, [r4, #64]	@ 0x40
      HAL_ADCEx_InjectedConvCpltCallback(hadc);
 802141a:	4620      	mov	r0, r4
 802141c:	f000 f8f4 	bl	8021608 <HAL_ADCEx_InjectedConvCpltCallback>
    __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_JSTRT | ADC_FLAG_JEOC));
 8021420:	6823      	ldr	r3, [r4, #0]
 8021422:	f06f 020c 	mvn.w	r2, #12
 8021426:	601a      	str	r2, [r3, #0]
 8021428:	e7b1      	b.n	802138e <HAL_ADC_IRQHandler+0x1e>
    if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))
 802142a:	6c22      	ldr	r2, [r4, #64]	@ 0x40
 802142c:	06d5      	lsls	r5, r2, #27
 802142e:	d403      	bmi.n	8021438 <HAL_ADC_IRQHandler+0xc8>
      SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC); 
 8021430:	6c22      	ldr	r2, [r4, #64]	@ 0x40
 8021432:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 8021436:	6422      	str	r2, [r4, #64]	@ 0x40
    if(ADC_IS_SOFTWARE_START_REGULAR(hadc)                   &&
 8021438:	689a      	ldr	r2, [r3, #8]
 802143a:	f012 5f40 	tst.w	r2, #805306368	@ 0x30000000
 802143e:	d114      	bne.n	802146a <HAL_ADC_IRQHandler+0xfa>
 8021440:	7e22      	ldrb	r2, [r4, #24]
 8021442:	b992      	cbnz	r2, 802146a <HAL_ADC_IRQHandler+0xfa>
       (HAL_IS_BIT_CLR(hadc->Instance->SQR1, ADC_SQR1_L) || 
 8021444:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
       (hadc->Init.ContinuousConvMode == DISABLE)            &&
 8021446:	f412 0f70 	tst.w	r2, #15728640	@ 0xf00000
 802144a:	d123      	bne.n	8021494 <HAL_ADC_IRQHandler+0x124>
      __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC);
 802144c:	685a      	ldr	r2, [r3, #4]
 802144e:	f022 0220 	bic.w	r2, r2, #32
 8021452:	605a      	str	r2, [r3, #4]
      CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);
 8021454:	6c23      	ldr	r3, [r4, #64]	@ 0x40
 8021456:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 802145a:	6423      	str	r3, [r4, #64]	@ 0x40
      if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_INJ_BUSY))
 802145c:	6c23      	ldr	r3, [r4, #64]	@ 0x40
 802145e:	04d9      	lsls	r1, r3, #19
 8021460:	d403      	bmi.n	802146a <HAL_ADC_IRQHandler+0xfa>
        SET_BIT(hadc->State, HAL_ADC_STATE_READY);
 8021462:	6c23      	ldr	r3, [r4, #64]	@ 0x40
 8021464:	f043 0301 	orr.w	r3, r3, #1
 8021468:	6423      	str	r3, [r4, #64]	@ 0x40
    HAL_ADC_ConvCpltCallback(hadc);
 802146a:	4620      	mov	r0, r4
 802146c:	f004 fce4 	bl	8025e38 <HAL_ADC_ConvCpltCallback>
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_STRT | ADC_FLAG_EOC);
 8021470:	6823      	ldr	r3, [r4, #0]
 8021472:	f06f 0212 	mvn.w	r2, #18
 8021476:	601a      	str	r2, [r3, #0]
 8021478:	e783      	b.n	8021382 <HAL_ADC_IRQHandler+0x12>
    SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_OVR);
 802147a:	6c62      	ldr	r2, [r4, #68]	@ 0x44
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_OVR);
 802147c:	f06f 0520 	mvn.w	r5, #32
    SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_OVR);
 8021480:	f042 0202 	orr.w	r2, r2, #2
 8021484:	6462      	str	r2, [r4, #68]	@ 0x44
      HAL_ADC_ErrorCallback(hadc);
 8021486:	4620      	mov	r0, r4
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_OVR);
 8021488:	601d      	str	r5, [r3, #0]
      HAL_ADC_ErrorCallback(hadc);
 802148a:	f7ff ff6f 	bl	802136c <HAL_ADC_ErrorCallback>
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_OVR);
 802148e:	6823      	ldr	r3, [r4, #0]
 8021490:	601d      	str	r5, [r3, #0]
}
 8021492:	bd38      	pop	{r3, r4, r5, pc}
        HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_EOCS)  )   )
 8021494:	689a      	ldr	r2, [r3, #8]
       (HAL_IS_BIT_CLR(hadc->Instance->SQR1, ADC_SQR1_L) || 
 8021496:	0550      	lsls	r0, r2, #21
 8021498:	d4e7      	bmi.n	802146a <HAL_ADC_IRQHandler+0xfa>
 802149a:	e7d7      	b.n	802144c <HAL_ADC_IRQHandler+0xdc>

0802149c <HAL_ADC_ConfigChannel>:
{
 802149c:	b570      	push	{r4, r5, r6, lr}
  __HAL_LOCK(hadc);
 802149e:	f890 303c 	ldrb.w	r3, [r0, #60]	@ 0x3c
{
 80214a2:	b082      	sub	sp, #8
 80214a4:	4602      	mov	r2, r0
  __HAL_LOCK(hadc);
 80214a6:	2b01      	cmp	r3, #1
  __IO uint32_t counter = 0U;
 80214a8:	f04f 0000 	mov.w	r0, #0
 80214ac:	9001      	str	r0, [sp, #4]
  __HAL_LOCK(hadc);
 80214ae:	f000 809e 	beq.w	80215ee <HAL_ADC_ConfigChannel+0x152>
 80214b2:	2301      	movs	r3, #1
 80214b4:	f882 303c 	strb.w	r3, [r2, #60]	@ 0x3c
  if (sConfig->Channel > ADC_CHANNEL_9)
 80214b8:	680d      	ldr	r5, [r1, #0]
    hadc->Instance->SMPR1 &= ~ADC_SMPR1(ADC_SMPR1_SMP10, sConfig->Channel);
 80214ba:	6813      	ldr	r3, [r2, #0]
    hadc->Instance->SMPR1 |= ADC_SMPR1(sConfig->SamplingTime, sConfig->Channel);
 80214bc:	688c      	ldr	r4, [r1, #8]
  if (sConfig->Channel > ADC_CHANNEL_9)
 80214be:	2d09      	cmp	r5, #9
 80214c0:	b2a8      	uxth	r0, r5
 80214c2:	d828      	bhi.n	8021516 <HAL_ADC_ConfigChannel+0x7a>
    hadc->Instance->SMPR2 &= ~ADC_SMPR2(ADC_SMPR2_SMP0, sConfig->Channel);
 80214c4:	691e      	ldr	r6, [r3, #16]
 80214c6:	eb05 0e45 	add.w	lr, r5, r5, lsl #1
 80214ca:	f04f 0c07 	mov.w	ip, #7
 80214ce:	fa0c fc0e 	lsl.w	ip, ip, lr
 80214d2:	ea26 060c 	bic.w	r6, r6, ip
 80214d6:	611e      	str	r6, [r3, #16]
    hadc->Instance->SMPR2 |= ADC_SMPR2(sConfig->SamplingTime, sConfig->Channel);
 80214d8:	691e      	ldr	r6, [r3, #16]
 80214da:	fa04 f40e 	lsl.w	r4, r4, lr
 80214de:	4334      	orrs	r4, r6
 80214e0:	611c      	str	r4, [r3, #16]
  if (sConfig->Rank < 7U)
 80214e2:	684c      	ldr	r4, [r1, #4]
 80214e4:	2c06      	cmp	r4, #6
    hadc->Instance->SQR3 &= ~ADC_SQR3_RK(ADC_SQR3_SQ1, sConfig->Rank);
 80214e6:	eb04 0184 	add.w	r1, r4, r4, lsl #2
  if (sConfig->Rank < 7U)
 80214ea:	d82a      	bhi.n	8021542 <HAL_ADC_ConfigChannel+0xa6>
    hadc->Instance->SQR3 &= ~ADC_SQR3_RK(ADC_SQR3_SQ1, sConfig->Rank);
 80214ec:	6b5c      	ldr	r4, [r3, #52]	@ 0x34
 80214ee:	3905      	subs	r1, #5
 80214f0:	f04f 0c1f 	mov.w	ip, #31
    hadc->Instance->SQR3 |= ADC_SQR3_RK(sConfig->Channel, sConfig->Rank);
 80214f4:	4088      	lsls	r0, r1
    hadc->Instance->SQR3 &= ~ADC_SQR3_RK(ADC_SQR3_SQ1, sConfig->Rank);
 80214f6:	fa0c f101 	lsl.w	r1, ip, r1
 80214fa:	ea24 0101 	bic.w	r1, r4, r1
 80214fe:	6359      	str	r1, [r3, #52]	@ 0x34
    hadc->Instance->SQR3 |= ADC_SQR3_RK(sConfig->Channel, sConfig->Rank);
 8021500:	6b59      	ldr	r1, [r3, #52]	@ 0x34
 8021502:	4308      	orrs	r0, r1
 8021504:	6358      	str	r0, [r3, #52]	@ 0x34
  if ((hadc->Instance == ADC1) && (sConfig->Channel == ADC_CHANNEL_VBAT))
 8021506:	493b      	ldr	r1, [pc, #236]	@ (80215f4 <HAL_ADC_ConfigChannel+0x158>)
 8021508:	428b      	cmp	r3, r1
 802150a:	d02b      	beq.n	8021564 <HAL_ADC_ConfigChannel+0xc8>
  __HAL_UNLOCK(hadc);
 802150c:	2000      	movs	r0, #0
 802150e:	f882 003c 	strb.w	r0, [r2, #60]	@ 0x3c
}
 8021512:	b002      	add	sp, #8
 8021514:	bd70      	pop	{r4, r5, r6, pc}
    hadc->Instance->SMPR1 &= ~ADC_SMPR1(ADC_SMPR1_SMP10, sConfig->Channel);
 8021516:	eb00 0c40 	add.w	ip, r0, r0, lsl #1
 802151a:	68de      	ldr	r6, [r3, #12]
 802151c:	f1ac 0c1e 	sub.w	ip, ip, #30
 8021520:	f04f 0e07 	mov.w	lr, #7
    hadc->Instance->SMPR1 |= ADC_SMPR1(sConfig->SamplingTime, sConfig->Channel);
 8021524:	fa04 f40c 	lsl.w	r4, r4, ip
    hadc->Instance->SMPR1 &= ~ADC_SMPR1(ADC_SMPR1_SMP10, sConfig->Channel);
 8021528:	fa0e fc0c 	lsl.w	ip, lr, ip
 802152c:	ea26 060c 	bic.w	r6, r6, ip
 8021530:	60de      	str	r6, [r3, #12]
    hadc->Instance->SMPR1 |= ADC_SMPR1(sConfig->SamplingTime, sConfig->Channel);
 8021532:	68de      	ldr	r6, [r3, #12]
 8021534:	4334      	orrs	r4, r6
 8021536:	60dc      	str	r4, [r3, #12]
  if (sConfig->Rank < 7U)
 8021538:	684c      	ldr	r4, [r1, #4]
 802153a:	2c06      	cmp	r4, #6
    hadc->Instance->SQR3 &= ~ADC_SQR3_RK(ADC_SQR3_SQ1, sConfig->Rank);
 802153c:	eb04 0184 	add.w	r1, r4, r4, lsl #2
  if (sConfig->Rank < 7U)
 8021540:	d9d4      	bls.n	80214ec <HAL_ADC_ConfigChannel+0x50>
  else if (sConfig->Rank < 13U)
 8021542:	2c0c      	cmp	r4, #12
 8021544:	d81f      	bhi.n	8021586 <HAL_ADC_ConfigChannel+0xea>
    hadc->Instance->SQR2 &= ~ADC_SQR2_RK(ADC_SQR2_SQ7, sConfig->Rank);
 8021546:	6b1c      	ldr	r4, [r3, #48]	@ 0x30
 8021548:	3923      	subs	r1, #35	@ 0x23
 802154a:	261f      	movs	r6, #31
    hadc->Instance->SQR2 |= ADC_SQR2_RK(sConfig->Channel, sConfig->Rank);
 802154c:	4088      	lsls	r0, r1
    hadc->Instance->SQR2 &= ~ADC_SQR2_RK(ADC_SQR2_SQ7, sConfig->Rank);
 802154e:	fa06 f101 	lsl.w	r1, r6, r1
 8021552:	ea24 0101 	bic.w	r1, r4, r1
 8021556:	6319      	str	r1, [r3, #48]	@ 0x30
    hadc->Instance->SQR2 |= ADC_SQR2_RK(sConfig->Channel, sConfig->Rank);
 8021558:	6b19      	ldr	r1, [r3, #48]	@ 0x30
 802155a:	4308      	orrs	r0, r1
  if ((hadc->Instance == ADC1) && (sConfig->Channel == ADC_CHANNEL_VBAT))
 802155c:	4925      	ldr	r1, [pc, #148]	@ (80215f4 <HAL_ADC_ConfigChannel+0x158>)
    hadc->Instance->SQR2 |= ADC_SQR2_RK(sConfig->Channel, sConfig->Rank);
 802155e:	6318      	str	r0, [r3, #48]	@ 0x30
  if ((hadc->Instance == ADC1) && (sConfig->Channel == ADC_CHANNEL_VBAT))
 8021560:	428b      	cmp	r3, r1
 8021562:	d1d3      	bne.n	802150c <HAL_ADC_ConfigChannel+0x70>
 8021564:	2d12      	cmp	r5, #18
 8021566:	d01b      	beq.n	80215a0 <HAL_ADC_ConfigChannel+0x104>
  if ((hadc->Instance == ADC1) && ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) || (sConfig->Channel == ADC_CHANNEL_VREFINT)))
 8021568:	4b23      	ldr	r3, [pc, #140]	@ (80215f8 <HAL_ADC_ConfigChannel+0x15c>)
 802156a:	429d      	cmp	r5, r3
 802156c:	d022      	beq.n	80215b4 <HAL_ADC_ConfigChannel+0x118>
 802156e:	2d11      	cmp	r5, #17
 8021570:	d1cc      	bne.n	802150c <HAL_ADC_ConfigChannel+0x70>
      tmpADC_Common->CCR &= ~ADC_CCR_VBATE;
 8021572:	4b22      	ldr	r3, [pc, #136]	@ (80215fc <HAL_ADC_ConfigChannel+0x160>)
 8021574:	6859      	ldr	r1, [r3, #4]
 8021576:	f421 0180 	bic.w	r1, r1, #4194304	@ 0x400000
 802157a:	6059      	str	r1, [r3, #4]
    tmpADC_Common->CCR |= ADC_CCR_TSVREFE;
 802157c:	6859      	ldr	r1, [r3, #4]
 802157e:	f441 0100 	orr.w	r1, r1, #8388608	@ 0x800000
 8021582:	6059      	str	r1, [r3, #4]
    if((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR))
 8021584:	e7c2      	b.n	802150c <HAL_ADC_ConfigChannel+0x70>
    hadc->Instance->SQR1 &= ~ADC_SQR1_RK(ADC_SQR1_SQ13, sConfig->Rank);
 8021586:	6adc      	ldr	r4, [r3, #44]	@ 0x2c
 8021588:	3941      	subs	r1, #65	@ 0x41
 802158a:	261f      	movs	r6, #31
    hadc->Instance->SQR1 |= ADC_SQR1_RK(sConfig->Channel, sConfig->Rank);
 802158c:	4088      	lsls	r0, r1
    hadc->Instance->SQR1 &= ~ADC_SQR1_RK(ADC_SQR1_SQ13, sConfig->Rank);
 802158e:	fa06 f101 	lsl.w	r1, r6, r1
 8021592:	ea24 0101 	bic.w	r1, r4, r1
 8021596:	62d9      	str	r1, [r3, #44]	@ 0x2c
    hadc->Instance->SQR1 |= ADC_SQR1_RK(sConfig->Channel, sConfig->Rank);
 8021598:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
 802159a:	4308      	orrs	r0, r1
 802159c:	62d8      	str	r0, [r3, #44]	@ 0x2c
 802159e:	e7b2      	b.n	8021506 <HAL_ADC_ConfigChannel+0x6a>
      tmpADC_Common->CCR &= ~ADC_CCR_TSVREFE;
 80215a0:	4b16      	ldr	r3, [pc, #88]	@ (80215fc <HAL_ADC_ConfigChannel+0x160>)
 80215a2:	6859      	ldr	r1, [r3, #4]
 80215a4:	f421 0100 	bic.w	r1, r1, #8388608	@ 0x800000
 80215a8:	6059      	str	r1, [r3, #4]
    tmpADC_Common->CCR |= ADC_CCR_VBATE;
 80215aa:	6859      	ldr	r1, [r3, #4]
 80215ac:	f441 0180 	orr.w	r1, r1, #4194304	@ 0x400000
 80215b0:	6059      	str	r1, [r3, #4]
  if ((hadc->Instance == ADC1) && ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) || (sConfig->Channel == ADC_CHANNEL_VREFINT)))
 80215b2:	e7ab      	b.n	802150c <HAL_ADC_ConfigChannel+0x70>
      tmpADC_Common->CCR &= ~ADC_CCR_VBATE;
 80215b4:	4b11      	ldr	r3, [pc, #68]	@ (80215fc <HAL_ADC_ConfigChannel+0x160>)
      counter = (ADC_TEMPSENSOR_DELAY_US * (SystemCoreClock / 1000000U));
 80215b6:	4c12      	ldr	r4, [pc, #72]	@ (8021600 <HAL_ADC_ConfigChannel+0x164>)
      tmpADC_Common->CCR &= ~ADC_CCR_VBATE;
 80215b8:	6859      	ldr	r1, [r3, #4]
      counter = (ADC_TEMPSENSOR_DELAY_US * (SystemCoreClock / 1000000U));
 80215ba:	4812      	ldr	r0, [pc, #72]	@ (8021604 <HAL_ADC_ConfigChannel+0x168>)
      tmpADC_Common->CCR &= ~ADC_CCR_VBATE;
 80215bc:	f421 0180 	bic.w	r1, r1, #4194304	@ 0x400000
 80215c0:	6059      	str	r1, [r3, #4]
    tmpADC_Common->CCR |= ADC_CCR_TSVREFE;
 80215c2:	6859      	ldr	r1, [r3, #4]
 80215c4:	f441 0100 	orr.w	r1, r1, #8388608	@ 0x800000
 80215c8:	6059      	str	r1, [r3, #4]
      counter = (ADC_TEMPSENSOR_DELAY_US * (SystemCoreClock / 1000000U));
 80215ca:	6823      	ldr	r3, [r4, #0]
 80215cc:	fba0 0303 	umull	r0, r3, r0, r3
 80215d0:	0c9b      	lsrs	r3, r3, #18
 80215d2:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80215d6:	005b      	lsls	r3, r3, #1
 80215d8:	9301      	str	r3, [sp, #4]
      while(counter != 0U)
 80215da:	9b01      	ldr	r3, [sp, #4]
 80215dc:	2b00      	cmp	r3, #0
 80215de:	d095      	beq.n	802150c <HAL_ADC_ConfigChannel+0x70>
        counter--;
 80215e0:	9b01      	ldr	r3, [sp, #4]
 80215e2:	3b01      	subs	r3, #1
 80215e4:	9301      	str	r3, [sp, #4]
      while(counter != 0U)
 80215e6:	9b01      	ldr	r3, [sp, #4]
 80215e8:	2b00      	cmp	r3, #0
 80215ea:	d1f9      	bne.n	80215e0 <HAL_ADC_ConfigChannel+0x144>
 80215ec:	e78e      	b.n	802150c <HAL_ADC_ConfigChannel+0x70>
  __HAL_LOCK(hadc);
 80215ee:	2002      	movs	r0, #2
}
 80215f0:	b002      	add	sp, #8
 80215f2:	bd70      	pop	{r4, r5, r6, pc}
 80215f4:	40012000 	.word	0x40012000
 80215f8:	10000012 	.word	0x10000012
 80215fc:	40012300 	.word	0x40012300
 8021600:	20000130 	.word	0x20000130
 8021604:	431bde83 	.word	0x431bde83

08021608 <HAL_ADCEx_InjectedConvCpltCallback>:
  /* Prevent unused argument(s) compilation warning */
  UNUSED(hadc);
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_ADC_InjectedConvCpltCallback could be implemented in the user file
   */
}
 8021608:	4770      	bx	lr
 802160a:	bf00      	nop

0802160c <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 802160c:	4907      	ldr	r1, [pc, #28]	@ (802162c <HAL_NVIC_SetPriorityGrouping+0x20>)
 802160e:	68ca      	ldr	r2, [r1, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8021610:	0203      	lsls	r3, r0, #8
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8021612:	f64f 00ff 	movw	r0, #63743	@ 0xf8ff
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8021616:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 802161a:	4002      	ands	r2, r0
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 802161c:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 802161e:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
 8021622:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
  SCB->AIRCR =  reg_value;
 8021626:	60cb      	str	r3, [r1, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 8021628:	4770      	bx	lr
 802162a:	bf00      	nop
 802162c:	e000ed00 	.word	0xe000ed00

08021630 <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8021630:	4b1b      	ldr	r3, [pc, #108]	@ (80216a0 <HAL_NVIC_SetPriority+0x70>)
 8021632:	68db      	ldr	r3, [r3, #12]
 8021634:	f3c3 2302 	ubfx	r3, r3, #8, #3
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 8021638:	b500      	push	{lr}
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 802163a:	f1c3 0e07 	rsb	lr, r3, #7
 802163e:	f1be 0f04 	cmp.w	lr, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8021642:	f103 0c04 	add.w	ip, r3, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8021646:	bf28      	it	cs
 8021648:	f04f 0e04 	movcs.w	lr, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 802164c:	f1bc 0f06 	cmp.w	ip, #6
 8021650:	d91c      	bls.n	802168c <HAL_NVIC_SetPriority+0x5c>
 8021652:	f1a3 0c03 	sub.w	ip, r3, #3

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8021656:	f04f 33ff 	mov.w	r3, #4294967295
 802165a:	fa03 f30c 	lsl.w	r3, r3, ip
 802165e:	ea22 0203 	bic.w	r2, r2, r3
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8021662:	f04f 33ff 	mov.w	r3, #4294967295
 8021666:	fa03 f30e 	lsl.w	r3, r3, lr
 802166a:	ea21 0303 	bic.w	r3, r1, r3
 802166e:	fa03 f30c 	lsl.w	r3, r3, ip
 8021672:	4313      	orrs	r3, r2
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8021674:	011b      	lsls	r3, r3, #4
  if ((int32_t)(IRQn) >= 0)
 8021676:	2800      	cmp	r0, #0
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8021678:	b2db      	uxtb	r3, r3
  if ((int32_t)(IRQn) >= 0)
 802167a:	db0a      	blt.n	8021692 <HAL_NVIC_SetPriority+0x62>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 802167c:	f100 4060 	add.w	r0, r0, #3758096384	@ 0xe0000000
 8021680:	f500 4061 	add.w	r0, r0, #57600	@ 0xe100
 8021684:	f880 3300 	strb.w	r3, [r0, #768]	@ 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 8021688:	f85d fb04 	ldr.w	pc, [sp], #4
 802168c:	2200      	movs	r2, #0
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 802168e:	4694      	mov	ip, r2
 8021690:	e7e7      	b.n	8021662 <HAL_NVIC_SetPriority+0x32>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8021692:	4a04      	ldr	r2, [pc, #16]	@ (80216a4 <HAL_NVIC_SetPriority+0x74>)
 8021694:	f000 000f 	and.w	r0, r0, #15
 8021698:	4402      	add	r2, r0
 802169a:	7613      	strb	r3, [r2, #24]
 802169c:	f85d fb04 	ldr.w	pc, [sp], #4
 80216a0:	e000ed00 	.word	0xe000ed00
 80216a4:	e000ecfc 	.word	0xe000ecfc

080216a8 <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 80216a8:	2800      	cmp	r0, #0
 80216aa:	db07      	blt.n	80216bc <HAL_NVIC_EnableIRQ+0x14>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 80216ac:	0941      	lsrs	r1, r0, #5
 80216ae:	4a04      	ldr	r2, [pc, #16]	@ (80216c0 <HAL_NVIC_EnableIRQ+0x18>)
 80216b0:	f000 001f 	and.w	r0, r0, #31
 80216b4:	2301      	movs	r3, #1
 80216b6:	4083      	lsls	r3, r0
 80216b8:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 80216bc:	4770      	bx	lr
 80216be:	bf00      	nop
 80216c0:	e000e100 	.word	0xe000e100

080216c4 <HAL_NVIC_DisableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 80216c4:	2800      	cmp	r0, #0
 80216c6:	db0c      	blt.n	80216e2 <HAL_NVIC_DisableIRQ+0x1e>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 80216c8:	0943      	lsrs	r3, r0, #5
 80216ca:	4906      	ldr	r1, [pc, #24]	@ (80216e4 <HAL_NVIC_DisableIRQ+0x20>)
 80216cc:	f000 001f 	and.w	r0, r0, #31
 80216d0:	3320      	adds	r3, #32
 80216d2:	2201      	movs	r2, #1
 80216d4:	4082      	lsls	r2, r0
 80216d6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 80216da:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 80216de:	f3bf 8f6f 	isb	sy
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Disable interrupt */
  NVIC_DisableIRQ(IRQn);
}
 80216e2:	4770      	bx	lr
 80216e4:	e000e100 	.word	0xe000e100

080216e8 <HAL_NVIC_SystemReset>:
  __ASM volatile ("dsb 0xF":::"memory");
 80216e8:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 80216ec:	4905      	ldr	r1, [pc, #20]	@ (8021704 <HAL_NVIC_SystemReset+0x1c>)
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 80216ee:	4b06      	ldr	r3, [pc, #24]	@ (8021708 <HAL_NVIC_SystemReset+0x20>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 80216f0:	68ca      	ldr	r2, [r1, #12]
 80216f2:	f402 62e0 	and.w	r2, r2, #1792	@ 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 80216f6:	4313      	orrs	r3, r2
 80216f8:	60cb      	str	r3, [r1, #12]
 80216fa:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
 80216fe:	bf00      	nop
  for(;;)                                                           /* wait until reset */
 8021700:	e7fd      	b.n	80216fe <HAL_NVIC_SystemReset+0x16>
 8021702:	bf00      	nop
 8021704:	e000ed00 	.word	0xe000ed00
 8021708:	05fa0004 	.word	0x05fa0004

0802170c <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 802170c:	3801      	subs	r0, #1
 802170e:	f1b0 7f80 	cmp.w	r0, #16777216	@ 0x1000000
 8021712:	d301      	bcc.n	8021718 <HAL_SYSTICK_Config+0xc>
  {
    return (1UL);                                                   /* Reload value impossible */
 8021714:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 8021716:	4770      	bx	lr
{
 8021718:	b410      	push	{r4}
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 802171a:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 802171e:	4c07      	ldr	r4, [pc, #28]	@ (802173c <HAL_SYSTICK_Config+0x30>)
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8021720:	6158      	str	r0, [r3, #20]
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8021722:	f04f 0cf0 	mov.w	ip, #240	@ 0xf0
 8021726:	f884 c023 	strb.w	ip, [r4, #35]	@ 0x23
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 802172a:	2200      	movs	r2, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 802172c:	2107      	movs	r1, #7
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 802172e:	4610      	mov	r0, r2
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8021730:	619a      	str	r2, [r3, #24]
}
 8021732:	f85d 4b04 	ldr.w	r4, [sp], #4
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8021736:	6119      	str	r1, [r3, #16]
 8021738:	4770      	bx	lr
 802173a:	bf00      	nop
 802173c:	e000ed00 	.word	0xe000ed00

08021740 <HAL_DMA_Init>:
  * @param  hdma Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{
 8021740:	b538      	push	{r3, r4, r5, lr}
 8021742:	4604      	mov	r4, r0
  uint32_t tmp = 0U;
  uint32_t tickstart = HAL_GetTick();
 8021744:	f7ff fcc8 	bl	80210d8 <HAL_GetTick>
  DMA_Base_Registers *regs;

  /* Check the DMA peripheral state */
  if(hdma == NULL)
 8021748:	2c00      	cmp	r4, #0
 802174a:	d06d      	beq.n	8021828 <HAL_DMA_Init+0xe8>

  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
  
  /* Disable the peripheral */
  __HAL_DMA_DISABLE(hdma);
 802174c:	6823      	ldr	r3, [r4, #0]
  hdma->State = HAL_DMA_STATE_BUSY;
 802174e:	2202      	movs	r2, #2
  __HAL_UNLOCK(hdma);
 8021750:	2100      	movs	r1, #0
 8021752:	f884 1034 	strb.w	r1, [r4, #52]	@ 0x34
  hdma->State = HAL_DMA_STATE_BUSY;
 8021756:	f884 2035 	strb.w	r2, [r4, #53]	@ 0x35
  __HAL_DMA_DISABLE(hdma);
 802175a:	681a      	ldr	r2, [r3, #0]
 802175c:	f022 0201 	bic.w	r2, r2, #1
 8021760:	4605      	mov	r5, r0
 8021762:	601a      	str	r2, [r3, #0]
  
  /* Check if the DMA Stream is effectively disabled */
  while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
 8021764:	e005      	b.n	8021772 <HAL_DMA_Init+0x32>
  {
    /* Check for the Timeout */
    if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
 8021766:	f7ff fcb7 	bl	80210d8 <HAL_GetTick>
 802176a:	1b43      	subs	r3, r0, r5
 802176c:	2b05      	cmp	r3, #5
 802176e:	d837      	bhi.n	80217e0 <HAL_DMA_Init+0xa0>
  while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
 8021770:	6823      	ldr	r3, [r4, #0]
 8021772:	681a      	ldr	r2, [r3, #0]
 8021774:	07d1      	lsls	r1, r2, #31
 8021776:	d4f6      	bmi.n	8021766 <HAL_DMA_Init+0x26>
                      DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
                      DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
                      DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));

  /* Prepare the DMA Stream configuration */
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 8021778:	e9d4 2001 	ldrd	r2, r0, [r4, #4]
 802177c:	68e1      	ldr	r1, [r4, #12]
 802177e:	4302      	orrs	r2, r0
 8021780:	430a      	orrs	r2, r1
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8021782:	e9d4 5104 	ldrd	r5, r1, [r4, #16]
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8021786:	69a0      	ldr	r0, [r4, #24]
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8021788:	432a      	orrs	r2, r5
 802178a:	430a      	orrs	r2, r1
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 802178c:	69e1      	ldr	r1, [r4, #28]
  tmp = hdma->Instance->CR;
 802178e:	681d      	ldr	r5, [r3, #0]
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8021790:	4302      	orrs	r2, r0
 8021792:	430a      	orrs	r2, r1
  tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 8021794:	4931      	ldr	r1, [pc, #196]	@ (802185c <HAL_DMA_Init+0x11c>)
 8021796:	4029      	ands	r1, r5
          hdma->Init.Mode                | hdma->Init.Priority;
 8021798:	6a25      	ldr	r5, [r4, #32]
 802179a:	432a      	orrs	r2, r5
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 802179c:	430a      	orrs	r2, r1

  /* the Memory burst and peripheral burst are not used when the FIFO is disabled */
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 802179e:	6a61      	ldr	r1, [r4, #36]	@ 0x24
 80217a0:	2904      	cmp	r1, #4
 80217a2:	d024      	beq.n	80217ee <HAL_DMA_Init+0xae>
    /* Get memory burst and peripheral burst */
    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
  }
  
  /* Write to DMA Stream CR register */
  hdma->Instance->CR = tmp;  
 80217a4:	601a      	str	r2, [r3, #0]

  /* Get the FCR register value */
  tmp = hdma->Instance->FCR;
 80217a6:	695a      	ldr	r2, [r3, #20]

  /* Clear Direct mode and FIFO threshold bits */
  tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 80217a8:	f022 0207 	bic.w	r2, r2, #7

  /* Prepare the DMA Stream FIFO configuration */
  tmp |= hdma->Init.FIFOMode;
 80217ac:	4311      	orrs	r1, r2
  *                     the configuration information for the specified DMA Stream. 
  * @retval Stream base address
  */
static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
{
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 80217ae:	b2d8      	uxtb	r0, r3
 80217b0:	4a2b      	ldr	r2, [pc, #172]	@ (8021860 <HAL_DMA_Init+0x120>)
  hdma->Instance->FCR = tmp;
 80217b2:	6159      	str	r1, [r3, #20]
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 80217b4:	3810      	subs	r0, #16
 80217b6:	fba2 5200 	umull	r5, r2, r2, r0
 80217ba:	0912      	lsrs	r2, r2, #4
  
  /* lookup table for necessary bitshift of flags within status registers */
  static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 80217bc:	4929      	ldr	r1, [pc, #164]	@ (8021864 <HAL_DMA_Init+0x124>)
  
  if (stream_number > 3U)
  {
    /* return pointer to HISR and HIFCR */
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
 80217be:	f36f 0309 	bfc	r3, #0, #10
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 80217c2:	5c89      	ldrb	r1, [r1, r2]
 80217c4:	65e1      	str	r1, [r4, #92]	@ 0x5c
  if (stream_number > 3U)
 80217c6:	285f      	cmp	r0, #95	@ 0x5f
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
 80217c8:	bf88      	it	hi
 80217ca:	3304      	addhi	r3, #4
  regs->IFCR = 0x3FU << hdma->StreamIndex;
 80217cc:	223f      	movs	r2, #63	@ 0x3f
 80217ce:	408a      	lsls	r2, r1
 80217d0:	65a3      	str	r3, [r4, #88]	@ 0x58
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 80217d2:	2000      	movs	r0, #0
  regs->IFCR = 0x3FU << hdma->StreamIndex;
 80217d4:	609a      	str	r2, [r3, #8]
  hdma->State = HAL_DMA_STATE_READY;
 80217d6:	2301      	movs	r3, #1
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 80217d8:	6560      	str	r0, [r4, #84]	@ 0x54
  hdma->State = HAL_DMA_STATE_READY;
 80217da:	f884 3035 	strb.w	r3, [r4, #53]	@ 0x35
}
 80217de:	bd38      	pop	{r3, r4, r5, pc}
      hdma->State = HAL_DMA_STATE_TIMEOUT;
 80217e0:	2303      	movs	r3, #3
      hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 80217e2:	2220      	movs	r2, #32
 80217e4:	6562      	str	r2, [r4, #84]	@ 0x54
      hdma->State = HAL_DMA_STATE_TIMEOUT;
 80217e6:	f884 3035 	strb.w	r3, [r4, #53]	@ 0x35
      return HAL_TIMEOUT;
 80217ea:	4618      	mov	r0, r3
}
 80217ec:	bd38      	pop	{r3, r4, r5, pc}
    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
 80217ee:	e9d4 510b 	ldrd	r5, r1, [r4, #44]	@ 0x2c
 80217f2:	4329      	orrs	r1, r5
 80217f4:	4311      	orrs	r1, r2
  hdma->Instance->CR = tmp;  
 80217f6:	6019      	str	r1, [r3, #0]
  tmp = hdma->Instance->FCR;
 80217f8:	6959      	ldr	r1, [r3, #20]
    tmp |= hdma->Init.FIFOThreshold;
 80217fa:	6aa2      	ldr	r2, [r4, #40]	@ 0x28
  tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 80217fc:	f021 0107 	bic.w	r1, r1, #7
 8021800:	4311      	orrs	r1, r2
    tmp |= hdma->Init.FIFOThreshold;
 8021802:	f041 0104 	orr.w	r1, r1, #4
    if (hdma->Init.MemBurst != DMA_MBURST_SINGLE)
 8021806:	2d00      	cmp	r5, #0
 8021808:	d0d1      	beq.n	80217ae <HAL_DMA_Init+0x6e>
{
  HAL_StatusTypeDef status = HAL_OK;
  uint32_t tmp = hdma->Init.FIFOThreshold;
  
  /* Memory Data size equal to Byte */
  if(hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
 802180a:	b178      	cbz	r0, 802182c <HAL_DMA_Init+0xec>
      break;
    }
  }
  
  /* Memory Data size equal to Half-Word */
  else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
 802180c:	f5b0 5f00 	cmp.w	r0, #8192	@ 0x2000
 8021810:	d016      	beq.n	8021840 <HAL_DMA_Init+0x100>
  }
  
  /* Memory Data size equal to Word */
  else
  {
    switch (tmp)
 8021812:	2a02      	cmp	r2, #2
 8021814:	d903      	bls.n	802181e <HAL_DMA_Init+0xde>
 8021816:	2a03      	cmp	r2, #3
 8021818:	d1c9      	bne.n	80217ae <HAL_DMA_Init+0x6e>
    case DMA_FIFO_THRESHOLD_HALFFULL:
    case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
      status = HAL_ERROR;
      break;
    case DMA_FIFO_THRESHOLD_FULL:
      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 802181a:	01ea      	lsls	r2, r5, #7
 802181c:	d5c7      	bpl.n	80217ae <HAL_DMA_Init+0x6e>
        hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
 802181e:	2240      	movs	r2, #64	@ 0x40
        hdma->State = HAL_DMA_STATE_READY;
 8021820:	2301      	movs	r3, #1
        hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
 8021822:	6562      	str	r2, [r4, #84]	@ 0x54
        hdma->State = HAL_DMA_STATE_READY;
 8021824:	f884 3035 	strb.w	r3, [r4, #53]	@ 0x35
    return HAL_ERROR;
 8021828:	2001      	movs	r0, #1
}
 802182a:	bd38      	pop	{r3, r4, r5, pc}
    switch (tmp)
 802182c:	2a01      	cmp	r2, #1
 802182e:	d003      	beq.n	8021838 <HAL_DMA_Init+0xf8>
 8021830:	f032 0202 	bics.w	r2, r2, #2
 8021834:	d1bb      	bne.n	80217ae <HAL_DMA_Init+0x6e>
 8021836:	e7f0      	b.n	802181a <HAL_DMA_Init+0xda>
      if (hdma->Init.MemBurst == DMA_MBURST_INC16)
 8021838:	f1b5 7fc0 	cmp.w	r5, #25165824	@ 0x1800000
 802183c:	d1b7      	bne.n	80217ae <HAL_DMA_Init+0x6e>
 802183e:	e7ee      	b.n	802181e <HAL_DMA_Init+0xde>
    switch (tmp)
 8021840:	2a03      	cmp	r2, #3
 8021842:	d8b4      	bhi.n	80217ae <HAL_DMA_Init+0x6e>
 8021844:	a001      	add	r0, pc, #4	@ (adr r0, 802184c <HAL_DMA_Init+0x10c>)
 8021846:	f850 f022 	ldr.w	pc, [r0, r2, lsl #2]
 802184a:	bf00      	nop
 802184c:	0802181f 	.word	0x0802181f
 8021850:	0802181b 	.word	0x0802181b
 8021854:	0802181f 	.word	0x0802181f
 8021858:	08021839 	.word	0x08021839
 802185c:	e010803f 	.word	0xe010803f
 8021860:	aaaaaaab 	.word	0xaaaaaaab
 8021864:	0802acd8 	.word	0x0802acd8

08021868 <HAL_DMA_Start_IT>:
{
 8021868:	b470      	push	{r4, r5, r6}
  __HAL_LOCK(hdma);
 802186a:	f890 4034 	ldrb.w	r4, [r0, #52]	@ 0x34
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 802186e:	6d85      	ldr	r5, [r0, #88]	@ 0x58
  __HAL_LOCK(hdma);
 8021870:	2c01      	cmp	r4, #1
 8021872:	d00a      	beq.n	802188a <HAL_DMA_Start_IT+0x22>
  if(HAL_DMA_STATE_READY == hdma->State)
 8021874:	f890 4035 	ldrb.w	r4, [r0, #53]	@ 0x35
  __HAL_LOCK(hdma);
 8021878:	f04f 0c01 	mov.w	ip, #1
  if(HAL_DMA_STATE_READY == hdma->State)
 802187c:	4564      	cmp	r4, ip
  __HAL_LOCK(hdma);
 802187e:	f880 c034 	strb.w	ip, [r0, #52]	@ 0x34
  if(HAL_DMA_STATE_READY == hdma->State)
 8021882:	d005      	beq.n	8021890 <HAL_DMA_Start_IT+0x28>
    __HAL_UNLOCK(hdma);	  
 8021884:	2300      	movs	r3, #0
 8021886:	f880 3034 	strb.w	r3, [r0, #52]	@ 0x34
  __HAL_LOCK(hdma);
 802188a:	2002      	movs	r0, #2
}
 802188c:	bc70      	pop	{r4, r5, r6}
 802188e:	4770      	bx	lr
    hdma->State = HAL_DMA_STATE_BUSY;
 8021890:	2602      	movs	r6, #2
 8021892:	f880 6035 	strb.w	r6, [r0, #53]	@ 0x35
  hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
 8021896:	6804      	ldr	r4, [r0, #0]
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8021898:	2600      	movs	r6, #0
 802189a:	6546      	str	r6, [r0, #84]	@ 0x54
  hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
 802189c:	6826      	ldr	r6, [r4, #0]
 802189e:	f426 2680 	bic.w	r6, r6, #262144	@ 0x40000
 80218a2:	6026      	str	r6, [r4, #0]
  hdma->Instance->NDTR = DataLength;
 80218a4:	6063      	str	r3, [r4, #4]
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 80218a6:	6883      	ldr	r3, [r0, #8]
 80218a8:	2b40      	cmp	r3, #64	@ 0x40
    hdma->Instance->PAR = DstAddress;
 80218aa:	bf0e      	itee	eq
 80218ac:	60a2      	streq	r2, [r4, #8]
    hdma->Instance->PAR = SrcAddress;
 80218ae:	60a1      	strne	r1, [r4, #8]
    hdma->Instance->M0AR = DstAddress;
 80218b0:	60e2      	strne	r2, [r4, #12]
    regs->IFCR = 0x3FU << hdma->StreamIndex;
 80218b2:	6dc2      	ldr	r2, [r0, #92]	@ 0x5c
    hdma->Instance->M0AR = SrcAddress;
 80218b4:	bf08      	it	eq
 80218b6:	60e1      	streq	r1, [r4, #12]
    regs->IFCR = 0x3FU << hdma->StreamIndex;
 80218b8:	233f      	movs	r3, #63	@ 0x3f
 80218ba:	4093      	lsls	r3, r2
 80218bc:	60ab      	str	r3, [r5, #8]
    hdma->Instance->CR  |= DMA_IT_TC | DMA_IT_TE | DMA_IT_DME;
 80218be:	6823      	ldr	r3, [r4, #0]
    if(hdma->XferHalfCpltCallback != NULL)
 80218c0:	6c02      	ldr	r2, [r0, #64]	@ 0x40
    hdma->Instance->CR  |= DMA_IT_TC | DMA_IT_TE | DMA_IT_DME;
 80218c2:	f043 0316 	orr.w	r3, r3, #22
 80218c6:	6023      	str	r3, [r4, #0]
    hdma->Instance->FCR |= DMA_IT_FE;
 80218c8:	6963      	ldr	r3, [r4, #20]
 80218ca:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 80218ce:	6163      	str	r3, [r4, #20]
    if(hdma->XferHalfCpltCallback != NULL)
 80218d0:	b11a      	cbz	r2, 80218da <HAL_DMA_Start_IT+0x72>
      hdma->Instance->CR  |= DMA_IT_HT;
 80218d2:	6823      	ldr	r3, [r4, #0]
 80218d4:	f043 0308 	orr.w	r3, r3, #8
 80218d8:	6023      	str	r3, [r4, #0]
    __HAL_DMA_ENABLE(hdma);
 80218da:	6823      	ldr	r3, [r4, #0]
 80218dc:	f043 0301 	orr.w	r3, r3, #1
  HAL_StatusTypeDef status = HAL_OK;
 80218e0:	2000      	movs	r0, #0
    __HAL_DMA_ENABLE(hdma);
 80218e2:	6023      	str	r3, [r4, #0]
}
 80218e4:	bc70      	pop	{r4, r5, r6}
 80218e6:	4770      	bx	lr

080218e8 <HAL_DMA_Abort_IT>:
  if(hdma->State != HAL_DMA_STATE_BUSY)
 80218e8:	f890 3035 	ldrb.w	r3, [r0, #53]	@ 0x35
 80218ec:	2b02      	cmp	r3, #2
 80218ee:	d003      	beq.n	80218f8 <HAL_DMA_Abort_IT+0x10>
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 80218f0:	2380      	movs	r3, #128	@ 0x80
 80218f2:	6543      	str	r3, [r0, #84]	@ 0x54
    return HAL_ERROR;
 80218f4:	2001      	movs	r0, #1
 80218f6:	4770      	bx	lr
    __HAL_DMA_DISABLE(hdma);
 80218f8:	6802      	ldr	r2, [r0, #0]
    hdma->State = HAL_DMA_STATE_ABORT;
 80218fa:	2305      	movs	r3, #5
 80218fc:	f880 3035 	strb.w	r3, [r0, #53]	@ 0x35
    __HAL_DMA_DISABLE(hdma);
 8021900:	6813      	ldr	r3, [r2, #0]
 8021902:	f023 0301 	bic.w	r3, r3, #1
  return HAL_OK;
 8021906:	2000      	movs	r0, #0
    __HAL_DMA_DISABLE(hdma);
 8021908:	6013      	str	r3, [r2, #0]
}
 802190a:	4770      	bx	lr

0802190c <HAL_DMA_IRQHandler>:
{
 802190c:	b5f0      	push	{r4, r5, r6, r7, lr}
 802190e:	b083      	sub	sp, #12
  uint32_t timeout = SystemCoreClock / 9600U;
 8021910:	4a67      	ldr	r2, [pc, #412]	@ (8021ab0 <HAL_DMA_IRQHandler+0x1a4>)
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 8021912:	6d87      	ldr	r7, [r0, #88]	@ 0x58
  uint32_t timeout = SystemCoreClock / 9600U;
 8021914:	6816      	ldr	r6, [r2, #0]
  __IO uint32_t count = 0U;
 8021916:	2300      	movs	r3, #0
 8021918:	9301      	str	r3, [sp, #4]
  if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
 802191a:	6dc3      	ldr	r3, [r0, #92]	@ 0x5c
  tmpisr = regs->ISR;
 802191c:	683d      	ldr	r5, [r7, #0]
  if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
 802191e:	2208      	movs	r2, #8
 8021920:	409a      	lsls	r2, r3
 8021922:	422a      	tst	r2, r5
{
 8021924:	4604      	mov	r4, r0
  if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
 8021926:	d003      	beq.n	8021930 <HAL_DMA_IRQHandler+0x24>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
 8021928:	6801      	ldr	r1, [r0, #0]
 802192a:	6808      	ldr	r0, [r1, #0]
 802192c:	0740      	lsls	r0, r0, #29
 802192e:	d478      	bmi.n	8021a22 <HAL_DMA_IRQHandler+0x116>
  if ((tmpisr & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)
 8021930:	2201      	movs	r2, #1
 8021932:	409a      	lsls	r2, r3
 8021934:	422a      	tst	r2, r5
 8021936:	d003      	beq.n	8021940 <HAL_DMA_IRQHandler+0x34>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != RESET)
 8021938:	6821      	ldr	r1, [r4, #0]
 802193a:	6949      	ldr	r1, [r1, #20]
 802193c:	0608      	lsls	r0, r1, #24
 802193e:	d46a      	bmi.n	8021a16 <HAL_DMA_IRQHandler+0x10a>
  if ((tmpisr & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)
 8021940:	2204      	movs	r2, #4
 8021942:	409a      	lsls	r2, r3
 8021944:	422a      	tst	r2, r5
 8021946:	d003      	beq.n	8021950 <HAL_DMA_IRQHandler+0x44>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != RESET)
 8021948:	6821      	ldr	r1, [r4, #0]
 802194a:	6809      	ldr	r1, [r1, #0]
 802194c:	0789      	lsls	r1, r1, #30
 802194e:	d45c      	bmi.n	8021a0a <HAL_DMA_IRQHandler+0xfe>
  if ((tmpisr & (DMA_FLAG_HTIF0_4 << hdma->StreamIndex)) != RESET)
 8021950:	2210      	movs	r2, #16
 8021952:	409a      	lsls	r2, r3
 8021954:	422a      	tst	r2, r5
 8021956:	d003      	beq.n	8021960 <HAL_DMA_IRQHandler+0x54>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
 8021958:	6821      	ldr	r1, [r4, #0]
 802195a:	6808      	ldr	r0, [r1, #0]
 802195c:	0700      	lsls	r0, r0, #28
 802195e:	d441      	bmi.n	80219e4 <HAL_DMA_IRQHandler+0xd8>
  if ((tmpisr & (DMA_FLAG_TCIF0_4 << hdma->StreamIndex)) != RESET)
 8021960:	2220      	movs	r2, #32
 8021962:	409a      	lsls	r2, r3
 8021964:	422a      	tst	r2, r5
 8021966:	d014      	beq.n	8021992 <HAL_DMA_IRQHandler+0x86>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET)
 8021968:	6821      	ldr	r1, [r4, #0]
 802196a:	6808      	ldr	r0, [r1, #0]
 802196c:	06c0      	lsls	r0, r0, #27
 802196e:	d510      	bpl.n	8021992 <HAL_DMA_IRQHandler+0x86>
      regs->IFCR = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
 8021970:	60ba      	str	r2, [r7, #8]
      if(HAL_DMA_STATE_ABORT == hdma->State)
 8021972:	f894 2035 	ldrb.w	r2, [r4, #53]	@ 0x35
 8021976:	2a05      	cmp	r2, #5
 8021978:	d063      	beq.n	8021a42 <HAL_DMA_IRQHandler+0x136>
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 802197a:	680b      	ldr	r3, [r1, #0]
 802197c:	f413 2f80 	tst.w	r3, #262144	@ 0x40000
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 8021980:	680b      	ldr	r3, [r1, #0]
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 8021982:	d07e      	beq.n	8021a82 <HAL_DMA_IRQHandler+0x176>
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 8021984:	0319      	lsls	r1, r3, #12
 8021986:	f140 8089 	bpl.w	8021a9c <HAL_DMA_IRQHandler+0x190>
        if(hdma->XferCpltCallback != NULL)
 802198a:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
 802198c:	b10b      	cbz	r3, 8021992 <HAL_DMA_IRQHandler+0x86>
          hdma->XferCpltCallback(hdma);
 802198e:	4620      	mov	r0, r4
 8021990:	4798      	blx	r3
  if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
 8021992:	6d63      	ldr	r3, [r4, #84]	@ 0x54
 8021994:	b323      	cbz	r3, 80219e0 <HAL_DMA_IRQHandler+0xd4>
    if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != RESET)
 8021996:	6d63      	ldr	r3, [r4, #84]	@ 0x54
 8021998:	07da      	lsls	r2, r3, #31
 802199a:	d51a      	bpl.n	80219d2 <HAL_DMA_IRQHandler+0xc6>
      __HAL_DMA_DISABLE(hdma);
 802199c:	6822      	ldr	r2, [r4, #0]
  uint32_t timeout = SystemCoreClock / 9600U;
 802199e:	4945      	ldr	r1, [pc, #276]	@ (8021ab4 <HAL_DMA_IRQHandler+0x1a8>)
      hdma->State = HAL_DMA_STATE_ABORT;
 80219a0:	2305      	movs	r3, #5
 80219a2:	f884 3035 	strb.w	r3, [r4, #53]	@ 0x35
      __HAL_DMA_DISABLE(hdma);
 80219a6:	6813      	ldr	r3, [r2, #0]
  uint32_t timeout = SystemCoreClock / 9600U;
 80219a8:	fba1 1606 	umull	r1, r6, r1, r6
      __HAL_DMA_DISABLE(hdma);
 80219ac:	f023 0301 	bic.w	r3, r3, #1
  uint32_t timeout = SystemCoreClock / 9600U;
 80219b0:	0ab6      	lsrs	r6, r6, #10
      __HAL_DMA_DISABLE(hdma);
 80219b2:	6013      	str	r3, [r2, #0]
 80219b4:	e002      	b.n	80219bc <HAL_DMA_IRQHandler+0xb0>
      while((hdma->Instance->CR & DMA_SxCR_EN) != RESET);
 80219b6:	6813      	ldr	r3, [r2, #0]
 80219b8:	07db      	lsls	r3, r3, #31
 80219ba:	d504      	bpl.n	80219c6 <HAL_DMA_IRQHandler+0xba>
        if (++count > timeout)
 80219bc:	9b01      	ldr	r3, [sp, #4]
 80219be:	3301      	adds	r3, #1
 80219c0:	42b3      	cmp	r3, r6
 80219c2:	9301      	str	r3, [sp, #4]
 80219c4:	d9f7      	bls.n	80219b6 <HAL_DMA_IRQHandler+0xaa>
      __HAL_UNLOCK(hdma);
 80219c6:	2200      	movs	r2, #0
      hdma->State = HAL_DMA_STATE_READY;
 80219c8:	2301      	movs	r3, #1
      __HAL_UNLOCK(hdma);
 80219ca:	f884 2034 	strb.w	r2, [r4, #52]	@ 0x34
      hdma->State = HAL_DMA_STATE_READY;
 80219ce:	f884 3035 	strb.w	r3, [r4, #53]	@ 0x35
    if(hdma->XferErrorCallback != NULL)
 80219d2:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
 80219d4:	b123      	cbz	r3, 80219e0 <HAL_DMA_IRQHandler+0xd4>
      hdma->XferErrorCallback(hdma);
 80219d6:	4620      	mov	r0, r4
}
 80219d8:	b003      	add	sp, #12
 80219da:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
      hdma->XferErrorCallback(hdma);
 80219de:	4718      	bx	r3
}
 80219e0:	b003      	add	sp, #12
 80219e2:	bdf0      	pop	{r4, r5, r6, r7, pc}
      regs->IFCR = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
 80219e4:	60ba      	str	r2, [r7, #8]
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 80219e6:	680a      	ldr	r2, [r1, #0]
 80219e8:	f412 2f80 	tst.w	r2, #262144	@ 0x40000
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 80219ec:	680a      	ldr	r2, [r1, #0]
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 80219ee:	d122      	bne.n	8021a36 <HAL_DMA_IRQHandler+0x12a>
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
 80219f0:	05d2      	lsls	r2, r2, #23
 80219f2:	d403      	bmi.n	80219fc <HAL_DMA_IRQHandler+0xf0>
          hdma->Instance->CR  &= ~(DMA_IT_HT);
 80219f4:	680a      	ldr	r2, [r1, #0]
 80219f6:	f022 0208 	bic.w	r2, r2, #8
 80219fa:	600a      	str	r2, [r1, #0]
        if(hdma->XferHalfCpltCallback != NULL)
 80219fc:	6c22      	ldr	r2, [r4, #64]	@ 0x40
 80219fe:	2a00      	cmp	r2, #0
 8021a00:	d0ae      	beq.n	8021960 <HAL_DMA_IRQHandler+0x54>
          hdma->XferHalfCpltCallback(hdma);
 8021a02:	4620      	mov	r0, r4
 8021a04:	4790      	blx	r2
  if ((tmpisr & (DMA_FLAG_TCIF0_4 << hdma->StreamIndex)) != RESET)
 8021a06:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
 8021a08:	e7aa      	b.n	8021960 <HAL_DMA_IRQHandler+0x54>
      regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
 8021a0a:	60ba      	str	r2, [r7, #8]
      hdma->ErrorCode |= HAL_DMA_ERROR_DME;
 8021a0c:	6d62      	ldr	r2, [r4, #84]	@ 0x54
 8021a0e:	f042 0204 	orr.w	r2, r2, #4
 8021a12:	6562      	str	r2, [r4, #84]	@ 0x54
 8021a14:	e79c      	b.n	8021950 <HAL_DMA_IRQHandler+0x44>
      regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
 8021a16:	60ba      	str	r2, [r7, #8]
      hdma->ErrorCode |= HAL_DMA_ERROR_FE;
 8021a18:	6d62      	ldr	r2, [r4, #84]	@ 0x54
 8021a1a:	f042 0202 	orr.w	r2, r2, #2
 8021a1e:	6562      	str	r2, [r4, #84]	@ 0x54
 8021a20:	e78e      	b.n	8021940 <HAL_DMA_IRQHandler+0x34>
      hdma->Instance->CR  &= ~(DMA_IT_TE);
 8021a22:	6808      	ldr	r0, [r1, #0]
 8021a24:	f020 0004 	bic.w	r0, r0, #4
 8021a28:	6008      	str	r0, [r1, #0]
      regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
 8021a2a:	60ba      	str	r2, [r7, #8]
      hdma->ErrorCode |= HAL_DMA_ERROR_TE;
 8021a2c:	6d62      	ldr	r2, [r4, #84]	@ 0x54
 8021a2e:	f042 0201 	orr.w	r2, r2, #1
 8021a32:	6562      	str	r2, [r4, #84]	@ 0x54
 8021a34:	e77c      	b.n	8021930 <HAL_DMA_IRQHandler+0x24>
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 8021a36:	0311      	lsls	r1, r2, #12
 8021a38:	d5e0      	bpl.n	80219fc <HAL_DMA_IRQHandler+0xf0>
          if(hdma->XferM1HalfCpltCallback != NULL)
 8021a3a:	6ca2      	ldr	r2, [r4, #72]	@ 0x48
 8021a3c:	2a00      	cmp	r2, #0
 8021a3e:	d1e0      	bne.n	8021a02 <HAL_DMA_IRQHandler+0xf6>
 8021a40:	e78e      	b.n	8021960 <HAL_DMA_IRQHandler+0x54>
        hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
 8021a42:	680a      	ldr	r2, [r1, #0]
 8021a44:	f022 0216 	bic.w	r2, r2, #22
 8021a48:	600a      	str	r2, [r1, #0]
        hdma->Instance->FCR &= ~(DMA_IT_FE);
 8021a4a:	694a      	ldr	r2, [r1, #20]
 8021a4c:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
 8021a50:	614a      	str	r2, [r1, #20]
        if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 8021a52:	6c22      	ldr	r2, [r4, #64]	@ 0x40
 8021a54:	b33a      	cbz	r2, 8021aa6 <HAL_DMA_IRQHandler+0x19a>
          hdma->Instance->CR  &= ~(DMA_IT_HT);
 8021a56:	680a      	ldr	r2, [r1, #0]
 8021a58:	f022 0208 	bic.w	r2, r2, #8
 8021a5c:	600a      	str	r2, [r1, #0]
        regs->IFCR = 0x3FU << hdma->StreamIndex;
 8021a5e:	223f      	movs	r2, #63	@ 0x3f
 8021a60:	fa02 f303 	lsl.w	r3, r2, r3
        if(hdma->XferAbortCallback != NULL)
 8021a64:	6d21      	ldr	r1, [r4, #80]	@ 0x50
        regs->IFCR = 0x3FU << hdma->StreamIndex;
 8021a66:	60bb      	str	r3, [r7, #8]
        __HAL_UNLOCK(hdma);
 8021a68:	2200      	movs	r2, #0
        hdma->State = HAL_DMA_STATE_READY;
 8021a6a:	2301      	movs	r3, #1
        __HAL_UNLOCK(hdma);
 8021a6c:	f884 2034 	strb.w	r2, [r4, #52]	@ 0x34
        hdma->State = HAL_DMA_STATE_READY;
 8021a70:	f884 3035 	strb.w	r3, [r4, #53]	@ 0x35
        if(hdma->XferAbortCallback != NULL)
 8021a74:	2900      	cmp	r1, #0
 8021a76:	d0b3      	beq.n	80219e0 <HAL_DMA_IRQHandler+0xd4>
          hdma->XferAbortCallback(hdma);
 8021a78:	4620      	mov	r0, r4
}
 8021a7a:	b003      	add	sp, #12
 8021a7c:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
          hdma->XferAbortCallback(hdma);
 8021a80:	4708      	bx	r1
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
 8021a82:	f413 7380 	ands.w	r3, r3, #256	@ 0x100
 8021a86:	d180      	bne.n	802198a <HAL_DMA_IRQHandler+0x7e>
          hdma->Instance->CR  &= ~(DMA_IT_TC);
 8021a88:	680a      	ldr	r2, [r1, #0]
 8021a8a:	f022 0210 	bic.w	r2, r2, #16
 8021a8e:	600a      	str	r2, [r1, #0]
          hdma->State = HAL_DMA_STATE_READY;
 8021a90:	2201      	movs	r2, #1
          __HAL_UNLOCK(hdma);
 8021a92:	f884 3034 	strb.w	r3, [r4, #52]	@ 0x34
          hdma->State = HAL_DMA_STATE_READY;
 8021a96:	f884 2035 	strb.w	r2, [r4, #53]	@ 0x35
 8021a9a:	e776      	b.n	802198a <HAL_DMA_IRQHandler+0x7e>
          if(hdma->XferM1CpltCallback != NULL)
 8021a9c:	6c63      	ldr	r3, [r4, #68]	@ 0x44
 8021a9e:	2b00      	cmp	r3, #0
 8021aa0:	f47f af75 	bne.w	802198e <HAL_DMA_IRQHandler+0x82>
 8021aa4:	e775      	b.n	8021992 <HAL_DMA_IRQHandler+0x86>
        if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 8021aa6:	6ca2      	ldr	r2, [r4, #72]	@ 0x48
 8021aa8:	2a00      	cmp	r2, #0
 8021aaa:	d1d4      	bne.n	8021a56 <HAL_DMA_IRQHandler+0x14a>
 8021aac:	e7d7      	b.n	8021a5e <HAL_DMA_IRQHandler+0x152>
 8021aae:	bf00      	nop
 8021ab0:	20000130 	.word	0x20000130
 8021ab4:	1b4e81b5 	.word	0x1b4e81b5

08021ab8 <FLASH_SetErrorCode>:
  * @brief  Set the specific FLASH error flag.
  * @retval None
  */
static void FLASH_SetErrorCode(void)
{ 
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR) != RESET)
 8021ab8:	4b21      	ldr	r3, [pc, #132]	@ (8021b40 <FLASH_SetErrorCode+0x88>)
 8021aba:	68da      	ldr	r2, [r3, #12]
 8021abc:	06d0      	lsls	r0, r2, #27
 8021abe:	d505      	bpl.n	8021acc <FLASH_SetErrorCode+0x14>
  {
   pFlash.ErrorCode |= HAL_FLASH_ERROR_WRP;
 8021ac0:	4920      	ldr	r1, [pc, #128]	@ (8021b44 <FLASH_SetErrorCode+0x8c>)
 8021ac2:	69ca      	ldr	r2, [r1, #28]
   
   /* Clear FLASH write protection error pending bit */
   __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_WRPERR);
 8021ac4:	2010      	movs	r0, #16
   pFlash.ErrorCode |= HAL_FLASH_ERROR_WRP;
 8021ac6:	4302      	orrs	r2, r0
 8021ac8:	61ca      	str	r2, [r1, #28]
   __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_WRPERR);
 8021aca:	60d8      	str	r0, [r3, #12]
  }
  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGAERR) != RESET)
 8021acc:	4b1c      	ldr	r3, [pc, #112]	@ (8021b40 <FLASH_SetErrorCode+0x88>)
 8021ace:	68da      	ldr	r2, [r3, #12]
 8021ad0:	0691      	lsls	r1, r2, #26
 8021ad2:	d506      	bpl.n	8021ae2 <FLASH_SetErrorCode+0x2a>
  {
   pFlash.ErrorCode |= HAL_FLASH_ERROR_PGA;
 8021ad4:	491b      	ldr	r1, [pc, #108]	@ (8021b44 <FLASH_SetErrorCode+0x8c>)
 8021ad6:	69ca      	ldr	r2, [r1, #28]
   
   /* Clear FLASH Programming alignment error pending bit */
   __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_PGAERR);
 8021ad8:	2020      	movs	r0, #32
   pFlash.ErrorCode |= HAL_FLASH_ERROR_PGA;
 8021ada:	f042 0208 	orr.w	r2, r2, #8
 8021ade:	61ca      	str	r2, [r1, #28]
   __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_PGAERR);
 8021ae0:	60d8      	str	r0, [r3, #12]
  }
  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGPERR) != RESET)
 8021ae2:	4b17      	ldr	r3, [pc, #92]	@ (8021b40 <FLASH_SetErrorCode+0x88>)
 8021ae4:	68da      	ldr	r2, [r3, #12]
 8021ae6:	0652      	lsls	r2, r2, #25
 8021ae8:	d506      	bpl.n	8021af8 <FLASH_SetErrorCode+0x40>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_PGP;
 8021aea:	4916      	ldr	r1, [pc, #88]	@ (8021b44 <FLASH_SetErrorCode+0x8c>)
 8021aec:	69ca      	ldr	r2, [r1, #28]
    
    /* Clear FLASH Programming parallelism error pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_PGPERR);
 8021aee:	2040      	movs	r0, #64	@ 0x40
    pFlash.ErrorCode |= HAL_FLASH_ERROR_PGP;
 8021af0:	f042 0204 	orr.w	r2, r2, #4
 8021af4:	61ca      	str	r2, [r1, #28]
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_PGPERR);
 8021af6:	60d8      	str	r0, [r3, #12]
  }
  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGSERR) != RESET)
 8021af8:	4b11      	ldr	r3, [pc, #68]	@ (8021b40 <FLASH_SetErrorCode+0x88>)
 8021afa:	68da      	ldr	r2, [r3, #12]
 8021afc:	0610      	lsls	r0, r2, #24
 8021afe:	d506      	bpl.n	8021b0e <FLASH_SetErrorCode+0x56>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_PGS;
 8021b00:	4910      	ldr	r1, [pc, #64]	@ (8021b44 <FLASH_SetErrorCode+0x8c>)
 8021b02:	69ca      	ldr	r2, [r1, #28]
    
    /* Clear FLASH Programming sequence error pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_PGSERR);
 8021b04:	2080      	movs	r0, #128	@ 0x80
    pFlash.ErrorCode |= HAL_FLASH_ERROR_PGS;
 8021b06:	f042 0202 	orr.w	r2, r2, #2
 8021b0a:	61ca      	str	r2, [r1, #28]
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_PGSERR);
 8021b0c:	60d8      	str	r0, [r3, #12]
  }
#if defined(FLASH_SR_RDERR) 
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_RDERR) != RESET)
 8021b0e:	4b0c      	ldr	r3, [pc, #48]	@ (8021b40 <FLASH_SetErrorCode+0x88>)
 8021b10:	68da      	ldr	r2, [r3, #12]
 8021b12:	05d1      	lsls	r1, r2, #23
 8021b14:	d507      	bpl.n	8021b26 <FLASH_SetErrorCode+0x6e>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_RD;
 8021b16:	490b      	ldr	r1, [pc, #44]	@ (8021b44 <FLASH_SetErrorCode+0x8c>)
 8021b18:	69ca      	ldr	r2, [r1, #28]
    
    /* Clear FLASH Proprietary readout protection error pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_RDERR);
 8021b1a:	f44f 7080 	mov.w	r0, #256	@ 0x100
    pFlash.ErrorCode |= HAL_FLASH_ERROR_RD;
 8021b1e:	f042 0201 	orr.w	r2, r2, #1
 8021b22:	61ca      	str	r2, [r1, #28]
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_RDERR);
 8021b24:	60d8      	str	r0, [r3, #12]
  }
#endif /* FLASH_SR_RDERR */  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPERR) != RESET)
 8021b26:	4b06      	ldr	r3, [pc, #24]	@ (8021b40 <FLASH_SetErrorCode+0x88>)
 8021b28:	68da      	ldr	r2, [r3, #12]
 8021b2a:	0792      	lsls	r2, r2, #30
 8021b2c:	d506      	bpl.n	8021b3c <FLASH_SetErrorCode+0x84>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_OPERATION;
 8021b2e:	4905      	ldr	r1, [pc, #20]	@ (8021b44 <FLASH_SetErrorCode+0x8c>)
 8021b30:	69ca      	ldr	r2, [r1, #28]
    
    /* Clear FLASH Operation error pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_OPERR);
 8021b32:	2002      	movs	r0, #2
    pFlash.ErrorCode |= HAL_FLASH_ERROR_OPERATION;
 8021b34:	f042 0220 	orr.w	r2, r2, #32
 8021b38:	61ca      	str	r2, [r1, #28]
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_OPERR);
 8021b3a:	60d8      	str	r0, [r3, #12]
  }
}
 8021b3c:	4770      	bx	lr
 8021b3e:	bf00      	nop
 8021b40:	40023c00 	.word	0x40023c00
 8021b44:	200001b0 	.word	0x200001b0

08021b48 <HAL_FLASH_Program>:
{
 8021b48:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  __HAL_LOCK(&pFlash);
 8021b4c:	4f4c      	ldr	r7, [pc, #304]	@ (8021c80 <HAL_FLASH_Program+0x138>)
{
 8021b4e:	469b      	mov	fp, r3
  __HAL_LOCK(&pFlash);
 8021b50:	7e3b      	ldrb	r3, [r7, #24]
 8021b52:	2b01      	cmp	r3, #1
 8021b54:	d05e      	beq.n	8021c14 <HAL_FLASH_Program+0xcc>
 8021b56:	2301      	movs	r3, #1
 8021b58:	763b      	strb	r3, [r7, #24]
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 8021b5a:	2300      	movs	r3, #0
 8021b5c:	4681      	mov	r9, r0
 8021b5e:	468a      	mov	sl, r1
 8021b60:	4690      	mov	r8, r2
 8021b62:	61fb      	str	r3, [r7, #28]
  tickstart = HAL_GetTick();
 8021b64:	f7ff fab8 	bl	80210d8 <HAL_GetTick>
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != RESET) 
 8021b68:	4d46      	ldr	r5, [pc, #280]	@ (8021c84 <HAL_FLASH_Program+0x13c>)
  tickstart = HAL_GetTick();
 8021b6a:	4604      	mov	r4, r0
      if((Timeout == 0U)||((HAL_GetTick() - tickstart ) > Timeout))
 8021b6c:	f24c 3650 	movw	r6, #50000	@ 0xc350
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != RESET) 
 8021b70:	e004      	b.n	8021b7c <HAL_FLASH_Program+0x34>
      if((Timeout == 0U)||((HAL_GetTick() - tickstart ) > Timeout))
 8021b72:	f7ff fab1 	bl	80210d8 <HAL_GetTick>
 8021b76:	1b00      	subs	r0, r0, r4
 8021b78:	42b0      	cmp	r0, r6
 8021b7a:	d846      	bhi.n	8021c0a <HAL_FLASH_Program+0xc2>
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != RESET) 
 8021b7c:	68eb      	ldr	r3, [r5, #12]
 8021b7e:	03d8      	lsls	r0, r3, #15
 8021b80:	d4f7      	bmi.n	8021b72 <HAL_FLASH_Program+0x2a>
  if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP) != RESET)
 8021b82:	68eb      	ldr	r3, [r5, #12]
 8021b84:	07d9      	lsls	r1, r3, #31
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
 8021b86:	bf44      	itt	mi
 8021b88:	2301      	movmi	r3, #1
 8021b8a:	60eb      	strmi	r3, [r5, #12]
  if(__HAL_FLASH_GET_FLAG((FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | \
 8021b8c:	4b3d      	ldr	r3, [pc, #244]	@ (8021c84 <HAL_FLASH_Program+0x13c>)
 8021b8e:	68da      	ldr	r2, [r3, #12]
 8021b90:	f412 7ff9 	tst.w	r2, #498	@ 0x1f2
 8021b94:	d152      	bne.n	8021c3c <HAL_FLASH_Program+0xf4>
    if(TypeProgram == FLASH_TYPEPROGRAM_BYTE)
 8021b96:	f1b9 0f00 	cmp.w	r9, #0
 8021b9a:	d03e      	beq.n	8021c1a <HAL_FLASH_Program+0xd2>
    else if(TypeProgram == FLASH_TYPEPROGRAM_HALFWORD)
 8021b9c:	f1b9 0f01 	cmp.w	r9, #1
  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
 8021ba0:	691a      	ldr	r2, [r3, #16]
    else if(TypeProgram == FLASH_TYPEPROGRAM_HALFWORD)
 8021ba2:	d04f      	beq.n	8021c44 <HAL_FLASH_Program+0xfc>
  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
 8021ba4:	f422 7240 	bic.w	r2, r2, #768	@ 0x300
 8021ba8:	611a      	str	r2, [r3, #16]
    else if(TypeProgram == FLASH_TYPEPROGRAM_WORD)
 8021baa:	f1b9 0f02 	cmp.w	r9, #2
  FLASH->CR |= FLASH_PSIZE_WORD;
 8021bae:	691a      	ldr	r2, [r3, #16]
    else if(TypeProgram == FLASH_TYPEPROGRAM_WORD)
 8021bb0:	d05c      	beq.n	8021c6c <HAL_FLASH_Program+0x124>
  FLASH->CR |= FLASH_PSIZE_DOUBLE_WORD;
 8021bb2:	f442 7240 	orr.w	r2, r2, #768	@ 0x300
 8021bb6:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_CR_PG;
 8021bb8:	691a      	ldr	r2, [r3, #16]
 8021bba:	f042 0201 	orr.w	r2, r2, #1
 8021bbe:	611a      	str	r2, [r3, #16]
  *(__IO uint32_t*)Address = (uint32_t)Data;
 8021bc0:	f8ca 8000 	str.w	r8, [sl]
  *(__IO uint32_t*)(Address+4) = (uint32_t)(Data >> 32);
 8021bc4:	f8ca b004 	str.w	fp, [sl, #4]
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 8021bc8:	2300      	movs	r3, #0
 8021bca:	61fb      	str	r3, [r7, #28]
  tickstart = HAL_GetTick();
 8021bcc:	f7ff fa84 	bl	80210d8 <HAL_GetTick>
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != RESET) 
 8021bd0:	4d2c      	ldr	r5, [pc, #176]	@ (8021c84 <HAL_FLASH_Program+0x13c>)
  tickstart = HAL_GetTick();
 8021bd2:	4604      	mov	r4, r0
      if((Timeout == 0U)||((HAL_GetTick() - tickstart ) > Timeout))
 8021bd4:	f24c 3650 	movw	r6, #50000	@ 0xc350
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != RESET) 
 8021bd8:	e004      	b.n	8021be4 <HAL_FLASH_Program+0x9c>
      if((Timeout == 0U)||((HAL_GetTick() - tickstart ) > Timeout))
 8021bda:	f7ff fa7d 	bl	80210d8 <HAL_GetTick>
 8021bde:	1b00      	subs	r0, r0, r4
 8021be0:	42b0      	cmp	r0, r6
 8021be2:	d829      	bhi.n	8021c38 <HAL_FLASH_Program+0xf0>
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != RESET) 
 8021be4:	68eb      	ldr	r3, [r5, #12]
 8021be6:	03da      	lsls	r2, r3, #15
 8021be8:	d4f7      	bmi.n	8021bda <HAL_FLASH_Program+0x92>
  if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP) != RESET)
 8021bea:	68eb      	ldr	r3, [r5, #12]
 8021bec:	07db      	lsls	r3, r3, #31
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
 8021bee:	bf44      	itt	mi
 8021bf0:	2301      	movmi	r3, #1
 8021bf2:	60eb      	strmi	r3, [r5, #12]
  if(__HAL_FLASH_GET_FLAG((FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | \
 8021bf4:	4b23      	ldr	r3, [pc, #140]	@ (8021c84 <HAL_FLASH_Program+0x13c>)
 8021bf6:	68d8      	ldr	r0, [r3, #12]
 8021bf8:	f410 70f9 	ands.w	r0, r0, #498	@ 0x1f2
 8021bfc:	d132      	bne.n	8021c64 <HAL_FLASH_Program+0x11c>
    FLASH->CR &= (~FLASH_CR_PG);  
 8021bfe:	4a21      	ldr	r2, [pc, #132]	@ (8021c84 <HAL_FLASH_Program+0x13c>)
 8021c00:	6913      	ldr	r3, [r2, #16]
 8021c02:	f023 0301 	bic.w	r3, r3, #1
 8021c06:	6113      	str	r3, [r2, #16]
 8021c08:	e000      	b.n	8021c0c <HAL_FLASH_Program+0xc4>
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8021c0a:	2003      	movs	r0, #3
  __HAL_UNLOCK(&pFlash);
 8021c0c:	2300      	movs	r3, #0
 8021c0e:	763b      	strb	r3, [r7, #24]
}
 8021c10:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  __HAL_LOCK(&pFlash);
 8021c14:	2002      	movs	r0, #2
}
 8021c16:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
 8021c1a:	691a      	ldr	r2, [r3, #16]
 8021c1c:	f422 7240 	bic.w	r2, r2, #768	@ 0x300
 8021c20:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_PSIZE_BYTE;
 8021c22:	691a      	ldr	r2, [r3, #16]
 8021c24:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_CR_PG;
 8021c26:	691a      	ldr	r2, [r3, #16]
      FLASH_Program_Byte(Address, (uint8_t) Data);
 8021c28:	fa5f f888 	uxtb.w	r8, r8
  FLASH->CR |= FLASH_CR_PG;
 8021c2c:	f042 0201 	orr.w	r2, r2, #1
 8021c30:	611a      	str	r2, [r3, #16]
  *(__IO uint8_t*)Address = Data;
 8021c32:	f88a 8000 	strb.w	r8, [sl]
}
 8021c36:	e7c7      	b.n	8021bc8 <HAL_FLASH_Program+0x80>
        return HAL_TIMEOUT;
 8021c38:	2003      	movs	r0, #3
 8021c3a:	e7e0      	b.n	8021bfe <HAL_FLASH_Program+0xb6>
    FLASH_SetErrorCode();
 8021c3c:	f7ff ff3c 	bl	8021ab8 <FLASH_SetErrorCode>
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8021c40:	2001      	movs	r0, #1
 8021c42:	e7e3      	b.n	8021c0c <HAL_FLASH_Program+0xc4>
  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
 8021c44:	f422 7240 	bic.w	r2, r2, #768	@ 0x300
 8021c48:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_PSIZE_HALF_WORD;
 8021c4a:	691a      	ldr	r2, [r3, #16]
 8021c4c:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
 8021c50:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_CR_PG;
 8021c52:	691a      	ldr	r2, [r3, #16]
      FLASH_Program_HalfWord(Address, (uint16_t) Data);
 8021c54:	fa1f f888 	uxth.w	r8, r8
  FLASH->CR |= FLASH_CR_PG;
 8021c58:	f042 0201 	orr.w	r2, r2, #1
 8021c5c:	611a      	str	r2, [r3, #16]
  *(__IO uint16_t*)Address = Data;
 8021c5e:	f8aa 8000 	strh.w	r8, [sl]
}
 8021c62:	e7b1      	b.n	8021bc8 <HAL_FLASH_Program+0x80>
    FLASH_SetErrorCode();
 8021c64:	f7ff ff28 	bl	8021ab8 <FLASH_SetErrorCode>
    return HAL_ERROR;
 8021c68:	2001      	movs	r0, #1
 8021c6a:	e7c8      	b.n	8021bfe <HAL_FLASH_Program+0xb6>
  FLASH->CR |= FLASH_PSIZE_WORD;
 8021c6c:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 8021c70:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_CR_PG;
 8021c72:	691a      	ldr	r2, [r3, #16]
 8021c74:	f042 0201 	orr.w	r2, r2, #1
 8021c78:	611a      	str	r2, [r3, #16]
  *(__IO uint32_t*)Address = Data;
 8021c7a:	f8ca 8000 	str.w	r8, [sl]
}
 8021c7e:	e7a3      	b.n	8021bc8 <HAL_FLASH_Program+0x80>
 8021c80:	200001b0 	.word	0x200001b0
 8021c84:	40023c00 	.word	0x40023c00

08021c88 <FLASH_Erase_Sector>:
  {
    tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
  }

  /* If the previous operation is completed, proceed to erase the sector */
  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
 8021c88:	4b0d      	ldr	r3, [pc, #52]	@ (8021cc0 <FLASH_Erase_Sector+0x38>)
 8021c8a:	691a      	ldr	r2, [r3, #16]
 8021c8c:	f422 7240 	bic.w	r2, r2, #768	@ 0x300
 8021c90:	611a      	str	r2, [r3, #16]
  FLASH->CR |= tmp_psize;
 8021c92:	691a      	ldr	r2, [r3, #16]
 8021c94:	2902      	cmp	r1, #2
 8021c96:	bf94      	ite	ls
 8021c98:	0209      	lslls	r1, r1, #8
{
 8021c9a:	f44f 7140 	movhi.w	r1, #768	@ 0x300
  FLASH->CR |= tmp_psize;
 8021c9e:	430a      	orrs	r2, r1
 8021ca0:	611a      	str	r2, [r3, #16]
  CLEAR_BIT(FLASH->CR, FLASH_CR_SNB);
 8021ca2:	691a      	ldr	r2, [r3, #16]
 8021ca4:	f022 02f8 	bic.w	r2, r2, #248	@ 0xf8
 8021ca8:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_CR_SER | (Sector << FLASH_CR_SNB_Pos);
 8021caa:	691a      	ldr	r2, [r3, #16]
 8021cac:	ea42 00c0 	orr.w	r0, r2, r0, lsl #3
 8021cb0:	f040 0002 	orr.w	r0, r0, #2
 8021cb4:	6118      	str	r0, [r3, #16]
  FLASH->CR |= FLASH_CR_STRT;
 8021cb6:	691a      	ldr	r2, [r3, #16]
 8021cb8:	f442 3280 	orr.w	r2, r2, #65536	@ 0x10000
 8021cbc:	611a      	str	r2, [r3, #16]
}
 8021cbe:	4770      	bx	lr
 8021cc0:	40023c00 	.word	0x40023c00

08021cc4 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8021cc4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8021cc8:	4aad      	ldr	r2, [pc, #692]	@ (8021f80 <HAL_GPIO_Init+0x2bc>)
  for(position = 0U; position < GPIO_NUMBER; position++)
  {
    /* Get the IO position */
    ioposition = 0x01U << position;
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8021cca:	680b      	ldr	r3, [r1, #0]
 8021ccc:	4290      	cmp	r0, r2
{
 8021cce:	b087      	sub	sp, #28
  for(position = 0U; position < GPIO_NUMBER; position++)
 8021cd0:	f04f 0200 	mov.w	r2, #0
 8021cd4:	f000 80dd 	beq.w	8021e92 <HAL_GPIO_Init+0x1ce>
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
        SYSCFG->EXTICR[position >> 2U] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 8021cd8:	f8df b2b4 	ldr.w	fp, [pc, #692]	@ 8021f90 <HAL_GPIO_Init+0x2cc>
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
 8021cdc:	468a      	mov	sl, r1
 8021cde:	e003      	b.n	8021ce8 <HAL_GPIO_Init+0x24>
  for(position = 0U; position < GPIO_NUMBER; position++)
 8021ce0:	3201      	adds	r2, #1
 8021ce2:	2a10      	cmp	r2, #16
 8021ce4:	f000 8096 	beq.w	8021e14 <HAL_GPIO_Init+0x150>
    ioposition = 0x01U << position;
 8021ce8:	2101      	movs	r1, #1
 8021cea:	fa01 f402 	lsl.w	r4, r1, r2
    if(iocurrent == ioposition)
 8021cee:	ea34 0103 	bics.w	r1, r4, r3
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8021cf2:	ea04 0703 	and.w	r7, r4, r3
    if(iocurrent == ioposition)
 8021cf6:	d1f3      	bne.n	8021ce0 <HAL_GPIO_Init+0x1c>
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8021cf8:	f8da 1004 	ldr.w	r1, [sl, #4]
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 8021cfc:	f8da 5008 	ldr.w	r5, [sl, #8]
 8021d00:	0056      	lsls	r6, r2, #1
 8021d02:	fa05 fc06 	lsl.w	ip, r5, r6
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8021d06:	f021 0810 	bic.w	r8, r1, #16
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8021d0a:	2503      	movs	r5, #3
 8021d0c:	40b5      	lsls	r5, r6
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8021d0e:	f001 0e03 	and.w	lr, r1, #3
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8021d12:	f1b8 0f02 	cmp.w	r8, #2
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8021d16:	ea6f 0505 	mvn.w	r5, r5
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8021d1a:	fa0e fe06 	lsl.w	lr, lr, r6
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8021d1e:	d07c      	beq.n	8021e1a <HAL_GPIO_Init+0x156>
      temp = GPIOx->MODER;
 8021d20:	f8d0 9000 	ldr.w	r9, [r0]
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8021d24:	f108 38ff 	add.w	r8, r8, #4294967295
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8021d28:	ea09 0905 	and.w	r9, r9, r5
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8021d2c:	ea49 0e0e 	orr.w	lr, r9, lr
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8021d30:	f1b8 0f01 	cmp.w	r8, #1
      GPIOx->MODER = temp;
 8021d34:	f8c0 e000 	str.w	lr, [r0]
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8021d38:	f240 808f 	bls.w	8021e5a <HAL_GPIO_Init+0x196>
      temp = GPIOx->PUPDR;
 8021d3c:	68c4      	ldr	r4, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
 8021d3e:	402c      	ands	r4, r5
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 8021d40:	ea44 040c 	orr.w	r4, r4, ip
      GPIOx->PUPDR = temp;
 8021d44:	60c4      	str	r4, [r0, #12]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8021d46:	00cc      	lsls	r4, r1, #3
 8021d48:	d5ca      	bpl.n	8021ce0 <HAL_GPIO_Init+0x1c>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8021d4a:	4d8e      	ldr	r5, [pc, #568]	@ (8021f84 <HAL_GPIO_Init+0x2c0>)
 8021d4c:	2400      	movs	r4, #0
 8021d4e:	9405      	str	r4, [sp, #20]
 8021d50:	6c6c      	ldr	r4, [r5, #68]	@ 0x44
 8021d52:	f444 4480 	orr.w	r4, r4, #16384	@ 0x4000
 8021d56:	646c      	str	r4, [r5, #68]	@ 0x44
 8021d58:	6c6c      	ldr	r4, [r5, #68]	@ 0x44
 8021d5a:	f404 4480 	and.w	r4, r4, #16384	@ 0x4000
 8021d5e:	9405      	str	r4, [sp, #20]
 8021d60:	9c05      	ldr	r4, [sp, #20]
        temp = SYSCFG->EXTICR[position >> 2U];
 8021d62:	f022 0403 	bic.w	r4, r2, #3
 8021d66:	f104 4480 	add.w	r4, r4, #1073741824	@ 0x40000000
 8021d6a:	f504 349c 	add.w	r4, r4, #79872	@ 0x13800
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
 8021d6e:	f002 0603 	and.w	r6, r2, #3
        temp = SYSCFG->EXTICR[position >> 2U];
 8021d72:	68a5      	ldr	r5, [r4, #8]
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
 8021d74:	00b6      	lsls	r6, r6, #2
 8021d76:	f04f 0c0f 	mov.w	ip, #15
 8021d7a:	fa0c fc06 	lsl.w	ip, ip, r6
 8021d7e:	ea25 0e0c 	bic.w	lr, r5, ip
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8021d82:	4d81      	ldr	r5, [pc, #516]	@ (8021f88 <HAL_GPIO_Init+0x2c4>)
 8021d84:	42a8      	cmp	r0, r5
 8021d86:	d07e      	beq.n	8021e86 <HAL_GPIO_Init+0x1c2>
 8021d88:	4d80      	ldr	r5, [pc, #512]	@ (8021f8c <HAL_GPIO_Init+0x2c8>)
 8021d8a:	42a8      	cmp	r0, r5
 8021d8c:	f000 8149 	beq.w	8022022 <HAL_GPIO_Init+0x35e>
 8021d90:	f8df c200 	ldr.w	ip, [pc, #512]	@ 8021f94 <HAL_GPIO_Init+0x2d0>
 8021d94:	4560      	cmp	r0, ip
 8021d96:	f000 814b 	beq.w	8022030 <HAL_GPIO_Init+0x36c>
 8021d9a:	f8df c1fc 	ldr.w	ip, [pc, #508]	@ 8021f98 <HAL_GPIO_Init+0x2d4>
 8021d9e:	4560      	cmp	r0, ip
 8021da0:	f000 814c 	beq.w	802203c <HAL_GPIO_Init+0x378>
 8021da4:	f8df c1f4 	ldr.w	ip, [pc, #500]	@ 8021f9c <HAL_GPIO_Init+0x2d8>
 8021da8:	4560      	cmp	r0, ip
 8021daa:	f000 814e 	beq.w	802204a <HAL_GPIO_Init+0x386>
 8021dae:	f8df c1f0 	ldr.w	ip, [pc, #496]	@ 8021fa0 <HAL_GPIO_Init+0x2dc>
 8021db2:	4560      	cmp	r0, ip
 8021db4:	bf0c      	ite	eq
 8021db6:	f04f 0c06 	moveq.w	ip, #6
 8021dba:	f04f 0c07 	movne.w	ip, #7
 8021dbe:	fa0c f606 	lsl.w	r6, ip, r6
 8021dc2:	ea4e 0506 	orr.w	r5, lr, r6
        SYSCFG->EXTICR[position >> 2U] = temp;
 8021dc6:	60a5      	str	r5, [r4, #8]
        temp = EXTI->IMR;
 8021dc8:	f8db 4000 	ldr.w	r4, [fp]
        temp &= ~((uint32_t)iocurrent);
 8021dcc:	43fd      	mvns	r5, r7
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8021dce:	03ce      	lsls	r6, r1, #15
        temp &= ~((uint32_t)iocurrent);
 8021dd0:	bf54      	ite	pl
 8021dd2:	402c      	andpl	r4, r5
        {
          temp |= iocurrent;
 8021dd4:	433c      	orrmi	r4, r7
        }
        EXTI->IMR = temp;
 8021dd6:	f8cb 4000 	str.w	r4, [fp]

        temp = EXTI->EMR;
 8021dda:	f8db 4004 	ldr.w	r4, [fp, #4]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8021dde:	038e      	lsls	r6, r1, #14
        temp &= ~((uint32_t)iocurrent);
 8021de0:	bf54      	ite	pl
 8021de2:	402c      	andpl	r4, r5
        {
          temp |= iocurrent;
 8021de4:	433c      	orrmi	r4, r7
        }
        EXTI->EMR = temp;
 8021de6:	f8cb 4004 	str.w	r4, [fp, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 8021dea:	f8db 4008 	ldr.w	r4, [fp, #8]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8021dee:	02ce      	lsls	r6, r1, #11
        temp &= ~((uint32_t)iocurrent);
 8021df0:	bf54      	ite	pl
 8021df2:	402c      	andpl	r4, r5
        {
          temp |= iocurrent;
 8021df4:	433c      	orrmi	r4, r7
        }
        EXTI->RTSR = temp;
 8021df6:	f8cb 4008 	str.w	r4, [fp, #8]

        temp = EXTI->FTSR;
 8021dfa:	f8db 400c 	ldr.w	r4, [fp, #12]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8021dfe:	0289      	lsls	r1, r1, #10
  for(position = 0U; position < GPIO_NUMBER; position++)
 8021e00:	f102 0201 	add.w	r2, r2, #1
        temp &= ~((uint32_t)iocurrent);
 8021e04:	bf54      	ite	pl
 8021e06:	402c      	andpl	r4, r5
        {
          temp |= iocurrent;
 8021e08:	433c      	orrmi	r4, r7
  for(position = 0U; position < GPIO_NUMBER; position++)
 8021e0a:	2a10      	cmp	r2, #16
        }
        EXTI->FTSR = temp;
 8021e0c:	f8cb 400c 	str.w	r4, [fp, #12]
  for(position = 0U; position < GPIO_NUMBER; position++)
 8021e10:	f47f af6a 	bne.w	8021ce8 <HAL_GPIO_Init+0x24>
      }
    }
  }
}
 8021e14:	b007      	add	sp, #28
 8021e16:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        temp = GPIOx->AFR[position >> 3U];
 8021e1a:	ea4f 09d2 	mov.w	r9, r2, lsr #3
 8021e1e:	eb00 0989 	add.w	r9, r0, r9, lsl #2
        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 8021e22:	f002 0807 	and.w	r8, r2, #7
        temp = GPIOx->AFR[position >> 3U];
 8021e26:	f8d9 7020 	ldr.w	r7, [r9, #32]
 8021e2a:	9701      	str	r7, [sp, #4]
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));
 8021e2c:	f8da 7010 	ldr.w	r7, [sl, #16]
        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 8021e30:	ea4f 0888 	mov.w	r8, r8, lsl #2
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));
 8021e34:	fa07 f708 	lsl.w	r7, r7, r8
 8021e38:	9702      	str	r7, [sp, #8]
        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 8021e3a:	270f      	movs	r7, #15
 8021e3c:	fa07 f808 	lsl.w	r8, r7, r8
 8021e40:	9f01      	ldr	r7, [sp, #4]
 8021e42:	ea27 0808 	bic.w	r8, r7, r8
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));
 8021e46:	9f02      	ldr	r7, [sp, #8]
 8021e48:	ea47 0708 	orr.w	r7, r7, r8
        GPIOx->AFR[position >> 3U] = temp;
 8021e4c:	f8c9 7020 	str.w	r7, [r9, #32]
      temp = GPIOx->MODER;
 8021e50:	6807      	ldr	r7, [r0, #0]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8021e52:	402f      	ands	r7, r5
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8021e54:	ea47 070e 	orr.w	r7, r7, lr
      GPIOx->MODER = temp;
 8021e58:	6007      	str	r7, [r0, #0]
        temp = GPIOx->OSPEEDR; 
 8021e5a:	6887      	ldr	r7, [r0, #8]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 8021e5c:	ea07 0e05 	and.w	lr, r7, r5
        temp |= (GPIO_Init->Speed << (position * 2U));
 8021e60:	f8da 700c 	ldr.w	r7, [sl, #12]
 8021e64:	40b7      	lsls	r7, r6
 8021e66:	ea47 070e 	orr.w	r7, r7, lr
        GPIOx->OSPEEDR = temp;
 8021e6a:	6087      	str	r7, [r0, #8]
        temp = GPIOx->OTYPER;
 8021e6c:	6846      	ldr	r6, [r0, #4]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 8021e6e:	0909      	lsrs	r1, r1, #4
 8021e70:	4091      	lsls	r1, r2
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 8021e72:	ea26 0404 	bic.w	r4, r6, r4
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 8021e76:	4321      	orrs	r1, r4
        GPIOx->OTYPER = temp;
 8021e78:	6041      	str	r1, [r0, #4]
      temp = GPIOx->PUPDR;
 8021e7a:	68c1      	ldr	r1, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
 8021e7c:	4029      	ands	r1, r5
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 8021e7e:	ea41 010c 	orr.w	r1, r1, ip
      GPIOx->PUPDR = temp;
 8021e82:	60c1      	str	r1, [r0, #12]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8021e84:	e72c      	b.n	8021ce0 <HAL_GPIO_Init+0x1c>
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8021e86:	2501      	movs	r5, #1
 8021e88:	fa05 f606 	lsl.w	r6, r5, r6
 8021e8c:	ea4e 0506 	orr.w	r5, lr, r6
 8021e90:	e799      	b.n	8021dc6 <HAL_GPIO_Init+0x102>
        temp = EXTI->IMR;
 8021e92:	f8df b0fc 	ldr.w	fp, [pc, #252]	@ 8021f90 <HAL_GPIO_Init+0x2cc>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8021e96:	9101      	str	r1, [sp, #4]
    ioposition = 0x01U << position;
 8021e98:	f04f 0801 	mov.w	r8, #1
 8021e9c:	e002      	b.n	8021ea4 <HAL_GPIO_Init+0x1e0>
  for(position = 0U; position < GPIO_NUMBER; position++)
 8021e9e:	3201      	adds	r2, #1
 8021ea0:	2a10      	cmp	r2, #16
 8021ea2:	d0b7      	beq.n	8021e14 <HAL_GPIO_Init+0x150>
    ioposition = 0x01U << position;
 8021ea4:	fa08 f502 	lsl.w	r5, r8, r2
    if(iocurrent == ioposition)
 8021ea8:	ea35 0403 	bics.w	r4, r5, r3
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8021eac:	ea03 0705 	and.w	r7, r3, r5
    if(iocurrent == ioposition)
 8021eb0:	d1f5      	bne.n	8021e9e <HAL_GPIO_Init+0x1da>
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8021eb2:	9901      	ldr	r1, [sp, #4]
 8021eb4:	684c      	ldr	r4, [r1, #4]
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 8021eb6:	688e      	ldr	r6, [r1, #8]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8021eb8:	2103      	movs	r1, #3
 8021eba:	ea4f 0c42 	mov.w	ip, r2, lsl #1
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8021ebe:	ea04 0e01 	and.w	lr, r4, r1
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 8021ec2:	fa06 fa0c 	lsl.w	sl, r6, ip
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8021ec6:	fa01 f60c 	lsl.w	r6, r1, ip
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8021eca:	fa0e f10c 	lsl.w	r1, lr, ip
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8021ece:	f024 0e10 	bic.w	lr, r4, #16
 8021ed2:	f1be 0f02 	cmp.w	lr, #2
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8021ed6:	ea6f 0606 	mvn.w	r6, r6
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8021eda:	9102      	str	r1, [sp, #8]
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8021edc:	d062      	beq.n	8021fa4 <HAL_GPIO_Init+0x2e0>
      temp = GPIOx->MODER;
 8021ede:	f8d0 9000 	ldr.w	r9, [r0]
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8021ee2:	f10e 3eff 	add.w	lr, lr, #4294967295
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8021ee6:	ea09 0906 	and.w	r9, r9, r6
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8021eea:	ea41 0909 	orr.w	r9, r1, r9
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8021eee:	f1be 0f01 	cmp.w	lr, #1
      GPIOx->MODER = temp;
 8021ef2:	f8c0 9000 	str.w	r9, [r0]
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8021ef6:	d975      	bls.n	8021fe4 <HAL_GPIO_Init+0x320>
      temp = GPIOx->PUPDR;
 8021ef8:	68c5      	ldr	r5, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
 8021efa:	4035      	ands	r5, r6
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 8021efc:	ea45 050a 	orr.w	r5, r5, sl
      GPIOx->PUPDR = temp;
 8021f00:	60c5      	str	r5, [r0, #12]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8021f02:	00e5      	lsls	r5, r4, #3
 8021f04:	d5cb      	bpl.n	8021e9e <HAL_GPIO_Init+0x1da>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8021f06:	2100      	movs	r1, #0
 8021f08:	9105      	str	r1, [sp, #20]
 8021f0a:	491e      	ldr	r1, [pc, #120]	@ (8021f84 <HAL_GPIO_Init+0x2c0>)
 8021f0c:	6c4d      	ldr	r5, [r1, #68]	@ 0x44
 8021f0e:	f445 4580 	orr.w	r5, r5, #16384	@ 0x4000
 8021f12:	644d      	str	r5, [r1, #68]	@ 0x44
 8021f14:	6c4d      	ldr	r5, [r1, #68]	@ 0x44
 8021f16:	f405 4580 	and.w	r5, r5, #16384	@ 0x4000
 8021f1a:	9505      	str	r5, [sp, #20]
 8021f1c:	9d05      	ldr	r5, [sp, #20]
        temp = SYSCFG->EXTICR[position >> 2U];
 8021f1e:	f022 0503 	bic.w	r5, r2, #3
 8021f22:	f105 4580 	add.w	r5, r5, #1073741824	@ 0x40000000
 8021f26:	f505 359c 	add.w	r5, r5, #79872	@ 0x13800
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
 8021f2a:	f002 0603 	and.w	r6, r2, #3
        temp = SYSCFG->EXTICR[position >> 2U];
 8021f2e:	f8d5 c008 	ldr.w	ip, [r5, #8]
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
 8021f32:	210f      	movs	r1, #15
 8021f34:	00b6      	lsls	r6, r6, #2
 8021f36:	fa01 f606 	lsl.w	r6, r1, r6
 8021f3a:	ea2c 0606 	bic.w	r6, ip, r6
        SYSCFG->EXTICR[position >> 2U] = temp;
 8021f3e:	60ae      	str	r6, [r5, #8]
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8021f40:	03e1      	lsls	r1, r4, #15
        temp = EXTI->IMR;
 8021f42:	f8db 5000 	ldr.w	r5, [fp]
        temp &= ~((uint32_t)iocurrent);
 8021f46:	ea6f 0607 	mvn.w	r6, r7
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8021f4a:	d468      	bmi.n	802201e <HAL_GPIO_Init+0x35a>
        temp &= ~((uint32_t)iocurrent);
 8021f4c:	4035      	ands	r5, r6
        EXTI->IMR = temp;
 8021f4e:	f8cb 5000 	str.w	r5, [fp]
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8021f52:	03a1      	lsls	r1, r4, #14
        temp = EXTI->EMR;
 8021f54:	f8db 5004 	ldr.w	r5, [fp, #4]
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8021f58:	d45f      	bmi.n	802201a <HAL_GPIO_Init+0x356>
        temp &= ~((uint32_t)iocurrent);
 8021f5a:	4035      	ands	r5, r6
        EXTI->EMR = temp;
 8021f5c:	f8cb 5004 	str.w	r5, [fp, #4]
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8021f60:	02e1      	lsls	r1, r4, #11
        temp = EXTI->RTSR;
 8021f62:	f8db 5008 	ldr.w	r5, [fp, #8]
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8021f66:	d456      	bmi.n	8022016 <HAL_GPIO_Init+0x352>
        temp &= ~((uint32_t)iocurrent);
 8021f68:	4035      	ands	r5, r6
        EXTI->RTSR = temp;
 8021f6a:	f8cb 5008 	str.w	r5, [fp, #8]
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8021f6e:	02a1      	lsls	r1, r4, #10
        temp = EXTI->FTSR;
 8021f70:	f8db 500c 	ldr.w	r5, [fp, #12]
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8021f74:	d44d      	bmi.n	8022012 <HAL_GPIO_Init+0x34e>
        temp &= ~((uint32_t)iocurrent);
 8021f76:	4035      	ands	r5, r6
        EXTI->FTSR = temp;
 8021f78:	f8cb 500c 	str.w	r5, [fp, #12]
 8021f7c:	e78f      	b.n	8021e9e <HAL_GPIO_Init+0x1da>
 8021f7e:	bf00      	nop
 8021f80:	40020000 	.word	0x40020000
 8021f84:	40023800 	.word	0x40023800
 8021f88:	40020400 	.word	0x40020400
 8021f8c:	40020800 	.word	0x40020800
 8021f90:	40013c00 	.word	0x40013c00
 8021f94:	40020c00 	.word	0x40020c00
 8021f98:	40021000 	.word	0x40021000
 8021f9c:	40021400 	.word	0x40021400
 8021fa0:	40021800 	.word	0x40021800
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));
 8021fa4:	9901      	ldr	r1, [sp, #4]
        temp = GPIOx->AFR[position >> 3U];
 8021fa6:	08d7      	lsrs	r7, r2, #3
 8021fa8:	00bf      	lsls	r7, r7, #2
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));
 8021faa:	6909      	ldr	r1, [r1, #16]
 8021fac:	f107 4780 	add.w	r7, r7, #1073741824	@ 0x40000000
        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 8021fb0:	f002 0e07 	and.w	lr, r2, #7
 8021fb4:	f507 3700 	add.w	r7, r7, #131072	@ 0x20000
 8021fb8:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));
 8021fbc:	fa01 f10e 	lsl.w	r1, r1, lr
        temp = GPIOx->AFR[position >> 3U];
 8021fc0:	f8d7 9020 	ldr.w	r9, [r7, #32]
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));
 8021fc4:	9103      	str	r1, [sp, #12]
        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 8021fc6:	210f      	movs	r1, #15
 8021fc8:	fa01 fe0e 	lsl.w	lr, r1, lr
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));
 8021fcc:	9903      	ldr	r1, [sp, #12]
        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 8021fce:	ea29 090e 	bic.w	r9, r9, lr
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));
 8021fd2:	ea41 0e09 	orr.w	lr, r1, r9
        GPIOx->AFR[position >> 3U] = temp;
 8021fd6:	f8c7 e020 	str.w	lr, [r7, #32]
      temp = GPIOx->MODER;
 8021fda:	6807      	ldr	r7, [r0, #0]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8021fdc:	9902      	ldr	r1, [sp, #8]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8021fde:	4037      	ands	r7, r6
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8021fe0:	4339      	orrs	r1, r7
      GPIOx->MODER = temp;
 8021fe2:	6001      	str	r1, [r0, #0]
        temp = GPIOx->OSPEEDR; 
 8021fe4:	6887      	ldr	r7, [r0, #8]
        temp |= (GPIO_Init->Speed << (position * 2U));
 8021fe6:	9901      	ldr	r1, [sp, #4]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 8021fe8:	ea07 0e06 	and.w	lr, r7, r6
        temp |= (GPIO_Init->Speed << (position * 2U));
 8021fec:	68cf      	ldr	r7, [r1, #12]
 8021fee:	fa07 f70c 	lsl.w	r7, r7, ip
 8021ff2:	ea47 070e 	orr.w	r7, r7, lr
        GPIOx->OSPEEDR = temp;
 8021ff6:	6087      	str	r7, [r0, #8]
        temp = GPIOx->OTYPER;
 8021ff8:	6847      	ldr	r7, [r0, #4]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 8021ffa:	0924      	lsrs	r4, r4, #4
 8021ffc:	4094      	lsls	r4, r2
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 8021ffe:	ea27 0505 	bic.w	r5, r7, r5
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 8022002:	432c      	orrs	r4, r5
        GPIOx->OTYPER = temp;
 8022004:	6044      	str	r4, [r0, #4]
      temp = GPIOx->PUPDR;
 8022006:	68c4      	ldr	r4, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
 8022008:	4034      	ands	r4, r6
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 802200a:	ea44 040a 	orr.w	r4, r4, sl
      GPIOx->PUPDR = temp;
 802200e:	60c4      	str	r4, [r0, #12]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8022010:	e745      	b.n	8021e9e <HAL_GPIO_Init+0x1da>
          temp |= iocurrent;
 8022012:	433d      	orrs	r5, r7
 8022014:	e7b0      	b.n	8021f78 <HAL_GPIO_Init+0x2b4>
          temp |= iocurrent;
 8022016:	433d      	orrs	r5, r7
 8022018:	e7a7      	b.n	8021f6a <HAL_GPIO_Init+0x2a6>
          temp |= iocurrent;
 802201a:	433d      	orrs	r5, r7
 802201c:	e79e      	b.n	8021f5c <HAL_GPIO_Init+0x298>
          temp |= iocurrent;
 802201e:	433d      	orrs	r5, r7
 8022020:	e795      	b.n	8021f4e <HAL_GPIO_Init+0x28a>
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8022022:	f04f 0c02 	mov.w	ip, #2
 8022026:	fa0c f606 	lsl.w	r6, ip, r6
 802202a:	ea4e 0506 	orr.w	r5, lr, r6
 802202e:	e6ca      	b.n	8021dc6 <HAL_GPIO_Init+0x102>
 8022030:	2503      	movs	r5, #3
 8022032:	fa05 f606 	lsl.w	r6, r5, r6
 8022036:	ea4e 0506 	orr.w	r5, lr, r6
 802203a:	e6c4      	b.n	8021dc6 <HAL_GPIO_Init+0x102>
 802203c:	f04f 0c04 	mov.w	ip, #4
 8022040:	fa0c f606 	lsl.w	r6, ip, r6
 8022044:	ea4e 0506 	orr.w	r5, lr, r6
 8022048:	e6bd      	b.n	8021dc6 <HAL_GPIO_Init+0x102>
 802204a:	f04f 0c05 	mov.w	ip, #5
 802204e:	fa0c f606 	lsl.w	r6, ip, r6
 8022052:	ea4e 0506 	orr.w	r5, lr, r6
 8022056:	e6b6      	b.n	8021dc6 <HAL_GPIO_Init+0x102>

08022058 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 8022058:	b902      	cbnz	r2, 802205c <HAL_GPIO_WritePin+0x4>
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
 802205a:	0409      	lsls	r1, r1, #16
 802205c:	6181      	str	r1, [r0, #24]
  }
}
 802205e:	4770      	bx	lr

08022060 <HAL_GPIO_TogglePin>:
void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->ODR & GPIO_Pin) == GPIO_Pin)
 8022060:	6943      	ldr	r3, [r0, #20]
 8022062:	ea31 0303 	bics.w	r3, r1, r3
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
 8022066:	bf08      	it	eq
 8022068:	0409      	lsleq	r1, r1, #16
  }
  else
  {
    GPIOx->BSRR = GPIO_Pin;
 802206a:	6181      	str	r1, [r0, #24]
  }
}
 802206c:	4770      	bx	lr
 802206e:	bf00      	nop

08022070 <HAL_RCC_GetSysClockFreq>:
{
  uint32_t pllm = 0U, pllvco = 0U, pllp = 0U;
  uint32_t sysclockfreq = 0U;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8022070:	4916      	ldr	r1, [pc, #88]	@ (80220cc <HAL_RCC_GetSysClockFreq+0x5c>)
{
 8022072:	b508      	push	{r3, lr}
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8022074:	688b      	ldr	r3, [r1, #8]
 8022076:	f003 030c 	and.w	r3, r3, #12
 802207a:	2b04      	cmp	r3, #4
 802207c:	d01b      	beq.n	80220b6 <HAL_RCC_GetSysClockFreq+0x46>
 802207e:	2b08      	cmp	r3, #8
 8022080:	d001      	beq.n	8022086 <HAL_RCC_GetSysClockFreq+0x16>
  {
    case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */
    {
      sysclockfreq = HSI_VALUE;
 8022082:	4813      	ldr	r0, [pc, #76]	@ (80220d0 <HAL_RCC_GetSysClockFreq+0x60>)
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
 8022084:	bd08      	pop	{r3, pc}
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8022086:	684a      	ldr	r2, [r1, #4]
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 8022088:	684b      	ldr	r3, [r1, #4]
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 802208a:	6849      	ldr	r1, [r1, #4]
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 802208c:	f413 0380 	ands.w	r3, r3, #4194304	@ 0x400000
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8022090:	f002 023f 	and.w	r2, r2, #63	@ 0x3f
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 8022094:	d111      	bne.n	80220ba <HAL_RCC_GetSysClockFreq+0x4a>
        pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8022096:	480e      	ldr	r0, [pc, #56]	@ (80220d0 <HAL_RCC_GetSysClockFreq+0x60>)
 8022098:	f3c1 1188 	ubfx	r1, r1, #6, #9
 802209c:	fba1 0100 	umull	r0, r1, r1, r0
 80220a0:	f7fe fe3c 	bl	8020d1c <__aeabi_uldivmod>
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1U) *2U);
 80220a4:	4b09      	ldr	r3, [pc, #36]	@ (80220cc <HAL_RCC_GetSysClockFreq+0x5c>)
 80220a6:	685b      	ldr	r3, [r3, #4]
 80220a8:	f3c3 4301 	ubfx	r3, r3, #16, #2
 80220ac:	3301      	adds	r3, #1
 80220ae:	005b      	lsls	r3, r3, #1
      sysclockfreq = pllvco/pllp;
 80220b0:	fbb0 f0f3 	udiv	r0, r0, r3
}
 80220b4:	bd08      	pop	{r3, pc}
  switch (RCC->CFGR & RCC_CFGR_SWS)
 80220b6:	4807      	ldr	r0, [pc, #28]	@ (80220d4 <HAL_RCC_GetSysClockFreq+0x64>)
}
 80220b8:	bd08      	pop	{r3, pc}
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 80220ba:	4806      	ldr	r0, [pc, #24]	@ (80220d4 <HAL_RCC_GetSysClockFreq+0x64>)
 80220bc:	f3c1 1188 	ubfx	r1, r1, #6, #9
 80220c0:	2300      	movs	r3, #0
 80220c2:	fba1 0100 	umull	r0, r1, r1, r0
 80220c6:	f7fe fe29 	bl	8020d1c <__aeabi_uldivmod>
 80220ca:	e7eb      	b.n	80220a4 <HAL_RCC_GetSysClockFreq+0x34>
 80220cc:	40023800 	.word	0x40023800
 80220d0:	00f42400 	.word	0x00f42400
 80220d4:	00b71b00 	.word	0x00b71b00

080220d8 <HAL_RCC_ClockConfig>:
  if(RCC_ClkInitStruct == NULL)
 80220d8:	2800      	cmp	r0, #0
 80220da:	f000 8086 	beq.w	80221ea <HAL_RCC_ClockConfig+0x112>
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 80220de:	4a47      	ldr	r2, [pc, #284]	@ (80221fc <HAL_RCC_ClockConfig+0x124>)
 80220e0:	6813      	ldr	r3, [r2, #0]
 80220e2:	f003 030f 	and.w	r3, r3, #15
 80220e6:	428b      	cmp	r3, r1
{
 80220e8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80220ec:	460d      	mov	r5, r1
 80220ee:	4604      	mov	r4, r0
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 80220f0:	d209      	bcs.n	8022106 <HAL_RCC_ClockConfig+0x2e>
    __HAL_FLASH_SET_LATENCY(FLatency);
 80220f2:	b2cb      	uxtb	r3, r1
 80220f4:	7013      	strb	r3, [r2, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 80220f6:	6813      	ldr	r3, [r2, #0]
 80220f8:	f003 030f 	and.w	r3, r3, #15
 80220fc:	428b      	cmp	r3, r1
 80220fe:	d002      	beq.n	8022106 <HAL_RCC_ClockConfig+0x2e>
    return HAL_ERROR;
 8022100:	2001      	movs	r0, #1
}
 8022102:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8022106:	6823      	ldr	r3, [r4, #0]
 8022108:	0798      	lsls	r0, r3, #30
 802210a:	d514      	bpl.n	8022136 <HAL_RCC_ClockConfig+0x5e>
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 802210c:	0759      	lsls	r1, r3, #29
 802210e:	d504      	bpl.n	802211a <HAL_RCC_ClockConfig+0x42>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 8022110:	493b      	ldr	r1, [pc, #236]	@ (8022200 <HAL_RCC_ClockConfig+0x128>)
 8022112:	688a      	ldr	r2, [r1, #8]
 8022114:	f442 52e0 	orr.w	r2, r2, #7168	@ 0x1c00
 8022118:	608a      	str	r2, [r1, #8]
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 802211a:	071a      	lsls	r2, r3, #28
 802211c:	d504      	bpl.n	8022128 <HAL_RCC_ClockConfig+0x50>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 802211e:	4938      	ldr	r1, [pc, #224]	@ (8022200 <HAL_RCC_ClockConfig+0x128>)
 8022120:	688a      	ldr	r2, [r1, #8]
 8022122:	f442 4260 	orr.w	r2, r2, #57344	@ 0xe000
 8022126:	608a      	str	r2, [r1, #8]
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8022128:	4935      	ldr	r1, [pc, #212]	@ (8022200 <HAL_RCC_ClockConfig+0x128>)
 802212a:	68a0      	ldr	r0, [r4, #8]
 802212c:	688a      	ldr	r2, [r1, #8]
 802212e:	f022 02f0 	bic.w	r2, r2, #240	@ 0xf0
 8022132:	4302      	orrs	r2, r0
 8022134:	608a      	str	r2, [r1, #8]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8022136:	07df      	lsls	r7, r3, #31
 8022138:	d521      	bpl.n	802217e <HAL_RCC_ClockConfig+0xa6>
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 802213a:	6862      	ldr	r2, [r4, #4]
 802213c:	2a01      	cmp	r2, #1
 802213e:	d056      	beq.n	80221ee <HAL_RCC_ClockConfig+0x116>
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 8022140:	1e93      	subs	r3, r2, #2
 8022142:	2b01      	cmp	r3, #1
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8022144:	4b2e      	ldr	r3, [pc, #184]	@ (8022200 <HAL_RCC_ClockConfig+0x128>)
 8022146:	681b      	ldr	r3, [r3, #0]
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 8022148:	d94c      	bls.n	80221e4 <HAL_RCC_ClockConfig+0x10c>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 802214a:	0799      	lsls	r1, r3, #30
 802214c:	d5d8      	bpl.n	8022100 <HAL_RCC_ClockConfig+0x28>
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 802214e:	4e2c      	ldr	r6, [pc, #176]	@ (8022200 <HAL_RCC_ClockConfig+0x128>)
 8022150:	68b3      	ldr	r3, [r6, #8]
 8022152:	f023 0303 	bic.w	r3, r3, #3
 8022156:	4313      	orrs	r3, r2
 8022158:	60b3      	str	r3, [r6, #8]
    tickstart = HAL_GetTick();
 802215a:	f7fe ffbd 	bl	80210d8 <HAL_GetTick>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 802215e:	f241 3888 	movw	r8, #5000	@ 0x1388
    tickstart = HAL_GetTick();
 8022162:	4607      	mov	r7, r0
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8022164:	e004      	b.n	8022170 <HAL_RCC_ClockConfig+0x98>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8022166:	f7fe ffb7 	bl	80210d8 <HAL_GetTick>
 802216a:	1bc0      	subs	r0, r0, r7
 802216c:	4540      	cmp	r0, r8
 802216e:	d843      	bhi.n	80221f8 <HAL_RCC_ClockConfig+0x120>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8022170:	68b3      	ldr	r3, [r6, #8]
 8022172:	6862      	ldr	r2, [r4, #4]
 8022174:	f003 030c 	and.w	r3, r3, #12
 8022178:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 802217c:	d1f3      	bne.n	8022166 <HAL_RCC_ClockConfig+0x8e>
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 802217e:	4a1f      	ldr	r2, [pc, #124]	@ (80221fc <HAL_RCC_ClockConfig+0x124>)
 8022180:	6813      	ldr	r3, [r2, #0]
 8022182:	f003 030f 	and.w	r3, r3, #15
 8022186:	42ab      	cmp	r3, r5
 8022188:	d906      	bls.n	8022198 <HAL_RCC_ClockConfig+0xc0>
    __HAL_FLASH_SET_LATENCY(FLatency);
 802218a:	b2eb      	uxtb	r3, r5
 802218c:	7013      	strb	r3, [r2, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 802218e:	6813      	ldr	r3, [r2, #0]
 8022190:	f003 030f 	and.w	r3, r3, #15
 8022194:	42ab      	cmp	r3, r5
 8022196:	d1b3      	bne.n	8022100 <HAL_RCC_ClockConfig+0x28>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8022198:	6823      	ldr	r3, [r4, #0]
 802219a:	075a      	lsls	r2, r3, #29
 802219c:	d506      	bpl.n	80221ac <HAL_RCC_ClockConfig+0xd4>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 802219e:	4918      	ldr	r1, [pc, #96]	@ (8022200 <HAL_RCC_ClockConfig+0x128>)
 80221a0:	68e0      	ldr	r0, [r4, #12]
 80221a2:	688a      	ldr	r2, [r1, #8]
 80221a4:	f422 52e0 	bic.w	r2, r2, #7168	@ 0x1c00
 80221a8:	4302      	orrs	r2, r0
 80221aa:	608a      	str	r2, [r1, #8]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 80221ac:	071b      	lsls	r3, r3, #28
 80221ae:	d507      	bpl.n	80221c0 <HAL_RCC_ClockConfig+0xe8>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 80221b0:	4a13      	ldr	r2, [pc, #76]	@ (8022200 <HAL_RCC_ClockConfig+0x128>)
 80221b2:	6921      	ldr	r1, [r4, #16]
 80221b4:	6893      	ldr	r3, [r2, #8]
 80221b6:	f423 4360 	bic.w	r3, r3, #57344	@ 0xe000
 80221ba:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 80221be:	6093      	str	r3, [r2, #8]
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 80221c0:	f7ff ff56 	bl	8022070 <HAL_RCC_GetSysClockFreq>
 80221c4:	4a0e      	ldr	r2, [pc, #56]	@ (8022200 <HAL_RCC_ClockConfig+0x128>)
 80221c6:	4c0f      	ldr	r4, [pc, #60]	@ (8022204 <HAL_RCC_ClockConfig+0x12c>)
 80221c8:	6892      	ldr	r2, [r2, #8]
 80221ca:	490f      	ldr	r1, [pc, #60]	@ (8022208 <HAL_RCC_ClockConfig+0x130>)
 80221cc:	f3c2 1203 	ubfx	r2, r2, #4, #4
 80221d0:	4603      	mov	r3, r0
 80221d2:	5ca2      	ldrb	r2, [r4, r2]
  HAL_InitTick (TICK_INT_PRIORITY);
 80221d4:	2000      	movs	r0, #0
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 80221d6:	40d3      	lsrs	r3, r2
 80221d8:	600b      	str	r3, [r1, #0]
  HAL_InitTick (TICK_INT_PRIORITY);
 80221da:	f7fe ff35 	bl	8021048 <HAL_InitTick>
  return HAL_OK;
 80221de:	2000      	movs	r0, #0
}
 80221e0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 80221e4:	0198      	lsls	r0, r3, #6
 80221e6:	d4b2      	bmi.n	802214e <HAL_RCC_ClockConfig+0x76>
 80221e8:	e78a      	b.n	8022100 <HAL_RCC_ClockConfig+0x28>
    return HAL_ERROR;
 80221ea:	2001      	movs	r0, #1
}
 80221ec:	4770      	bx	lr
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80221ee:	4b04      	ldr	r3, [pc, #16]	@ (8022200 <HAL_RCC_ClockConfig+0x128>)
 80221f0:	681b      	ldr	r3, [r3, #0]
 80221f2:	039e      	lsls	r6, r3, #14
 80221f4:	d4ab      	bmi.n	802214e <HAL_RCC_ClockConfig+0x76>
 80221f6:	e783      	b.n	8022100 <HAL_RCC_ClockConfig+0x28>
        return HAL_TIMEOUT;
 80221f8:	2003      	movs	r0, #3
 80221fa:	e782      	b.n	8022102 <HAL_RCC_ClockConfig+0x2a>
 80221fc:	40023c00 	.word	0x40023c00
 8022200:	40023800 	.word	0x40023800
 8022204:	0802e200 	.word	0x0802e200
 8022208:	20000130 	.word	0x20000130

0802220c <HAL_RCC_GetPCLK1Freq>:
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> RCC_CFGR_PPRE1_Pos]);
 802220c:	4b04      	ldr	r3, [pc, #16]	@ (8022220 <HAL_RCC_GetPCLK1Freq+0x14>)
  return SystemCoreClock;
 802220e:	4905      	ldr	r1, [pc, #20]	@ (8022224 <HAL_RCC_GetPCLK1Freq+0x18>)
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> RCC_CFGR_PPRE1_Pos]);
 8022210:	689b      	ldr	r3, [r3, #8]
 8022212:	4a05      	ldr	r2, [pc, #20]	@ (8022228 <HAL_RCC_GetPCLK1Freq+0x1c>)
 8022214:	6808      	ldr	r0, [r1, #0]
 8022216:	f3c3 2382 	ubfx	r3, r3, #10, #3
 802221a:	5cd3      	ldrb	r3, [r2, r3]
}
 802221c:	40d8      	lsrs	r0, r3
 802221e:	4770      	bx	lr
 8022220:	40023800 	.word	0x40023800
 8022224:	20000130 	.word	0x20000130
 8022228:	0802e210 	.word	0x0802e210

0802222c <HAL_RCC_GetPCLK2Freq>:
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> RCC_CFGR_PPRE2_Pos]);
 802222c:	4b04      	ldr	r3, [pc, #16]	@ (8022240 <HAL_RCC_GetPCLK2Freq+0x14>)
  return SystemCoreClock;
 802222e:	4905      	ldr	r1, [pc, #20]	@ (8022244 <HAL_RCC_GetPCLK2Freq+0x18>)
  return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> RCC_CFGR_PPRE2_Pos]);
 8022230:	689b      	ldr	r3, [r3, #8]
 8022232:	4a05      	ldr	r2, [pc, #20]	@ (8022248 <HAL_RCC_GetPCLK2Freq+0x1c>)
 8022234:	6808      	ldr	r0, [r1, #0]
 8022236:	f3c3 3342 	ubfx	r3, r3, #13, #3
 802223a:	5cd3      	ldrb	r3, [r2, r3]
}
 802223c:	40d8      	lsrs	r0, r3
 802223e:	4770      	bx	lr
 8022240:	40023800 	.word	0x40023800
 8022244:	20000130 	.word	0x20000130
 8022248:	0802e210 	.word	0x0802e210

0802224c <HAL_RCC_OscConfig>:
  * @note   This function add the PLL/PLLR factor management during PLL configuration this feature
  *         is only available in STM32F410xx/STM32F446xx/STM32F469xx/STM32F479xx/STM32F412Zx/STM32F412Vx/STM32F412Rx/STM32F412Cx devices
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 802224c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t tickstart = 0U;

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8022250:	6803      	ldr	r3, [r0, #0]
 8022252:	07dd      	lsls	r5, r3, #31
{
 8022254:	b082      	sub	sp, #8
 8022256:	4604      	mov	r4, r0
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8022258:	d52f      	bpl.n	80222ba <HAL_RCC_OscConfig+0x6e>
#if defined(STM32F446xx)
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE)                                                                     ||\
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)) ||\
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLLR) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
#else
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE)                                                                     ||\
 802225a:	499f      	ldr	r1, [pc, #636]	@ (80224d8 <HAL_RCC_OscConfig+0x28c>)
 802225c:	688a      	ldr	r2, [r1, #8]
 802225e:	f002 020c 	and.w	r2, r2, #12
 8022262:	2a04      	cmp	r2, #4
 8022264:	f000 80c2 	beq.w	80223ec <HAL_RCC_OscConfig+0x1a0>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8022268:	688a      	ldr	r2, [r1, #8]
 802226a:	f002 020c 	and.w	r2, r2, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE)                                                                     ||\
 802226e:	2a08      	cmp	r2, #8
 8022270:	f000 80b8 	beq.w	80223e4 <HAL_RCC_OscConfig+0x198>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8022274:	6863      	ldr	r3, [r4, #4]
 8022276:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 802227a:	f000 80f9 	beq.w	8022470 <HAL_RCC_OscConfig+0x224>
 802227e:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
 8022282:	f000 814c 	beq.w	802251e <HAL_RCC_OscConfig+0x2d2>
 8022286:	4d94      	ldr	r5, [pc, #592]	@ (80224d8 <HAL_RCC_OscConfig+0x28c>)
 8022288:	682a      	ldr	r2, [r5, #0]
 802228a:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
 802228e:	602a      	str	r2, [r5, #0]
 8022290:	682a      	ldr	r2, [r5, #0]
 8022292:	f422 2280 	bic.w	r2, r2, #262144	@ 0x40000
 8022296:	602a      	str	r2, [r5, #0]

      /* Check the HSE State */
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
 8022298:	2b00      	cmp	r3, #0
 802229a:	f040 80ee 	bne.w	802247a <HAL_RCC_OscConfig+0x22e>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 802229e:	f7fe ff1b 	bl	80210d8 <HAL_GetTick>
 80222a2:	4606      	mov	r6, r0

        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 80222a4:	e005      	b.n	80222b2 <HAL_RCC_OscConfig+0x66>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 80222a6:	f7fe ff17 	bl	80210d8 <HAL_GetTick>
 80222aa:	1b80      	subs	r0, r0, r6
 80222ac:	2864      	cmp	r0, #100	@ 0x64
 80222ae:	f200 8102 	bhi.w	80224b6 <HAL_RCC_OscConfig+0x26a>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 80222b2:	682b      	ldr	r3, [r5, #0]
 80222b4:	039b      	lsls	r3, r3, #14
 80222b6:	d4f6      	bmi.n	80222a6 <HAL_RCC_OscConfig+0x5a>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 80222b8:	6823      	ldr	r3, [r4, #0]
 80222ba:	079f      	lsls	r7, r3, #30
 80222bc:	d528      	bpl.n	8022310 <HAL_RCC_OscConfig+0xc4>
#if defined(STM32F446xx)
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI)                                                                     ||\
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)) ||\
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLLR) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
#else
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI)                                                                     ||\
 80222be:	4a86      	ldr	r2, [pc, #536]	@ (80224d8 <HAL_RCC_OscConfig+0x28c>)
 80222c0:	6891      	ldr	r1, [r2, #8]
 80222c2:	f011 0f0c 	tst.w	r1, #12
 80222c6:	f000 809f 	beq.w	8022408 <HAL_RCC_OscConfig+0x1bc>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 80222ca:	6891      	ldr	r1, [r2, #8]
 80222cc:	f001 010c 	and.w	r1, r1, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI)                                                                     ||\
 80222d0:	2908      	cmp	r1, #8
 80222d2:	f000 8095 	beq.w	8022400 <HAL_RCC_OscConfig+0x1b4>
      }
    }
    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 80222d6:	68e3      	ldr	r3, [r4, #12]
 80222d8:	2b00      	cmp	r3, #0
 80222da:	f000 810f 	beq.w	80224fc <HAL_RCC_OscConfig+0x2b0>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 80222de:	4b7f      	ldr	r3, [pc, #508]	@ (80224dc <HAL_RCC_OscConfig+0x290>)

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80222e0:	4e7d      	ldr	r6, [pc, #500]	@ (80224d8 <HAL_RCC_OscConfig+0x28c>)
        __HAL_RCC_HSI_ENABLE();
 80222e2:	2201      	movs	r2, #1
 80222e4:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 80222e6:	f7fe fef7 	bl	80210d8 <HAL_GetTick>
 80222ea:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80222ec:	e005      	b.n	80222fa <HAL_RCC_OscConfig+0xae>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 80222ee:	f7fe fef3 	bl	80210d8 <HAL_GetTick>
 80222f2:	1b40      	subs	r0, r0, r5
 80222f4:	2802      	cmp	r0, #2
 80222f6:	f200 80de 	bhi.w	80224b6 <HAL_RCC_OscConfig+0x26a>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80222fa:	6833      	ldr	r3, [r6, #0]
 80222fc:	0798      	lsls	r0, r3, #30
 80222fe:	d5f6      	bpl.n	80222ee <HAL_RCC_OscConfig+0xa2>
            return HAL_TIMEOUT;
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8022300:	6833      	ldr	r3, [r6, #0]
 8022302:	6922      	ldr	r2, [r4, #16]
 8022304:	f023 03f8 	bic.w	r3, r3, #248	@ 0xf8
 8022308:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 802230c:	6033      	str	r3, [r6, #0]
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 802230e:	6823      	ldr	r3, [r4, #0]
 8022310:	071a      	lsls	r2, r3, #28
 8022312:	d516      	bpl.n	8022342 <HAL_RCC_OscConfig+0xf6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 8022314:	6963      	ldr	r3, [r4, #20]
 8022316:	2b00      	cmp	r3, #0
 8022318:	f000 8081 	beq.w	802241e <HAL_RCC_OscConfig+0x1d2>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 802231c:	4b6f      	ldr	r3, [pc, #444]	@ (80224dc <HAL_RCC_OscConfig+0x290>)

      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 802231e:	4e6e      	ldr	r6, [pc, #440]	@ (80224d8 <HAL_RCC_OscConfig+0x28c>)
      __HAL_RCC_LSI_ENABLE();
 8022320:	2201      	movs	r2, #1
 8022322:	f8c3 2e80 	str.w	r2, [r3, #3712]	@ 0xe80
      tickstart = HAL_GetTick();
 8022326:	f7fe fed7 	bl	80210d8 <HAL_GetTick>
 802232a:	4605      	mov	r5, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 802232c:	e005      	b.n	802233a <HAL_RCC_OscConfig+0xee>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 802232e:	f7fe fed3 	bl	80210d8 <HAL_GetTick>
 8022332:	1b40      	subs	r0, r0, r5
 8022334:	2802      	cmp	r0, #2
 8022336:	f200 80be 	bhi.w	80224b6 <HAL_RCC_OscConfig+0x26a>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 802233a:	6f73      	ldr	r3, [r6, #116]	@ 0x74
 802233c:	079b      	lsls	r3, r3, #30
 802233e:	d5f6      	bpl.n	802232e <HAL_RCC_OscConfig+0xe2>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8022340:	6823      	ldr	r3, [r4, #0]
 8022342:	0758      	lsls	r0, r3, #29
 8022344:	d52f      	bpl.n	80223a6 <HAL_RCC_OscConfig+0x15a>
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8022346:	4a64      	ldr	r2, [pc, #400]	@ (80224d8 <HAL_RCC_OscConfig+0x28c>)
 8022348:	6c13      	ldr	r3, [r2, #64]	@ 0x40
 802234a:	f013 5380 	ands.w	r3, r3, #268435456	@ 0x10000000
 802234e:	d077      	beq.n	8022440 <HAL_RCC_OscConfig+0x1f4>
    FlagStatus       pwrclkchanged = RESET;
 8022350:	2500      	movs	r5, #0
    {
      __HAL_RCC_PWR_CLK_ENABLE();
      pwrclkchanged = SET;
    }

    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8022352:	4e63      	ldr	r6, [pc, #396]	@ (80224e0 <HAL_RCC_OscConfig+0x294>)
 8022354:	6833      	ldr	r3, [r6, #0]
 8022356:	05d9      	lsls	r1, r3, #23
 8022358:	f140 809d 	bpl.w	8022496 <HAL_RCC_OscConfig+0x24a>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 802235c:	68a3      	ldr	r3, [r4, #8]
 802235e:	2b01      	cmp	r3, #1
 8022360:	f000 80ad 	beq.w	80224be <HAL_RCC_OscConfig+0x272>
 8022364:	2b05      	cmp	r3, #5
 8022366:	f000 8119 	beq.w	802259c <HAL_RCC_OscConfig+0x350>
 802236a:	4e5b      	ldr	r6, [pc, #364]	@ (80224d8 <HAL_RCC_OscConfig+0x28c>)
 802236c:	6f32      	ldr	r2, [r6, #112]	@ 0x70
 802236e:	f022 0201 	bic.w	r2, r2, #1
 8022372:	6732      	str	r2, [r6, #112]	@ 0x70
 8022374:	6f32      	ldr	r2, [r6, #112]	@ 0x70
 8022376:	f022 0204 	bic.w	r2, r2, #4
 802237a:	6732      	str	r2, [r6, #112]	@ 0x70
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 802237c:	2b00      	cmp	r3, #0
 802237e:	f040 80a3 	bne.w	80224c8 <HAL_RCC_OscConfig+0x27c>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8022382:	f7fe fea9 	bl	80210d8 <HAL_GetTick>

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8022386:	f241 3888 	movw	r8, #5000	@ 0x1388
      tickstart = HAL_GetTick();
 802238a:	4607      	mov	r7, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 802238c:	e005      	b.n	802239a <HAL_RCC_OscConfig+0x14e>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 802238e:	f7fe fea3 	bl	80210d8 <HAL_GetTick>
 8022392:	1bc0      	subs	r0, r0, r7
 8022394:	4540      	cmp	r0, r8
 8022396:	f200 808e 	bhi.w	80224b6 <HAL_RCC_OscConfig+0x26a>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 802239a:	6f33      	ldr	r3, [r6, #112]	@ 0x70
 802239c:	0798      	lsls	r0, r3, #30
 802239e:	d4f6      	bmi.n	802238e <HAL_RCC_OscConfig+0x142>
        }
      }
    }

    /* Restore clock configuration if changed */
    if(pwrclkchanged == SET)
 80223a0:	2d00      	cmp	r5, #0
 80223a2:	f040 80c6 	bne.w	8022532 <HAL_RCC_OscConfig+0x2e6>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 80223a6:	69a3      	ldr	r3, [r4, #24]
 80223a8:	b1c3      	cbz	r3, 80223dc <HAL_RCC_OscConfig+0x190>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 80223aa:	4d4b      	ldr	r5, [pc, #300]	@ (80224d8 <HAL_RCC_OscConfig+0x28c>)
 80223ac:	68aa      	ldr	r2, [r5, #8]
 80223ae:	f002 020c 	and.w	r2, r2, #12
 80223b2:	2a08      	cmp	r2, #8
 80223b4:	d02f      	beq.n	8022416 <HAL_RCC_OscConfig+0x1ca>
    {
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 80223b6:	2b02      	cmp	r3, #2
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 80223b8:	4b48      	ldr	r3, [pc, #288]	@ (80224dc <HAL_RCC_OscConfig+0x290>)
 80223ba:	f04f 0200 	mov.w	r2, #0
 80223be:	661a      	str	r2, [r3, #96]	@ 0x60
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 80223c0:	f000 80bd 	beq.w	802253e <HAL_RCC_OscConfig+0x2f2>
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80223c4:	f7fe fe88 	bl	80210d8 <HAL_GetTick>
 80223c8:	4604      	mov	r4, r0

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80223ca:	e004      	b.n	80223d6 <HAL_RCC_OscConfig+0x18a>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80223cc:	f7fe fe84 	bl	80210d8 <HAL_GetTick>
 80223d0:	1b00      	subs	r0, r0, r4
 80223d2:	2802      	cmp	r0, #2
 80223d4:	d86f      	bhi.n	80224b6 <HAL_RCC_OscConfig+0x26a>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80223d6:	682b      	ldr	r3, [r5, #0]
 80223d8:	019b      	lsls	r3, r3, #6
 80223da:	d4f7      	bmi.n	80223cc <HAL_RCC_OscConfig+0x180>
    else
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
 80223dc:	2000      	movs	r0, #0
}
 80223de:	b002      	add	sp, #8
 80223e0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 80223e4:	684a      	ldr	r2, [r1, #4]
 80223e6:	0250      	lsls	r0, r2, #9
 80223e8:	f57f af44 	bpl.w	8022274 <HAL_RCC_OscConfig+0x28>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 80223ec:	4a3a      	ldr	r2, [pc, #232]	@ (80224d8 <HAL_RCC_OscConfig+0x28c>)
 80223ee:	6812      	ldr	r2, [r2, #0]
 80223f0:	0391      	lsls	r1, r2, #14
 80223f2:	f57f af62 	bpl.w	80222ba <HAL_RCC_OscConfig+0x6e>
 80223f6:	6862      	ldr	r2, [r4, #4]
 80223f8:	2a00      	cmp	r2, #0
 80223fa:	f47f af5e 	bne.w	80222ba <HAL_RCC_OscConfig+0x6e>
 80223fe:	e00a      	b.n	8022416 <HAL_RCC_OscConfig+0x1ca>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8022400:	6852      	ldr	r2, [r2, #4]
 8022402:	0256      	lsls	r6, r2, #9
 8022404:	f53f af67 	bmi.w	80222d6 <HAL_RCC_OscConfig+0x8a>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8022408:	4a33      	ldr	r2, [pc, #204]	@ (80224d8 <HAL_RCC_OscConfig+0x28c>)
 802240a:	6812      	ldr	r2, [r2, #0]
 802240c:	0795      	lsls	r5, r2, #30
 802240e:	d523      	bpl.n	8022458 <HAL_RCC_OscConfig+0x20c>
 8022410:	68e2      	ldr	r2, [r4, #12]
 8022412:	2a01      	cmp	r2, #1
 8022414:	d020      	beq.n	8022458 <HAL_RCC_OscConfig+0x20c>
        return HAL_ERROR;
 8022416:	2001      	movs	r0, #1
}
 8022418:	b002      	add	sp, #8
 802241a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      __HAL_RCC_LSI_DISABLE();
 802241e:	4a2f      	ldr	r2, [pc, #188]	@ (80224dc <HAL_RCC_OscConfig+0x290>)
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8022420:	4e2d      	ldr	r6, [pc, #180]	@ (80224d8 <HAL_RCC_OscConfig+0x28c>)
      __HAL_RCC_LSI_DISABLE();
 8022422:	f8c2 3e80 	str.w	r3, [r2, #3712]	@ 0xe80
      tickstart = HAL_GetTick();
 8022426:	f7fe fe57 	bl	80210d8 <HAL_GetTick>
 802242a:	4605      	mov	r5, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 802242c:	e004      	b.n	8022438 <HAL_RCC_OscConfig+0x1ec>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 802242e:	f7fe fe53 	bl	80210d8 <HAL_GetTick>
 8022432:	1b40      	subs	r0, r0, r5
 8022434:	2802      	cmp	r0, #2
 8022436:	d83e      	bhi.n	80224b6 <HAL_RCC_OscConfig+0x26a>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8022438:	6f73      	ldr	r3, [r6, #116]	@ 0x74
 802243a:	079f      	lsls	r7, r3, #30
 802243c:	d4f7      	bmi.n	802242e <HAL_RCC_OscConfig+0x1e2>
 802243e:	e77f      	b.n	8022340 <HAL_RCC_OscConfig+0xf4>
      __HAL_RCC_PWR_CLK_ENABLE();
 8022440:	9301      	str	r3, [sp, #4]
 8022442:	6c13      	ldr	r3, [r2, #64]	@ 0x40
 8022444:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 8022448:	6413      	str	r3, [r2, #64]	@ 0x40
 802244a:	6c13      	ldr	r3, [r2, #64]	@ 0x40
 802244c:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 8022450:	9301      	str	r3, [sp, #4]
 8022452:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 8022454:	2501      	movs	r5, #1
 8022456:	e77c      	b.n	8022352 <HAL_RCC_OscConfig+0x106>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8022458:	491f      	ldr	r1, [pc, #124]	@ (80224d8 <HAL_RCC_OscConfig+0x28c>)
 802245a:	6920      	ldr	r0, [r4, #16]
 802245c:	680a      	ldr	r2, [r1, #0]
 802245e:	f022 02f8 	bic.w	r2, r2, #248	@ 0xf8
 8022462:	ea42 02c0 	orr.w	r2, r2, r0, lsl #3
 8022466:	600a      	str	r2, [r1, #0]
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8022468:	071a      	lsls	r2, r3, #28
 802246a:	f57f af6a 	bpl.w	8022342 <HAL_RCC_OscConfig+0xf6>
 802246e:	e751      	b.n	8022314 <HAL_RCC_OscConfig+0xc8>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8022470:	4a19      	ldr	r2, [pc, #100]	@ (80224d8 <HAL_RCC_OscConfig+0x28c>)
 8022472:	6813      	ldr	r3, [r2, #0]
 8022474:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8022478:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 802247a:	f7fe fe2d 	bl	80210d8 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 802247e:	4e16      	ldr	r6, [pc, #88]	@ (80224d8 <HAL_RCC_OscConfig+0x28c>)
        tickstart = HAL_GetTick();
 8022480:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8022482:	e004      	b.n	802248e <HAL_RCC_OscConfig+0x242>
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8022484:	f7fe fe28 	bl	80210d8 <HAL_GetTick>
 8022488:	1b40      	subs	r0, r0, r5
 802248a:	2864      	cmp	r0, #100	@ 0x64
 802248c:	d813      	bhi.n	80224b6 <HAL_RCC_OscConfig+0x26a>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 802248e:	6833      	ldr	r3, [r6, #0]
 8022490:	039a      	lsls	r2, r3, #14
 8022492:	d5f7      	bpl.n	8022484 <HAL_RCC_OscConfig+0x238>
 8022494:	e710      	b.n	80222b8 <HAL_RCC_OscConfig+0x6c>
      SET_BIT(PWR->CR, PWR_CR_DBP);
 8022496:	6833      	ldr	r3, [r6, #0]
 8022498:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 802249c:	6033      	str	r3, [r6, #0]
      tickstart = HAL_GetTick();
 802249e:	f7fe fe1b 	bl	80210d8 <HAL_GetTick>
 80224a2:	4607      	mov	r7, r0
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 80224a4:	6833      	ldr	r3, [r6, #0]
 80224a6:	05da      	lsls	r2, r3, #23
 80224a8:	f53f af58 	bmi.w	802235c <HAL_RCC_OscConfig+0x110>
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 80224ac:	f7fe fe14 	bl	80210d8 <HAL_GetTick>
 80224b0:	1bc0      	subs	r0, r0, r7
 80224b2:	2802      	cmp	r0, #2
 80224b4:	d9f6      	bls.n	80224a4 <HAL_RCC_OscConfig+0x258>
            return HAL_TIMEOUT;
 80224b6:	2003      	movs	r0, #3
}
 80224b8:	b002      	add	sp, #8
 80224ba:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80224be:	4a06      	ldr	r2, [pc, #24]	@ (80224d8 <HAL_RCC_OscConfig+0x28c>)
 80224c0:	6f13      	ldr	r3, [r2, #112]	@ 0x70
 80224c2:	f043 0301 	orr.w	r3, r3, #1
 80224c6:	6713      	str	r3, [r2, #112]	@ 0x70
      tickstart = HAL_GetTick();
 80224c8:	f7fe fe06 	bl	80210d8 <HAL_GetTick>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 80224cc:	4f02      	ldr	r7, [pc, #8]	@ (80224d8 <HAL_RCC_OscConfig+0x28c>)
      tickstart = HAL_GetTick();
 80224ce:	4606      	mov	r6, r0
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80224d0:	f241 3888 	movw	r8, #5000	@ 0x1388
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 80224d4:	e00b      	b.n	80224ee <HAL_RCC_OscConfig+0x2a2>
 80224d6:	bf00      	nop
 80224d8:	40023800 	.word	0x40023800
 80224dc:	42470000 	.word	0x42470000
 80224e0:	40007000 	.word	0x40007000
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80224e4:	f7fe fdf8 	bl	80210d8 <HAL_GetTick>
 80224e8:	1b80      	subs	r0, r0, r6
 80224ea:	4540      	cmp	r0, r8
 80224ec:	d8e3      	bhi.n	80224b6 <HAL_RCC_OscConfig+0x26a>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 80224ee:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 80224f0:	079b      	lsls	r3, r3, #30
 80224f2:	d5f7      	bpl.n	80224e4 <HAL_RCC_OscConfig+0x298>
    if(pwrclkchanged == SET)
 80224f4:	2d00      	cmp	r5, #0
 80224f6:	f43f af56 	beq.w	80223a6 <HAL_RCC_OscConfig+0x15a>
 80224fa:	e01a      	b.n	8022532 <HAL_RCC_OscConfig+0x2e6>
        __HAL_RCC_HSI_DISABLE();
 80224fc:	4a2c      	ldr	r2, [pc, #176]	@ (80225b0 <HAL_RCC_OscConfig+0x364>)
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 80224fe:	4e2d      	ldr	r6, [pc, #180]	@ (80225b4 <HAL_RCC_OscConfig+0x368>)
        __HAL_RCC_HSI_DISABLE();
 8022500:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 8022502:	f7fe fde9 	bl	80210d8 <HAL_GetTick>
 8022506:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8022508:	e004      	b.n	8022514 <HAL_RCC_OscConfig+0x2c8>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 802250a:	f7fe fde5 	bl	80210d8 <HAL_GetTick>
 802250e:	1b40      	subs	r0, r0, r5
 8022510:	2802      	cmp	r0, #2
 8022512:	d8d0      	bhi.n	80224b6 <HAL_RCC_OscConfig+0x26a>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8022514:	6833      	ldr	r3, [r6, #0]
 8022516:	0799      	lsls	r1, r3, #30
 8022518:	d4f7      	bmi.n	802250a <HAL_RCC_OscConfig+0x2be>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 802251a:	6823      	ldr	r3, [r4, #0]
 802251c:	e6f8      	b.n	8022310 <HAL_RCC_OscConfig+0xc4>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 802251e:	4b25      	ldr	r3, [pc, #148]	@ (80225b4 <HAL_RCC_OscConfig+0x368>)
 8022520:	681a      	ldr	r2, [r3, #0]
 8022522:	f442 2280 	orr.w	r2, r2, #262144	@ 0x40000
 8022526:	601a      	str	r2, [r3, #0]
 8022528:	681a      	ldr	r2, [r3, #0]
 802252a:	f442 3280 	orr.w	r2, r2, #65536	@ 0x10000
 802252e:	601a      	str	r2, [r3, #0]
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
 8022530:	e7a3      	b.n	802247a <HAL_RCC_OscConfig+0x22e>
      __HAL_RCC_PWR_CLK_DISABLE();
 8022532:	4a20      	ldr	r2, [pc, #128]	@ (80225b4 <HAL_RCC_OscConfig+0x368>)
 8022534:	6c13      	ldr	r3, [r2, #64]	@ 0x40
 8022536:	f023 5380 	bic.w	r3, r3, #268435456	@ 0x10000000
 802253a:	6413      	str	r3, [r2, #64]	@ 0x40
 802253c:	e733      	b.n	80223a6 <HAL_RCC_OscConfig+0x15a>
        tickstart = HAL_GetTick();
 802253e:	f7fe fdcb 	bl	80210d8 <HAL_GetTick>
 8022542:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8022544:	e004      	b.n	8022550 <HAL_RCC_OscConfig+0x304>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8022546:	f7fe fdc7 	bl	80210d8 <HAL_GetTick>
 802254a:	1b80      	subs	r0, r0, r6
 802254c:	2802      	cmp	r0, #2
 802254e:	d8b2      	bhi.n	80224b6 <HAL_RCC_OscConfig+0x26a>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8022550:	682b      	ldr	r3, [r5, #0]
 8022552:	0199      	lsls	r1, r3, #6
 8022554:	d4f7      	bmi.n	8022546 <HAL_RCC_OscConfig+0x2fa>
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8022556:	e9d4 3107 	ldrd	r3, r1, [r4, #28]
 802255a:	6a62      	ldr	r2, [r4, #36]	@ 0x24
 802255c:	430b      	orrs	r3, r1
 802255e:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
 8022562:	e9d4 200a 	ldrd	r2, r0, [r4, #40]	@ 0x28
 8022566:	6b21      	ldr	r1, [r4, #48]	@ 0x30
 8022568:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
 802256c:	0852      	lsrs	r2, r2, #1
 802256e:	ea43 7301 	orr.w	r3, r3, r1, lsl #28
 8022572:	3a01      	subs	r2, #1
        __HAL_RCC_PLL_ENABLE();
 8022574:	490e      	ldr	r1, [pc, #56]	@ (80225b0 <HAL_RCC_OscConfig+0x364>)
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8022576:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
        __HAL_RCC_PLL_ENABLE();
 802257a:	2201      	movs	r2, #1
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 802257c:	606b      	str	r3, [r5, #4]
        __HAL_RCC_PLL_ENABLE();
 802257e:	660a      	str	r2, [r1, #96]	@ 0x60
        tickstart = HAL_GetTick();
 8022580:	f7fe fdaa 	bl	80210d8 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8022584:	4d0b      	ldr	r5, [pc, #44]	@ (80225b4 <HAL_RCC_OscConfig+0x368>)
        tickstart = HAL_GetTick();
 8022586:	4604      	mov	r4, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8022588:	e004      	b.n	8022594 <HAL_RCC_OscConfig+0x348>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 802258a:	f7fe fda5 	bl	80210d8 <HAL_GetTick>
 802258e:	1b00      	subs	r0, r0, r4
 8022590:	2802      	cmp	r0, #2
 8022592:	d890      	bhi.n	80224b6 <HAL_RCC_OscConfig+0x26a>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8022594:	682b      	ldr	r3, [r5, #0]
 8022596:	019a      	lsls	r2, r3, #6
 8022598:	d5f7      	bpl.n	802258a <HAL_RCC_OscConfig+0x33e>
 802259a:	e71f      	b.n	80223dc <HAL_RCC_OscConfig+0x190>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 802259c:	4b05      	ldr	r3, [pc, #20]	@ (80225b4 <HAL_RCC_OscConfig+0x368>)
 802259e:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
 80225a0:	f042 0204 	orr.w	r2, r2, #4
 80225a4:	671a      	str	r2, [r3, #112]	@ 0x70
 80225a6:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
 80225a8:	f042 0201 	orr.w	r2, r2, #1
 80225ac:	671a      	str	r2, [r3, #112]	@ 0x70
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 80225ae:	e78b      	b.n	80224c8 <HAL_RCC_OscConfig+0x27c>
 80225b0:	42470000 	.word	0x42470000
 80225b4:	40023800 	.word	0x40023800

080225b8 <SPI_EndRxTxTransaction>:
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart)
{
  /* Timeout in s */
  __IO uint32_t count = SPI_BSY_FLAG_WORKAROUND_TIMEOUT * (SystemCoreClock / 24U / 1000000U);
 80225b8:	4b30      	ldr	r3, [pc, #192]	@ (802267c <SPI_EndRxTxTransaction+0xc4>)
{
 80225ba:	b530      	push	{r4, r5, lr}
  __IO uint32_t count = SPI_BSY_FLAG_WORKAROUND_TIMEOUT * (SystemCoreClock / 24U / 1000000U);
 80225bc:	681b      	ldr	r3, [r3, #0]
 80225be:	4d30      	ldr	r5, [pc, #192]	@ (8022680 <SPI_EndRxTxTransaction+0xc8>)
{
 80225c0:	4604      	mov	r4, r0
  __IO uint32_t count = SPI_BSY_FLAG_WORKAROUND_TIMEOUT * (SystemCoreClock / 24U / 1000000U);
 80225c2:	fba5 5303 	umull	r5, r3, r5, r3
 80225c6:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
 80225ca:	0d5b      	lsrs	r3, r3, #21
 80225cc:	fb00 f303 	mul.w	r3, r0, r3
  /* Erratasheet: BSY bit may stay high at the end of a data transfer in Slave mode */
  if (hspi->Init.Mode == SPI_MODE_MASTER)
 80225d0:	6860      	ldr	r0, [r4, #4]
{
 80225d2:	b085      	sub	sp, #20
  if (hspi->Init.Mode == SPI_MODE_MASTER)
 80225d4:	f5b0 7f82 	cmp.w	r0, #260	@ 0x104
  __IO uint32_t count = SPI_BSY_FLAG_WORKAROUND_TIMEOUT * (SystemCoreClock / 24U / 1000000U);
 80225d8:	9303      	str	r3, [sp, #12]
  if (hspi->Init.Mode == SPI_MODE_MASTER)
 80225da:	d107      	bne.n	80225ec <SPI_EndRxTxTransaction+0x34>
 80225dc:	e00c      	b.n	80225f8 <SPI_EndRxTxTransaction+0x40>
    {
      if (count == 0U)
      {
        break;
      }
      count--;
 80225de:	9b03      	ldr	r3, [sp, #12]
    } while (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_BSY) != RESET);
 80225e0:	6822      	ldr	r2, [r4, #0]
      count--;
 80225e2:	3b01      	subs	r3, #1
 80225e4:	9303      	str	r3, [sp, #12]
    } while (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_BSY) != RESET);
 80225e6:	6893      	ldr	r3, [r2, #8]
 80225e8:	061b      	lsls	r3, r3, #24
 80225ea:	d502      	bpl.n	80225f2 <SPI_EndRxTxTransaction+0x3a>
      if (count == 0U)
 80225ec:	9b03      	ldr	r3, [sp, #12]
 80225ee:	2b00      	cmp	r3, #0
 80225f0:	d1f5      	bne.n	80225de <SPI_EndRxTxTransaction+0x26>
  }

  return HAL_OK;
 80225f2:	2000      	movs	r0, #0
}
 80225f4:	b005      	add	sp, #20
 80225f6:	bd30      	pop	{r4, r5, pc}
 80225f8:	1c4d      	adds	r5, r1, #1
 80225fa:	d104      	bne.n	8022606 <SPI_EndRxTxTransaction+0x4e>
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 80225fc:	6822      	ldr	r2, [r4, #0]
 80225fe:	6893      	ldr	r3, [r2, #8]
 8022600:	061c      	lsls	r4, r3, #24
 8022602:	d4fc      	bmi.n	80225fe <SPI_EndRxTxTransaction+0x46>
 8022604:	e7f5      	b.n	80225f2 <SPI_EndRxTxTransaction+0x3a>
 8022606:	6823      	ldr	r3, [r4, #0]
 8022608:	689b      	ldr	r3, [r3, #8]
 802260a:	0618      	lsls	r0, r3, #24
 802260c:	d5f1      	bpl.n	80225f2 <SPI_EndRxTxTransaction+0x3a>
 802260e:	e9cd 1200 	strd	r1, r2, [sp]
      if (((HAL_GetTick() - Tickstart) >= Timeout) || (Timeout == 0U))
 8022612:	f7fe fd61 	bl	80210d8 <HAL_GetTick>
 8022616:	9a01      	ldr	r2, [sp, #4]
 8022618:	9900      	ldr	r1, [sp, #0]
 802261a:	1a83      	subs	r3, r0, r2
 802261c:	4299      	cmp	r1, r3
 802261e:	d8f2      	bhi.n	8022606 <SPI_EndRxTxTransaction+0x4e>
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8022620:	e9d4 3100 	ldrd	r3, r1, [r4]
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 8022624:	685a      	ldr	r2, [r3, #4]
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8022626:	f5b1 7f82 	cmp.w	r1, #260	@ 0x104
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 802262a:	f022 02e0 	bic.w	r2, r2, #224	@ 0xe0
 802262e:	605a      	str	r2, [r3, #4]
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8022630:	d017      	beq.n	8022662 <SPI_EndRxTxTransaction+0xaa>
        if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8022632:	6aa2      	ldr	r2, [r4, #40]	@ 0x28
 8022634:	f5b2 5f00 	cmp.w	r2, #8192	@ 0x2000
 8022638:	d107      	bne.n	802264a <SPI_EndRxTxTransaction+0x92>
          SPI_RESET_CRC(hspi);
 802263a:	681a      	ldr	r2, [r3, #0]
 802263c:	f422 5200 	bic.w	r2, r2, #8192	@ 0x2000
 8022640:	601a      	str	r2, [r3, #0]
 8022642:	681a      	ldr	r2, [r3, #0]
 8022644:	f442 5200 	orr.w	r2, r2, #8192	@ 0x2000
 8022648:	601a      	str	r2, [r3, #0]
        hspi->State = HAL_SPI_STATE_READY;
 802264a:	2301      	movs	r3, #1
 802264c:	f884 3051 	strb.w	r3, [r4, #81]	@ 0x51
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8022650:	6d63      	ldr	r3, [r4, #84]	@ 0x54
        __HAL_UNLOCK(hspi);
 8022652:	2200      	movs	r2, #0
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8022654:	f043 0320 	orr.w	r3, r3, #32
        __HAL_UNLOCK(hspi);
 8022658:	f884 2050 	strb.w	r2, [r4, #80]	@ 0x50
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 802265c:	6563      	str	r3, [r4, #84]	@ 0x54
      return HAL_TIMEOUT;
 802265e:	2003      	movs	r0, #3
 8022660:	e7c8      	b.n	80225f4 <SPI_EndRxTxTransaction+0x3c>
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8022662:	68a2      	ldr	r2, [r4, #8]
 8022664:	f5b2 4f00 	cmp.w	r2, #32768	@ 0x8000
 8022668:	d002      	beq.n	8022670 <SPI_EndRxTxTransaction+0xb8>
                                                     || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 802266a:	f5b2 6f80 	cmp.w	r2, #1024	@ 0x400
 802266e:	d1e0      	bne.n	8022632 <SPI_EndRxTxTransaction+0x7a>
          __HAL_SPI_DISABLE(hspi);
 8022670:	681a      	ldr	r2, [r3, #0]
 8022672:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
 8022676:	601a      	str	r2, [r3, #0]
 8022678:	e7db      	b.n	8022632 <SPI_EndRxTxTransaction+0x7a>
 802267a:	bf00      	nop
 802267c:	20000130 	.word	0x20000130
 8022680:	165e9f81 	.word	0x165e9f81

08022684 <HAL_SPI_Init>:
  if (hspi == NULL)
 8022684:	2800      	cmp	r0, #0
 8022686:	d03b      	beq.n	8022700 <HAL_SPI_Init+0x7c>
{
 8022688:	b538      	push	{r3, r4, r5, lr}
  if (hspi->State == HAL_SPI_STATE_RESET)
 802268a:	f890 3051 	ldrb.w	r3, [r0, #81]	@ 0x51
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 802268e:	2200      	movs	r2, #0
 8022690:	4604      	mov	r4, r0
 8022692:	6282      	str	r2, [r0, #40]	@ 0x28
  if (hspi->State == HAL_SPI_STATE_RESET)
 8022694:	f003 01ff 	and.w	r1, r3, #255	@ 0xff
 8022698:	b363      	cbz	r3, 80226f4 <HAL_SPI_Init+0x70>
 802269a:	4610      	mov	r0, r2
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
 802269c:	e9d4 3101 	ldrd	r3, r1, [r4, #4]
 80226a0:	68e2      	ldr	r2, [r4, #12]
  __HAL_SPI_DISABLE(hspi);
 80226a2:	6825      	ldr	r5, [r4, #0]
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
 80226a4:	430b      	orrs	r3, r1
 80226a6:	4313      	orrs	r3, r2
 80226a8:	e9d4 1204 	ldrd	r1, r2, [r4, #16]
 80226ac:	430b      	orrs	r3, r1
 80226ae:	4313      	orrs	r3, r2
 80226b0:	69e2      	ldr	r2, [r4, #28]
  hspi->State = HAL_SPI_STATE_BUSY;
 80226b2:	2102      	movs	r1, #2
 80226b4:	f884 1051 	strb.w	r1, [r4, #81]	@ 0x51
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
 80226b8:	4313      	orrs	r3, r2
 80226ba:	6a22      	ldr	r2, [r4, #32]
  __HAL_SPI_DISABLE(hspi);
 80226bc:	6829      	ldr	r1, [r5, #0]
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
 80226be:	4313      	orrs	r3, r2
 80226c0:	69a2      	ldr	r2, [r4, #24]
  __HAL_SPI_DISABLE(hspi);
 80226c2:	f021 0140 	bic.w	r1, r1, #64	@ 0x40
 80226c6:	6029      	str	r1, [r5, #0]
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
 80226c8:	f402 7c00 	and.w	ip, r2, #512	@ 0x200
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode));
 80226cc:	6a61      	ldr	r1, [r4, #36]	@ 0x24
 80226ce:	0c12      	lsrs	r2, r2, #16
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
 80226d0:	ea43 030c 	orr.w	r3, r3, ip
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode));
 80226d4:	f002 0204 	and.w	r2, r2, #4
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
 80226d8:	4303      	orrs	r3, r0
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode));
 80226da:	430a      	orrs	r2, r1
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
 80226dc:	602b      	str	r3, [r5, #0]
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode));
 80226de:	606a      	str	r2, [r5, #4]
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 80226e0:	69eb      	ldr	r3, [r5, #28]
  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 80226e2:	2000      	movs	r0, #0
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 80226e4:	f423 6300 	bic.w	r3, r3, #2048	@ 0x800
  hspi->State     = HAL_SPI_STATE_READY;
 80226e8:	2201      	movs	r2, #1
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 80226ea:	61eb      	str	r3, [r5, #28]
  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 80226ec:	6560      	str	r0, [r4, #84]	@ 0x54
  hspi->State     = HAL_SPI_STATE_READY;
 80226ee:	f884 2051 	strb.w	r2, [r4, #81]	@ 0x51
}
 80226f2:	bd38      	pop	{r3, r4, r5, pc}
    hspi->Lock = HAL_UNLOCKED;
 80226f4:	f880 1050 	strb.w	r1, [r0, #80]	@ 0x50
    HAL_SPI_MspInit(hspi);
 80226f8:	f003 faba 	bl	8025c70 <HAL_SPI_MspInit>
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
 80226fc:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
 80226fe:	e7cd      	b.n	802269c <HAL_SPI_Init+0x18>
    return HAL_ERROR;
 8022700:	2001      	movs	r0, #1
}
 8022702:	4770      	bx	lr

08022704 <HAL_SPI_Transmit>:
{
 8022704:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8022708:	4604      	mov	r4, r0
  __HAL_LOCK(hspi);
 802270a:	f890 0050 	ldrb.w	r0, [r0, #80]	@ 0x50
 802270e:	2801      	cmp	r0, #1
{
 8022710:	b082      	sub	sp, #8
  __HAL_LOCK(hspi);
 8022712:	d073      	beq.n	80227fc <HAL_SPI_Transmit+0xf8>
 8022714:	461d      	mov	r5, r3
 8022716:	2301      	movs	r3, #1
 8022718:	f884 3050 	strb.w	r3, [r4, #80]	@ 0x50
  tickstart = HAL_GetTick();
 802271c:	4688      	mov	r8, r1
 802271e:	4617      	mov	r7, r2
 8022720:	f7fe fcda 	bl	80210d8 <HAL_GetTick>
  if (hspi->State != HAL_SPI_STATE_READY)
 8022724:	f894 3051 	ldrb.w	r3, [r4, #81]	@ 0x51
 8022728:	2b01      	cmp	r3, #1
  tickstart = HAL_GetTick();
 802272a:	4606      	mov	r6, r0
  if (hspi->State != HAL_SPI_STATE_READY)
 802272c:	b2d8      	uxtb	r0, r3
 802272e:	d009      	beq.n	8022744 <HAL_SPI_Transmit+0x40>
    errorcode = HAL_BUSY;
 8022730:	2002      	movs	r0, #2
  hspi->State = HAL_SPI_STATE_READY;
 8022732:	2201      	movs	r2, #1
  __HAL_UNLOCK(hspi);
 8022734:	2300      	movs	r3, #0
  hspi->State = HAL_SPI_STATE_READY;
 8022736:	f884 2051 	strb.w	r2, [r4, #81]	@ 0x51
  __HAL_UNLOCK(hspi);
 802273a:	f884 3050 	strb.w	r3, [r4, #80]	@ 0x50
}
 802273e:	b002      	add	sp, #8
 8022740:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if ((pData == NULL) || (Size == 0U))
 8022744:	f1b8 0f00 	cmp.w	r8, #0
 8022748:	d0f3      	beq.n	8022732 <HAL_SPI_Transmit+0x2e>
 802274a:	2f00      	cmp	r7, #0
 802274c:	d0f1      	beq.n	8022732 <HAL_SPI_Transmit+0x2e>
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 802274e:	68a2      	ldr	r2, [r4, #8]
    SPI_1LINE_TX(hspi);
 8022750:	6820      	ldr	r0, [r4, #0]
  hspi->pTxBuffPtr  = (uint8_t *)pData;
 8022752:	f8c4 8030 	str.w	r8, [r4, #48]	@ 0x30
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8022756:	2300      	movs	r3, #0
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
 8022758:	2103      	movs	r1, #3
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 802275a:	f5b2 4f00 	cmp.w	r2, #32768	@ 0x8000
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
 802275e:	f884 1051 	strb.w	r1, [r4, #81]	@ 0x51
  hspi->RxISR       = NULL;
 8022762:	e9c4 3310 	strd	r3, r3, [r4, #64]	@ 0x40
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8022766:	6563      	str	r3, [r4, #84]	@ 0x54
  hspi->TxXferSize  = Size;
 8022768:	86a7      	strh	r7, [r4, #52]	@ 0x34
  hspi->TxXferCount = Size;
 802276a:	86e7      	strh	r7, [r4, #54]	@ 0x36
  hspi->pRxBuffPtr  = (uint8_t *)NULL;
 802276c:	63a3      	str	r3, [r4, #56]	@ 0x38
  hspi->RxXferSize  = 0U;
 802276e:	87a3      	strh	r3, [r4, #60]	@ 0x3c
  hspi->RxXferCount = 0U;
 8022770:	87e3      	strh	r3, [r4, #62]	@ 0x3e
    SPI_1LINE_TX(hspi);
 8022772:	4684      	mov	ip, r0
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8022774:	d072      	beq.n	802285c <HAL_SPI_Transmit+0x158>
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 8022776:	6803      	ldr	r3, [r0, #0]
 8022778:	0659      	lsls	r1, r3, #25
 802277a:	d403      	bmi.n	8022784 <HAL_SPI_Transmit+0x80>
    __HAL_SPI_ENABLE(hspi);
 802277c:	6803      	ldr	r3, [r0, #0]
 802277e:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8022782:	6003      	str	r3, [r0, #0]
  if (hspi->Init.DataSize == SPI_DATASIZE_16BIT)
 8022784:	68e3      	ldr	r3, [r4, #12]
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 8022786:	6862      	ldr	r2, [r4, #4]
  if (hspi->Init.DataSize == SPI_DATASIZE_16BIT)
 8022788:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 802278c:	d03a      	beq.n	8022804 <HAL_SPI_Transmit+0x100>
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 802278e:	2a00      	cmp	r2, #0
 8022790:	f000 8082 	beq.w	8022898 <HAL_SPI_Transmit+0x194>
 8022794:	2f01      	cmp	r7, #1
 8022796:	d07f      	beq.n	8022898 <HAL_SPI_Transmit+0x194>
    while (hspi->TxXferCount > 0U)
 8022798:	8ee3      	ldrh	r3, [r4, #54]	@ 0x36
 802279a:	b29b      	uxth	r3, r3
 802279c:	b1c3      	cbz	r3, 80227d0 <HAL_SPI_Transmit+0xcc>
 802279e:	1c68      	adds	r0, r5, #1
 80227a0:	d16f      	bne.n	8022882 <HAL_SPI_Transmit+0x17e>
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 80227a2:	6823      	ldr	r3, [r4, #0]
 80227a4:	689a      	ldr	r2, [r3, #8]
 80227a6:	0791      	lsls	r1, r2, #30
 80227a8:	f140 8081 	bpl.w	80228ae <HAL_SPI_Transmit+0x1aa>
        *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
 80227ac:	6b22      	ldr	r2, [r4, #48]	@ 0x30
 80227ae:	7812      	ldrb	r2, [r2, #0]
 80227b0:	731a      	strb	r2, [r3, #12]
        hspi->TxXferCount--;
 80227b2:	f8b4 c036 	ldrh.w	ip, [r4, #54]	@ 0x36
        hspi->pTxBuffPtr += sizeof(uint8_t);
 80227b6:	6b23      	ldr	r3, [r4, #48]	@ 0x30
        hspi->TxXferCount--;
 80227b8:	f10c 3cff 	add.w	ip, ip, #4294967295
 80227bc:	fa1f fc8c 	uxth.w	ip, ip
 80227c0:	f8a4 c036 	strh.w	ip, [r4, #54]	@ 0x36
    while (hspi->TxXferCount > 0U)
 80227c4:	8ee1      	ldrh	r1, [r4, #54]	@ 0x36
        hspi->pTxBuffPtr += sizeof(uint8_t);
 80227c6:	3301      	adds	r3, #1
    while (hspi->TxXferCount > 0U)
 80227c8:	b289      	uxth	r1, r1
        hspi->pTxBuffPtr += sizeof(uint8_t);
 80227ca:	6323      	str	r3, [r4, #48]	@ 0x30
    while (hspi->TxXferCount > 0U)
 80227cc:	2900      	cmp	r1, #0
 80227ce:	d1e8      	bne.n	80227a2 <HAL_SPI_Transmit+0x9e>
  if (SPI_EndRxTxTransaction(hspi, Timeout, tickstart) != HAL_OK)
 80227d0:	4632      	mov	r2, r6
 80227d2:	4629      	mov	r1, r5
 80227d4:	4620      	mov	r0, r4
 80227d6:	f7ff feef 	bl	80225b8 <SPI_EndRxTxTransaction>
 80227da:	b108      	cbz	r0, 80227e0 <HAL_SPI_Transmit+0xdc>
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 80227dc:	2320      	movs	r3, #32
 80227de:	6563      	str	r3, [r4, #84]	@ 0x54
  if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
 80227e0:	68a3      	ldr	r3, [r4, #8]
 80227e2:	b933      	cbnz	r3, 80227f2 <HAL_SPI_Transmit+0xee>
    __HAL_SPI_CLEAR_OVRFLAG(hspi);
 80227e4:	6822      	ldr	r2, [r4, #0]
 80227e6:	9301      	str	r3, [sp, #4]
 80227e8:	68d3      	ldr	r3, [r2, #12]
 80227ea:	9301      	str	r3, [sp, #4]
 80227ec:	6893      	ldr	r3, [r2, #8]
 80227ee:	9301      	str	r3, [sp, #4]
 80227f0:	9b01      	ldr	r3, [sp, #4]
  if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 80227f2:	6d60      	ldr	r0, [r4, #84]	@ 0x54
 80227f4:	3800      	subs	r0, #0
 80227f6:	bf18      	it	ne
 80227f8:	2001      	movne	r0, #1
error:
 80227fa:	e79a      	b.n	8022732 <HAL_SPI_Transmit+0x2e>
  __HAL_LOCK(hspi);
 80227fc:	2002      	movs	r0, #2
}
 80227fe:	b002      	add	sp, #8
 8022800:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 8022804:	2a00      	cmp	r2, #0
 8022806:	d175      	bne.n	80228f4 <HAL_SPI_Transmit+0x1f0>
      hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8022808:	4641      	mov	r1, r8
 802280a:	f831 3b02 	ldrh.w	r3, [r1], #2
 802280e:	60c3      	str	r3, [r0, #12]
      hspi->TxXferCount--;
 8022810:	8ee3      	ldrh	r3, [r4, #54]	@ 0x36
      hspi->pTxBuffPtr += sizeof(uint16_t);
 8022812:	6321      	str	r1, [r4, #48]	@ 0x30
      hspi->TxXferCount--;
 8022814:	3b01      	subs	r3, #1
 8022816:	b29b      	uxth	r3, r3
 8022818:	86e3      	strh	r3, [r4, #54]	@ 0x36
    while (hspi->TxXferCount > 0U)
 802281a:	8ee3      	ldrh	r3, [r4, #54]	@ 0x36
 802281c:	b29b      	uxth	r3, r3
 802281e:	2b00      	cmp	r3, #0
 8022820:	d0d6      	beq.n	80227d0 <HAL_SPI_Transmit+0xcc>
 8022822:	1c6b      	adds	r3, r5, #1
 8022824:	d15c      	bne.n	80228e0 <HAL_SPI_Transmit+0x1dc>
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 8022826:	6883      	ldr	r3, [r0, #8]
 8022828:	079f      	lsls	r7, r3, #30
 802282a:	d50f      	bpl.n	802284c <HAL_SPI_Transmit+0x148>
        hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 802282c:	6b22      	ldr	r2, [r4, #48]	@ 0x30
 802282e:	f832 3b02 	ldrh.w	r3, [r2], #2
 8022832:	60c3      	str	r3, [r0, #12]
        hspi->TxXferCount--;
 8022834:	8ee3      	ldrh	r3, [r4, #54]	@ 0x36
        hspi->pTxBuffPtr += sizeof(uint16_t);
 8022836:	6322      	str	r2, [r4, #48]	@ 0x30
        hspi->TxXferCount--;
 8022838:	3b01      	subs	r3, #1
 802283a:	b29b      	uxth	r3, r3
 802283c:	86e3      	strh	r3, [r4, #54]	@ 0x36
    while (hspi->TxXferCount > 0U)
 802283e:	8ee3      	ldrh	r3, [r4, #54]	@ 0x36
 8022840:	b29b      	uxth	r3, r3
 8022842:	2b00      	cmp	r3, #0
 8022844:	d0c4      	beq.n	80227d0 <HAL_SPI_Transmit+0xcc>
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 8022846:	6883      	ldr	r3, [r0, #8]
 8022848:	079f      	lsls	r7, r3, #30
 802284a:	d4ef      	bmi.n	802282c <HAL_SPI_Transmit+0x128>
        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 802284c:	f7fe fc44 	bl	80210d8 <HAL_GetTick>
    while (hspi->TxXferCount > 0U)
 8022850:	8ee3      	ldrh	r3, [r4, #54]	@ 0x36
 8022852:	b29b      	uxth	r3, r3
 8022854:	2b00      	cmp	r3, #0
 8022856:	d0bb      	beq.n	80227d0 <HAL_SPI_Transmit+0xcc>
 8022858:	6820      	ldr	r0, [r4, #0]
 802285a:	e7e4      	b.n	8022826 <HAL_SPI_Transmit+0x122>
    SPI_1LINE_TX(hspi);
 802285c:	6803      	ldr	r3, [r0, #0]
 802285e:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 8022862:	6003      	str	r3, [r0, #0]
 8022864:	e787      	b.n	8022776 <HAL_SPI_Transmit+0x72>
        *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
 8022866:	6b22      	ldr	r2, [r4, #48]	@ 0x30
 8022868:	7812      	ldrb	r2, [r2, #0]
 802286a:	731a      	strb	r2, [r3, #12]
        hspi->TxXferCount--;
 802286c:	8ee3      	ldrh	r3, [r4, #54]	@ 0x36
        hspi->pTxBuffPtr += sizeof(uint8_t);
 802286e:	6b22      	ldr	r2, [r4, #48]	@ 0x30
        hspi->TxXferCount--;
 8022870:	3b01      	subs	r3, #1
        hspi->pTxBuffPtr += sizeof(uint8_t);
 8022872:	3201      	adds	r2, #1
        hspi->TxXferCount--;
 8022874:	b29b      	uxth	r3, r3
        hspi->pTxBuffPtr += sizeof(uint8_t);
 8022876:	6322      	str	r2, [r4, #48]	@ 0x30
        hspi->TxXferCount--;
 8022878:	86e3      	strh	r3, [r4, #54]	@ 0x36
    while (hspi->TxXferCount > 0U)
 802287a:	8ee3      	ldrh	r3, [r4, #54]	@ 0x36
 802287c:	b29b      	uxth	r3, r3
 802287e:	2b00      	cmp	r3, #0
 8022880:	d0a6      	beq.n	80227d0 <HAL_SPI_Transmit+0xcc>
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 8022882:	6823      	ldr	r3, [r4, #0]
 8022884:	689a      	ldr	r2, [r3, #8]
 8022886:	0792      	lsls	r2, r2, #30
 8022888:	d4ed      	bmi.n	8022866 <HAL_SPI_Transmit+0x162>
        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 802288a:	f7fe fc25 	bl	80210d8 <HAL_GetTick>
 802288e:	1b80      	subs	r0, r0, r6
 8022890:	42a8      	cmp	r0, r5
 8022892:	d3f2      	bcc.n	802287a <HAL_SPI_Transmit+0x176>
          errorcode = HAL_TIMEOUT;
 8022894:	2003      	movs	r0, #3
 8022896:	e74c      	b.n	8022732 <HAL_SPI_Transmit+0x2e>
      *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
 8022898:	f898 3000 	ldrb.w	r3, [r8]
 802289c:	7303      	strb	r3, [r0, #12]
      hspi->TxXferCount--;
 802289e:	8ee3      	ldrh	r3, [r4, #54]	@ 0x36
      hspi->pTxBuffPtr += sizeof(uint8_t);
 80228a0:	6b22      	ldr	r2, [r4, #48]	@ 0x30
      hspi->TxXferCount--;
 80228a2:	3b01      	subs	r3, #1
      hspi->pTxBuffPtr += sizeof(uint8_t);
 80228a4:	3201      	adds	r2, #1
      hspi->TxXferCount--;
 80228a6:	b29b      	uxth	r3, r3
      hspi->pTxBuffPtr += sizeof(uint8_t);
 80228a8:	6322      	str	r2, [r4, #48]	@ 0x30
      hspi->TxXferCount--;
 80228aa:	86e3      	strh	r3, [r4, #54]	@ 0x36
 80228ac:	e774      	b.n	8022798 <HAL_SPI_Transmit+0x94>
        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 80228ae:	f7fe fc13 	bl	80210d8 <HAL_GetTick>
    while (hspi->TxXferCount > 0U)
 80228b2:	8ee3      	ldrh	r3, [r4, #54]	@ 0x36
 80228b4:	b29b      	uxth	r3, r3
 80228b6:	2b00      	cmp	r3, #0
 80228b8:	f47f af73 	bne.w	80227a2 <HAL_SPI_Transmit+0x9e>
 80228bc:	e788      	b.n	80227d0 <HAL_SPI_Transmit+0xcc>
        hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 80228be:	6b22      	ldr	r2, [r4, #48]	@ 0x30
 80228c0:	f832 3b02 	ldrh.w	r3, [r2], #2
 80228c4:	f8cc 300c 	str.w	r3, [ip, #12]
        hspi->TxXferCount--;
 80228c8:	8ee3      	ldrh	r3, [r4, #54]	@ 0x36
        hspi->pTxBuffPtr += sizeof(uint16_t);
 80228ca:	6322      	str	r2, [r4, #48]	@ 0x30
        hspi->TxXferCount--;
 80228cc:	3b01      	subs	r3, #1
 80228ce:	b29b      	uxth	r3, r3
 80228d0:	86e3      	strh	r3, [r4, #54]	@ 0x36
    while (hspi->TxXferCount > 0U)
 80228d2:	8ee3      	ldrh	r3, [r4, #54]	@ 0x36
 80228d4:	b29b      	uxth	r3, r3
 80228d6:	2b00      	cmp	r3, #0
 80228d8:	f43f af7a 	beq.w	80227d0 <HAL_SPI_Transmit+0xcc>
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 80228dc:	f8d4 c000 	ldr.w	ip, [r4]
 80228e0:	f8dc 3008 	ldr.w	r3, [ip, #8]
 80228e4:	079a      	lsls	r2, r3, #30
 80228e6:	d4ea      	bmi.n	80228be <HAL_SPI_Transmit+0x1ba>
        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 80228e8:	f7fe fbf6 	bl	80210d8 <HAL_GetTick>
 80228ec:	1b83      	subs	r3, r0, r6
 80228ee:	42ab      	cmp	r3, r5
 80228f0:	d3ef      	bcc.n	80228d2 <HAL_SPI_Transmit+0x1ce>
 80228f2:	e7cf      	b.n	8022894 <HAL_SPI_Transmit+0x190>
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 80228f4:	2f01      	cmp	r7, #1
 80228f6:	d190      	bne.n	802281a <HAL_SPI_Transmit+0x116>
 80228f8:	e786      	b.n	8022808 <HAL_SPI_Transmit+0x104>
 80228fa:	bf00      	nop

080228fc <HAL_SPI_TransmitReceive>:
{
 80228fc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8022900:	4604      	mov	r4, r0
  __HAL_LOCK(hspi);
 8022902:	f890 0050 	ldrb.w	r0, [r0, #80]	@ 0x50
 8022906:	2801      	cmp	r0, #1
{
 8022908:	b082      	sub	sp, #8
  __HAL_LOCK(hspi);
 802290a:	f000 8095 	beq.w	8022a38 <HAL_SPI_TransmitReceive+0x13c>
 802290e:	461d      	mov	r5, r3
 8022910:	2301      	movs	r3, #1
 8022912:	f884 3050 	strb.w	r3, [r4, #80]	@ 0x50
  tickstart = HAL_GetTick();
 8022916:	4688      	mov	r8, r1
 8022918:	4617      	mov	r7, r2
 802291a:	f7fe fbdd 	bl	80210d8 <HAL_GetTick>
  tmp_state           = hspi->State;
 802291e:	f894 3051 	ldrb.w	r3, [r4, #81]	@ 0x51
  tmp_mode            = hspi->Init.Mode;
 8022922:	6861      	ldr	r1, [r4, #4]
  if (!((tmp_state == HAL_SPI_STATE_READY) || \
 8022924:	2b01      	cmp	r3, #1
  tickstart = HAL_GetTick();
 8022926:	4606      	mov	r6, r0
  tmp_state           = hspi->State;
 8022928:	b2da      	uxtb	r2, r3
  if (!((tmp_state == HAL_SPI_STATE_READY) || \
 802292a:	d011      	beq.n	8022950 <HAL_SPI_TransmitReceive+0x54>
 802292c:	f5b1 7f82 	cmp.w	r1, #260	@ 0x104
 8022930:	d009      	beq.n	8022946 <HAL_SPI_TransmitReceive+0x4a>
    errorcode = HAL_BUSY;
 8022932:	2002      	movs	r0, #2
  hspi->State = HAL_SPI_STATE_READY;
 8022934:	2201      	movs	r2, #1
  __HAL_UNLOCK(hspi);
 8022936:	2300      	movs	r3, #0
  hspi->State = HAL_SPI_STATE_READY;
 8022938:	f884 2051 	strb.w	r2, [r4, #81]	@ 0x51
  __HAL_UNLOCK(hspi);
 802293c:	f884 3050 	strb.w	r3, [r4, #80]	@ 0x50
}
 8022940:	b002      	add	sp, #8
 8022942:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        ((tmp_mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp_state == HAL_SPI_STATE_BUSY_RX))))
 8022946:	68a3      	ldr	r3, [r4, #8]
 8022948:	2b00      	cmp	r3, #0
 802294a:	d1f2      	bne.n	8022932 <HAL_SPI_TransmitReceive+0x36>
 802294c:	2a04      	cmp	r2, #4
 802294e:	d1f0      	bne.n	8022932 <HAL_SPI_TransmitReceive+0x36>
  if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
 8022950:	f1b8 0f00 	cmp.w	r8, #0
 8022954:	d076      	beq.n	8022a44 <HAL_SPI_TransmitReceive+0x148>
 8022956:	2f00      	cmp	r7, #0
 8022958:	d074      	beq.n	8022a44 <HAL_SPI_TransmitReceive+0x148>
 802295a:	2d00      	cmp	r5, #0
 802295c:	d072      	beq.n	8022a44 <HAL_SPI_TransmitReceive+0x148>
  if (hspi->State != HAL_SPI_STATE_BUSY_RX)
 802295e:	f894 3051 	ldrb.w	r3, [r4, #81]	@ 0x51
  hspi->pRxBuffPtr  = (uint8_t *)pRxData;
 8022962:	63a7      	str	r7, [r4, #56]	@ 0x38
  if (hspi->State != HAL_SPI_STATE_BUSY_RX)
 8022964:	2b04      	cmp	r3, #4
    hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
 8022966:	bf1c      	itt	ne
 8022968:	2305      	movne	r3, #5
 802296a:	f884 3051 	strbne.w	r3, [r4, #81]	@ 0x51
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 802296e:	2300      	movs	r3, #0
 8022970:	6563      	str	r3, [r4, #84]	@ 0x54
  hspi->RxISR       = NULL;
 8022972:	e9c4 3310 	strd	r3, r3, [r4, #64]	@ 0x40
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 8022976:	6823      	ldr	r3, [r4, #0]
  hspi->RxXferCount = Size;
 8022978:	87e5      	strh	r5, [r4, #62]	@ 0x3e
  hspi->TxXferCount = Size;
 802297a:	86e5      	strh	r5, [r4, #54]	@ 0x36
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 802297c:	681a      	ldr	r2, [r3, #0]
  hspi->RxXferSize  = Size;
 802297e:	87a5      	strh	r5, [r4, #60]	@ 0x3c
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 8022980:	0652      	lsls	r2, r2, #25
  hspi->pTxBuffPtr  = (uint8_t *)pTxData;
 8022982:	f8c4 8030 	str.w	r8, [r4, #48]	@ 0x30
  hspi->TxXferSize  = Size;
 8022986:	86a5      	strh	r5, [r4, #52]	@ 0x34
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 8022988:	d403      	bmi.n	8022992 <HAL_SPI_TransmitReceive+0x96>
    __HAL_SPI_ENABLE(hspi);
 802298a:	681a      	ldr	r2, [r3, #0]
 802298c:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 8022990:	601a      	str	r2, [r3, #0]
  if (hspi->Init.DataSize == SPI_DATASIZE_16BIT)
 8022992:	68e2      	ldr	r2, [r4, #12]
 8022994:	f5b2 6f00 	cmp.w	r2, #2048	@ 0x800
 8022998:	f000 808d 	beq.w	8022ab6 <HAL_SPI_TransmitReceive+0x1ba>
	hspi->pRxBuffPtr+=(Size-1);
 802299c:	1e6a      	subs	r2, r5, #1
 802299e:	443a      	add	r2, r7
 80229a0:	63a2      	str	r2, [r4, #56]	@ 0x38
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 80229a2:	2900      	cmp	r1, #0
 80229a4:	d07c      	beq.n	8022aa0 <HAL_SPI_TransmitReceive+0x1a4>
 80229a6:	2d01      	cmp	r5, #1
 80229a8:	d07a      	beq.n	8022aa0 <HAL_SPI_TransmitReceive+0x1a4>
 80229aa:	9b08      	ldr	r3, [sp, #32]
 80229ac:	3301      	adds	r3, #1
        txallowed = 1U;
 80229ae:	f04f 0501 	mov.w	r5, #1
 80229b2:	d028      	beq.n	8022a06 <HAL_SPI_TransmitReceive+0x10a>
 80229b4:	e048      	b.n	8022a48 <HAL_SPI_TransmitReceive+0x14c>
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) && (hspi->TxXferCount > 0U) && (txallowed == 1U))
 80229b6:	6821      	ldr	r1, [r4, #0]
 80229b8:	688b      	ldr	r3, [r1, #8]
 80229ba:	079a      	lsls	r2, r3, #30
 80229bc:	d50f      	bpl.n	80229de <HAL_SPI_TransmitReceive+0xe2>
 80229be:	8ee3      	ldrh	r3, [r4, #54]	@ 0x36
 80229c0:	b29b      	uxth	r3, r3
 80229c2:	b163      	cbz	r3, 80229de <HAL_SPI_TransmitReceive+0xe2>
 80229c4:	b15d      	cbz	r5, 80229de <HAL_SPI_TransmitReceive+0xe2>
        *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
 80229c6:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 80229c8:	781b      	ldrb	r3, [r3, #0]
 80229ca:	730b      	strb	r3, [r1, #12]
        hspi->TxXferCount--;
 80229cc:	8ee3      	ldrh	r3, [r4, #54]	@ 0x36
        hspi->pTxBuffPtr++;
 80229ce:	6b22      	ldr	r2, [r4, #48]	@ 0x30
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) && (hspi->RxXferCount > 0U))
 80229d0:	6821      	ldr	r1, [r4, #0]
        hspi->TxXferCount--;
 80229d2:	3b01      	subs	r3, #1
        hspi->pTxBuffPtr++;
 80229d4:	3201      	adds	r2, #1
        hspi->TxXferCount--;
 80229d6:	b29b      	uxth	r3, r3
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) && (hspi->RxXferCount > 0U))
 80229d8:	2500      	movs	r5, #0
        hspi->TxXferCount--;
 80229da:	86e3      	strh	r3, [r4, #54]	@ 0x36
        hspi->pTxBuffPtr++;
 80229dc:	6322      	str	r2, [r4, #48]	@ 0x30
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) && (hspi->RxXferCount > 0U))
 80229de:	688b      	ldr	r3, [r1, #8]
 80229e0:	f013 0301 	ands.w	r3, r3, #1
 80229e4:	d00d      	beq.n	8022a02 <HAL_SPI_TransmitReceive+0x106>
 80229e6:	8fe2      	ldrh	r2, [r4, #62]	@ 0x3e
 80229e8:	b292      	uxth	r2, r2
 80229ea:	b152      	cbz	r2, 8022a02 <HAL_SPI_TransmitReceive+0x106>
        (*(uint8_t *)hspi->pRxBuffPtr) = hspi->Instance->DR;
 80229ec:	6ba2      	ldr	r2, [r4, #56]	@ 0x38
 80229ee:	68c9      	ldr	r1, [r1, #12]
 80229f0:	7011      	strb	r1, [r2, #0]
        hspi->RxXferCount--;
 80229f2:	8fe2      	ldrh	r2, [r4, #62]	@ 0x3e
        hspi->pRxBuffPtr--;
 80229f4:	6ba1      	ldr	r1, [r4, #56]	@ 0x38
        hspi->RxXferCount--;
 80229f6:	3a01      	subs	r2, #1
        hspi->pRxBuffPtr--;
 80229f8:	3901      	subs	r1, #1
        hspi->RxXferCount--;
 80229fa:	b292      	uxth	r2, r2
        hspi->pRxBuffPtr--;
 80229fc:	63a1      	str	r1, [r4, #56]	@ 0x38
        hspi->RxXferCount--;
 80229fe:	87e2      	strh	r2, [r4, #62]	@ 0x3e
        txallowed = 1U;
 8022a00:	461d      	mov	r5, r3
      if ((((HAL_GetTick() - tickstart) >=  Timeout) && ((Timeout != HAL_MAX_DELAY))) || (Timeout == 0U))
 8022a02:	f7fe fb69 	bl	80210d8 <HAL_GetTick>
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 8022a06:	8ee3      	ldrh	r3, [r4, #54]	@ 0x36
 8022a08:	b29b      	uxth	r3, r3
 8022a0a:	2b00      	cmp	r3, #0
 8022a0c:	d1d3      	bne.n	80229b6 <HAL_SPI_TransmitReceive+0xba>
 8022a0e:	8fe3      	ldrh	r3, [r4, #62]	@ 0x3e
 8022a10:	b29b      	uxth	r3, r3
 8022a12:	2b00      	cmp	r3, #0
 8022a14:	d1cf      	bne.n	80229b6 <HAL_SPI_TransmitReceive+0xba>
  if (SPI_EndRxTxTransaction(hspi, Timeout, tickstart) != HAL_OK)
 8022a16:	9908      	ldr	r1, [sp, #32]
 8022a18:	4632      	mov	r2, r6
 8022a1a:	4620      	mov	r0, r4
 8022a1c:	f7ff fdcc 	bl	80225b8 <SPI_EndRxTxTransaction>
 8022a20:	b970      	cbnz	r0, 8022a40 <HAL_SPI_TransmitReceive+0x144>
  if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
 8022a22:	68a3      	ldr	r3, [r4, #8]
 8022a24:	2b00      	cmp	r3, #0
 8022a26:	d185      	bne.n	8022934 <HAL_SPI_TransmitReceive+0x38>
    __HAL_SPI_CLEAR_OVRFLAG(hspi);
 8022a28:	6823      	ldr	r3, [r4, #0]
 8022a2a:	9001      	str	r0, [sp, #4]
 8022a2c:	68da      	ldr	r2, [r3, #12]
 8022a2e:	9201      	str	r2, [sp, #4]
 8022a30:	689b      	ldr	r3, [r3, #8]
 8022a32:	9301      	str	r3, [sp, #4]
 8022a34:	9b01      	ldr	r3, [sp, #4]
 8022a36:	e77d      	b.n	8022934 <HAL_SPI_TransmitReceive+0x38>
  __HAL_LOCK(hspi);
 8022a38:	2002      	movs	r0, #2
}
 8022a3a:	b002      	add	sp, #8
 8022a3c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 8022a40:	2320      	movs	r3, #32
 8022a42:	6563      	str	r3, [r4, #84]	@ 0x54
    errorcode = HAL_ERROR;
 8022a44:	2001      	movs	r0, #1
 8022a46:	e775      	b.n	8022934 <HAL_SPI_TransmitReceive+0x38>
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 8022a48:	8ee3      	ldrh	r3, [r4, #54]	@ 0x36
 8022a4a:	b29b      	uxth	r3, r3
 8022a4c:	b91b      	cbnz	r3, 8022a56 <HAL_SPI_TransmitReceive+0x15a>
 8022a4e:	8fe3      	ldrh	r3, [r4, #62]	@ 0x3e
 8022a50:	b29b      	uxth	r3, r3
 8022a52:	2b00      	cmp	r3, #0
 8022a54:	d0df      	beq.n	8022a16 <HAL_SPI_TransmitReceive+0x11a>
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) && (hspi->TxXferCount > 0U) && (txallowed == 1U))
 8022a56:	6822      	ldr	r2, [r4, #0]
 8022a58:	6893      	ldr	r3, [r2, #8]
 8022a5a:	079b      	lsls	r3, r3, #30
 8022a5c:	d50f      	bpl.n	8022a7e <HAL_SPI_TransmitReceive+0x182>
 8022a5e:	8ee3      	ldrh	r3, [r4, #54]	@ 0x36
 8022a60:	b29b      	uxth	r3, r3
 8022a62:	b163      	cbz	r3, 8022a7e <HAL_SPI_TransmitReceive+0x182>
 8022a64:	b15d      	cbz	r5, 8022a7e <HAL_SPI_TransmitReceive+0x182>
        *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
 8022a66:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 8022a68:	781b      	ldrb	r3, [r3, #0]
 8022a6a:	7313      	strb	r3, [r2, #12]
        hspi->TxXferCount--;
 8022a6c:	8ee3      	ldrh	r3, [r4, #54]	@ 0x36
        hspi->pTxBuffPtr++;
 8022a6e:	6b22      	ldr	r2, [r4, #48]	@ 0x30
        hspi->TxXferCount--;
 8022a70:	3b01      	subs	r3, #1
        hspi->pTxBuffPtr++;
 8022a72:	3201      	adds	r2, #1
        hspi->TxXferCount--;
 8022a74:	b29b      	uxth	r3, r3
        hspi->pTxBuffPtr++;
 8022a76:	6322      	str	r2, [r4, #48]	@ 0x30
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) && (hspi->RxXferCount > 0U))
 8022a78:	6822      	ldr	r2, [r4, #0]
        hspi->TxXferCount--;
 8022a7a:	86e3      	strh	r3, [r4, #54]	@ 0x36
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) && (hspi->RxXferCount > 0U))
 8022a7c:	2500      	movs	r5, #0
 8022a7e:	6893      	ldr	r3, [r2, #8]
 8022a80:	f013 0301 	ands.w	r3, r3, #1
 8022a84:	d004      	beq.n	8022a90 <HAL_SPI_TransmitReceive+0x194>
 8022a86:	8fe1      	ldrh	r1, [r4, #62]	@ 0x3e
 8022a88:	b289      	uxth	r1, r1
 8022a8a:	2900      	cmp	r1, #0
 8022a8c:	f040 8087 	bne.w	8022b9e <HAL_SPI_TransmitReceive+0x2a2>
      if ((((HAL_GetTick() - tickstart) >=  Timeout) && ((Timeout != HAL_MAX_DELAY))) || (Timeout == 0U))
 8022a90:	f7fe fb22 	bl	80210d8 <HAL_GetTick>
 8022a94:	9b08      	ldr	r3, [sp, #32]
 8022a96:	1b80      	subs	r0, r0, r6
 8022a98:	4298      	cmp	r0, r3
 8022a9a:	d3d5      	bcc.n	8022a48 <HAL_SPI_TransmitReceive+0x14c>
        errorcode = HAL_TIMEOUT;
 8022a9c:	2003      	movs	r0, #3
 8022a9e:	e749      	b.n	8022934 <HAL_SPI_TransmitReceive+0x38>
      *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
 8022aa0:	f898 2000 	ldrb.w	r2, [r8]
 8022aa4:	731a      	strb	r2, [r3, #12]
      hspi->TxXferCount--;
 8022aa6:	8ee3      	ldrh	r3, [r4, #54]	@ 0x36
      hspi->pTxBuffPtr += sizeof(uint8_t);
 8022aa8:	6b22      	ldr	r2, [r4, #48]	@ 0x30
      hspi->TxXferCount--;
 8022aaa:	3b01      	subs	r3, #1
      hspi->pTxBuffPtr += sizeof(uint8_t);
 8022aac:	3201      	adds	r2, #1
      hspi->TxXferCount--;
 8022aae:	b29b      	uxth	r3, r3
      hspi->pTxBuffPtr += sizeof(uint8_t);
 8022ab0:	6322      	str	r2, [r4, #48]	@ 0x30
      hspi->TxXferCount--;
 8022ab2:	86e3      	strh	r3, [r4, #54]	@ 0x36
 8022ab4:	e779      	b.n	80229aa <HAL_SPI_TransmitReceive+0xae>
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 8022ab6:	2900      	cmp	r1, #0
 8022ab8:	d13c      	bne.n	8022b34 <HAL_SPI_TransmitReceive+0x238>
      hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8022aba:	4641      	mov	r1, r8
 8022abc:	f831 2b02 	ldrh.w	r2, [r1], #2
 8022ac0:	60da      	str	r2, [r3, #12]
      hspi->TxXferCount--;
 8022ac2:	8ee3      	ldrh	r3, [r4, #54]	@ 0x36
      hspi->pTxBuffPtr += sizeof(uint16_t);
 8022ac4:	6321      	str	r1, [r4, #48]	@ 0x30
      hspi->TxXferCount--;
 8022ac6:	3b01      	subs	r3, #1
 8022ac8:	b29b      	uxth	r3, r3
 8022aca:	86e3      	strh	r3, [r4, #54]	@ 0x36
 8022acc:	9b08      	ldr	r3, [sp, #32]
 8022ace:	3301      	adds	r3, #1
{
 8022ad0:	f04f 0501 	mov.w	r5, #1
 8022ad4:	d025      	beq.n	8022b22 <HAL_SPI_TransmitReceive+0x226>
 8022ad6:	e030      	b.n	8022b3a <HAL_SPI_TransmitReceive+0x23e>
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) && (hspi->TxXferCount > 0U) && (txallowed == 1U))
 8022ad8:	6822      	ldr	r2, [r4, #0]
 8022ada:	6893      	ldr	r3, [r2, #8]
 8022adc:	0798      	lsls	r0, r3, #30
 8022ade:	d50d      	bpl.n	8022afc <HAL_SPI_TransmitReceive+0x200>
 8022ae0:	8ee3      	ldrh	r3, [r4, #54]	@ 0x36
 8022ae2:	b29b      	uxth	r3, r3
 8022ae4:	b153      	cbz	r3, 8022afc <HAL_SPI_TransmitReceive+0x200>
 8022ae6:	b145      	cbz	r5, 8022afa <HAL_SPI_TransmitReceive+0x1fe>
        hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8022ae8:	6b21      	ldr	r1, [r4, #48]	@ 0x30
 8022aea:	f831 3b02 	ldrh.w	r3, [r1], #2
 8022aee:	60d3      	str	r3, [r2, #12]
        hspi->TxXferCount--;
 8022af0:	8ee3      	ldrh	r3, [r4, #54]	@ 0x36
        hspi->pTxBuffPtr += sizeof(uint16_t);
 8022af2:	6321      	str	r1, [r4, #48]	@ 0x30
        hspi->TxXferCount--;
 8022af4:	3b01      	subs	r3, #1
 8022af6:	b29b      	uxth	r3, r3
 8022af8:	86e3      	strh	r3, [r4, #54]	@ 0x36
{
 8022afa:	2500      	movs	r5, #0
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) && (hspi->RxXferCount > 0U))
 8022afc:	6893      	ldr	r3, [r2, #8]
 8022afe:	f013 0301 	ands.w	r3, r3, #1
 8022b02:	d00c      	beq.n	8022b1e <HAL_SPI_TransmitReceive+0x222>
 8022b04:	8fe1      	ldrh	r1, [r4, #62]	@ 0x3e
 8022b06:	b289      	uxth	r1, r1
 8022b08:	b149      	cbz	r1, 8022b1e <HAL_SPI_TransmitReceive+0x222>
        *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
 8022b0a:	6ba1      	ldr	r1, [r4, #56]	@ 0x38
 8022b0c:	68d2      	ldr	r2, [r2, #12]
 8022b0e:	f821 2b02 	strh.w	r2, [r1], #2
        txallowed = 1U;
 8022b12:	461d      	mov	r5, r3
        hspi->RxXferCount--;
 8022b14:	8fe3      	ldrh	r3, [r4, #62]	@ 0x3e
        hspi->pRxBuffPtr += sizeof(uint16_t);
 8022b16:	63a1      	str	r1, [r4, #56]	@ 0x38
        hspi->RxXferCount--;
 8022b18:	3b01      	subs	r3, #1
 8022b1a:	b29b      	uxth	r3, r3
 8022b1c:	87e3      	strh	r3, [r4, #62]	@ 0x3e
      if (((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY))
 8022b1e:	f7fe fadb 	bl	80210d8 <HAL_GetTick>
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 8022b22:	8ee3      	ldrh	r3, [r4, #54]	@ 0x36
 8022b24:	b29b      	uxth	r3, r3
 8022b26:	2b00      	cmp	r3, #0
 8022b28:	d1d6      	bne.n	8022ad8 <HAL_SPI_TransmitReceive+0x1dc>
 8022b2a:	8fe3      	ldrh	r3, [r4, #62]	@ 0x3e
 8022b2c:	b29b      	uxth	r3, r3
 8022b2e:	2b00      	cmp	r3, #0
 8022b30:	d1d2      	bne.n	8022ad8 <HAL_SPI_TransmitReceive+0x1dc>
 8022b32:	e770      	b.n	8022a16 <HAL_SPI_TransmitReceive+0x11a>
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 8022b34:	2d01      	cmp	r5, #1
 8022b36:	d1c9      	bne.n	8022acc <HAL_SPI_TransmitReceive+0x1d0>
 8022b38:	e7bf      	b.n	8022aba <HAL_SPI_TransmitReceive+0x1be>
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 8022b3a:	8ee3      	ldrh	r3, [r4, #54]	@ 0x36
 8022b3c:	b29b      	uxth	r3, r3
 8022b3e:	b923      	cbnz	r3, 8022b4a <HAL_SPI_TransmitReceive+0x24e>
 8022b40:	8fe3      	ldrh	r3, [r4, #62]	@ 0x3e
 8022b42:	b29b      	uxth	r3, r3
 8022b44:	2b00      	cmp	r3, #0
 8022b46:	f43f af66 	beq.w	8022a16 <HAL_SPI_TransmitReceive+0x11a>
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) && (hspi->TxXferCount > 0U) && (txallowed == 1U))
 8022b4a:	6822      	ldr	r2, [r4, #0]
 8022b4c:	6893      	ldr	r3, [r2, #8]
 8022b4e:	0799      	lsls	r1, r3, #30
 8022b50:	d50d      	bpl.n	8022b6e <HAL_SPI_TransmitReceive+0x272>
 8022b52:	8ee3      	ldrh	r3, [r4, #54]	@ 0x36
 8022b54:	b29b      	uxth	r3, r3
 8022b56:	b153      	cbz	r3, 8022b6e <HAL_SPI_TransmitReceive+0x272>
 8022b58:	b145      	cbz	r5, 8022b6c <HAL_SPI_TransmitReceive+0x270>
        hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8022b5a:	6b21      	ldr	r1, [r4, #48]	@ 0x30
 8022b5c:	f831 3b02 	ldrh.w	r3, [r1], #2
 8022b60:	60d3      	str	r3, [r2, #12]
        hspi->TxXferCount--;
 8022b62:	8ee3      	ldrh	r3, [r4, #54]	@ 0x36
        hspi->pTxBuffPtr += sizeof(uint16_t);
 8022b64:	6321      	str	r1, [r4, #48]	@ 0x30
        hspi->TxXferCount--;
 8022b66:	3b01      	subs	r3, #1
 8022b68:	b29b      	uxth	r3, r3
 8022b6a:	86e3      	strh	r3, [r4, #54]	@ 0x36
        txallowed = 1U;
 8022b6c:	2500      	movs	r5, #0
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) && (hspi->RxXferCount > 0U))
 8022b6e:	6893      	ldr	r3, [r2, #8]
 8022b70:	f013 0301 	ands.w	r3, r3, #1
 8022b74:	d00c      	beq.n	8022b90 <HAL_SPI_TransmitReceive+0x294>
 8022b76:	8fe1      	ldrh	r1, [r4, #62]	@ 0x3e
 8022b78:	b289      	uxth	r1, r1
 8022b7a:	b149      	cbz	r1, 8022b90 <HAL_SPI_TransmitReceive+0x294>
        *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
 8022b7c:	6ba1      	ldr	r1, [r4, #56]	@ 0x38
 8022b7e:	68d2      	ldr	r2, [r2, #12]
 8022b80:	f821 2b02 	strh.w	r2, [r1], #2
        txallowed = 1U;
 8022b84:	461d      	mov	r5, r3
        hspi->RxXferCount--;
 8022b86:	8fe3      	ldrh	r3, [r4, #62]	@ 0x3e
        hspi->pRxBuffPtr += sizeof(uint16_t);
 8022b88:	63a1      	str	r1, [r4, #56]	@ 0x38
        hspi->RxXferCount--;
 8022b8a:	3b01      	subs	r3, #1
 8022b8c:	b29b      	uxth	r3, r3
 8022b8e:	87e3      	strh	r3, [r4, #62]	@ 0x3e
      if (((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY))
 8022b90:	f7fe faa2 	bl	80210d8 <HAL_GetTick>
 8022b94:	9b08      	ldr	r3, [sp, #32]
 8022b96:	1b80      	subs	r0, r0, r6
 8022b98:	4298      	cmp	r0, r3
 8022b9a:	d3ce      	bcc.n	8022b3a <HAL_SPI_TransmitReceive+0x23e>
 8022b9c:	e77e      	b.n	8022a9c <HAL_SPI_TransmitReceive+0x1a0>
        (*(uint8_t *)hspi->pRxBuffPtr) = hspi->Instance->DR;
 8022b9e:	6ba1      	ldr	r1, [r4, #56]	@ 0x38
 8022ba0:	68d2      	ldr	r2, [r2, #12]
 8022ba2:	700a      	strb	r2, [r1, #0]
        hspi->RxXferCount--;
 8022ba4:	8fe2      	ldrh	r2, [r4, #62]	@ 0x3e
        hspi->pRxBuffPtr--;
 8022ba6:	6ba1      	ldr	r1, [r4, #56]	@ 0x38
        hspi->RxXferCount--;
 8022ba8:	3a01      	subs	r2, #1
        hspi->pRxBuffPtr--;
 8022baa:	3901      	subs	r1, #1
        hspi->RxXferCount--;
 8022bac:	b292      	uxth	r2, r2
        hspi->pRxBuffPtr--;
 8022bae:	63a1      	str	r1, [r4, #56]	@ 0x38
        hspi->RxXferCount--;
 8022bb0:	87e2      	strh	r2, [r4, #62]	@ 0x3e
        txallowed = 1U;
 8022bb2:	461d      	mov	r5, r3
 8022bb4:	e76c      	b.n	8022a90 <HAL_SPI_TransmitReceive+0x194>
 8022bb6:	bf00      	nop

08022bb8 <HAL_SPI_Receive>:
{
 8022bb8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8022bbc:	461d      	mov	r5, r3
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
 8022bbe:	6843      	ldr	r3, [r0, #4]
 8022bc0:	f5b3 7f82 	cmp.w	r3, #260	@ 0x104
{
 8022bc4:	b082      	sub	sp, #8
 8022bc6:	4604      	mov	r4, r0
 8022bc8:	4617      	mov	r7, r2
 8022bca:	4688      	mov	r8, r1
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
 8022bcc:	d061      	beq.n	8022c92 <HAL_SPI_Receive+0xda>
  __HAL_LOCK(hspi);
 8022bce:	f894 3050 	ldrb.w	r3, [r4, #80]	@ 0x50
 8022bd2:	2b01      	cmp	r3, #1
 8022bd4:	d069      	beq.n	8022caa <HAL_SPI_Receive+0xf2>
 8022bd6:	2301      	movs	r3, #1
 8022bd8:	f884 3050 	strb.w	r3, [r4, #80]	@ 0x50
  tickstart = HAL_GetTick();
 8022bdc:	f7fe fa7c 	bl	80210d8 <HAL_GetTick>
  if (hspi->State != HAL_SPI_STATE_READY)
 8022be0:	f894 3051 	ldrb.w	r3, [r4, #81]	@ 0x51
 8022be4:	2b01      	cmp	r3, #1
  tickstart = HAL_GetTick();
 8022be6:	4606      	mov	r6, r0
  if (hspi->State != HAL_SPI_STATE_READY)
 8022be8:	b2d8      	uxtb	r0, r3
 8022bea:	d009      	beq.n	8022c00 <HAL_SPI_Receive+0x48>
    errorcode = HAL_BUSY;
 8022bec:	2002      	movs	r0, #2
  hspi->State = HAL_SPI_STATE_READY;
 8022bee:	2201      	movs	r2, #1
  __HAL_UNLOCK(hspi);
 8022bf0:	2300      	movs	r3, #0
  hspi->State = HAL_SPI_STATE_READY;
 8022bf2:	f884 2051 	strb.w	r2, [r4, #81]	@ 0x51
  __HAL_UNLOCK(hspi);
 8022bf6:	f884 3050 	strb.w	r3, [r4, #80]	@ 0x50
}
 8022bfa:	b002      	add	sp, #8
 8022bfc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if ((pData == NULL) || (Size == 0U))
 8022c00:	f1b8 0f00 	cmp.w	r8, #0
 8022c04:	d0f3      	beq.n	8022bee <HAL_SPI_Receive+0x36>
 8022c06:	2f00      	cmp	r7, #0
 8022c08:	d0f1      	beq.n	8022bee <HAL_SPI_Receive+0x36>
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8022c0a:	68a2      	ldr	r2, [r4, #8]
    SPI_1LINE_RX(hspi);
 8022c0c:	6821      	ldr	r1, [r4, #0]
  hspi->pRxBuffPtr  = (uint8_t *)pData;
 8022c0e:	f8c4 8038 	str.w	r8, [r4, #56]	@ 0x38
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8022c12:	2300      	movs	r3, #0
  hspi->State       = HAL_SPI_STATE_BUSY_RX;
 8022c14:	2004      	movs	r0, #4
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8022c16:	f5b2 4f00 	cmp.w	r2, #32768	@ 0x8000
  hspi->State       = HAL_SPI_STATE_BUSY_RX;
 8022c1a:	f884 0051 	strb.w	r0, [r4, #81]	@ 0x51
  hspi->RxISR       = NULL;
 8022c1e:	e9c4 3310 	strd	r3, r3, [r4, #64]	@ 0x40
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8022c22:	6563      	str	r3, [r4, #84]	@ 0x54
  hspi->RxXferSize  = Size;
 8022c24:	87a7      	strh	r7, [r4, #60]	@ 0x3c
  hspi->RxXferCount = Size;
 8022c26:	87e7      	strh	r7, [r4, #62]	@ 0x3e
  hspi->pTxBuffPtr  = (uint8_t *)NULL;
 8022c28:	6323      	str	r3, [r4, #48]	@ 0x30
  hspi->TxXferSize  = 0U;
 8022c2a:	86a3      	strh	r3, [r4, #52]	@ 0x34
  hspi->TxXferCount = 0U;
 8022c2c:	86e3      	strh	r3, [r4, #54]	@ 0x36
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8022c2e:	d103      	bne.n	8022c38 <HAL_SPI_Receive+0x80>
    SPI_1LINE_RX(hspi);
 8022c30:	680b      	ldr	r3, [r1, #0]
 8022c32:	f423 4380 	bic.w	r3, r3, #16384	@ 0x4000
 8022c36:	600b      	str	r3, [r1, #0]
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 8022c38:	680b      	ldr	r3, [r1, #0]
 8022c3a:	0658      	lsls	r0, r3, #25
 8022c3c:	d403      	bmi.n	8022c46 <HAL_SPI_Receive+0x8e>
    __HAL_SPI_ENABLE(hspi);
 8022c3e:	680b      	ldr	r3, [r1, #0]
 8022c40:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8022c44:	600b      	str	r3, [r1, #0]
  if (hspi->Init.DataSize == SPI_DATASIZE_8BIT)
 8022c46:	68e3      	ldr	r3, [r4, #12]
 8022c48:	2b00      	cmp	r3, #0
 8022c4a:	d051      	beq.n	8022cf0 <HAL_SPI_Receive+0x138>
    while (hspi->RxXferCount > 0U)
 8022c4c:	8fe3      	ldrh	r3, [r4, #62]	@ 0x3e
 8022c4e:	b29b      	uxth	r3, r3
 8022c50:	2b00      	cmp	r3, #0
 8022c52:	f000 80c4 	beq.w	8022dde <HAL_SPI_Receive+0x226>
 8022c56:	1c68      	adds	r0, r5, #1
 8022c58:	d138      	bne.n	8022ccc <HAL_SPI_Receive+0x114>
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE))
 8022c5a:	688b      	ldr	r3, [r1, #8]
 8022c5c:	07da      	lsls	r2, r3, #31
 8022c5e:	d53f      	bpl.n	8022ce0 <HAL_SPI_Receive+0x128>
        *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
 8022c60:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
 8022c62:	68ca      	ldr	r2, [r1, #12]
 8022c64:	f823 2b02 	strh.w	r2, [r3], #2
        hspi->RxXferCount--;
 8022c68:	8fe2      	ldrh	r2, [r4, #62]	@ 0x3e
        hspi->pRxBuffPtr += sizeof(uint16_t);
 8022c6a:	63a3      	str	r3, [r4, #56]	@ 0x38
        hspi->RxXferCount--;
 8022c6c:	3a01      	subs	r2, #1
 8022c6e:	b292      	uxth	r2, r2
 8022c70:	87e2      	strh	r2, [r4, #62]	@ 0x3e
    while (hspi->RxXferCount > 0U)
 8022c72:	8fe3      	ldrh	r3, [r4, #62]	@ 0x3e
 8022c74:	b29b      	uxth	r3, r3
 8022c76:	2b00      	cmp	r3, #0
 8022c78:	d1ef      	bne.n	8022c5a <HAL_SPI_Receive+0xa2>
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8022c7a:	6863      	ldr	r3, [r4, #4]
 8022c7c:	f5b3 7f82 	cmp.w	r3, #260	@ 0x104
 8022c80:	d075      	beq.n	8022d6e <HAL_SPI_Receive+0x1b6>
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 8022c82:	688b      	ldr	r3, [r1, #8]
 8022c84:	07d8      	lsls	r0, r3, #31
 8022c86:	d4fc      	bmi.n	8022c82 <HAL_SPI_Receive+0xca>
  if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 8022c88:	6d60      	ldr	r0, [r4, #84]	@ 0x54
 8022c8a:	3800      	subs	r0, #0
 8022c8c:	bf18      	it	ne
 8022c8e:	2001      	movne	r0, #1
error :
 8022c90:	e7ad      	b.n	8022bee <HAL_SPI_Receive+0x36>
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
 8022c92:	6883      	ldr	r3, [r0, #8]
 8022c94:	2b00      	cmp	r3, #0
 8022c96:	d19a      	bne.n	8022bce <HAL_SPI_Receive+0x16>
    return HAL_SPI_TransmitReceive(hspi, pData, pData, Size, Timeout);
 8022c98:	9500      	str	r5, [sp, #0]
    hspi->State = HAL_SPI_STATE_BUSY_RX;
 8022c9a:	2504      	movs	r5, #4
    return HAL_SPI_TransmitReceive(hspi, pData, pData, Size, Timeout);
 8022c9c:	4613      	mov	r3, r2
    hspi->State = HAL_SPI_STATE_BUSY_RX;
 8022c9e:	f880 5051 	strb.w	r5, [r0, #81]	@ 0x51
    return HAL_SPI_TransmitReceive(hspi, pData, pData, Size, Timeout);
 8022ca2:	460a      	mov	r2, r1
 8022ca4:	f7ff fe2a 	bl	80228fc <HAL_SPI_TransmitReceive>
 8022ca8:	e7a7      	b.n	8022bfa <HAL_SPI_Receive+0x42>
  __HAL_LOCK(hspi);
 8022caa:	2002      	movs	r0, #2
}
 8022cac:	b002      	add	sp, #8
 8022cae:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
 8022cb2:	6ba2      	ldr	r2, [r4, #56]	@ 0x38
 8022cb4:	68cb      	ldr	r3, [r1, #12]
 8022cb6:	f822 3b02 	strh.w	r3, [r2], #2
        hspi->RxXferCount--;
 8022cba:	8fe3      	ldrh	r3, [r4, #62]	@ 0x3e
        hspi->pRxBuffPtr += sizeof(uint16_t);
 8022cbc:	63a2      	str	r2, [r4, #56]	@ 0x38
        hspi->RxXferCount--;
 8022cbe:	3b01      	subs	r3, #1
 8022cc0:	b29b      	uxth	r3, r3
 8022cc2:	87e3      	strh	r3, [r4, #62]	@ 0x3e
    while (hspi->RxXferCount > 0U)
 8022cc4:	8fe3      	ldrh	r3, [r4, #62]	@ 0x3e
 8022cc6:	b29b      	uxth	r3, r3
 8022cc8:	2b00      	cmp	r3, #0
 8022cca:	d04c      	beq.n	8022d66 <HAL_SPI_Receive+0x1ae>
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE))
 8022ccc:	688b      	ldr	r3, [r1, #8]
 8022cce:	07db      	lsls	r3, r3, #31
 8022cd0:	d4ef      	bmi.n	8022cb2 <HAL_SPI_Receive+0xfa>
        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 8022cd2:	f7fe fa01 	bl	80210d8 <HAL_GetTick>
 8022cd6:	1b80      	subs	r0, r0, r6
 8022cd8:	42a8      	cmp	r0, r5
 8022cda:	d242      	bcs.n	8022d62 <HAL_SPI_Receive+0x1aa>
    __HAL_SPI_DISABLE(hspi);
 8022cdc:	6821      	ldr	r1, [r4, #0]
 8022cde:	e7f1      	b.n	8022cc4 <HAL_SPI_Receive+0x10c>
        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 8022ce0:	f7fe f9fa 	bl	80210d8 <HAL_GetTick>
    while (hspi->RxXferCount > 0U)
 8022ce4:	8fe3      	ldrh	r3, [r4, #62]	@ 0x3e
    __HAL_SPI_DISABLE(hspi);
 8022ce6:	6821      	ldr	r1, [r4, #0]
    while (hspi->RxXferCount > 0U)
 8022ce8:	b29b      	uxth	r3, r3
 8022cea:	2b00      	cmp	r3, #0
 8022cec:	d1b5      	bne.n	8022c5a <HAL_SPI_Receive+0xa2>
 8022cee:	e7c4      	b.n	8022c7a <HAL_SPI_Receive+0xc2>
    while (hspi->RxXferCount > 0U)
 8022cf0:	8fe3      	ldrh	r3, [r4, #62]	@ 0x3e
 8022cf2:	b29b      	uxth	r3, r3
 8022cf4:	2b00      	cmp	r3, #0
 8022cf6:	d072      	beq.n	8022dde <HAL_SPI_Receive+0x226>
 8022cf8:	1c6a      	adds	r2, r5, #1
 8022cfa:	d12a      	bne.n	8022d52 <HAL_SPI_Receive+0x19a>
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE))
 8022cfc:	688b      	ldr	r3, [r1, #8]
 8022cfe:	07db      	lsls	r3, r3, #31
 8022d00:	d511      	bpl.n	8022d26 <HAL_SPI_Receive+0x16e>
        (* (uint8_t *)(hspi->pRxBuffPtr)) = *(__IO uint8_t *)&hspi->Instance->DR;
 8022d02:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
 8022d04:	7b0a      	ldrb	r2, [r1, #12]
 8022d06:	701a      	strb	r2, [r3, #0]
        hspi->RxXferCount--;
 8022d08:	8fe2      	ldrh	r2, [r4, #62]	@ 0x3e
        hspi->pRxBuffPtr += sizeof(uint8_t);
 8022d0a:	6ba1      	ldr	r1, [r4, #56]	@ 0x38
        hspi->RxXferCount--;
 8022d0c:	3a01      	subs	r2, #1
 8022d0e:	b292      	uxth	r2, r2
 8022d10:	87e2      	strh	r2, [r4, #62]	@ 0x3e
    while (hspi->RxXferCount > 0U)
 8022d12:	8fe3      	ldrh	r3, [r4, #62]	@ 0x3e
        hspi->pRxBuffPtr += sizeof(uint8_t);
 8022d14:	1c4a      	adds	r2, r1, #1
    while (hspi->RxXferCount > 0U)
 8022d16:	b29b      	uxth	r3, r3
    __HAL_SPI_DISABLE(hspi);
 8022d18:	6821      	ldr	r1, [r4, #0]
        hspi->pRxBuffPtr += sizeof(uint8_t);
 8022d1a:	63a2      	str	r2, [r4, #56]	@ 0x38
    while (hspi->RxXferCount > 0U)
 8022d1c:	2b00      	cmp	r3, #0
 8022d1e:	d0ac      	beq.n	8022c7a <HAL_SPI_Receive+0xc2>
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE))
 8022d20:	688b      	ldr	r3, [r1, #8]
 8022d22:	07db      	lsls	r3, r3, #31
 8022d24:	d4ed      	bmi.n	8022d02 <HAL_SPI_Receive+0x14a>
        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 8022d26:	f7fe f9d7 	bl	80210d8 <HAL_GetTick>
    while (hspi->RxXferCount > 0U)
 8022d2a:	8fe3      	ldrh	r3, [r4, #62]	@ 0x3e
    __HAL_SPI_DISABLE(hspi);
 8022d2c:	6821      	ldr	r1, [r4, #0]
    while (hspi->RxXferCount > 0U)
 8022d2e:	b29b      	uxth	r3, r3
 8022d30:	2b00      	cmp	r3, #0
 8022d32:	d1e3      	bne.n	8022cfc <HAL_SPI_Receive+0x144>
 8022d34:	e7a1      	b.n	8022c7a <HAL_SPI_Receive+0xc2>
        (* (uint8_t *)(hspi->pRxBuffPtr)) = *(__IO uint8_t *)&hspi->Instance->DR;
 8022d36:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
 8022d38:	7b0a      	ldrb	r2, [r1, #12]
 8022d3a:	701a      	strb	r2, [r3, #0]
        hspi->RxXferCount--;
 8022d3c:	8fe3      	ldrh	r3, [r4, #62]	@ 0x3e
        hspi->pRxBuffPtr += sizeof(uint8_t);
 8022d3e:	6ba2      	ldr	r2, [r4, #56]	@ 0x38
        hspi->RxXferCount--;
 8022d40:	3b01      	subs	r3, #1
        hspi->pRxBuffPtr += sizeof(uint8_t);
 8022d42:	3201      	adds	r2, #1
        hspi->RxXferCount--;
 8022d44:	b29b      	uxth	r3, r3
        hspi->pRxBuffPtr += sizeof(uint8_t);
 8022d46:	63a2      	str	r2, [r4, #56]	@ 0x38
        hspi->RxXferCount--;
 8022d48:	87e3      	strh	r3, [r4, #62]	@ 0x3e
    while (hspi->RxXferCount > 0U)
 8022d4a:	8fe3      	ldrh	r3, [r4, #62]	@ 0x3e
    __HAL_SPI_DISABLE(hspi);
 8022d4c:	6821      	ldr	r1, [r4, #0]
    while (hspi->RxXferCount > 0U)
 8022d4e:	b29b      	uxth	r3, r3
 8022d50:	b14b      	cbz	r3, 8022d66 <HAL_SPI_Receive+0x1ae>
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE))
 8022d52:	688b      	ldr	r3, [r1, #8]
 8022d54:	07df      	lsls	r7, r3, #31
 8022d56:	d4ee      	bmi.n	8022d36 <HAL_SPI_Receive+0x17e>
        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 8022d58:	f7fe f9be 	bl	80210d8 <HAL_GetTick>
 8022d5c:	1b80      	subs	r0, r0, r6
 8022d5e:	42a8      	cmp	r0, r5
 8022d60:	d3f3      	bcc.n	8022d4a <HAL_SPI_Receive+0x192>
          errorcode = HAL_TIMEOUT;
 8022d62:	2003      	movs	r0, #3
 8022d64:	e743      	b.n	8022bee <HAL_SPI_Receive+0x36>
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8022d66:	6863      	ldr	r3, [r4, #4]
 8022d68:	f5b3 7f82 	cmp.w	r3, #260	@ 0x104
 8022d6c:	d13e      	bne.n	8022dec <HAL_SPI_Receive+0x234>
 8022d6e:	68a2      	ldr	r2, [r4, #8]
 8022d70:	f5b2 4f00 	cmp.w	r2, #32768	@ 0x8000
 8022d74:	d008      	beq.n	8022d88 <HAL_SPI_Receive+0x1d0>
                                               || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 8022d76:	f5b2 6f80 	cmp.w	r2, #1024	@ 0x400
 8022d7a:	d018      	beq.n	8022dae <HAL_SPI_Receive+0x1f6>
 8022d7c:	1c6f      	adds	r7, r5, #1
 8022d7e:	d108      	bne.n	8022d92 <HAL_SPI_Receive+0x1da>
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 8022d80:	688b      	ldr	r3, [r1, #8]
 8022d82:	0618      	lsls	r0, r3, #24
 8022d84:	d4fc      	bmi.n	8022d80 <HAL_SPI_Receive+0x1c8>
 8022d86:	e77f      	b.n	8022c88 <HAL_SPI_Receive+0xd0>
    __HAL_SPI_DISABLE(hspi);
 8022d88:	680b      	ldr	r3, [r1, #0]
 8022d8a:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 8022d8e:	600b      	str	r3, [r1, #0]
    if (hspi->Init.Direction != SPI_DIRECTION_2LINES_RXONLY)
 8022d90:	e7f4      	b.n	8022d7c <HAL_SPI_Receive+0x1c4>
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 8022d92:	688b      	ldr	r3, [r1, #8]
 8022d94:	0619      	lsls	r1, r3, #24
 8022d96:	f57f af77 	bpl.w	8022c88 <HAL_SPI_Receive+0xd0>
      if (((HAL_GetTick() - Tickstart) >= Timeout) || (Timeout == 0U))
 8022d9a:	f7fe f99d 	bl	80210d8 <HAL_GetTick>
 8022d9e:	1b83      	subs	r3, r0, r6
 8022da0:	429d      	cmp	r5, r3
 8022da2:	d931      	bls.n	8022e08 <HAL_SPI_Receive+0x250>
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 8022da4:	6821      	ldr	r1, [r4, #0]
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 8022da6:	688b      	ldr	r3, [r1, #8]
 8022da8:	0619      	lsls	r1, r3, #24
 8022daa:	d4f6      	bmi.n	8022d9a <HAL_SPI_Receive+0x1e2>
 8022dac:	e76c      	b.n	8022c88 <HAL_SPI_Receive+0xd0>
    __HAL_SPI_DISABLE(hspi);
 8022dae:	680b      	ldr	r3, [r1, #0]
 8022db0:	1c6a      	adds	r2, r5, #1
 8022db2:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 8022db6:	600b      	str	r3, [r1, #0]
    if (hspi->Init.Direction != SPI_DIRECTION_2LINES_RXONLY)
 8022db8:	d103      	bne.n	8022dc2 <HAL_SPI_Receive+0x20a>
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 8022dba:	688b      	ldr	r3, [r1, #8]
 8022dbc:	07db      	lsls	r3, r3, #31
 8022dbe:	d4fc      	bmi.n	8022dba <HAL_SPI_Receive+0x202>
 8022dc0:	e762      	b.n	8022c88 <HAL_SPI_Receive+0xd0>
 8022dc2:	688b      	ldr	r3, [r1, #8]
 8022dc4:	07da      	lsls	r2, r3, #31
 8022dc6:	f57f af5f 	bpl.w	8022c88 <HAL_SPI_Receive+0xd0>
      if (((HAL_GetTick() - Tickstart) >= Timeout) || (Timeout == 0U))
 8022dca:	f7fe f985 	bl	80210d8 <HAL_GetTick>
 8022dce:	1b83      	subs	r3, r0, r6
 8022dd0:	429d      	cmp	r5, r3
 8022dd2:	d919      	bls.n	8022e08 <HAL_SPI_Receive+0x250>
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 8022dd4:	6821      	ldr	r1, [r4, #0]
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 8022dd6:	688b      	ldr	r3, [r1, #8]
 8022dd8:	07da      	lsls	r2, r3, #31
 8022dda:	d4f6      	bmi.n	8022dca <HAL_SPI_Receive+0x212>
 8022ddc:	e754      	b.n	8022c88 <HAL_SPI_Receive+0xd0>
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8022dde:	6863      	ldr	r3, [r4, #4]
 8022de0:	f5b3 7f82 	cmp.w	r3, #260	@ 0x104
 8022de4:	d0c4      	beq.n	8022d70 <HAL_SPI_Receive+0x1b8>
 8022de6:	1c6f      	adds	r7, r5, #1
 8022de8:	f43f af4b 	beq.w	8022c82 <HAL_SPI_Receive+0xca>
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 8022dec:	688b      	ldr	r3, [r1, #8]
 8022dee:	07db      	lsls	r3, r3, #31
 8022df0:	f57f af4a 	bpl.w	8022c88 <HAL_SPI_Receive+0xd0>
      if (((HAL_GetTick() - Tickstart) >= Timeout) || (Timeout == 0U))
 8022df4:	f7fe f970 	bl	80210d8 <HAL_GetTick>
 8022df8:	1b83      	subs	r3, r0, r6
 8022dfa:	429d      	cmp	r5, r3
 8022dfc:	d904      	bls.n	8022e08 <HAL_SPI_Receive+0x250>
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 8022dfe:	6821      	ldr	r1, [r4, #0]
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 8022e00:	688b      	ldr	r3, [r1, #8]
 8022e02:	07db      	lsls	r3, r3, #31
 8022e04:	d4f6      	bmi.n	8022df4 <HAL_SPI_Receive+0x23c>
 8022e06:	e73f      	b.n	8022c88 <HAL_SPI_Receive+0xd0>
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8022e08:	e9d4 3100 	ldrd	r3, r1, [r4]
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 8022e0c:	685a      	ldr	r2, [r3, #4]
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8022e0e:	f5b1 7f82 	cmp.w	r1, #260	@ 0x104
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 8022e12:	f022 02e0 	bic.w	r2, r2, #224	@ 0xe0
 8022e16:	605a      	str	r2, [r3, #4]
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8022e18:	d015      	beq.n	8022e46 <HAL_SPI_Receive+0x28e>
        if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8022e1a:	6aa2      	ldr	r2, [r4, #40]	@ 0x28
 8022e1c:	f5b2 5f00 	cmp.w	r2, #8192	@ 0x2000
 8022e20:	d107      	bne.n	8022e32 <HAL_SPI_Receive+0x27a>
          SPI_RESET_CRC(hspi);
 8022e22:	681a      	ldr	r2, [r3, #0]
 8022e24:	f422 5200 	bic.w	r2, r2, #8192	@ 0x2000
 8022e28:	601a      	str	r2, [r3, #0]
 8022e2a:	681a      	ldr	r2, [r3, #0]
 8022e2c:	f442 5200 	orr.w	r2, r2, #8192	@ 0x2000
 8022e30:	601a      	str	r2, [r3, #0]
        hspi->State = HAL_SPI_STATE_READY;
 8022e32:	2301      	movs	r3, #1
 8022e34:	f884 3051 	strb.w	r3, [r4, #81]	@ 0x51
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8022e38:	6d63      	ldr	r3, [r4, #84]	@ 0x54
 8022e3a:	f043 0320 	orr.w	r3, r3, #32
 8022e3e:	6563      	str	r3, [r4, #84]	@ 0x54
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 8022e40:	2320      	movs	r3, #32
 8022e42:	6563      	str	r3, [r4, #84]	@ 0x54
 8022e44:	e720      	b.n	8022c88 <HAL_SPI_Receive+0xd0>
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8022e46:	68a2      	ldr	r2, [r4, #8]
 8022e48:	f5b2 4f00 	cmp.w	r2, #32768	@ 0x8000
 8022e4c:	d002      	beq.n	8022e54 <HAL_SPI_Receive+0x29c>
                                                     || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 8022e4e:	f5b2 6f80 	cmp.w	r2, #1024	@ 0x400
 8022e52:	d1e2      	bne.n	8022e1a <HAL_SPI_Receive+0x262>
          __HAL_SPI_DISABLE(hspi);
 8022e54:	681a      	ldr	r2, [r3, #0]
 8022e56:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
 8022e5a:	601a      	str	r2, [r3, #0]
 8022e5c:	e7dd      	b.n	8022e1a <HAL_SPI_Receive+0x262>
 8022e5e:	bf00      	nop

08022e60 <HAL_SPI_ErrorCallback>:
__weak void HAL_SPI_ErrorCallback(SPI_HandleTypeDef *hspi)
 8022e60:	4770      	bx	lr
 8022e62:	bf00      	nop

08022e64 <HAL_SPI_IRQHandler>:
{
 8022e64:	b530      	push	{r4, r5, lr}
  uint32_t itsource = hspi->Instance->CR2;
 8022e66:	6802      	ldr	r2, [r0, #0]
 8022e68:	6851      	ldr	r1, [r2, #4]
  uint32_t itflag   = hspi->Instance->SR;
 8022e6a:	6893      	ldr	r3, [r2, #8]
  if ((SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) == RESET) &&
 8022e6c:	f013 0f40 	tst.w	r3, #64	@ 0x40
{
 8022e70:	b085      	sub	sp, #20
 8022e72:	4604      	mov	r4, r0
 8022e74:	f3c3 1580 	ubfx	r5, r3, #6, #1
  if ((SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) == RESET) &&
 8022e78:	d116      	bne.n	8022ea8 <HAL_SPI_IRQHandler+0x44>
 8022e7a:	f013 0f01 	tst.w	r3, #1
 8022e7e:	d153      	bne.n	8022f28 <HAL_SPI_IRQHandler+0xc4>
  if ((SPI_CHECK_FLAG(itflag, SPI_FLAG_TXE) != RESET) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_TXE) != RESET))
 8022e80:	0798      	lsls	r0, r3, #30
 8022e82:	d56a      	bpl.n	8022f5a <HAL_SPI_IRQHandler+0xf6>
 8022e84:	0608      	lsls	r0, r1, #24
 8022e86:	d47c      	bmi.n	8022f82 <HAL_SPI_IRQHandler+0x11e>
  if (((SPI_CHECK_FLAG(itflag, SPI_FLAG_MODF) != RESET) || (SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) != RESET) || (SPI_CHECK_FLAG(itflag, SPI_FLAG_FRE) != RESET)) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_ERR) != RESET))
 8022e88:	0698      	lsls	r0, r3, #26
 8022e8a:	d413      	bmi.n	8022eb4 <HAL_SPI_IRQHandler+0x50>
 8022e8c:	05db      	lsls	r3, r3, #23
 8022e8e:	d568      	bpl.n	8022f62 <HAL_SPI_IRQHandler+0xfe>
 8022e90:	068d      	lsls	r5, r1, #26
 8022e92:	d566      	bpl.n	8022f62 <HAL_SPI_IRQHandler+0xfe>
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FRE);
 8022e94:	6d63      	ldr	r3, [r4, #84]	@ 0x54
      __HAL_SPI_CLEAR_FREFLAG(hspi);
 8022e96:	2000      	movs	r0, #0
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FRE);
 8022e98:	f043 0308 	orr.w	r3, r3, #8
 8022e9c:	6563      	str	r3, [r4, #84]	@ 0x54
      __HAL_SPI_CLEAR_FREFLAG(hspi);
 8022e9e:	9003      	str	r0, [sp, #12]
 8022ea0:	6893      	ldr	r3, [r2, #8]
 8022ea2:	9303      	str	r3, [sp, #12]
 8022ea4:	9b03      	ldr	r3, [sp, #12]
 8022ea6:	e018      	b.n	8022eda <HAL_SPI_IRQHandler+0x76>
  if ((SPI_CHECK_FLAG(itflag, SPI_FLAG_TXE) != RESET) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_TXE) != RESET))
 8022ea8:	0798      	lsls	r0, r3, #30
 8022eaa:	d542      	bpl.n	8022f32 <HAL_SPI_IRQHandler+0xce>
 8022eac:	0608      	lsls	r0, r1, #24
 8022eae:	d468      	bmi.n	8022f82 <HAL_SPI_IRQHandler+0x11e>
  if (((SPI_CHECK_FLAG(itflag, SPI_FLAG_MODF) != RESET) || (SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) != RESET) || (SPI_CHECK_FLAG(itflag, SPI_FLAG_FRE) != RESET)) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_ERR) != RESET))
 8022eb0:	0698      	lsls	r0, r3, #26
 8022eb2:	d540      	bpl.n	8022f36 <HAL_SPI_IRQHandler+0xd2>
 8022eb4:	0688      	lsls	r0, r1, #26
 8022eb6:	d554      	bpl.n	8022f62 <HAL_SPI_IRQHandler+0xfe>
    if (SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) != RESET)
 8022eb8:	2d00      	cmp	r5, #0
 8022eba:	d156      	bne.n	8022f6a <HAL_SPI_IRQHandler+0x106>
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_MODF);
 8022ebc:	6d60      	ldr	r0, [r4, #84]	@ 0x54
 8022ebe:	f040 0001 	orr.w	r0, r0, #1
 8022ec2:	6560      	str	r0, [r4, #84]	@ 0x54
      __HAL_SPI_CLEAR_MODFFLAG(hspi);
 8022ec4:	2000      	movs	r0, #0
 8022ec6:	9002      	str	r0, [sp, #8]
 8022ec8:	6890      	ldr	r0, [r2, #8]
 8022eca:	9002      	str	r0, [sp, #8]
 8022ecc:	6810      	ldr	r0, [r2, #0]
 8022ece:	f020 0040 	bic.w	r0, r0, #64	@ 0x40
 8022ed2:	6010      	str	r0, [r2, #0]
 8022ed4:	9802      	ldr	r0, [sp, #8]
    if (SPI_CHECK_FLAG(itflag, SPI_FLAG_FRE) != RESET)
 8022ed6:	05db      	lsls	r3, r3, #23
 8022ed8:	d4dc      	bmi.n	8022e94 <HAL_SPI_IRQHandler+0x30>
    if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 8022eda:	6d63      	ldr	r3, [r4, #84]	@ 0x54
 8022edc:	2b00      	cmp	r3, #0
 8022ede:	d040      	beq.n	8022f62 <HAL_SPI_IRQHandler+0xfe>
      __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE | SPI_IT_TXE | SPI_IT_ERR);
 8022ee0:	6853      	ldr	r3, [r2, #4]
      hspi->State = HAL_SPI_STATE_READY;
 8022ee2:	2001      	movs	r0, #1
      __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE | SPI_IT_TXE | SPI_IT_ERR);
 8022ee4:	f023 03e0 	bic.w	r3, r3, #224	@ 0xe0
      if ((HAL_IS_BIT_SET(itsource, SPI_CR2_TXDMAEN)) || (HAL_IS_BIT_SET(itsource, SPI_CR2_RXDMAEN)))
 8022ee8:	078d      	lsls	r5, r1, #30
      __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE | SPI_IT_TXE | SPI_IT_ERR);
 8022eea:	6053      	str	r3, [r2, #4]
      hspi->State = HAL_SPI_STATE_READY;
 8022eec:	f884 0051 	strb.w	r0, [r4, #81]	@ 0x51
      if ((HAL_IS_BIT_SET(itsource, SPI_CR2_TXDMAEN)) || (HAL_IS_BIT_SET(itsource, SPI_CR2_RXDMAEN)))
 8022ef0:	d059      	beq.n	8022fa6 <HAL_SPI_IRQHandler+0x142>
        CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN));
 8022ef2:	6853      	ldr	r3, [r2, #4]
        if (hspi->hdmarx != NULL)
 8022ef4:	6ce0      	ldr	r0, [r4, #76]	@ 0x4c
        CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN));
 8022ef6:	f023 0303 	bic.w	r3, r3, #3
 8022efa:	6053      	str	r3, [r2, #4]
        if (hspi->hdmarx != NULL)
 8022efc:	b140      	cbz	r0, 8022f10 <HAL_SPI_IRQHandler+0xac>
          hspi->hdmarx->XferAbortCallback = SPI_DMAAbortOnError;
 8022efe:	4b2c      	ldr	r3, [pc, #176]	@ (8022fb0 <HAL_SPI_IRQHandler+0x14c>)
 8022f00:	6503      	str	r3, [r0, #80]	@ 0x50
          if (HAL_OK != HAL_DMA_Abort_IT(hspi->hdmarx))
 8022f02:	f7fe fcf1 	bl	80218e8 <HAL_DMA_Abort_IT>
 8022f06:	b118      	cbz	r0, 8022f10 <HAL_SPI_IRQHandler+0xac>
            SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
 8022f08:	6d63      	ldr	r3, [r4, #84]	@ 0x54
 8022f0a:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8022f0e:	6563      	str	r3, [r4, #84]	@ 0x54
        if (hspi->hdmatx != NULL)
 8022f10:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
 8022f12:	b330      	cbz	r0, 8022f62 <HAL_SPI_IRQHandler+0xfe>
          hspi->hdmatx->XferAbortCallback = SPI_DMAAbortOnError;
 8022f14:	4b26      	ldr	r3, [pc, #152]	@ (8022fb0 <HAL_SPI_IRQHandler+0x14c>)
 8022f16:	6503      	str	r3, [r0, #80]	@ 0x50
          if (HAL_OK != HAL_DMA_Abort_IT(hspi->hdmatx))
 8022f18:	f7fe fce6 	bl	80218e8 <HAL_DMA_Abort_IT>
 8022f1c:	b308      	cbz	r0, 8022f62 <HAL_SPI_IRQHandler+0xfe>
            SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
 8022f1e:	6d63      	ldr	r3, [r4, #84]	@ 0x54
 8022f20:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8022f24:	6563      	str	r3, [r4, #84]	@ 0x54
 8022f26:	e01c      	b.n	8022f62 <HAL_SPI_IRQHandler+0xfe>
      (SPI_CHECK_FLAG(itflag, SPI_FLAG_RXNE) != RESET) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_RXNE) != RESET))
 8022f28:	f011 0f40 	tst.w	r1, #64	@ 0x40
 8022f2c:	d0a8      	beq.n	8022e80 <HAL_SPI_IRQHandler+0x1c>
    hspi->RxISR(hspi);
 8022f2e:	6c03      	ldr	r3, [r0, #64]	@ 0x40
 8022f30:	e029      	b.n	8022f86 <HAL_SPI_IRQHandler+0x122>
  if (((SPI_CHECK_FLAG(itflag, SPI_FLAG_MODF) != RESET) || (SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) != RESET) || (SPI_CHECK_FLAG(itflag, SPI_FLAG_FRE) != RESET)) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_ERR) != RESET))
 8022f32:	069d      	lsls	r5, r3, #26
 8022f34:	d417      	bmi.n	8022f66 <HAL_SPI_IRQHandler+0x102>
 8022f36:	0688      	lsls	r0, r1, #26
 8022f38:	d513      	bpl.n	8022f62 <HAL_SPI_IRQHandler+0xfe>
      if (hspi->State != HAL_SPI_STATE_BUSY_TX)
 8022f3a:	f894 0051 	ldrb.w	r0, [r4, #81]	@ 0x51
 8022f3e:	2803      	cmp	r0, #3
 8022f40:	d017      	beq.n	8022f72 <HAL_SPI_IRQHandler+0x10e>
        SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_OVR);
 8022f42:	6d60      	ldr	r0, [r4, #84]	@ 0x54
 8022f44:	f040 0004 	orr.w	r0, r0, #4
 8022f48:	6560      	str	r0, [r4, #84]	@ 0x54
        __HAL_SPI_CLEAR_OVRFLAG(hspi);
 8022f4a:	2000      	movs	r0, #0
 8022f4c:	9000      	str	r0, [sp, #0]
 8022f4e:	68d0      	ldr	r0, [r2, #12]
 8022f50:	9000      	str	r0, [sp, #0]
 8022f52:	6890      	ldr	r0, [r2, #8]
 8022f54:	9000      	str	r0, [sp, #0]
 8022f56:	9800      	ldr	r0, [sp, #0]
    if (SPI_CHECK_FLAG(itflag, SPI_FLAG_MODF) != RESET)
 8022f58:	e7bd      	b.n	8022ed6 <HAL_SPI_IRQHandler+0x72>
  if (((SPI_CHECK_FLAG(itflag, SPI_FLAG_MODF) != RESET) || (SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) != RESET) || (SPI_CHECK_FLAG(itflag, SPI_FLAG_FRE) != RESET)) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_ERR) != RESET))
 8022f5a:	0698      	lsls	r0, r3, #26
 8022f5c:	d596      	bpl.n	8022e8c <HAL_SPI_IRQHandler+0x28>
 8022f5e:	0688      	lsls	r0, r1, #26
 8022f60:	d4ac      	bmi.n	8022ebc <HAL_SPI_IRQHandler+0x58>
}
 8022f62:	b005      	add	sp, #20
 8022f64:	bd30      	pop	{r4, r5, pc}
  if (((SPI_CHECK_FLAG(itflag, SPI_FLAG_MODF) != RESET) || (SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) != RESET) || (SPI_CHECK_FLAG(itflag, SPI_FLAG_FRE) != RESET)) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_ERR) != RESET))
 8022f66:	068d      	lsls	r5, r1, #26
 8022f68:	d5fb      	bpl.n	8022f62 <HAL_SPI_IRQHandler+0xfe>
      if (hspi->State != HAL_SPI_STATE_BUSY_TX)
 8022f6a:	f894 0051 	ldrb.w	r0, [r4, #81]	@ 0x51
 8022f6e:	2803      	cmp	r0, #3
 8022f70:	d10d      	bne.n	8022f8e <HAL_SPI_IRQHandler+0x12a>
        __HAL_SPI_CLEAR_OVRFLAG(hspi);
 8022f72:	2300      	movs	r3, #0
 8022f74:	9301      	str	r3, [sp, #4]
 8022f76:	68d3      	ldr	r3, [r2, #12]
 8022f78:	9301      	str	r3, [sp, #4]
 8022f7a:	6893      	ldr	r3, [r2, #8]
 8022f7c:	9301      	str	r3, [sp, #4]
 8022f7e:	9b01      	ldr	r3, [sp, #4]
        return;
 8022f80:	e7ef      	b.n	8022f62 <HAL_SPI_IRQHandler+0xfe>
    hspi->TxISR(hspi);
 8022f82:	6c63      	ldr	r3, [r4, #68]	@ 0x44
 8022f84:	4620      	mov	r0, r4
}
 8022f86:	b005      	add	sp, #20
 8022f88:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    hspi->TxISR(hspi);
 8022f8c:	4718      	bx	r3
        SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_OVR);
 8022f8e:	6d60      	ldr	r0, [r4, #84]	@ 0x54
 8022f90:	f040 0004 	orr.w	r0, r0, #4
 8022f94:	6560      	str	r0, [r4, #84]	@ 0x54
        __HAL_SPI_CLEAR_OVRFLAG(hspi);
 8022f96:	2000      	movs	r0, #0
 8022f98:	9000      	str	r0, [sp, #0]
 8022f9a:	68d0      	ldr	r0, [r2, #12]
 8022f9c:	9000      	str	r0, [sp, #0]
 8022f9e:	6890      	ldr	r0, [r2, #8]
 8022fa0:	9000      	str	r0, [sp, #0]
 8022fa2:	9800      	ldr	r0, [sp, #0]
    if (SPI_CHECK_FLAG(itflag, SPI_FLAG_MODF) != RESET)
 8022fa4:	e78a      	b.n	8022ebc <HAL_SPI_IRQHandler+0x58>
        HAL_SPI_ErrorCallback(hspi);
 8022fa6:	4620      	mov	r0, r4
 8022fa8:	f7ff ff5a 	bl	8022e60 <HAL_SPI_ErrorCallback>
 8022fac:	e7d9      	b.n	8022f62 <HAL_SPI_IRQHandler+0xfe>
 8022fae:	bf00      	nop
 8022fb0:	08022fb5 	.word	0x08022fb5

08022fb4 <SPI_DMAAbortOnError>:
{
 8022fb4:	b508      	push	{r3, lr}
  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
 8022fb6:	6b80      	ldr	r0, [r0, #56]	@ 0x38
  hspi->RxXferCount = 0U;
 8022fb8:	2300      	movs	r3, #0
 8022fba:	87c3      	strh	r3, [r0, #62]	@ 0x3e
  hspi->TxXferCount = 0U;
 8022fbc:	86c3      	strh	r3, [r0, #54]	@ 0x36
  HAL_SPI_ErrorCallback(hspi);
 8022fbe:	f7ff ff4f 	bl	8022e60 <HAL_SPI_ErrorCallback>
}
 8022fc2:	bd08      	pop	{r3, pc}

08022fc4 <HAL_TIM_Base_Init>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
{
  /* Check the TIM handle allocation */
  if (htim == NULL)
 8022fc4:	2800      	cmp	r0, #0
 8022fc6:	d073      	beq.n	80230b0 <HAL_TIM_Base_Init+0xec>
{
 8022fc8:	b538      	push	{r3, r4, r5, lr}
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));

  if (htim->State == HAL_TIM_STATE_RESET)
 8022fca:	f890 303d 	ldrb.w	r3, [r0, #61]	@ 0x3d
 8022fce:	4604      	mov	r4, r0
 8022fd0:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
 8022fd4:	2b00      	cmp	r3, #0
 8022fd6:	d066      	beq.n	80230a6 <HAL_TIM_Base_Init+0xe2>

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;

  /* Set the Time Base configuration */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8022fd8:	6822      	ldr	r2, [r4, #0]
{
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8022fda:	4936      	ldr	r1, [pc, #216]	@ (80230b4 <HAL_TIM_Base_Init+0xf0>)
  htim->State = HAL_TIM_STATE_BUSY;
 8022fdc:	2302      	movs	r3, #2
 8022fde:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8022fe2:	428a      	cmp	r2, r1
  tmpcr1 = TIMx->CR1;
 8022fe4:	6813      	ldr	r3, [r2, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8022fe6:	d04a      	beq.n	802307e <HAL_TIM_Base_Init+0xba>
 8022fe8:	f1b2 4f80 	cmp.w	r2, #1073741824	@ 0x40000000
 8022fec:	d030      	beq.n	8023050 <HAL_TIM_Base_Init+0x8c>
 8022fee:	f5a1 417c 	sub.w	r1, r1, #64512	@ 0xfc00
 8022ff2:	428a      	cmp	r2, r1
 8022ff4:	d02c      	beq.n	8023050 <HAL_TIM_Base_Init+0x8c>
 8022ff6:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 8022ffa:	428a      	cmp	r2, r1
 8022ffc:	d028      	beq.n	8023050 <HAL_TIM_Base_Init+0x8c>
 8022ffe:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 8023002:	428a      	cmp	r2, r1
 8023004:	d024      	beq.n	8023050 <HAL_TIM_Base_Init+0x8c>
 8023006:	f501 4178 	add.w	r1, r1, #63488	@ 0xf800
 802300a:	428a      	cmp	r2, r1
 802300c:	d037      	beq.n	802307e <HAL_TIM_Base_Init+0xba>
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
    tmpcr1 |= Structure->CounterMode;
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 802300e:	492a      	ldr	r1, [pc, #168]	@ (80230b8 <HAL_TIM_Base_Init+0xf4>)
 8023010:	428a      	cmp	r2, r1
 8023012:	d021      	beq.n	8023058 <HAL_TIM_Base_Init+0x94>
 8023014:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 8023018:	428a      	cmp	r2, r1
 802301a:	d01d      	beq.n	8023058 <HAL_TIM_Base_Init+0x94>
 802301c:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 8023020:	428a      	cmp	r2, r1
 8023022:	d019      	beq.n	8023058 <HAL_TIM_Base_Init+0x94>
 8023024:	f5a1 3198 	sub.w	r1, r1, #77824	@ 0x13000
 8023028:	428a      	cmp	r2, r1
 802302a:	d015      	beq.n	8023058 <HAL_TIM_Base_Init+0x94>
 802302c:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 8023030:	428a      	cmp	r2, r1
 8023032:	d011      	beq.n	8023058 <HAL_TIM_Base_Init+0x94>
 8023034:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 8023038:	428a      	cmp	r2, r1
 802303a:	d00d      	beq.n	8023058 <HAL_TIM_Base_Init+0x94>
    tmpcr1 &= ~TIM_CR1_CKD;
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 802303c:	69a5      	ldr	r5, [r4, #24]

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;
 802303e:	6861      	ldr	r1, [r4, #4]
  TIMx->ARR = (uint32_t)Structure->Period ;
 8023040:	68e0      	ldr	r0, [r4, #12]
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8023042:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 8023046:	432b      	orrs	r3, r5
  TIMx->CR1 = tmpcr1;
 8023048:	6013      	str	r3, [r2, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 802304a:	62d0      	str	r0, [r2, #44]	@ 0x2c
  TIMx->PSC = Structure->Prescaler;
 802304c:	6291      	str	r1, [r2, #40]	@ 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 802304e:	e010      	b.n	8023072 <HAL_TIM_Base_Init+0xae>
    tmpcr1 |= Structure->CounterMode;
 8023050:	68a1      	ldr	r1, [r4, #8]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8023052:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
    tmpcr1 |= Structure->CounterMode;
 8023056:	430b      	orrs	r3, r1
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8023058:	6920      	ldr	r0, [r4, #16]
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 802305a:	69a1      	ldr	r1, [r4, #24]
    tmpcr1 &= ~TIM_CR1_CKD;
 802305c:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8023060:	4303      	orrs	r3, r0
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8023062:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
  TIMx->ARR = (uint32_t)Structure->Period ;
 8023066:	68e0      	ldr	r0, [r4, #12]
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8023068:	430b      	orrs	r3, r1
  TIMx->PSC = Structure->Prescaler;
 802306a:	6861      	ldr	r1, [r4, #4]
  TIMx->CR1 = tmpcr1;
 802306c:	6013      	str	r3, [r2, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 802306e:	62d0      	str	r0, [r2, #44]	@ 0x2c
  TIMx->PSC = Structure->Prescaler;
 8023070:	6291      	str	r1, [r2, #40]	@ 0x28
    TIMx->RCR = Structure->RepetitionCounter;
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 8023072:	2301      	movs	r3, #1
 8023074:	6153      	str	r3, [r2, #20]
  htim->State = HAL_TIM_STATE_READY;
 8023076:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
  return HAL_OK;
 802307a:	2000      	movs	r0, #0
}
 802307c:	bd38      	pop	{r3, r4, r5, pc}
    tmpcr1 |= Structure->CounterMode;
 802307e:	68a0      	ldr	r0, [r4, #8]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8023080:	6921      	ldr	r1, [r4, #16]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8023082:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
    tmpcr1 |= Structure->CounterMode;
 8023086:	4303      	orrs	r3, r0
    tmpcr1 &= ~TIM_CR1_CKD;
 8023088:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 802308c:	430b      	orrs	r3, r1
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 802308e:	69a1      	ldr	r1, [r4, #24]
 8023090:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 8023094:	430b      	orrs	r3, r1
  TIMx->CR1 = tmpcr1;
 8023096:	6013      	str	r3, [r2, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 8023098:	68e3      	ldr	r3, [r4, #12]
 802309a:	62d3      	str	r3, [r2, #44]	@ 0x2c
  TIMx->PSC = Structure->Prescaler;
 802309c:	6863      	ldr	r3, [r4, #4]
 802309e:	6293      	str	r3, [r2, #40]	@ 0x28
    TIMx->RCR = Structure->RepetitionCounter;
 80230a0:	6963      	ldr	r3, [r4, #20]
 80230a2:	6313      	str	r3, [r2, #48]	@ 0x30
 80230a4:	e7e5      	b.n	8023072 <HAL_TIM_Base_Init+0xae>
    htim->Lock = HAL_UNLOCKED;
 80230a6:	f880 203c 	strb.w	r2, [r0, #60]	@ 0x3c
    HAL_TIM_Base_MspInit(htim);
 80230aa:	f002 ff39 	bl	8025f20 <HAL_TIM_Base_MspInit>
 80230ae:	e793      	b.n	8022fd8 <HAL_TIM_Base_Init+0x14>
    return HAL_ERROR;
 80230b0:	2001      	movs	r0, #1
}
 80230b2:	4770      	bx	lr
 80230b4:	40010000 	.word	0x40010000
 80230b8:	40014000 	.word	0x40014000

080230bc <HAL_TIM_Base_Start_IT>:
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 80230bc:	6803      	ldr	r3, [r0, #0]
 80230be:	68da      	ldr	r2, [r3, #12]
 80230c0:	f042 0201 	orr.w	r2, r2, #1
 80230c4:	60da      	str	r2, [r3, #12]
  tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 80230c6:	689a      	ldr	r2, [r3, #8]
 80230c8:	f002 0207 	and.w	r2, r2, #7
  if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 80230cc:	2a06      	cmp	r2, #6
 80230ce:	d003      	beq.n	80230d8 <HAL_TIM_Base_Start_IT+0x1c>
    __HAL_TIM_ENABLE(htim);
 80230d0:	681a      	ldr	r2, [r3, #0]
 80230d2:	f042 0201 	orr.w	r2, r2, #1
 80230d6:	601a      	str	r2, [r3, #0]
}
 80230d8:	2000      	movs	r0, #0
 80230da:	4770      	bx	lr

080230dc <UART_SetConfig>:
  assert_param(IS_UART_MODE(huart->Init.Mode));

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits
     according to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 80230dc:	6802      	ldr	r2, [r0, #0]
 80230de:	6911      	ldr	r1, [r2, #16]
{
 80230e0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80230e4:	4604      	mov	r4, r0
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 80230e6:	68c0      	ldr	r0, [r0, #12]
     Set the M bits according to huart->Init.WordLength value
     Set PCE and PS bits according to huart->Init.Parity value
     Set TE and RE bits according to huart->Init.Mode value
     Set OVER8 bit according to huart->Init.OverSampling value */

  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 80230e8:	68a3      	ldr	r3, [r4, #8]
 80230ea:	6925      	ldr	r5, [r4, #16]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 80230ec:	f421 5140 	bic.w	r1, r1, #12288	@ 0x3000
 80230f0:	4301      	orrs	r1, r0
 80230f2:	6111      	str	r1, [r2, #16]
  MODIFY_REG(huart->Instance->CR1,
 80230f4:	68d1      	ldr	r1, [r2, #12]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 80230f6:	69e0      	ldr	r0, [r4, #28]
 80230f8:	432b      	orrs	r3, r5
 80230fa:	6965      	ldr	r5, [r4, #20]
  MODIFY_REG(huart->Instance->CR1,
 80230fc:	f421 4116 	bic.w	r1, r1, #38400	@ 0x9600
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 8023100:	432b      	orrs	r3, r5
  MODIFY_REG(huart->Instance->CR1,
 8023102:	f021 010c 	bic.w	r1, r1, #12
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 8023106:	4303      	orrs	r3, r0
  MODIFY_REG(huart->Instance->CR1,
 8023108:	430b      	orrs	r3, r1
 802310a:	60d3      	str	r3, [r2, #12]
             (uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE | USART_CR1_OVER8),
             tmpreg);

  /*-------------------------- USART CR3 Configuration -----------------------*/
  /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart->Init.HwFlowCtl);
 802310c:	6953      	ldr	r3, [r2, #20]
 802310e:	69a1      	ldr	r1, [r4, #24]
 8023110:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 8023114:	430b      	orrs	r3, r1

  /* Check the Over Sampling */
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8023116:	f5b0 4f00 	cmp.w	r0, #32768	@ 0x8000
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart->Init.HwFlowCtl);
 802311a:	6153      	str	r3, [r2, #20]
  {
    /*-------------------------- USART BRR Configuration ---------------------*/
#if defined(USART6)
    if ((huart->Instance == USART1) || (huart->Instance == USART6))
 802311c:	4b9d      	ldr	r3, [pc, #628]	@ (8023394 <UART_SetConfig+0x2b8>)
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 802311e:	f000 809c 	beq.w	802325a <UART_SetConfig+0x17e>
  }
  else
  {
    /*-------------------------- USART BRR Configuration ---------------------*/
#if defined(USART6)
    if ((huart->Instance == USART1) || (huart->Instance == USART6))
 8023122:	429a      	cmp	r2, r3
 8023124:	d05a      	beq.n	80231dc <UART_SetConfig+0x100>
 8023126:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 802312a:	429a      	cmp	r2, r3
 802312c:	d056      	beq.n	80231dc <UART_SetConfig+0x100>
      huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
    }
#endif /* USART6 */
    else
    {
      huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
 802312e:	f7ff f86d 	bl	802220c <HAL_RCC_GetPCLK1Freq>
 8023132:	6863      	ldr	r3, [r4, #4]
 8023134:	f8df 8260 	ldr.w	r8, [pc, #608]	@ 8023398 <UART_SetConfig+0x2bc>
 8023138:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 802313c:	009b      	lsls	r3, r3, #2
 802313e:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8023142:	fbb0 f7f3 	udiv	r7, r0, r3
 8023146:	f7ff f861 	bl	802220c <HAL_RCC_GetPCLK1Freq>
 802314a:	fba8 3707 	umull	r3, r7, r8, r7
 802314e:	6863      	ldr	r3, [r4, #4]
 8023150:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8023154:	009b      	lsls	r3, r3, #2
 8023156:	eb00 0680 	add.w	r6, r0, r0, lsl #2
 802315a:	fbb6 f6f3 	udiv	r6, r6, r3
 802315e:	f7ff f855 	bl	802220c <HAL_RCC_GetPCLK1Freq>
 8023162:	6863      	ldr	r3, [r4, #4]
 8023164:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8023168:	009b      	lsls	r3, r3, #2
 802316a:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 802316e:	fbb0 f0f3 	udiv	r0, r0, r3
 8023172:	fba8 3000 	umull	r3, r0, r8, r0
 8023176:	0940      	lsrs	r0, r0, #5
 8023178:	f04f 0964 	mov.w	r9, #100	@ 0x64
 802317c:	fb09 6610 	mls	r6, r9, r0, r6
 8023180:	0136      	lsls	r6, r6, #4
 8023182:	f7ff f843 	bl	802220c <HAL_RCC_GetPCLK1Freq>
 8023186:	3632      	adds	r6, #50	@ 0x32
 8023188:	fba8 3606 	umull	r3, r6, r8, r6
 802318c:	6862      	ldr	r2, [r4, #4]
 802318e:	097f      	lsrs	r7, r7, #5
 8023190:	0976      	lsrs	r6, r6, #5
 8023192:	eb00 0380 	add.w	r3, r0, r0, lsl #2
 8023196:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 802319a:	0092      	lsls	r2, r2, #2
 802319c:	013f      	lsls	r7, r7, #4
 802319e:	f006 06f0 	and.w	r6, r6, #240	@ 0xf0
 80231a2:	fbb3 f5f2 	udiv	r5, r3, r2
 80231a6:	f7ff f831 	bl	802220c <HAL_RCC_GetPCLK1Freq>
 80231aa:	e9d4 2300 	ldrd	r2, r3, [r4]
 80231ae:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 80231b2:	009b      	lsls	r3, r3, #2
 80231b4:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 80231b8:	fbb0 f0f3 	udiv	r0, r0, r3
 80231bc:	fba8 3000 	umull	r3, r0, r8, r0
 80231c0:	0940      	lsrs	r0, r0, #5
 80231c2:	fb09 5310 	mls	r3, r9, r0, r5
 80231c6:	011b      	lsls	r3, r3, #4
 80231c8:	3332      	adds	r3, #50	@ 0x32
 80231ca:	fba8 8303 	umull	r8, r3, r8, r3
 80231ce:	f3c3 1343 	ubfx	r3, r3, #5, #4
 80231d2:	4333      	orrs	r3, r6
 80231d4:	443b      	add	r3, r7
 80231d6:	6093      	str	r3, [r2, #8]
    }
  }
}
 80231d8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
 80231dc:	f7ff f826 	bl	802222c <HAL_RCC_GetPCLK2Freq>
 80231e0:	6863      	ldr	r3, [r4, #4]
 80231e2:	f8df 81b4 	ldr.w	r8, [pc, #436]	@ 8023398 <UART_SetConfig+0x2bc>
 80231e6:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 80231ea:	009b      	lsls	r3, r3, #2
 80231ec:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 80231f0:	fbb0 f7f3 	udiv	r7, r0, r3
 80231f4:	f7ff f81a 	bl	802222c <HAL_RCC_GetPCLK2Freq>
 80231f8:	fba8 3707 	umull	r3, r7, r8, r7
 80231fc:	6863      	ldr	r3, [r4, #4]
 80231fe:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8023202:	009b      	lsls	r3, r3, #2
 8023204:	eb00 0680 	add.w	r6, r0, r0, lsl #2
 8023208:	fbb6 f6f3 	udiv	r6, r6, r3
 802320c:	f7ff f80e 	bl	802222c <HAL_RCC_GetPCLK2Freq>
 8023210:	6863      	ldr	r3, [r4, #4]
 8023212:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8023216:	009b      	lsls	r3, r3, #2
 8023218:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 802321c:	fbb0 f0f3 	udiv	r0, r0, r3
 8023220:	fba8 3000 	umull	r3, r0, r8, r0
 8023224:	0940      	lsrs	r0, r0, #5
 8023226:	f04f 0964 	mov.w	r9, #100	@ 0x64
 802322a:	fb09 6610 	mls	r6, r9, r0, r6
 802322e:	0136      	lsls	r6, r6, #4
 8023230:	f7fe fffc 	bl	802222c <HAL_RCC_GetPCLK2Freq>
 8023234:	3632      	adds	r6, #50	@ 0x32
 8023236:	fba8 3606 	umull	r3, r6, r8, r6
 802323a:	6863      	ldr	r3, [r4, #4]
 802323c:	097f      	lsrs	r7, r7, #5
 802323e:	0976      	lsrs	r6, r6, #5
 8023240:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8023244:	009b      	lsls	r3, r3, #2
 8023246:	013f      	lsls	r7, r7, #4
 8023248:	f006 06f0 	and.w	r6, r6, #240	@ 0xf0
 802324c:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8023250:	fbb0 f5f3 	udiv	r5, r0, r3
 8023254:	f7fe ffea 	bl	802222c <HAL_RCC_GetPCLK2Freq>
 8023258:	e7a7      	b.n	80231aa <UART_SetConfig+0xce>
    if ((huart->Instance == USART1) || (huart->Instance == USART6))
 802325a:	429a      	cmp	r2, r3
 802325c:	d05a      	beq.n	8023314 <UART_SetConfig+0x238>
 802325e:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8023262:	429a      	cmp	r2, r3
 8023264:	d056      	beq.n	8023314 <UART_SetConfig+0x238>
      huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
 8023266:	f7fe ffd1 	bl	802220c <HAL_RCC_GetPCLK1Freq>
 802326a:	6863      	ldr	r3, [r4, #4]
 802326c:	f8df 8128 	ldr.w	r8, [pc, #296]	@ 8023398 <UART_SetConfig+0x2bc>
 8023270:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8023274:	005b      	lsls	r3, r3, #1
 8023276:	eb00 0780 	add.w	r7, r0, r0, lsl #2
 802327a:	fbb7 f7f3 	udiv	r7, r7, r3
 802327e:	f7fe ffc5 	bl	802220c <HAL_RCC_GetPCLK1Freq>
 8023282:	fba8 3707 	umull	r3, r7, r8, r7
 8023286:	6863      	ldr	r3, [r4, #4]
 8023288:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 802328c:	005b      	lsls	r3, r3, #1
 802328e:	eb00 0680 	add.w	r6, r0, r0, lsl #2
 8023292:	fbb6 f6f3 	udiv	r6, r6, r3
 8023296:	f7fe ffb9 	bl	802220c <HAL_RCC_GetPCLK1Freq>
 802329a:	6863      	ldr	r3, [r4, #4]
 802329c:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 80232a0:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 80232a4:	005b      	lsls	r3, r3, #1
 80232a6:	fbb0 f3f3 	udiv	r3, r0, r3
 80232aa:	fba8 2303 	umull	r2, r3, r8, r3
 80232ae:	095b      	lsrs	r3, r3, #5
 80232b0:	f04f 0964 	mov.w	r9, #100	@ 0x64
 80232b4:	fb09 6613 	mls	r6, r9, r3, r6
 80232b8:	00f6      	lsls	r6, r6, #3
 80232ba:	f7fe ffa7 	bl	802220c <HAL_RCC_GetPCLK1Freq>
 80232be:	3632      	adds	r6, #50	@ 0x32
 80232c0:	fba8 3606 	umull	r3, r6, r8, r6
 80232c4:	6862      	ldr	r2, [r4, #4]
 80232c6:	097f      	lsrs	r7, r7, #5
 80232c8:	0936      	lsrs	r6, r6, #4
 80232ca:	eb00 0380 	add.w	r3, r0, r0, lsl #2
 80232ce:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80232d2:	0052      	lsls	r2, r2, #1
 80232d4:	013f      	lsls	r7, r7, #4
 80232d6:	f406 76f8 	and.w	r6, r6, #496	@ 0x1f0
 80232da:	fbb3 f5f2 	udiv	r5, r3, r2
 80232de:	f7fe ff95 	bl	802220c <HAL_RCC_GetPCLK1Freq>
 80232e2:	e9d4 2300 	ldrd	r2, r3, [r4]
 80232e6:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 80232ea:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 80232ee:	005b      	lsls	r3, r3, #1
 80232f0:	fbb0 f3f3 	udiv	r3, r0, r3
 80232f4:	fba8 1303 	umull	r1, r3, r8, r3
 80232f8:	095b      	lsrs	r3, r3, #5
 80232fa:	fb09 5313 	mls	r3, r9, r3, r5
 80232fe:	00db      	lsls	r3, r3, #3
 8023300:	3332      	adds	r3, #50	@ 0x32
 8023302:	fba8 8303 	umull	r8, r3, r8, r3
 8023306:	f3c3 1342 	ubfx	r3, r3, #5, #3
 802330a:	443b      	add	r3, r7
 802330c:	4433      	add	r3, r6
 802330e:	6093      	str	r3, [r2, #8]
}
 8023310:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
 8023314:	f7fe ff8a 	bl	802222c <HAL_RCC_GetPCLK2Freq>
 8023318:	6863      	ldr	r3, [r4, #4]
 802331a:	f8df 807c 	ldr.w	r8, [pc, #124]	@ 8023398 <UART_SetConfig+0x2bc>
 802331e:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8023322:	005b      	lsls	r3, r3, #1
 8023324:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8023328:	fbb0 f7f3 	udiv	r7, r0, r3
 802332c:	f7fe ff7e 	bl	802222c <HAL_RCC_GetPCLK2Freq>
 8023330:	fba8 3707 	umull	r3, r7, r8, r7
 8023334:	6863      	ldr	r3, [r4, #4]
 8023336:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 802333a:	005b      	lsls	r3, r3, #1
 802333c:	eb00 0680 	add.w	r6, r0, r0, lsl #2
 8023340:	fbb6 f6f3 	udiv	r6, r6, r3
 8023344:	f7fe ff72 	bl	802222c <HAL_RCC_GetPCLK2Freq>
 8023348:	6863      	ldr	r3, [r4, #4]
 802334a:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 802334e:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8023352:	005b      	lsls	r3, r3, #1
 8023354:	fbb0 f3f3 	udiv	r3, r0, r3
 8023358:	fba8 2303 	umull	r2, r3, r8, r3
 802335c:	095b      	lsrs	r3, r3, #5
 802335e:	f04f 0964 	mov.w	r9, #100	@ 0x64
 8023362:	fb09 6613 	mls	r6, r9, r3, r6
 8023366:	00f6      	lsls	r6, r6, #3
 8023368:	f7fe ff60 	bl	802222c <HAL_RCC_GetPCLK2Freq>
 802336c:	3632      	adds	r6, #50	@ 0x32
 802336e:	fba8 3606 	umull	r3, r6, r8, r6
 8023372:	6863      	ldr	r3, [r4, #4]
 8023374:	097f      	lsrs	r7, r7, #5
 8023376:	0936      	lsrs	r6, r6, #4
 8023378:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 802337c:	005b      	lsls	r3, r3, #1
 802337e:	013f      	lsls	r7, r7, #4
 8023380:	f406 76f8 	and.w	r6, r6, #496	@ 0x1f0
 8023384:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8023388:	fbb0 f5f3 	udiv	r5, r0, r3
 802338c:	f7fe ff4e 	bl	802222c <HAL_RCC_GetPCLK2Freq>
 8023390:	e7a7      	b.n	80232e2 <UART_SetConfig+0x206>
 8023392:	bf00      	nop
 8023394:	40011000 	.word	0x40011000
 8023398:	51eb851f 	.word	0x51eb851f

0802339c <HAL_UART_Init>:
  if (huart == NULL)
 802339c:	b360      	cbz	r0, 80233f8 <HAL_UART_Init+0x5c>
{
 802339e:	b538      	push	{r3, r4, r5, lr}
  if (huart->gState == HAL_UART_STATE_RESET)
 80233a0:	f890 3039 	ldrb.w	r3, [r0, #57]	@ 0x39
 80233a4:	4604      	mov	r4, r0
 80233a6:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
 80233aa:	b303      	cbz	r3, 80233ee <HAL_UART_Init+0x52>
  __HAL_UART_DISABLE(huart);
 80233ac:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 80233ae:	2324      	movs	r3, #36	@ 0x24
 80233b0:	f884 3039 	strb.w	r3, [r4, #57]	@ 0x39
  __HAL_UART_DISABLE(huart);
 80233b4:	68d3      	ldr	r3, [r2, #12]
 80233b6:	f423 5300 	bic.w	r3, r3, #8192	@ 0x2000
  UART_SetConfig(huart);
 80233ba:	4620      	mov	r0, r4
  __HAL_UART_DISABLE(huart);
 80233bc:	60d3      	str	r3, [r2, #12]
  UART_SetConfig(huart);
 80233be:	f7ff fe8d 	bl	80230dc <UART_SetConfig>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 80233c2:	6823      	ldr	r3, [r4, #0]
 80233c4:	691a      	ldr	r2, [r3, #16]
 80233c6:	f422 4290 	bic.w	r2, r2, #18432	@ 0x4800
 80233ca:	611a      	str	r2, [r3, #16]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 80233cc:	695a      	ldr	r2, [r3, #20]
 80233ce:	f022 022a 	bic.w	r2, r2, #42	@ 0x2a
 80233d2:	615a      	str	r2, [r3, #20]
  __HAL_UART_ENABLE(huart);
 80233d4:	68da      	ldr	r2, [r3, #12]
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 80233d6:	2500      	movs	r5, #0
  huart->gState = HAL_UART_STATE_READY;
 80233d8:	2120      	movs	r1, #32
  __HAL_UART_ENABLE(huart);
 80233da:	f442 5200 	orr.w	r2, r2, #8192	@ 0x2000
 80233de:	60da      	str	r2, [r3, #12]
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 80233e0:	63e5      	str	r5, [r4, #60]	@ 0x3c
  huart->gState = HAL_UART_STATE_READY;
 80233e2:	f884 1039 	strb.w	r1, [r4, #57]	@ 0x39
  huart->RxState = HAL_UART_STATE_READY;
 80233e6:	f884 103a 	strb.w	r1, [r4, #58]	@ 0x3a
  return HAL_OK;
 80233ea:	4628      	mov	r0, r5
}
 80233ec:	bd38      	pop	{r3, r4, r5, pc}
    huart->Lock = HAL_UNLOCKED;
 80233ee:	f880 2038 	strb.w	r2, [r0, #56]	@ 0x38
    HAL_UART_MspInit(huart);
 80233f2:	f005 f831 	bl	8028458 <HAL_UART_MspInit>
 80233f6:	e7d9      	b.n	80233ac <HAL_UART_Init+0x10>
    return HAL_ERROR;
 80233f8:	2001      	movs	r0, #1
}
 80233fa:	4770      	bx	lr

080233fc <HAL_UART_Transmit_DMA>:
{
 80233fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80233fe:	4604      	mov	r4, r0
  if (huart->gState == HAL_UART_STATE_READY)
 8023400:	f890 0039 	ldrb.w	r0, [r0, #57]	@ 0x39
 8023404:	2820      	cmp	r0, #32
 8023406:	d12d      	bne.n	8023464 <HAL_UART_Transmit_DMA+0x68>
    if ((pData == NULL) || (Size == 0U))
 8023408:	b351      	cbz	r1, 8023460 <HAL_UART_Transmit_DMA+0x64>
 802340a:	b34a      	cbz	r2, 8023460 <HAL_UART_Transmit_DMA+0x64>
    __HAL_LOCK(huart);
 802340c:	f894 0038 	ldrb.w	r0, [r4, #56]	@ 0x38
 8023410:	2801      	cmp	r0, #1
 8023412:	d027      	beq.n	8023464 <HAL_UART_Transmit_DMA+0x68>
 8023414:	2001      	movs	r0, #1
    huart->TxXferCount = Size;
 8023416:	84e2      	strh	r2, [r4, #38]	@ 0x26
    __HAL_LOCK(huart);
 8023418:	f884 0038 	strb.w	r0, [r4, #56]	@ 0x38
    huart->TxXferSize = Size;
 802341c:	84a2      	strh	r2, [r4, #36]	@ 0x24
    huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
 802341e:	6b20      	ldr	r0, [r4, #48]	@ 0x30
 8023420:	f8df c04c 	ldr.w	ip, [pc, #76]	@ 8023470 <HAL_UART_Transmit_DMA+0x74>
    huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
 8023424:	4f10      	ldr	r7, [pc, #64]	@ (8023468 <HAL_UART_Transmit_DMA+0x6c>)
    huart->hdmatx->XferErrorCallback = UART_DMAError;
 8023426:	4e11      	ldr	r6, [pc, #68]	@ (802346c <HAL_UART_Transmit_DMA+0x70>)
    huart->pTxBuffPtr = pData;
 8023428:	6221      	str	r1, [r4, #32]
    HAL_DMA_Start_IT(huart->hdmatx, *(uint32_t *)tmp, (uint32_t)&huart->Instance->DR, Size);
 802342a:	4613      	mov	r3, r2
 802342c:	6822      	ldr	r2, [r4, #0]
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 802342e:	2500      	movs	r5, #0
    huart->gState = HAL_UART_STATE_BUSY_TX;
 8023430:	f04f 0e21 	mov.w	lr, #33	@ 0x21
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8023434:	63e5      	str	r5, [r4, #60]	@ 0x3c
    HAL_DMA_Start_IT(huart->hdmatx, *(uint32_t *)tmp, (uint32_t)&huart->Instance->DR, Size);
 8023436:	3204      	adds	r2, #4
    huart->gState = HAL_UART_STATE_BUSY_TX;
 8023438:	f884 e039 	strb.w	lr, [r4, #57]	@ 0x39
    huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
 802343c:	e9c0 c70f 	strd	ip, r7, [r0, #60]	@ 0x3c
    huart->hdmatx->XferAbortCallback = NULL;
 8023440:	e9c0 6513 	strd	r6, r5, [r0, #76]	@ 0x4c
    HAL_DMA_Start_IT(huart->hdmatx, *(uint32_t *)tmp, (uint32_t)&huart->Instance->DR, Size);
 8023444:	f7fe fa10 	bl	8021868 <HAL_DMA_Start_IT>
    __HAL_UART_CLEAR_FLAG(huart, UART_FLAG_TC);
 8023448:	6823      	ldr	r3, [r4, #0]
 802344a:	f06f 0240 	mvn.w	r2, #64	@ 0x40
 802344e:	601a      	str	r2, [r3, #0]
    __HAL_UNLOCK(huart);
 8023450:	f884 5038 	strb.w	r5, [r4, #56]	@ 0x38
    SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 8023454:	695a      	ldr	r2, [r3, #20]
 8023456:	f042 0280 	orr.w	r2, r2, #128	@ 0x80
    return HAL_OK;
 802345a:	4628      	mov	r0, r5
    SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 802345c:	615a      	str	r2, [r3, #20]
}
 802345e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      return HAL_ERROR;
 8023460:	2001      	movs	r0, #1
}
 8023462:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    __HAL_LOCK(huart);
 8023464:	2002      	movs	r0, #2
}
 8023466:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8023468:	080234a5 	.word	0x080234a5
 802346c:	08023525 	.word	0x08023525
 8023470:	08023475 	.word	0x08023475

08023474 <UART_DMATransmitCplt>:
{
 8023474:	b508      	push	{r3, lr}
  if ((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
 8023476:	6803      	ldr	r3, [r0, #0]
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8023478:	6b80      	ldr	r0, [r0, #56]	@ 0x38
  if ((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
 802347a:	681b      	ldr	r3, [r3, #0]
 802347c:	f413 7380 	ands.w	r3, r3, #256	@ 0x100
 8023480:	d10a      	bne.n	8023498 <UART_DMATransmitCplt+0x24>
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 8023482:	6802      	ldr	r2, [r0, #0]
    huart->TxXferCount = 0x00U;
 8023484:	84c3      	strh	r3, [r0, #38]	@ 0x26
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 8023486:	6953      	ldr	r3, [r2, #20]
 8023488:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 802348c:	6153      	str	r3, [r2, #20]
    SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 802348e:	68d3      	ldr	r3, [r2, #12]
 8023490:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8023494:	60d3      	str	r3, [r2, #12]
}
 8023496:	bd08      	pop	{r3, pc}
    HAL_UART_TxCpltCallback(huart);
 8023498:	f004 fee2 	bl	8028260 <HAL_UART_TxCpltCallback>
}
 802349c:	bd08      	pop	{r3, pc}
 802349e:	bf00      	nop

080234a0 <HAL_UART_TxHalfCpltCallback>:
__weak void HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart)
 80234a0:	4770      	bx	lr
 80234a2:	bf00      	nop

080234a4 <UART_DMATxHalfCplt>:
{
 80234a4:	b508      	push	{r3, lr}
  HAL_UART_TxHalfCpltCallback(huart);
 80234a6:	6b80      	ldr	r0, [r0, #56]	@ 0x38
 80234a8:	f7ff fffa 	bl	80234a0 <HAL_UART_TxHalfCpltCallback>
}
 80234ac:	bd08      	pop	{r3, pc}
 80234ae:	bf00      	nop

080234b0 <HAL_UART_RxCpltCallback>:
__weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
 80234b0:	4770      	bx	lr
 80234b2:	bf00      	nop

080234b4 <UART_Receive_IT.part.0.isra.0>:
static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
 80234b4:	b510      	push	{r4, lr}
    if (huart->Init.WordLength == UART_WORDLENGTH_9B)
 80234b6:	6884      	ldr	r4, [r0, #8]
      if (huart->Init.Parity == UART_PARITY_NONE)
 80234b8:	6901      	ldr	r1, [r0, #16]
        *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
 80234ba:	6802      	ldr	r2, [r0, #0]
      tmp = (uint16_t *) huart->pRxBuffPtr;
 80234bc:	6a83      	ldr	r3, [r0, #40]	@ 0x28
    if (huart->Init.WordLength == UART_WORDLENGTH_9B)
 80234be:	f5b4 5f80 	cmp.w	r4, #4096	@ 0x1000
 80234c2:	d020      	beq.n	8023506 <UART_Receive_IT.part.0.isra.0+0x52>
        *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
 80234c4:	1c5c      	adds	r4, r3, #1
 80234c6:	6852      	ldr	r2, [r2, #4]
 80234c8:	6284      	str	r4, [r0, #40]	@ 0x28
      if (huart->Init.Parity == UART_PARITY_NONE)
 80234ca:	b9c9      	cbnz	r1, 8023500 <UART_Receive_IT.part.0.isra.0+0x4c>
        *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
 80234cc:	701a      	strb	r2, [r3, #0]
    if (--huart->RxXferCount == 0U)
 80234ce:	8dc3      	ldrh	r3, [r0, #46]	@ 0x2e
 80234d0:	3b01      	subs	r3, #1
 80234d2:	b29b      	uxth	r3, r3
 80234d4:	85c3      	strh	r3, [r0, #46]	@ 0x2e
 80234d6:	b103      	cbz	r3, 80234da <UART_Receive_IT.part.0.isra.0+0x26>
}
 80234d8:	bd10      	pop	{r4, pc}
      __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
 80234da:	6803      	ldr	r3, [r0, #0]
 80234dc:	68da      	ldr	r2, [r3, #12]
 80234de:	f022 0220 	bic.w	r2, r2, #32
 80234e2:	60da      	str	r2, [r3, #12]
      __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
 80234e4:	68da      	ldr	r2, [r3, #12]
 80234e6:	f422 7280 	bic.w	r2, r2, #256	@ 0x100
 80234ea:	60da      	str	r2, [r3, #12]
      __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
 80234ec:	695a      	ldr	r2, [r3, #20]
      huart->RxState = HAL_UART_STATE_READY;
 80234ee:	2120      	movs	r1, #32
      __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
 80234f0:	f022 0201 	bic.w	r2, r2, #1
 80234f4:	615a      	str	r2, [r3, #20]
      huart->RxState = HAL_UART_STATE_READY;
 80234f6:	f880 103a 	strb.w	r1, [r0, #58]	@ 0x3a
      HAL_UART_RxCpltCallback(huart);
 80234fa:	f7ff ffd9 	bl	80234b0 <HAL_UART_RxCpltCallback>
}
 80234fe:	bd10      	pop	{r4, pc}
        *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
 8023500:	f002 027f 	and.w	r2, r2, #127	@ 0x7f
 8023504:	e7e2      	b.n	80234cc <UART_Receive_IT.part.0.isra.0+0x18>
        *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
 8023506:	6852      	ldr	r2, [r2, #4]
      if (huart->Init.Parity == UART_PARITY_NONE)
 8023508:	b929      	cbnz	r1, 8023516 <UART_Receive_IT.part.0.isra.0+0x62>
        *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
 802350a:	f3c2 0208 	ubfx	r2, r2, #0, #9
 802350e:	f823 2b02 	strh.w	r2, [r3], #2
        huart->pRxBuffPtr += 2U;
 8023512:	6283      	str	r3, [r0, #40]	@ 0x28
 8023514:	e7db      	b.n	80234ce <UART_Receive_IT.part.0.isra.0+0x1a>
        *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x00FF);
 8023516:	b2d2      	uxtb	r2, r2
 8023518:	f823 2b01 	strh.w	r2, [r3], #1
        huart->pRxBuffPtr += 1U;
 802351c:	6283      	str	r3, [r0, #40]	@ 0x28
 802351e:	e7d6      	b.n	80234ce <UART_Receive_IT.part.0.isra.0+0x1a>

08023520 <HAL_UART_ErrorCallback>:
__weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
 8023520:	4770      	bx	lr
 8023522:	bf00      	nop

08023524 <UART_DMAError>:
{
 8023524:	b508      	push	{r3, lr}
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8023526:	6b80      	ldr	r0, [r0, #56]	@ 0x38
  dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
 8023528:	6803      	ldr	r3, [r0, #0]
 802352a:	6959      	ldr	r1, [r3, #20]
  if ((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
 802352c:	f890 2039 	ldrb.w	r2, [r0, #57]	@ 0x39
 8023530:	2a21      	cmp	r2, #33	@ 0x21
 8023532:	d00b      	beq.n	802354c <UART_DMAError+0x28>
  dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
 8023534:	6959      	ldr	r1, [r3, #20]
  if ((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
 8023536:	f890 203a 	ldrb.w	r2, [r0, #58]	@ 0x3a
 802353a:	2a22      	cmp	r2, #34	@ 0x22
 802353c:	d016      	beq.n	802356c <UART_DMAError+0x48>
  huart->ErrorCode |= HAL_UART_ERROR_DMA;
 802353e:	6bc3      	ldr	r3, [r0, #60]	@ 0x3c
 8023540:	f043 0310 	orr.w	r3, r3, #16
 8023544:	63c3      	str	r3, [r0, #60]	@ 0x3c
  HAL_UART_ErrorCallback(huart);
 8023546:	f7ff ffeb 	bl	8023520 <HAL_UART_ErrorCallback>
}
 802354a:	bd08      	pop	{r3, pc}
  if ((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
 802354c:	0609      	lsls	r1, r1, #24
 802354e:	d5f1      	bpl.n	8023534 <UART_DMAError+0x10>
    huart->TxXferCount = 0x00U;
 8023550:	2200      	movs	r2, #0
 8023552:	84c2      	strh	r2, [r0, #38]	@ 0x26
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
 8023554:	68da      	ldr	r2, [r3, #12]
  huart->gState = HAL_UART_STATE_READY;
 8023556:	2120      	movs	r1, #32
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
 8023558:	f022 02c0 	bic.w	r2, r2, #192	@ 0xc0
 802355c:	60da      	str	r2, [r3, #12]
  huart->gState = HAL_UART_STATE_READY;
 802355e:	f880 1039 	strb.w	r1, [r0, #57]	@ 0x39
  dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
 8023562:	6959      	ldr	r1, [r3, #20]
  if ((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
 8023564:	f890 203a 	ldrb.w	r2, [r0, #58]	@ 0x3a
 8023568:	2a22      	cmp	r2, #34	@ 0x22
 802356a:	d1e8      	bne.n	802353e <UART_DMAError+0x1a>
 802356c:	064a      	lsls	r2, r1, #25
 802356e:	d5e6      	bpl.n	802353e <UART_DMAError+0x1a>
    huart->RxXferCount = 0x00U;
 8023570:	2200      	movs	r2, #0
 8023572:	85c2      	strh	r2, [r0, #46]	@ 0x2e
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 8023574:	68da      	ldr	r2, [r3, #12]
 8023576:	f422 7290 	bic.w	r2, r2, #288	@ 0x120
 802357a:	60da      	str	r2, [r3, #12]
  CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 802357c:	695a      	ldr	r2, [r3, #20]
  huart->RxState = HAL_UART_STATE_READY;
 802357e:	2120      	movs	r1, #32
  CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8023580:	f022 0201 	bic.w	r2, r2, #1
 8023584:	615a      	str	r2, [r3, #20]
  huart->RxState = HAL_UART_STATE_READY;
 8023586:	f880 103a 	strb.w	r1, [r0, #58]	@ 0x3a
}
 802358a:	e7d8      	b.n	802353e <UART_DMAError+0x1a>

0802358c <HAL_UART_IRQHandler>:
  uint32_t isrflags   = READ_REG(huart->Instance->SR);
 802358c:	6803      	ldr	r3, [r0, #0]
 802358e:	681a      	ldr	r2, [r3, #0]
{
 8023590:	b570      	push	{r4, r5, r6, lr}
  if (errorflags == RESET)
 8023592:	0716      	lsls	r6, r2, #28
  uint32_t cr1its     = READ_REG(huart->Instance->CR1);
 8023594:	68dd      	ldr	r5, [r3, #12]
  uint32_t cr3its     = READ_REG(huart->Instance->CR3);
 8023596:	6959      	ldr	r1, [r3, #20]
{
 8023598:	4604      	mov	r4, r0
  if (errorflags == RESET)
 802359a:	d10c      	bne.n	80235b6 <HAL_UART_IRQHandler+0x2a>
    if (((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
 802359c:	0691      	lsls	r1, r2, #26
 802359e:	d501      	bpl.n	80235a4 <HAL_UART_IRQHandler+0x18>
 80235a0:	06ae      	lsls	r6, r5, #26
 80235a2:	d438      	bmi.n	8023616 <HAL_UART_IRQHandler+0x8a>
  if (((isrflags & USART_SR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
 80235a4:	0610      	lsls	r0, r2, #24
 80235a6:	d501      	bpl.n	80235ac <HAL_UART_IRQHandler+0x20>
 80235a8:	0629      	lsls	r1, r5, #24
 80235aa:	d43c      	bmi.n	8023626 <HAL_UART_IRQHandler+0x9a>
  if (((isrflags & USART_SR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
 80235ac:	0656      	lsls	r6, r2, #25
 80235ae:	d501      	bpl.n	80235b4 <HAL_UART_IRQHandler+0x28>
 80235b0:	0668      	lsls	r0, r5, #25
 80235b2:	d454      	bmi.n	802365e <HAL_UART_IRQHandler+0xd2>
}
 80235b4:	bd70      	pop	{r4, r5, r6, pc}
  if ((errorflags != RESET) && (((cr3its & USART_CR3_EIE) != RESET) || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)))
 80235b6:	f011 0101 	ands.w	r1, r1, #1
 80235ba:	d16e      	bne.n	802369a <HAL_UART_IRQHandler+0x10e>
 80235bc:	f415 7f90 	tst.w	r5, #288	@ 0x120
 80235c0:	d0f0      	beq.n	80235a4 <HAL_UART_IRQHandler+0x18>
    if (((isrflags & USART_SR_PE) != RESET) && ((cr1its & USART_CR1_PEIE) != RESET))
 80235c2:	07d0      	lsls	r0, r2, #31
 80235c4:	d50a      	bpl.n	80235dc <HAL_UART_IRQHandler+0x50>
 80235c6:	05ee      	lsls	r6, r5, #23
 80235c8:	f140 809b 	bpl.w	8023702 <HAL_UART_IRQHandler+0x176>
      huart->ErrorCode |= HAL_UART_ERROR_PE;
 80235cc:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
    if (((isrflags & USART_SR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 80235ce:	0756      	lsls	r6, r2, #29
      huart->ErrorCode |= HAL_UART_ERROR_PE;
 80235d0:	f040 0001 	orr.w	r0, r0, #1
 80235d4:	63e0      	str	r0, [r4, #60]	@ 0x3c
    if (((isrflags & USART_SR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 80235d6:	d551      	bpl.n	802367c <HAL_UART_IRQHandler+0xf0>
 80235d8:	2900      	cmp	r1, #0
 80235da:	d162      	bne.n	80236a2 <HAL_UART_IRQHandler+0x116>
    if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 80235dc:	6be1      	ldr	r1, [r4, #60]	@ 0x3c
 80235de:	2900      	cmp	r1, #0
 80235e0:	d0e8      	beq.n	80235b4 <HAL_UART_IRQHandler+0x28>
      if (((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
 80235e2:	0692      	lsls	r2, r2, #26
 80235e4:	d509      	bpl.n	80235fa <HAL_UART_IRQHandler+0x6e>
 80235e6:	06ae      	lsls	r6, r5, #26
 80235e8:	d507      	bpl.n	80235fa <HAL_UART_IRQHandler+0x6e>
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 80235ea:	f894 203a 	ldrb.w	r2, [r4, #58]	@ 0x3a
 80235ee:	2a22      	cmp	r2, #34	@ 0x22
 80235f0:	d103      	bne.n	80235fa <HAL_UART_IRQHandler+0x6e>
 80235f2:	4620      	mov	r0, r4
 80235f4:	f7ff ff5e 	bl	80234b4 <UART_Receive_IT.part.0.isra.0>
      dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
 80235f8:	6823      	ldr	r3, [r4, #0]
 80235fa:	695a      	ldr	r2, [r3, #20]
      if (((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) || dmarequest)
 80235fc:	6be1      	ldr	r1, [r4, #60]	@ 0x3c
      dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
 80235fe:	f002 0240 	and.w	r2, r2, #64	@ 0x40
      if (((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) || dmarequest)
 8023602:	f001 0108 	and.w	r1, r1, #8
 8023606:	ea52 0501 	orrs.w	r5, r2, r1
 802360a:	d153      	bne.n	80236b4 <HAL_UART_IRQHandler+0x128>
        HAL_UART_ErrorCallback(huart);
 802360c:	4620      	mov	r0, r4
 802360e:	f7ff ff87 	bl	8023520 <HAL_UART_ErrorCallback>
        huart->ErrorCode = HAL_UART_ERROR_NONE;
 8023612:	63e5      	str	r5, [r4, #60]	@ 0x3c
}
 8023614:	bd70      	pop	{r4, r5, r6, pc}
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 8023616:	f890 303a 	ldrb.w	r3, [r0, #58]	@ 0x3a
 802361a:	2b22      	cmp	r3, #34	@ 0x22
 802361c:	d1ca      	bne.n	80235b4 <HAL_UART_IRQHandler+0x28>
}
 802361e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 8023622:	f7ff bf47 	b.w	80234b4 <UART_Receive_IT.part.0.isra.0>
  if (huart->gState == HAL_UART_STATE_BUSY_TX)
 8023626:	f894 2039 	ldrb.w	r2, [r4, #57]	@ 0x39
 802362a:	2a21      	cmp	r2, #33	@ 0x21
 802362c:	d1c2      	bne.n	80235b4 <HAL_UART_IRQHandler+0x28>
    if (huart->Init.WordLength == UART_WORDLENGTH_9B)
 802362e:	68a1      	ldr	r1, [r4, #8]
      tmp = (uint16_t *) huart->pTxBuffPtr;
 8023630:	6a22      	ldr	r2, [r4, #32]
    if (huart->Init.WordLength == UART_WORDLENGTH_9B)
 8023632:	f5b1 5f80 	cmp.w	r1, #4096	@ 0x1000
 8023636:	d06e      	beq.n	8023716 <HAL_UART_IRQHandler+0x18a>
      huart->Instance->DR = (uint8_t)(*huart->pTxBuffPtr++ & (uint8_t)0x00FF);
 8023638:	1c51      	adds	r1, r2, #1
 802363a:	6221      	str	r1, [r4, #32]
 802363c:	7812      	ldrb	r2, [r2, #0]
 802363e:	605a      	str	r2, [r3, #4]
    if (--huart->TxXferCount == 0U)
 8023640:	8ce2      	ldrh	r2, [r4, #38]	@ 0x26
 8023642:	3a01      	subs	r2, #1
 8023644:	b292      	uxth	r2, r2
 8023646:	84e2      	strh	r2, [r4, #38]	@ 0x26
 8023648:	2a00      	cmp	r2, #0
 802364a:	d1b3      	bne.n	80235b4 <HAL_UART_IRQHandler+0x28>
      __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
 802364c:	68da      	ldr	r2, [r3, #12]
 802364e:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
 8023652:	60da      	str	r2, [r3, #12]
      __HAL_UART_ENABLE_IT(huart, UART_IT_TC);
 8023654:	68da      	ldr	r2, [r3, #12]
 8023656:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 802365a:	60da      	str	r2, [r3, #12]
}
 802365c:	bd70      	pop	{r4, r5, r6, pc}
  __HAL_UART_DISABLE_IT(huart, UART_IT_TC);
 802365e:	68da      	ldr	r2, [r3, #12]
  huart->gState = HAL_UART_STATE_READY;
 8023660:	2120      	movs	r1, #32
  __HAL_UART_DISABLE_IT(huart, UART_IT_TC);
 8023662:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
 8023666:	60da      	str	r2, [r3, #12]
  HAL_UART_TxCpltCallback(huart);
 8023668:	4620      	mov	r0, r4
  huart->gState = HAL_UART_STATE_READY;
 802366a:	f884 1039 	strb.w	r1, [r4, #57]	@ 0x39
  HAL_UART_TxCpltCallback(huart);
 802366e:	f004 fdf7 	bl	8028260 <HAL_UART_TxCpltCallback>
}
 8023672:	bd70      	pop	{r4, r5, r6, pc}
    if (((isrflags & USART_SR_PE) != RESET) && ((cr1its & USART_CR1_PEIE) != RESET))
 8023674:	05ee      	lsls	r6, r5, #23
 8023676:	d4a9      	bmi.n	80235cc <HAL_UART_IRQHandler+0x40>
    if (((isrflags & USART_SR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 8023678:	0750      	lsls	r0, r2, #29
 802367a:	d412      	bmi.n	80236a2 <HAL_UART_IRQHandler+0x116>
    if (((isrflags & USART_SR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 802367c:	0796      	lsls	r6, r2, #30
 802367e:	d544      	bpl.n	802370a <HAL_UART_IRQHandler+0x17e>
 8023680:	2900      	cmp	r1, #0
 8023682:	d0ab      	beq.n	80235dc <HAL_UART_IRQHandler+0x50>
      huart->ErrorCode |= HAL_UART_ERROR_FE;
 8023684:	6be1      	ldr	r1, [r4, #60]	@ 0x3c
    if (((isrflags & USART_SR_ORE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 8023686:	0710      	lsls	r0, r2, #28
      huart->ErrorCode |= HAL_UART_ERROR_FE;
 8023688:	f041 0104 	orr.w	r1, r1, #4
 802368c:	63e1      	str	r1, [r4, #60]	@ 0x3c
    if (((isrflags & USART_SR_ORE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 802368e:	d5a5      	bpl.n	80235dc <HAL_UART_IRQHandler+0x50>
      huart->ErrorCode |= HAL_UART_ERROR_ORE;
 8023690:	6be1      	ldr	r1, [r4, #60]	@ 0x3c
 8023692:	f041 0108 	orr.w	r1, r1, #8
 8023696:	63e1      	str	r1, [r4, #60]	@ 0x3c
 8023698:	e7a0      	b.n	80235dc <HAL_UART_IRQHandler+0x50>
    if (((isrflags & USART_SR_PE) != RESET) && ((cr1its & USART_CR1_PEIE) != RESET))
 802369a:	07d0      	lsls	r0, r2, #31
 802369c:	d4ea      	bmi.n	8023674 <HAL_UART_IRQHandler+0xe8>
    if (((isrflags & USART_SR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 802369e:	0751      	lsls	r1, r2, #29
 80236a0:	d52c      	bpl.n	80236fc <HAL_UART_IRQHandler+0x170>
      huart->ErrorCode |= HAL_UART_ERROR_NE;
 80236a2:	6be1      	ldr	r1, [r4, #60]	@ 0x3c
    if (((isrflags & USART_SR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 80236a4:	0796      	lsls	r6, r2, #30
      huart->ErrorCode |= HAL_UART_ERROR_NE;
 80236a6:	f041 0102 	orr.w	r1, r1, #2
 80236aa:	63e1      	str	r1, [r4, #60]	@ 0x3c
    if (((isrflags & USART_SR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 80236ac:	d4ea      	bmi.n	8023684 <HAL_UART_IRQHandler+0xf8>
    if (((isrflags & USART_SR_ORE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 80236ae:	0711      	lsls	r1, r2, #28
 80236b0:	d594      	bpl.n	80235dc <HAL_UART_IRQHandler+0x50>
 80236b2:	e7ed      	b.n	8023690 <HAL_UART_IRQHandler+0x104>
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 80236b4:	68da      	ldr	r2, [r3, #12]
 80236b6:	f422 7290 	bic.w	r2, r2, #288	@ 0x120
 80236ba:	60da      	str	r2, [r3, #12]
  CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 80236bc:	695a      	ldr	r2, [r3, #20]
  huart->RxState = HAL_UART_STATE_READY;
 80236be:	2120      	movs	r1, #32
  CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 80236c0:	f022 0201 	bic.w	r2, r2, #1
 80236c4:	615a      	str	r2, [r3, #20]
  huart->RxState = HAL_UART_STATE_READY;
 80236c6:	f884 103a 	strb.w	r1, [r4, #58]	@ 0x3a
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 80236ca:	695a      	ldr	r2, [r3, #20]
 80236cc:	0655      	lsls	r5, r2, #25
 80236ce:	d511      	bpl.n	80236f4 <HAL_UART_IRQHandler+0x168>
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 80236d0:	695a      	ldr	r2, [r3, #20]
          if (huart->hdmarx != NULL)
 80236d2:	6b60      	ldr	r0, [r4, #52]	@ 0x34
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 80236d4:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
 80236d8:	615a      	str	r2, [r3, #20]
          if (huart->hdmarx != NULL)
 80236da:	b158      	cbz	r0, 80236f4 <HAL_UART_IRQHandler+0x168>
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
 80236dc:	4b14      	ldr	r3, [pc, #80]	@ (8023730 <HAL_UART_IRQHandler+0x1a4>)
 80236de:	6503      	str	r3, [r0, #80]	@ 0x50
            if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
 80236e0:	f7fe f902 	bl	80218e8 <HAL_DMA_Abort_IT>
 80236e4:	2800      	cmp	r0, #0
 80236e6:	f43f af65 	beq.w	80235b4 <HAL_UART_IRQHandler+0x28>
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 80236ea:	6b60      	ldr	r0, [r4, #52]	@ 0x34
}
 80236ec:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 80236f0:	6d03      	ldr	r3, [r0, #80]	@ 0x50
 80236f2:	4718      	bx	r3
            HAL_UART_ErrorCallback(huart);
 80236f4:	4620      	mov	r0, r4
 80236f6:	f7ff ff13 	bl	8023520 <HAL_UART_ErrorCallback>
}
 80236fa:	bd70      	pop	{r4, r5, r6, pc}
    if (((isrflags & USART_SR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 80236fc:	0791      	lsls	r1, r2, #30
 80236fe:	d4c1      	bmi.n	8023684 <HAL_UART_IRQHandler+0xf8>
 8023700:	e7d5      	b.n	80236ae <HAL_UART_IRQHandler+0x122>
    if (((isrflags & USART_SR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 8023702:	0750      	lsls	r0, r2, #29
 8023704:	f53f af6a 	bmi.w	80235dc <HAL_UART_IRQHandler+0x50>
 8023708:	e7b8      	b.n	802367c <HAL_UART_IRQHandler+0xf0>
    if (((isrflags & USART_SR_ORE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 802370a:	0710      	lsls	r0, r2, #28
 802370c:	f57f af66 	bpl.w	80235dc <HAL_UART_IRQHandler+0x50>
 8023710:	2900      	cmp	r1, #0
 8023712:	d1bd      	bne.n	8023690 <HAL_UART_IRQHandler+0x104>
 8023714:	e762      	b.n	80235dc <HAL_UART_IRQHandler+0x50>
      huart->Instance->DR = (uint16_t)(*tmp & (uint16_t)0x01FF);
 8023716:	8811      	ldrh	r1, [r2, #0]
      if (huart->Init.Parity == UART_PARITY_NONE)
 8023718:	6920      	ldr	r0, [r4, #16]
      huart->Instance->DR = (uint16_t)(*tmp & (uint16_t)0x01FF);
 802371a:	f3c1 0108 	ubfx	r1, r1, #0, #9
 802371e:	6059      	str	r1, [r3, #4]
      if (huart->Init.Parity == UART_PARITY_NONE)
 8023720:	b910      	cbnz	r0, 8023728 <HAL_UART_IRQHandler+0x19c>
        huart->pTxBuffPtr += 2U;
 8023722:	3202      	adds	r2, #2
 8023724:	6222      	str	r2, [r4, #32]
 8023726:	e78b      	b.n	8023640 <HAL_UART_IRQHandler+0xb4>
        huart->pTxBuffPtr += 1U;
 8023728:	3201      	adds	r2, #1
 802372a:	6222      	str	r2, [r4, #32]
 802372c:	e788      	b.n	8023640 <HAL_UART_IRQHandler+0xb4>
 802372e:	bf00      	nop
 8023730:	08023735 	.word	0x08023735

08023734 <UART_DMAAbortOnError>:
{
 8023734:	b508      	push	{r3, lr}
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8023736:	6b80      	ldr	r0, [r0, #56]	@ 0x38
  huart->RxXferCount = 0x00U;
 8023738:	2300      	movs	r3, #0
 802373a:	85c3      	strh	r3, [r0, #46]	@ 0x2e
  huart->TxXferCount = 0x00U;
 802373c:	84c3      	strh	r3, [r0, #38]	@ 0x26
  HAL_UART_ErrorCallback(huart);
 802373e:	f7ff feef 	bl	8023520 <HAL_UART_ErrorCallback>
}
 8023742:	bd08      	pop	{r3, pc}

08023744 <ModbusMath_ACQStart_Write>:
ModbusMathOutput_t  ModbusMathOutput;

bool ModbusMath_ACQStart = false;

void ModbusMath_ACQStart_Write(bool state)
    {
 8023744:	b508      	push	{r3, lr}
    ModbusMath_ACQStart = state;
 8023746:	4b03      	ldr	r3, [pc, #12]	@ (8023754 <ModbusMath_ACQStart_Write+0x10>)
 8023748:	7018      	strb	r0, [r3, #0]
    Sensor.number_of_samples = Comm_Modbus_MaxSampleAtOnce();
 802374a:	f001 fb7f 	bl	8024e4c <Comm_Modbus_MaxSampleAtOnce>
 802374e:	4b02      	ldr	r3, [pc, #8]	@ (8023758 <ModbusMath_ACQStart_Write+0x14>)
 8023750:	6098      	str	r0, [r3, #8]
    }
 8023752:	bd08      	pop	{r3, pc}
 8023754:	200001d0 	.word	0x200001d0
 8023758:	20000008 	.word	0x20000008

0802375c <ModbusMath_MaxMin_Start>:
uint32_t ModbusMath_MaxMin_MaxValue = 0;
uint32_t ModbusMath_MaxMin_MinValue = 0;

void ModbusMath_MaxMin_Start()
    {
    ModbusMath_MaxMin_enable = true;
 802375c:	4b03      	ldr	r3, [pc, #12]	@ (802376c <ModbusMath_MaxMin_Start+0x10>)
    ModbusMath_MaxMin_MaxValue = 0;
 802375e:	2200      	movs	r2, #0
    ModbusMath_MaxMin_enable = true;
 8023760:	2101      	movs	r1, #1
    ModbusMath_MaxMin_MinValue = 0;
 8023762:	e9c3 2201 	strd	r2, r2, [r3, #4]
    ModbusMath_MaxMin_enable = true;
 8023766:	7019      	strb	r1, [r3, #0]
    }
 8023768:	4770      	bx	lr
 802376a:	bf00      	nop
 802376c:	200001dc 	.word	0x200001dc

08023770 <ModbusMath_MaxMin_Stop>:

void ModbusMath_MaxMin_Stop()
    {
    ModbusMath_MaxMin_enable = false;
 8023770:	4b01      	ldr	r3, [pc, #4]	@ (8023778 <ModbusMath_MaxMin_Stop+0x8>)
 8023772:	2200      	movs	r2, #0
 8023774:	701a      	strb	r2, [r3, #0]
    }
 8023776:	4770      	bx	lr
 8023778:	200001dc 	.word	0x200001dc

0802377c <ACQ_getRandom>:



/******************************************************************************/
uint8_t ACQ_getRandom(void)
{
 802377c:	b508      	push	{r3, lr}
    //let's roll the dices
    return (uint8_t)((adxl_GetAxisData(DataX) >> 4));
 802377e:	2002      	movs	r0, #2
 8023780:	f001 fdf2 	bl	8025368 <adxl_GetAxisData>
}
 8023784:	f3c0 1007 	ubfx	r0, r0, #4, #8
 8023788:	bd08      	pop	{r3, pc}
 802378a:	bf00      	nop

0802378c <ACQ_Init>:
    ResetScheduledSending();
#endif
}
/******************************************************************************/
void ACQ_Init(void)
{
 802378c:	b570      	push	{r4, r5, r6, lr}
    {
        PRINTF_HW("DATA_BUFFER_LENGTH is not divided by 3\n");
        while (1) { ; }
    }

    if (Protocol == MODBUS)
 802378e:	4b27      	ldr	r3, [pc, #156]	@ (802382c <ACQ_Init+0xa0>)
    else
    {
        dataResolution = 3;
        Sensor.configuration.RS485_speed = speed_1500k;
    }
    RS485_Init(Sensor.configuration.RS485_speed);
 8023790:	4e27      	ldr	r6, [pc, #156]	@ (8023830 <ACQ_Init+0xa4>)
    if (Protocol == MODBUS)
 8023792:	781b      	ldrb	r3, [r3, #0]
 8023794:	2b01      	cmp	r3, #1
{
 8023796:	b092      	sub	sp, #72	@ 0x48
    if (Protocol == MODBUS)
 8023798:	d044      	beq.n	8023824 <ACQ_Init+0x98>
        Sensor.configuration.RS485_speed = speed_1500k;
 802379a:	20d0      	movs	r0, #208	@ 0xd0
 802379c:	f886 007b 	strb.w	r0, [r6, #123]	@ 0x7b
        dataResolution = 3;
 80237a0:	2303      	movs	r3, #3
 80237a2:	4c24      	ldr	r4, [pc, #144]	@ (8023834 <ACQ_Init+0xa8>)
 80237a4:	7123      	strb	r3, [r4, #4]
    RS485_Init(Sensor.configuration.RS485_speed);
 80237a6:	f002 f863 	bl	8025870 <RS485_Init>
    AdiConf_t Config;
	Memory_TakeConfig(&Config);
 80237aa:	4668      	mov	r0, sp
 80237ac:	f003 fbfc 	bl	8026fa8 <Memory_TakeConfig>
    memcpy(&z_sensitivity, &Config.Z_Calibration_Sensitivity, sizeof(float));
//	Config.RS485_speed = Sensor.configuration.RS485_speed;
//	Config.protocol = SLS;
//	Memory_SaveConfig(&Config); ///!!!!!

    dataStorage.overFlw = false;
 80237b0:	4821      	ldr	r0, [pc, #132]	@ (8023838 <ACQ_Init+0xac>)
    dataStorage.start = 0;
    dataStorage.end = 0;
    _samplesCounter = 0;
    dataStorage.size = dataResolution * DATA_BUFFER_LENGTH;
 80237b2:	7923      	ldrb	r3, [r4, #4]
    memcpy(&x_coefficientA, &Config.X_Calibration_A, sizeof(float));
 80237b4:	f8dd 1021 	ldr.w	r1, [sp, #33]	@ 0x21
 80237b8:	60a1      	str	r1, [r4, #8]
    dataStorage.overFlw = false;
 80237ba:	f500 32f8 	add.w	r2, r0, #126976	@ 0x1f000
 80237be:	2500      	movs	r5, #0
 80237c0:	f882 559c 	strb.w	r5, [r2, #1436]	@ 0x59c
    dataStorage.size = dataResolution * DATA_BUFFER_LENGTH;
 80237c4:	f647 5264 	movw	r2, #32100	@ 0x7d64
 80237c8:	fb02 f303 	mul.w	r3, r2, r3
 80237cc:	6083      	str	r3, [r0, #8]
    memcpy(&x_coefficientB, &Config.X_Calibration_B, sizeof(float));
 80237ce:	f8dd 3025 	ldr.w	r3, [sp, #37]	@ 0x25
 80237d2:	60e3      	str	r3, [r4, #12]
    memcpy(&x_sensitivity, &Config.X_Calibration_Sensitivity, sizeof(float));
 80237d4:	f8dd 3029 	ldr.w	r3, [sp, #41]	@ 0x29
 80237d8:	6123      	str	r3, [r4, #16]
    memcpy(&y_coefficientA, &Config.Y_Calibration_A, sizeof(float));
 80237da:	f8dd 302d 	ldr.w	r3, [sp, #45]	@ 0x2d
 80237de:	6163      	str	r3, [r4, #20]
    memcpy(&y_coefficientB, &Config.Y_Calibration_B, sizeof(float));
 80237e0:	f8dd 3031 	ldr.w	r3, [sp, #49]	@ 0x31
 80237e4:	61a3      	str	r3, [r4, #24]
    memcpy(&y_sensitivity, &Config.Y_Calibration_Sensitivity, sizeof(float));
 80237e6:	f8dd 3035 	ldr.w	r3, [sp, #53]	@ 0x35
 80237ea:	61e3      	str	r3, [r4, #28]
    memcpy(&z_coefficientA, &Config.Z_Calibration_A, sizeof(float));
 80237ec:	f8dd 3039 	ldr.w	r3, [sp, #57]	@ 0x39
 80237f0:	6223      	str	r3, [r4, #32]
    memcpy(&z_coefficientB, &Config.Z_Calibration_B, sizeof(float));
 80237f2:	f8dd 303d 	ldr.w	r3, [sp, #61]	@ 0x3d
    dataStorage.start = 0;
 80237f6:	6045      	str	r5, [r0, #4]
 80237f8:	6005      	str	r5, [r0, #0]
    memcpy(&z_coefficientB, &Config.Z_Calibration_B, sizeof(float));
 80237fa:	6263      	str	r3, [r4, #36]	@ 0x24
    Sensor.sample_counter = 0;
    memset(dataStorage.data, 0, SAMPLE_SIZE * DATA_BUFFER_LENGTH);
 80237fc:	4629      	mov	r1, r5
    memcpy(&z_sensitivity, &Config.Z_Calibration_Sensitivity, sizeof(float));
 80237fe:	f8dd 3041 	ldr.w	r3, [sp, #65]	@ 0x41
    memset(dataStorage.data, 0, SAMPLE_SIZE * DATA_BUFFER_LENGTH);
 8023802:	4a0e      	ldr	r2, [pc, #56]	@ (802383c <ACQ_Init+0xb0>)
    memcpy(&z_sensitivity, &Config.Z_Calibration_Sensitivity, sizeof(float));
 8023804:	62a3      	str	r3, [r4, #40]	@ 0x28
    memset(dataStorage.data, 0, SAMPLE_SIZE * DATA_BUFFER_LENGTH);
 8023806:	300c      	adds	r0, #12
    Sensor.sample_counter = 0;
 8023808:	60f5      	str	r5, [r6, #12]
    _samplesCounter = 0;
 802380a:	6025      	str	r5, [r4, #0]
    memset(dataStorage.data, 0, SAMPLE_SIZE * DATA_BUFFER_LENGTH);
 802380c:	f006 f98e 	bl	8029b2c <memset>

    HAL_NVIC_SetPriority(EXTI3_IRQn, 1, 0);
 8023810:	462a      	mov	r2, r5
 8023812:	2101      	movs	r1, #1
 8023814:	2009      	movs	r0, #9
 8023816:	f7fd ff0b 	bl	8021630 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(EXTI3_IRQn);
 802381a:	2009      	movs	r0, #9
 802381c:	f7fd ff44 	bl	80216a8 <HAL_NVIC_EnableIRQ>
}
 8023820:	b012      	add	sp, #72	@ 0x48
 8023822:	bd70      	pop	{r4, r5, r6, pc}
    RS485_Init(Sensor.configuration.RS485_speed);
 8023824:	f896 007b 	ldrb.w	r0, [r6, #123]	@ 0x7b
        dataResolution = 4;
 8023828:	2304      	movs	r3, #4
 802382a:	e7ba      	b.n	80237a2 <ACQ_Init+0x16>
 802382c:	20023e5c 	.word	0x20023e5c
 8023830:	20000008 	.word	0x20000008
 8023834:	200001e8 	.word	0x200001e8
 8023838:	20000214 	.word	0x20000214
 802383c:	0001f590 	.word	0x0001f590

08023840 <ACQ_Start>:

/******************************************************************************/
void ACQ_Start(void)
{
    //CyclicBuffer_flush(&_acqBuff);
    dataStorage.overFlw = false;
 8023840:	4a0a      	ldr	r2, [pc, #40]	@ (802386c <ACQ_Start+0x2c>)
    Sensor.aqusition = true;
 8023842:	490b      	ldr	r1, [pc, #44]	@ (8023870 <ACQ_Start+0x30>)
{
 8023844:	b410      	push	{r4}
    Sensor.overflow = false;
    dataStorage.start = 0;
    dataStorage.end = 0;
    Sensor.sample_counter = 0;
    _samplesCounter = 0;
 8023846:	4c0b      	ldr	r4, [pc, #44]	@ (8023874 <ACQ_Start+0x34>)
    dataStorage.overFlw = false;
 8023848:	2300      	movs	r3, #0
 802384a:	f502 3cf8 	add.w	ip, r2, #126976	@ 0x1f000
    dataStorage.end = 0;
 802384e:	e9c2 3300 	strd	r3, r3, [r2]
    _samplesCounter = 0;
 8023852:	6023      	str	r3, [r4, #0]
    Sensor.aqusition = true;
 8023854:	2201      	movs	r2, #1
    HAL_NVIC_EnableIRQ(EXTI3_IRQn);
    //HAL_TIM_Base_Start_IT(&htim7);
}
 8023856:	f85d 4b04 	ldr.w	r4, [sp], #4
    dataStorage.overFlw = false;
 802385a:	f88c 359c 	strb.w	r3, [ip, #1436]	@ 0x59c
    HAL_NVIC_EnableIRQ(EXTI3_IRQn);
 802385e:	2009      	movs	r0, #9
    Sensor.aqusition = true;
 8023860:	f8a1 2003 	strh.w	r2, [r1, #3]
    Sensor.sample_counter = 0;
 8023864:	60cb      	str	r3, [r1, #12]
    HAL_NVIC_EnableIRQ(EXTI3_IRQn);
 8023866:	f7fd bf1f 	b.w	80216a8 <HAL_NVIC_EnableIRQ>
 802386a:	bf00      	nop
 802386c:	20000214 	.word	0x20000214
 8023870:	20000008 	.word	0x20000008
 8023874:	200001e8 	.word	0x200001e8

08023878 <ACQ_Stop>:

/******************************************************************************/
void ACQ_Stop(void)
{
 8023878:	b510      	push	{r4, lr}
    //dataStorage.start = 0;
    //dataStorage.end = 0;
    PRINTF_APP("========================\n");
 802387a:	4c0a      	ldr	r4, [pc, #40]	@ (80238a4 <ACQ_Stop+0x2c>)
 802387c:	2000      	movs	r0, #0
 802387e:	4621      	mov	r1, r4
 8023880:	f004 fbd2 	bl	8028028 <LOG_fprintf>
    PRINTF_APP("CLEARING SAMPLE COUNTER\n");
 8023884:	4908      	ldr	r1, [pc, #32]	@ (80238a8 <ACQ_Stop+0x30>)
 8023886:	2000      	movs	r0, #0
 8023888:	f004 fbce 	bl	8028028 <LOG_fprintf>
    PRINTF_APP("========================\n");
 802388c:	4621      	mov	r1, r4
 802388e:	2000      	movs	r0, #0
 8023890:	f004 fbca 	bl	8028028 <LOG_fprintf>
    //Sensor.sample_counter = 0;
    Sensor.aqusition=false;
 8023894:	4b05      	ldr	r3, [pc, #20]	@ (80238ac <ACQ_Stop+0x34>)
 8023896:	2200      	movs	r2, #0
    //_samplesCounter = 0;
    HAL_NVIC_DisableIRQ(EXTI3_IRQn);
    //HAL_TIM_Base_Stop_IT(&htim7);
}
 8023898:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    HAL_NVIC_DisableIRQ(EXTI3_IRQn);
 802389c:	2009      	movs	r0, #9
    Sensor.aqusition=false;
 802389e:	70da      	strb	r2, [r3, #3]
    HAL_NVIC_DisableIRQ(EXTI3_IRQn);
 80238a0:	f7fd bf10 	b.w	80216c4 <HAL_NVIC_DisableIRQ>
 80238a4:	0802e218 	.word	0x0802e218
 80238a8:	0802e234 	.word	0x0802e234
 80238ac:	20000008 	.word	0x20000008

080238b0 <ACQ_SampleAppend>:

/******************************************************************************/
void ACQ_SampleAppend(uint8_t* sample)
{
 80238b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        float xResultingFloat = (float)zAccInt * ns_coeff / x_sensitivity;
        float yResultingFloat = (float)xAccInt * ns_coeff / y_sensitivity * -1; // -1 -> Axis inversion to match AVS orientation
        float zResultingFloat = (float)yAccInt * ns_coeff / z_sensitivity;

        // Put the values in the dataStorage
        memcpy(dataStorage.data + (dataStorage.end / CHANNELS_AMMOUNT),                                                   &xResultingFloat, dataResolution);
 80238b4:	4ec8      	ldr	r6, [pc, #800]	@ (8023bd8 <ACQ_SampleAppend+0x328>)
        memcpy(dataStorage.data + dataStorage.end + (2 * dataResolution),   sample + (2 * dataResolution),  dataResolution);
    }

    dataStorage.end += (CHANNELS_AMMOUNT * dataResolution);
    _samplesCounter += CHANNELS_AMMOUNT;
    Sensor.sample_counter += CHANNELS_AMMOUNT;
 80238b6:	4fc9      	ldr	r7, [pc, #804]	@ (8023bdc <ACQ_SampleAppend+0x32c>)
    _samplesCounter += CHANNELS_AMMOUNT;
 80238b8:	6832      	ldr	r2, [r6, #0]
    if (Protocol == MODBUS)
 80238ba:	4bc9      	ldr	r3, [pc, #804]	@ (8023be0 <ACQ_SampleAppend+0x330>)
        memcpy(dataStorage.data + (dataStorage.end / CHANNELS_AMMOUNT),                                                   &xResultingFloat, dataResolution);
 80238bc:	4dc9      	ldr	r5, [pc, #804]	@ (8023be4 <ACQ_SampleAppend+0x334>)
{
 80238be:	ed2d 8b02 	vpush	{d8}
 80238c2:	b08b      	sub	sp, #44	@ 0x2c
    _samplesCounter += CHANNELS_AMMOUNT;
 80238c4:	3203      	adds	r2, #3
 80238c6:	9203      	str	r2, [sp, #12]
    Sensor.sample_counter += CHANNELS_AMMOUNT;
 80238c8:	68fa      	ldr	r2, [r7, #12]
    if (Protocol == MODBUS)
 80238ca:	f893 b000 	ldrb.w	fp, [r3]
        memcpy(dataStorage.data + (dataStorage.end / CHANNELS_AMMOUNT),                                                   &xResultingFloat, dataResolution);
 80238ce:	7934      	ldrb	r4, [r6, #4]
    Sensor.sample_counter += CHANNELS_AMMOUNT;
 80238d0:	f102 0a03 	add.w	sl, r2, #3
        memcpy(dataStorage.data + (dataStorage.end / CHANNELS_AMMOUNT),                                                   &xResultingFloat, dataResolution);
 80238d4:	686a      	ldr	r2, [r5, #4]
 80238d6:	9201      	str	r2, [sp, #4]
    if (Protocol == MODBUS)
 80238d8:	f1bb 0f01 	cmp.w	fp, #1
    dataStorage.end += (CHANNELS_AMMOUNT * dataResolution);
 80238dc:	eb04 0244 	add.w	r2, r4, r4, lsl #1
{
 80238e0:	4680      	mov	r8, r0
    dataStorage.end += (CHANNELS_AMMOUNT * dataResolution);
 80238e2:	9202      	str	r2, [sp, #8]
    if (Protocol == MODBUS)
 80238e4:	f040 8136 	bne.w	8023b54 <ACQ_SampleAppend+0x2a4>
        AccPtr[0] = sample[0];
 80238e8:	8801      	ldrh	r1, [r0, #0]
        AccPtr[2] = sample[2];
 80238ea:	7882      	ldrb	r2, [r0, #2]
        AccPtr[0] = sample[0];
 80238ec:	2300      	movs	r3, #0
 80238ee:	f361 030f 	bfi	r3, r1, #0, #16
        AccPtr[2] = sample[2];
 80238f2:	f362 4317 	bfi	r3, r2, #16, #8
        if (xAccInt & 0x00800000)
 80238f6:	0218      	lsls	r0, r3, #8
 80238f8:	f023 427f 	bic.w	r2, r3, #4278190080	@ 0xff000000
 80238fc:	bf48      	it	mi
 80238fe:	f042 427f 	orrmi.w	r2, r2, #4278190080	@ 0xff000000
        xAccInt *= scalling;
 8023902:	ee07 2a90 	vmov	s15, r2
 8023906:	eef8 7ae7 	vcvt.f32.s32	s15, s15
        v = (double)(xAccInt) * x_coefficientA + x_coefficientB;
 802390a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 802390e:	ee17 0a90 	vmov	r0, s15
 8023912:	f7fc fe8f 	bl	8020634 <__aeabi_i2d>
 8023916:	e9cd 0104 	strd	r0, r1, [sp, #16]
 802391a:	68b0      	ldr	r0, [r6, #8]
 802391c:	f7fc fe9c 	bl	8020658 <__aeabi_f2d>
 8023920:	4602      	mov	r2, r0
 8023922:	460b      	mov	r3, r1
 8023924:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8023928:	f7fc feee 	bl	8020708 <__aeabi_dmul>
 802392c:	e9cd 0104 	strd	r0, r1, [sp, #16]
 8023930:	68f0      	ldr	r0, [r6, #12]
 8023932:	f7fc fe91 	bl	8020658 <__aeabi_f2d>
 8023936:	4602      	mov	r2, r0
 8023938:	460b      	mov	r3, r1
 802393a:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 802393e:	f7fc fd2d 	bl	802039c <__adddf3>
 8023942:	f7fd f99b 	bl	8020c7c <__aeabi_d2f>
        if (v < (-(1 << 23)))
 8023946:	eddf 6aa8 	vldr	s13, [pc, #672]	@ 8023be8 <ACQ_SampleAppend+0x338>
        xAccInt = (int32_t)(v);
 802394a:	ed9f 7aa8 	vldr	s14, [pc, #672]	@ 8023bec <ACQ_SampleAppend+0x33c>
        AccPtr[0] = sample[3];
 802394e:	f8b8 1003 	ldrh.w	r1, [r8, #3]
        AccPtr[2] = sample[5];
 8023952:	f898 2005 	ldrb.w	r2, [r8, #5]
        v = (double)(xAccInt) * x_coefficientA + x_coefficientB;
 8023956:	ee07 0a90 	vmov	s15, r0
        if (v < (-(1 << 23)))
 802395a:	eef4 7ae6 	vcmpe.f32	s15, s13
 802395e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8023962:	bfb8      	it	lt
 8023964:	eef0 7a66 	vmovlt.f32	s15, s13
        AccPtr[0] = sample[3];
 8023968:	2300      	movs	r3, #0
        xAccInt = (int32_t)(v);
 802396a:	eef4 7ac7 	vcmpe.f32	s15, s14
        AccPtr[0] = sample[3];
 802396e:	f361 030f 	bfi	r3, r1, #0, #16
        xAccInt = (int32_t)(v);
 8023972:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
        AccPtr[2] = sample[5];
 8023976:	f362 4317 	bfi	r3, r2, #16, #8
        xAccInt = (int32_t)(v);
 802397a:	bf88      	it	hi
 802397c:	eef0 7a47 	vmovhi.f32	s15, s14
        if (yAccInt & 0x00800000)
 8023980:	f023 427f 	bic.w	r2, r3, #4278190080	@ 0xff000000
 8023984:	0219      	lsls	r1, r3, #8
 8023986:	bf48      	it	mi
 8023988:	f042 427f 	orrmi.w	r2, r2, #4278190080	@ 0xff000000
        xAccInt = (int32_t)(v);
 802398c:	eefd 8ae7 	vcvt.s32.f32	s17, s15
        yAccInt *= scalling;
 8023990:	ee07 2a90 	vmov	s15, r2
 8023994:	eef8 7ae7 	vcvt.f32.s32	s15, s15
        float yResultingFloat = (float)xAccInt * ns_coeff / y_sensitivity * -1; // -1 -> Axis inversion to match AVS orientation
 8023998:	eef8 8ae8 	vcvt.f32.s32	s17, s17
        v = (double)(yAccInt) * y_coefficientA + y_coefficientB;
 802399c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80239a0:	ee17 0a90 	vmov	r0, s15
 80239a4:	f7fc fe46 	bl	8020634 <__aeabi_i2d>
 80239a8:	e9cd 0104 	strd	r0, r1, [sp, #16]
 80239ac:	6970      	ldr	r0, [r6, #20]
 80239ae:	f7fc fe53 	bl	8020658 <__aeabi_f2d>
 80239b2:	4602      	mov	r2, r0
 80239b4:	460b      	mov	r3, r1
 80239b6:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 80239ba:	f7fc fea5 	bl	8020708 <__aeabi_dmul>
 80239be:	e9cd 0104 	strd	r0, r1, [sp, #16]
 80239c2:	69b0      	ldr	r0, [r6, #24]
 80239c4:	f7fc fe48 	bl	8020658 <__aeabi_f2d>
 80239c8:	4602      	mov	r2, r0
 80239ca:	460b      	mov	r3, r1
 80239cc:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 80239d0:	f7fc fce4 	bl	802039c <__adddf3>
 80239d4:	f7fd f952 	bl	8020c7c <__aeabi_d2f>
        if (v < (-(1 << 23)))
 80239d8:	eddf 6a83 	vldr	s13, [pc, #524]	@ 8023be8 <ACQ_SampleAppend+0x338>
        yAccInt = (int32_t)(v);
 80239dc:	ed9f 7a83 	vldr	s14, [pc, #524]	@ 8023bec <ACQ_SampleAppend+0x33c>
        AccPtr[0] = sample[6];
 80239e0:	f8b8 1006 	ldrh.w	r1, [r8, #6]
        AccPtr[2] = sample[8];
 80239e4:	f898 2008 	ldrb.w	r2, [r8, #8]
        v = (double)(yAccInt) * y_coefficientA + y_coefficientB;
 80239e8:	ee07 0a90 	vmov	s15, r0
        if (v < (-(1 << 23)))
 80239ec:	eef4 7ae6 	vcmpe.f32	s15, s13
 80239f0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80239f4:	bfb8      	it	lt
 80239f6:	eef0 7a66 	vmovlt.f32	s15, s13
        AccPtr[0] = sample[6];
 80239fa:	2300      	movs	r3, #0
        yAccInt = (int32_t)(v);
 80239fc:	eef4 7ac7 	vcmpe.f32	s15, s14
        AccPtr[0] = sample[6];
 8023a00:	f361 030f 	bfi	r3, r1, #0, #16
        yAccInt = (int32_t)(v);
 8023a04:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
        AccPtr[2] = sample[8];
 8023a08:	f362 4317 	bfi	r3, r2, #16, #8
        yAccInt = (int32_t)(v);
 8023a0c:	bf88      	it	hi
 8023a0e:	eef0 7a47 	vmovhi.f32	s15, s14
        if (zAccInt & 0x00800000)
 8023a12:	f023 427f 	bic.w	r2, r3, #4278190080	@ 0xff000000
 8023a16:	021b      	lsls	r3, r3, #8
 8023a18:	bf48      	it	mi
 8023a1a:	f042 427f 	orrmi.w	r2, r2, #4278190080	@ 0xff000000
        yAccInt = (int32_t)(v);
 8023a1e:	eebd 8ae7 	vcvt.s32.f32	s16, s15
        zAccInt *= scalling;
 8023a22:	ee07 2a90 	vmov	s15, r2
 8023a26:	eef8 7ae7 	vcvt.f32.s32	s15, s15
        v = (double)(zAccInt) * z_coefficientA + z_coefficientB;
 8023a2a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8023a2e:	ee17 0a90 	vmov	r0, s15
 8023a32:	f7fc fdff 	bl	8020634 <__aeabi_i2d>
 8023a36:	4680      	mov	r8, r0
 8023a38:	6a30      	ldr	r0, [r6, #32]
 8023a3a:	4689      	mov	r9, r1
 8023a3c:	f7fc fe0c 	bl	8020658 <__aeabi_f2d>
 8023a40:	4602      	mov	r2, r0
 8023a42:	460b      	mov	r3, r1
 8023a44:	4640      	mov	r0, r8
 8023a46:	4649      	mov	r1, r9
 8023a48:	f7fc fe5e 	bl	8020708 <__aeabi_dmul>
 8023a4c:	4680      	mov	r8, r0
 8023a4e:	6a70      	ldr	r0, [r6, #36]	@ 0x24
 8023a50:	4689      	mov	r9, r1
 8023a52:	f7fc fe01 	bl	8020658 <__aeabi_f2d>
 8023a56:	4602      	mov	r2, r0
 8023a58:	460b      	mov	r3, r1
 8023a5a:	4640      	mov	r0, r8
 8023a5c:	4649      	mov	r1, r9
 8023a5e:	f7fc fc9d 	bl	802039c <__adddf3>
 8023a62:	f7fd f90b 	bl	8020c7c <__aeabi_d2f>
        if (v < (-(1 << 23)))
 8023a66:	eddf 6a60 	vldr	s13, [pc, #384]	@ 8023be8 <ACQ_SampleAppend+0x338>
        zAccInt = (int32_t)(v);
 8023a6a:	ed9f 7a60 	vldr	s14, [pc, #384]	@ 8023bec <ACQ_SampleAppend+0x33c>
        float yResultingFloat = (float)xAccInt * ns_coeff / y_sensitivity * -1; // -1 -> Axis inversion to match AVS orientation
 8023a6e:	ed96 6a07 	vldr	s12, [r6, #28]
        float xResultingFloat = (float)zAccInt * ns_coeff / x_sensitivity;
 8023a72:	ed96 5a04 	vldr	s10, [r6, #16]
        float zResultingFloat = (float)yAccInt * ns_coeff / z_sensitivity;
 8023a76:	edd6 5a0a 	vldr	s11, [r6, #40]	@ 0x28
        memcpy(dataStorage.data + (dataStorage.end / CHANNELS_AMMOUNT),                                                   &xResultingFloat, dataResolution);
 8023a7a:	f8df 817c 	ldr.w	r8, [pc, #380]	@ 8023bf8 <ACQ_SampleAppend+0x348>
 8023a7e:	9b01      	ldr	r3, [sp, #4]
 8023a80:	f8df 9178 	ldr.w	r9, [pc, #376]	@ 8023bfc <ACQ_SampleAppend+0x34c>
        v = (double)(zAccInt) * z_coefficientA + z_coefficientB;
 8023a84:	ee07 0a90 	vmov	s15, r0
        if (v < (-(1 << 23)))
 8023a88:	eef4 7ae6 	vcmpe.f32	s15, s13
 8023a8c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8023a90:	bfb8      	it	lt
 8023a92:	eef0 7a66 	vmovlt.f32	s15, s13
        zAccInt = (int32_t)(v);
 8023a96:	eef4 7ac7 	vcmpe.f32	s15, s14
 8023a9a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8023a9e:	bf88      	it	hi
 8023aa0:	eef0 7a47 	vmovhi.f32	s15, s14
 8023aa4:	eebd 7ae7 	vcvt.s32.f32	s14, s15
        float xResultingFloat = (float)zAccInt * ns_coeff / x_sensitivity;
 8023aa8:	eddf 6a51 	vldr	s13, [pc, #324]	@ 8023bf0 <ACQ_SampleAppend+0x340>
 8023aac:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
        float zResultingFloat = (float)yAccInt * ns_coeff / z_sensitivity;
 8023ab0:	eef8 7ac8 	vcvt.f32.s32	s15, s16
        float yResultingFloat = (float)xAccInt * ns_coeff / y_sensitivity * -1; // -1 -> Axis inversion to match AVS orientation
 8023ab4:	ee68 8aa6 	vmul.f32	s17, s17, s13
        float xResultingFloat = (float)zAccInt * ns_coeff / x_sensitivity;
 8023ab8:	ee27 7a26 	vmul.f32	s14, s14, s13
        float zResultingFloat = (float)yAccInt * ns_coeff / z_sensitivity;
 8023abc:	ee67 7aa6 	vmul.f32	s15, s15, s13
        float yResultingFloat = (float)xAccInt * ns_coeff / y_sensitivity * -1; // -1 -> Axis inversion to match AVS orientation
 8023ac0:	eec8 6a86 	vdiv.f32	s13, s17, s12
        memcpy(dataStorage.data + (dataStorage.end / CHANNELS_AMMOUNT),                                                   &xResultingFloat, dataResolution);
 8023ac4:	fba8 3003 	umull	r3, r0, r8, r3
 8023ac8:	4622      	mov	r2, r4
 8023aca:	a907      	add	r1, sp, #28
 8023acc:	eb09 0050 	add.w	r0, r9, r0, lsr #1
        float xResultingFloat = (float)zAccInt * ns_coeff / x_sensitivity;
 8023ad0:	ee87 6a05 	vdiv.f32	s12, s14, s10
        float zResultingFloat = (float)yAccInt * ns_coeff / z_sensitivity;
 8023ad4:	ee87 7aa5 	vdiv.f32	s14, s15, s11
        float yResultingFloat = (float)xAccInt * ns_coeff / y_sensitivity * -1; // -1 -> Axis inversion to match AVS orientation
 8023ad8:	eef1 7a66 	vneg.f32	s15, s13
        float xResultingFloat = (float)zAccInt * ns_coeff / x_sensitivity;
 8023adc:	ed8d 6a07 	vstr	s12, [sp, #28]
        float yResultingFloat = (float)xAccInt * ns_coeff / y_sensitivity * -1; // -1 -> Axis inversion to match AVS orientation
 8023ae0:	edcd 7a08 	vstr	s15, [sp, #32]
        float zResultingFloat = (float)yAccInt * ns_coeff / z_sensitivity;
 8023ae4:	ed8d 7a09 	vstr	s14, [sp, #36]	@ 0x24
        memcpy(dataStorage.data + (dataStorage.end / CHANNELS_AMMOUNT),                                                   &xResultingFloat, dataResolution);
 8023ae8:	f006 f89b 	bl	8029c22 <memcpy>
        memcpy(dataStorage.data + (dataStorage.end / CHANNELS_AMMOUNT) + (MODBUS_SAMPLES_AMOUNT * dataResolution),        &yResultingFloat, dataResolution);
 8023aec:	686b      	ldr	r3, [r5, #4]
 8023aee:	f44f 607a 	mov.w	r0, #4000	@ 0xfa0
 8023af2:	fba8 2303 	umull	r2, r3, r8, r3
 8023af6:	fb04 f000 	mul.w	r0, r4, r0
 8023afa:	eb00 0053 	add.w	r0, r0, r3, lsr #1
 8023afe:	4622      	mov	r2, r4
 8023b00:	a908      	add	r1, sp, #32
 8023b02:	4448      	add	r0, r9
 8023b04:	f006 f88d 	bl	8029c22 <memcpy>
        memcpy(dataStorage.data + (dataStorage.end / CHANNELS_AMMOUNT) + (2 * MODBUS_SAMPLES_AMOUNT * dataResolution),    &zResultingFloat, dataResolution);
 8023b08:	686b      	ldr	r3, [r5, #4]
 8023b0a:	f44f 50fa 	mov.w	r0, #8000	@ 0x1f40
 8023b0e:	fba8 8303 	umull	r8, r3, r8, r3
 8023b12:	fb04 f000 	mul.w	r0, r4, r0
 8023b16:	eb00 0053 	add.w	r0, r0, r3, lsr #1
 8023b1a:	4622      	mov	r2, r4
 8023b1c:	4448      	add	r0, r9
 8023b1e:	a909      	add	r1, sp, #36	@ 0x24
 8023b20:	f006 f87f 	bl	8029c22 <memcpy>
    dataStorage.end += (CHANNELS_AMMOUNT * dataResolution);
 8023b24:	686b      	ldr	r3, [r5, #4]
 8023b26:	9a02      	ldr	r2, [sp, #8]
    Sensor.sample_counter += CHANNELS_AMMOUNT;
 8023b28:	f8c7 a00c 	str.w	sl, [r7, #12]
    dataStorage.end += (CHANNELS_AMMOUNT * dataResolution);
 8023b2c:	441a      	add	r2, r3
 8023b2e:	4613      	mov	r3, r2
 8023b30:	606a      	str	r2, [r5, #4]
    _samplesCounter += CHANNELS_AMMOUNT;
 8023b32:	9a03      	ldr	r2, [sp, #12]
 8023b34:	6032      	str	r2, [r6, #0]

    if (Protocol == MODBUS)
    {
        if (dataStorage.end == CHANNELS_AMMOUNT * MODBUS_SAMPLES_AMOUNT * dataResolution)
 8023b36:	f642 62e0 	movw	r2, #12000	@ 0x2ee0
 8023b3a:	fb04 f202 	mul.w	r2, r4, r2
 8023b3e:	429a      	cmp	r2, r3
 8023b40:	f000 8083 	beq.w	8023c4a <ACQ_SampleAppend+0x39a>
        {
            Sensor.aqusition = false;
            ACQ_Stop();
        }
    }
    if (dataStorage.end == dataStorage.start)
 8023b44:	682a      	ldr	r2, [r5, #0]
 8023b46:	429a      	cmp	r2, r3
 8023b48:	d078      	beq.n	8023c3c <ACQ_SampleAppend+0x38c>
            calculationsInterrupt = 1;
        }
        ACQ_setOverFlow();
        //ACQ_Stop();
    }
}
 8023b4a:	b00b      	add	sp, #44	@ 0x2c
 8023b4c:	ecbd 8b02 	vpop	{d8}
 8023b50:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        memcpy(dataStorage.data + dataStorage.end,                          sample + dataResolution,        dataResolution);
 8023b54:	9801      	ldr	r0, [sp, #4]
 8023b56:	f105 090c 	add.w	r9, r5, #12
 8023b5a:	4622      	mov	r2, r4
 8023b5c:	eb08 0104 	add.w	r1, r8, r4
 8023b60:	4448      	add	r0, r9
 8023b62:	f006 f85e 	bl	8029c22 <memcpy>
        memcpy(dataStorage.data + dataStorage.end + dataResolution,         sample,                         dataResolution);
 8023b66:	6868      	ldr	r0, [r5, #4]
 8023b68:	4420      	add	r0, r4
 8023b6a:	4622      	mov	r2, r4
 8023b6c:	4641      	mov	r1, r8
 8023b6e:	4448      	add	r0, r9
 8023b70:	f006 f857 	bl	8029c22 <memcpy>
        memcpy(dataStorage.data + dataStorage.end + (2 * dataResolution),   sample + (2 * dataResolution),  dataResolution);
 8023b74:	686a      	ldr	r2, [r5, #4]
 8023b76:	2002      	movs	r0, #2
 8023b78:	fb04 8100 	mla	r1, r4, r0, r8
 8023b7c:	fb10 2004 	smlabb	r0, r0, r4, r2
 8023b80:	4448      	add	r0, r9
 8023b82:	4622      	mov	r2, r4
 8023b84:	f006 f84d 	bl	8029c22 <memcpy>
    _samplesCounter += CHANNELS_AMMOUNT;
 8023b88:	9b03      	ldr	r3, [sp, #12]
    dataStorage.end += (CHANNELS_AMMOUNT * dataResolution);
 8023b8a:	686a      	ldr	r2, [r5, #4]
    _samplesCounter += CHANNELS_AMMOUNT;
 8023b8c:	6033      	str	r3, [r6, #0]
    dataStorage.end += (CHANNELS_AMMOUNT * dataResolution);
 8023b8e:	9b02      	ldr	r3, [sp, #8]
    Sensor.sample_counter += CHANNELS_AMMOUNT;
 8023b90:	f8c7 a00c 	str.w	sl, [r7, #12]
        if (dataStorage.end == DATA_BUFFER_LENGTH * dataResolution)
 8023b94:	f647 5164 	movw	r1, #32100	@ 0x7d64
    dataStorage.end += (CHANNELS_AMMOUNT * dataResolution);
 8023b98:	4413      	add	r3, r2
        if (dataStorage.end == DATA_BUFFER_LENGTH * dataResolution)
 8023b9a:	fb01 f404 	mul.w	r4, r1, r4
    if (Sensor.sample_counter == Sensor.number_of_samples)
 8023b9e:	68b9      	ldr	r1, [r7, #8]
    dataStorage.end += (CHANNELS_AMMOUNT * dataResolution);
 8023ba0:	461a      	mov	r2, r3
            dataStorage.end = 0;
 8023ba2:	429c      	cmp	r4, r3
 8023ba4:	bf08      	it	eq
 8023ba6:	2200      	moveq	r2, #0
    if (Sensor.sample_counter == Sensor.number_of_samples)
 8023ba8:	4551      	cmp	r1, sl
 8023baa:	606a      	str	r2, [r5, #4]
 8023bac:	d028      	beq.n	8023c00 <ACQ_SampleAppend+0x350>
    if (dataStorage.end == dataStorage.start)
 8023bae:	682b      	ldr	r3, [r5, #0]
 8023bb0:	429a      	cmp	r2, r3
 8023bb2:	d1ca      	bne.n	8023b4a <ACQ_SampleAppend+0x29a>
    dataStorage.overFlw = false;
 8023bb4:	490f      	ldr	r1, [pc, #60]	@ (8023bf4 <ACQ_SampleAppend+0x344>)
 8023bb6:	2300      	movs	r3, #0
    Sensor.aqusition=false;
 8023bb8:	f44f 7280 	mov.w	r2, #256	@ 0x100
    dataStorage.end = 0;
 8023bbc:	e9c5 3300 	strd	r3, r3, [r5]
    dataStorage.overFlw = false;
 8023bc0:	f881 359c 	strb.w	r3, [r1, #1436]	@ 0x59c
    _samplesCounter = 0;
 8023bc4:	6033      	str	r3, [r6, #0]
    Sensor.aqusition=false;
 8023bc6:	f8a7 2003 	strh.w	r2, [r7, #3]
    Sensor.sample_counter = 0;
 8023bca:	60fb      	str	r3, [r7, #12]
}
 8023bcc:	b00b      	add	sp, #44	@ 0x2c
 8023bce:	ecbd 8b02 	vpop	{d8}
 8023bd2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8023bd6:	bf00      	nop
 8023bd8:	200001e8 	.word	0x200001e8
 8023bdc:	20000008 	.word	0x20000008
 8023be0:	20023e5c 	.word	0x20023e5c
 8023be4:	20000214 	.word	0x20000214
 8023be8:	cb000000 	.word	0xcb000000
 8023bec:	4afffffe 	.word	0x4afffffe
 8023bf0:	36000000 	.word	0x36000000
 8023bf4:	2001f214 	.word	0x2001f214
 8023bf8:	aaaaaaab 	.word	0xaaaaaaab
 8023bfc:	20000220 	.word	0x20000220
        if (Protocol == SLS)
 8023c00:	f1bb 0f00 	cmp.w	fp, #0
 8023c04:	d1d3      	bne.n	8023bae <ACQ_SampleAppend+0x2fe>
    PRINTF_APP("========================\n");
 8023c06:	4914      	ldr	r1, [pc, #80]	@ (8023c58 <ACQ_SampleAppend+0x3a8>)
            Sensor.aqusition = false;
 8023c08:	f887 b003 	strb.w	fp, [r7, #3]
    PRINTF_APP("========================\n");
 8023c0c:	4658      	mov	r0, fp
 8023c0e:	f004 fa0b 	bl	8028028 <LOG_fprintf>
    PRINTF_APP("CLEARING SAMPLE COUNTER\n");
 8023c12:	4912      	ldr	r1, [pc, #72]	@ (8023c5c <ACQ_SampleAppend+0x3ac>)
 8023c14:	4658      	mov	r0, fp
 8023c16:	f004 fa07 	bl	8028028 <LOG_fprintf>
    PRINTF_APP("========================\n");
 8023c1a:	490f      	ldr	r1, [pc, #60]	@ (8023c58 <ACQ_SampleAppend+0x3a8>)
 8023c1c:	4658      	mov	r0, fp
 8023c1e:	f004 fa03 	bl	8028028 <LOG_fprintf>
    HAL_NVIC_DisableIRQ(EXTI3_IRQn);
 8023c22:	2009      	movs	r0, #9
    Sensor.aqusition=false;
 8023c24:	f887 b003 	strb.w	fp, [r7, #3]
    HAL_NVIC_DisableIRQ(EXTI3_IRQn);
 8023c28:	f7fd fd4c 	bl	80216c4 <HAL_NVIC_DisableIRQ>
    if (dataStorage.end == dataStorage.start)
 8023c2c:	e9d5 2100 	ldrd	r2, r1, [r5]
 8023c30:	4291      	cmp	r1, r2
 8023c32:	4b0b      	ldr	r3, [pc, #44]	@ (8023c60 <ACQ_SampleAppend+0x3b0>)
 8023c34:	d189      	bne.n	8023b4a <ACQ_SampleAppend+0x29a>
        if (Protocol == MODBUS)
 8023c36:	781b      	ldrb	r3, [r3, #0]
 8023c38:	2b01      	cmp	r3, #1
 8023c3a:	d1bb      	bne.n	8023bb4 <ACQ_SampleAppend+0x304>
            collectedData = (float*)dataStorage.data;
 8023c3c:	4b09      	ldr	r3, [pc, #36]	@ (8023c64 <ACQ_SampleAppend+0x3b4>)
 8023c3e:	f8c3 9000 	str.w	r9, [r3]
            calculationsInterrupt = 1;
 8023c42:	4b09      	ldr	r3, [pc, #36]	@ (8023c68 <ACQ_SampleAppend+0x3b8>)
 8023c44:	2201      	movs	r2, #1
 8023c46:	701a      	strb	r2, [r3, #0]
 8023c48:	e7b4      	b.n	8023bb4 <ACQ_SampleAppend+0x304>
    if (dataStorage.end == dataStorage.start)
 8023c4a:	682a      	ldr	r2, [r5, #0]
            dataStorage.end = 0;
 8023c4c:	2300      	movs	r3, #0
    if (dataStorage.end == dataStorage.start)
 8023c4e:	429a      	cmp	r2, r3
            dataStorage.end = 0;
 8023c50:	606b      	str	r3, [r5, #4]
    if (dataStorage.end == dataStorage.start)
 8023c52:	f47f af7a 	bne.w	8023b4a <ACQ_SampleAppend+0x29a>
 8023c56:	e7f1      	b.n	8023c3c <ACQ_SampleAppend+0x38c>
 8023c58:	0802e218 	.word	0x0802e218
 8023c5c:	0802e234 	.word	0x0802e234
 8023c60:	20023e5c 	.word	0x20023e5c
 8023c64:	20023e60 	.word	0x20023e60
 8023c68:	20023e5d 	.word	0x20023e5d

08023c6c <ACQ_DoJob>:
{
 8023c6c:	b500      	push	{lr}
 8023c6e:	b085      	sub	sp, #20
    uint8_t sample[ACCELEROMETER_SAMPLE_SIZE] = { 0 };
 8023c70:	2300      	movs	r3, #0
    adxl_GetAxisData_fast(sample);
 8023c72:	a801      	add	r0, sp, #4
    uint8_t sample[ACCELEROMETER_SAMPLE_SIZE] = { 0 };
 8023c74:	e9cd 3301 	strd	r3, r3, [sp, #4]
 8023c78:	f88d 300c 	strb.w	r3, [sp, #12]
    adxl_GetAxisData_fast(sample);
 8023c7c:	f001 fb70 	bl	8025360 <adxl_GetAxisData_fast>
    ACQ_SampleAppend(sample);
 8023c80:	a801      	add	r0, sp, #4
 8023c82:	f7ff fe15 	bl	80238b0 <ACQ_SampleAppend>
}
 8023c86:	b005      	add	sp, #20
 8023c88:	f85d fb04 	ldr.w	pc, [sp], #4

08023c8c <ACQ_GetSamples>:
{
    return _samplesCounter;
}
/******************************************************************************/
uint32_t ACQ_GetSamples(uint8_t* data, uint32_t samplesAmmount)
{
 8023c8c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    uint32_t samplesToTake = samplesAmmount;
    PRINTF_TEST("Samples requested: %d\n",samplesToTake);
    PRINTF_TEST("Samples in buffers: %d\n",Sensor.sample_counter);
    if (samplesToTake > _samplesCounter)
 8023c90:	4f63      	ldr	r7, [pc, #396]	@ (8023e20 <ACQ_GetSamples+0x194>)
 8023c92:	683d      	ldr	r5, [r7, #0]
 8023c94:	428d      	cmp	r5, r1
{
 8023c96:	b083      	sub	sp, #12
 8023c98:	4680      	mov	r8, r0
    if (samplesToTake > _samplesCounter)
 8023c9a:	d24a      	bcs.n	8023d32 <ACQ_GetSamples+0xa6>
    {
        samplesToTake = _samplesCounter;
        uint8_t reszta = samplesToTake % CHANNELS_AMMOUNT;
 8023c9c:	4961      	ldr	r1, [pc, #388]	@ (8023e24 <ACQ_GetSamples+0x198>)
 8023c9e:	fba1 3105 	umull	r3, r1, r1, r5
 8023ca2:	f021 0301 	bic.w	r3, r1, #1
 8023ca6:	eb03 0351 	add.w	r3, r3, r1, lsr #1
        if (reszta!=0)
 8023caa:	1aeb      	subs	r3, r5, r3
 8023cac:	d144      	bne.n	8023d38 <ACQ_GetSamples+0xac>
        }
    }
    _samplesCounter -= samplesToTake;
    samplesToTake = dataResolution * samplesToTake; // teraz juz bytes to take
    PRINTF_TEST("Bytes to take: %d\n",samplesToTake);
    if (dataStorage.start + samplesToTake < dataStorage.size)
 8023cae:	4e5e      	ldr	r6, [pc, #376]	@ (8023e28 <ACQ_GetSamples+0x19c>)
    samplesToTake = dataResolution * samplesToTake; // teraz juz bytes to take
 8023cb0:	f897 a004 	ldrb.w	sl, [r7, #4]
    if (dataStorage.start + samplesToTake < dataStorage.size)
 8023cb4:	6834      	ldr	r4, [r6, #0]
    _samplesCounter -= samplesToTake;
 8023cb6:	603b      	str	r3, [r7, #0]
    samplesToTake = dataResolution * samplesToTake; // teraz juz bytes to take
 8023cb8:	fb05 f50a 	mul.w	r5, r5, sl
    if (dataStorage.start + samplesToTake < dataStorage.size)
 8023cbc:	68b3      	ldr	r3, [r6, #8]
 8023cbe:	1962      	adds	r2, r4, r5
            ACQ_setOverFlow();
            ACQ_Stop();
            ACQ_Init();
            return 0;
        }*/
        memcpy(data,dataStorage.data+dataStorage.start,samplesToTake);
 8023cc0:	f106 0b0c 	add.w	fp, r6, #12
    if (dataStorage.start + samplesToTake < dataStorage.size)
 8023cc4:	429a      	cmp	r2, r3
        memcpy(data,dataStorage.data+dataStorage.start,samplesToTake);
 8023cc6:	eb0b 0104 	add.w	r1, fp, r4
    if (dataStorage.start + samplesToTake < dataStorage.size)
 8023cca:	d355      	bcc.n	8023d78 <ACQ_GetSamples+0xec>
        }
        return samplesToTake;
    }

    // KOPIOWANIE NA DWA RAZY
    uint16_t firstPart = dataStorage.size - dataStorage.start;
 8023ccc:	fa1f f983 	uxth.w	r9, r3
 8023cd0:	b2a4      	uxth	r4, r4
 8023cd2:	eba9 0204 	sub.w	r2, r9, r4
    uint16_t secondPart = samplesToTake - firstPart;

    //FIRST COPYING
    memcpy(data, dataStorage.data + dataStorage.start, firstPart);
 8023cd6:	b292      	uxth	r2, r2
 8023cd8:	4640      	mov	r0, r8
 8023cda:	9201      	str	r2, [sp, #4]
 8023cdc:	f005 ffa1 	bl	8029c22 <memcpy>
    dataStorage.start += firstPart;
    if (dataStorage.start == dataResolution * DATA_BUFFER_LENGTH)
 8023ce0:	f647 5364 	movw	r3, #32100	@ 0x7d64
 8023ce4:	fb03 fa0a 	mul.w	sl, r3, sl
    dataStorage.start += firstPart;
 8023ce8:	9a01      	ldr	r2, [sp, #4]
 8023cea:	6833      	ldr	r3, [r6, #0]
 8023cec:	4413      	add	r3, r2
    if (dataStorage.start == dataResolution * DATA_BUFFER_LENGTH)
 8023cee:	4553      	cmp	r3, sl
 8023cf0:	d123      	bne.n	8023d3a <ACQ_GetSamples+0xae>
    uint16_t secondPart = samplesToTake - firstPart;
 8023cf2:	eba4 0409 	sub.w	r4, r4, r9
        ACQ_setOverFlow();
        ACQ_Stop();
        return 0;
    }
    //SECOND COPYING
    if (dataStorage.start + secondPart > dataStorage.end && Sensor.aqusition)
 8023cf6:	6873      	ldr	r3, [r6, #4]
    uint16_t secondPart = samplesToTake - firstPart;
 8023cf8:	442c      	add	r4, r5
    if (dataStorage.start + secondPart > dataStorage.end && Sensor.aqusition)
 8023cfa:	b2a4      	uxth	r4, r4
        dataStorage.start = 0;
 8023cfc:	f04f 0900 	mov.w	r9, #0
    if (dataStorage.start + secondPart > dataStorage.end && Sensor.aqusition)
 8023d00:	429c      	cmp	r4, r3
        dataStorage.start = 0;
 8023d02:	f8c6 9000 	str.w	r9, [r6]
    if (dataStorage.start + secondPart > dataStorage.end && Sensor.aqusition)
 8023d06:	d905      	bls.n	8023d14 <ACQ_GetSamples+0x88>
 8023d08:	f8df a128 	ldr.w	sl, [pc, #296]	@ 8023e34 <ACQ_GetSamples+0x1a8>
 8023d0c:	f89a 3003 	ldrb.w	r3, [sl, #3]
 8023d10:	2b00      	cmp	r3, #0
 8023d12:	d164      	bne.n	8023dde <ACQ_GetSamples+0x152>
        PRINTF_TEST("Jakas dziwna sytuacja...3\n");
        ACQ_setOverFlow();
        ACQ_Stop();
        return 0;
    }
    memcpy(data + firstPart, dataStorage.data, secondPart);
 8023d14:	eb08 0002 	add.w	r0, r8, r2
 8023d18:	4944      	ldr	r1, [pc, #272]	@ (8023e2c <ACQ_GetSamples+0x1a0>)
 8023d1a:	4622      	mov	r2, r4
 8023d1c:	f005 ff81 	bl	8029c22 <memcpy>
    dataStorage.start += secondPart;
 8023d20:	f85b 3c0c 	ldr.w	r3, [fp, #-12]
 8023d24:	4423      	add	r3, r4
 8023d26:	f84b 3c0c 	str.w	r3, [fp, #-12]
    PRINTF_TEST("Samples second: %d to %d taken\n", 0, secondPart);
    PRINTF_TEST("Samples first: %d to %d taken\n", dataStorage.start, dataStorage.size);
    return samplesToTake;
}
 8023d2a:	4628      	mov	r0, r5
 8023d2c:	b003      	add	sp, #12
 8023d2e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    _samplesCounter -= samplesToTake;
 8023d32:	1a6b      	subs	r3, r5, r1
    uint32_t samplesToTake = samplesAmmount;
 8023d34:	460d      	mov	r5, r1
 8023d36:	e7ba      	b.n	8023cae <ACQ_GetSamples+0x22>
 8023d38:	4e3b      	ldr	r6, [pc, #236]	@ (8023e28 <ACQ_GetSamples+0x19c>)
    dataStorage.overFlw = false;
 8023d3a:	4b3d      	ldr	r3, [pc, #244]	@ (8023e30 <ACQ_GetSamples+0x1a4>)
    Sensor.aqusition=false;
 8023d3c:	4d3d      	ldr	r5, [pc, #244]	@ (8023e34 <ACQ_GetSamples+0x1a8>)
    PRINTF_APP("========================\n");
 8023d3e:	493e      	ldr	r1, [pc, #248]	@ (8023e38 <ACQ_GetSamples+0x1ac>)
    dataStorage.overFlw = false;
 8023d40:	2400      	movs	r4, #0
 8023d42:	f883 459c 	strb.w	r4, [r3, #1436]	@ 0x59c
    PRINTF_APP("========================\n");
 8023d46:	4620      	mov	r0, r4
    Sensor.aqusition=false;
 8023d48:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8023d4c:	f8a5 3003 	strh.w	r3, [r5, #3]
    dataStorage.start = 0;
 8023d50:	6034      	str	r4, [r6, #0]
    dataStorage.end = 0;
 8023d52:	6074      	str	r4, [r6, #4]
    _samplesCounter = 0;
 8023d54:	603c      	str	r4, [r7, #0]
    Sensor.sample_counter = 0;
 8023d56:	60ec      	str	r4, [r5, #12]
    PRINTF_APP("========================\n");
 8023d58:	f004 f966 	bl	8028028 <LOG_fprintf>
    PRINTF_APP("CLEARING SAMPLE COUNTER\n");
 8023d5c:	4937      	ldr	r1, [pc, #220]	@ (8023e3c <ACQ_GetSamples+0x1b0>)
 8023d5e:	4620      	mov	r0, r4
 8023d60:	f004 f962 	bl	8028028 <LOG_fprintf>
    PRINTF_APP("========================\n");
 8023d64:	4620      	mov	r0, r4
 8023d66:	4934      	ldr	r1, [pc, #208]	@ (8023e38 <ACQ_GetSamples+0x1ac>)
 8023d68:	f004 f95e 	bl	8028028 <LOG_fprintf>
    HAL_NVIC_DisableIRQ(EXTI3_IRQn);
 8023d6c:	2009      	movs	r0, #9
    Sensor.aqusition=false;
 8023d6e:	70ec      	strb	r4, [r5, #3]
    HAL_NVIC_DisableIRQ(EXTI3_IRQn);
 8023d70:	f7fd fca8 	bl	80216c4 <HAL_NVIC_DisableIRQ>
            return 0;
 8023d74:	2500      	movs	r5, #0
 8023d76:	e7d8      	b.n	8023d2a <ACQ_GetSamples+0x9e>
        memcpy(data,dataStorage.data+dataStorage.start,samplesToTake);
 8023d78:	462a      	mov	r2, r5
 8023d7a:	4640      	mov	r0, r8
 8023d7c:	f005 ff51 	bl	8029c22 <memcpy>
        dataStorage.start += samplesToTake;
 8023d80:	6833      	ldr	r3, [r6, #0]
        if (dataStorage.start == 3*DATA_BUFFER_LENGTH)
 8023d82:	4a2f      	ldr	r2, [pc, #188]	@ (8023e40 <ACQ_GetSamples+0x1b4>)
        dataStorage.start += samplesToTake;
 8023d84:	442b      	add	r3, r5
        if (dataStorage.start == 3*DATA_BUFFER_LENGTH)
 8023d86:	4293      	cmp	r3, r2
        dataStorage.start += samplesToTake;
 8023d88:	6033      	str	r3, [r6, #0]
        if (dataStorage.start == 3*DATA_BUFFER_LENGTH)
 8023d8a:	d022      	beq.n	8023dd2 <ACQ_GetSamples+0x146>
        else if (dataStorage.start > 3*DATA_BUFFER_LENGTH)
 8023d8c:	d9cd      	bls.n	8023d2a <ACQ_GetSamples+0x9e>
    dataStorage.overFlw = false;
 8023d8e:	f506 33f8 	add.w	r3, r6, #126976	@ 0x1f000
 8023d92:	2400      	movs	r4, #0
    Sensor.aqusition=false;
 8023d94:	f8df 809c 	ldr.w	r8, [pc, #156]	@ 8023e34 <ACQ_GetSamples+0x1a8>
    dataStorage.overFlw = false;
 8023d98:	f883 459c 	strb.w	r4, [r3, #1436]	@ 0x59c
    PRINTF_APP("========================\n");
 8023d9c:	4620      	mov	r0, r4
    Sensor.aqusition=false;
 8023d9e:	f44f 7380 	mov.w	r3, #256	@ 0x100
    PRINTF_APP("========================\n");
 8023da2:	4925      	ldr	r1, [pc, #148]	@ (8023e38 <ACQ_GetSamples+0x1ac>)
    Sensor.aqusition=false;
 8023da4:	f8a8 3003 	strh.w	r3, [r8, #3]
    dataStorage.end = 0;
 8023da8:	e9c6 4400 	strd	r4, r4, [r6]
    _samplesCounter = 0;
 8023dac:	603c      	str	r4, [r7, #0]
    Sensor.sample_counter = 0;
 8023dae:	f8c8 400c 	str.w	r4, [r8, #12]
    PRINTF_APP("========================\n");
 8023db2:	f004 f939 	bl	8028028 <LOG_fprintf>
    PRINTF_APP("CLEARING SAMPLE COUNTER\n");
 8023db6:	4620      	mov	r0, r4
 8023db8:	4920      	ldr	r1, [pc, #128]	@ (8023e3c <ACQ_GetSamples+0x1b0>)
 8023dba:	f004 f935 	bl	8028028 <LOG_fprintf>
    PRINTF_APP("========================\n");
 8023dbe:	4620      	mov	r0, r4
 8023dc0:	491d      	ldr	r1, [pc, #116]	@ (8023e38 <ACQ_GetSamples+0x1ac>)
 8023dc2:	f004 f931 	bl	8028028 <LOG_fprintf>
    HAL_NVIC_DisableIRQ(EXTI3_IRQn);
 8023dc6:	2009      	movs	r0, #9
    Sensor.aqusition=false;
 8023dc8:	f888 4003 	strb.w	r4, [r8, #3]
    HAL_NVIC_DisableIRQ(EXTI3_IRQn);
 8023dcc:	f7fd fc7a 	bl	80216c4 <HAL_NVIC_DisableIRQ>
}
 8023dd0:	e7ab      	b.n	8023d2a <ACQ_GetSamples+0x9e>
            dataStorage.start = 0;
 8023dd2:	2300      	movs	r3, #0
}
 8023dd4:	4628      	mov	r0, r5
            dataStorage.start = 0;
 8023dd6:	6033      	str	r3, [r6, #0]
}
 8023dd8:	b003      	add	sp, #12
 8023dda:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    dataStorage.overFlw = false;
 8023dde:	f506 32f8 	add.w	r2, r6, #126976	@ 0x1f000
    Sensor.aqusition=false;
 8023de2:	f44f 7380 	mov.w	r3, #256	@ 0x100
    PRINTF_APP("========================\n");
 8023de6:	4648      	mov	r0, r9
 8023de8:	4913      	ldr	r1, [pc, #76]	@ (8023e38 <ACQ_GetSamples+0x1ac>)
    dataStorage.overFlw = false;
 8023dea:	f882 959c 	strb.w	r9, [r2, #1436]	@ 0x59c
    Sensor.aqusition=false;
 8023dee:	f8aa 3003 	strh.w	r3, [sl, #3]
    dataStorage.end = 0;
 8023df2:	f8c6 9004 	str.w	r9, [r6, #4]
    _samplesCounter = 0;
 8023df6:	f8c7 9000 	str.w	r9, [r7]
    Sensor.sample_counter = 0;
 8023dfa:	f8ca 900c 	str.w	r9, [sl, #12]
    PRINTF_APP("========================\n");
 8023dfe:	f004 f913 	bl	8028028 <LOG_fprintf>
    PRINTF_APP("CLEARING SAMPLE COUNTER\n");
 8023e02:	4648      	mov	r0, r9
 8023e04:	490d      	ldr	r1, [pc, #52]	@ (8023e3c <ACQ_GetSamples+0x1b0>)
 8023e06:	f004 f90f 	bl	8028028 <LOG_fprintf>
    PRINTF_APP("========================\n");
 8023e0a:	4648      	mov	r0, r9
 8023e0c:	490a      	ldr	r1, [pc, #40]	@ (8023e38 <ACQ_GetSamples+0x1ac>)
 8023e0e:	f004 f90b 	bl	8028028 <LOG_fprintf>
    HAL_NVIC_DisableIRQ(EXTI3_IRQn);
 8023e12:	2009      	movs	r0, #9
    Sensor.aqusition=false;
 8023e14:	f88a 9003 	strb.w	r9, [sl, #3]
    HAL_NVIC_DisableIRQ(EXTI3_IRQn);
 8023e18:	f7fd fc54 	bl	80216c4 <HAL_NVIC_DisableIRQ>
}
 8023e1c:	e7aa      	b.n	8023d74 <ACQ_GetSamples+0xe8>
 8023e1e:	bf00      	nop
 8023e20:	200001e8 	.word	0x200001e8
 8023e24:	aaaaaaab 	.word	0xaaaaaaab
 8023e28:	20000214 	.word	0x20000214
 8023e2c:	20000220 	.word	0x20000220
 8023e30:	2001f214 	.word	0x2001f214
 8023e34:	20000008 	.word	0x20000008
 8023e38:	0802e218 	.word	0x0802e218
 8023e3c:	0802e234 	.word	0x0802e234
 8023e40:	0001782c 	.word	0x0001782c

08023e44 <ACQ_clearOverFlow>:
/******************************************************************************/
void ACQ_clearOverFlow(void)
{
    Sensor.overflow = false;
 8023e44:	4b01      	ldr	r3, [pc, #4]	@ (8023e4c <ACQ_clearOverFlow+0x8>)
 8023e46:	2200      	movs	r2, #0
 8023e48:	711a      	strb	r2, [r3, #4]
}
 8023e4a:	4770      	bx	lr
 8023e4c:	20000008 	.word	0x20000008

08023e50 <__NVIC_SystemReset>:
 8023e50:	f3bf 8f4f 	dsb	sy
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8023e54:	4905      	ldr	r1, [pc, #20]	@ (8023e6c <__NVIC_SystemReset+0x1c>)
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8023e56:	4b06      	ldr	r3, [pc, #24]	@ (8023e70 <__NVIC_SystemReset+0x20>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8023e58:	68ca      	ldr	r2, [r1, #12]
 8023e5a:	f402 62e0 	and.w	r2, r2, #1792	@ 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8023e5e:	4313      	orrs	r3, r2
 8023e60:	60cb      	str	r3, [r1, #12]
 8023e62:	f3bf 8f4f 	dsb	sy
    __NOP();
 8023e66:	bf00      	nop
  for(;;)                                                           /* wait until reset */
 8023e68:	e7fd      	b.n	8023e66 <__NVIC_SystemReset+0x16>
 8023e6a:	bf00      	nop
 8023e6c:	e000ed00 	.word	0xe000ed00
 8023e70:	05fa0004 	.word	0x05fa0004

08023e74 <handler_calibration>:
}

/******************************************************************************/

static void handler_calibration(uint8_t cmd)
{
 8023e74:	b508      	push	{r3, lr}
	PRINTF_APP("set calibration \r\n");
 8023e76:	4905      	ldr	r1, [pc, #20]	@ (8023e8c <handler_calibration+0x18>)
 8023e78:	2000      	movs	r0, #0
 8023e7a:	f004 f8d5 	bl	8028028 <LOG_fprintf>
	PRINTF_APP("ToDo\r\n");
}
 8023e7e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	PRINTF_APP("ToDo\r\n");
 8023e82:	4903      	ldr	r1, [pc, #12]	@ (8023e90 <handler_calibration+0x1c>)
 8023e84:	2000      	movs	r0, #0
 8023e86:	f004 b8cf 	b.w	8028028 <LOG_fprintf>
 8023e8a:	bf00      	nop
 8023e8c:	0802e250 	.word	0x0802e250
 8023e90:	0802e264 	.word	0x0802e264

08023e94 <ota_body>:
}

/******************************************************************************/

static void ota_body(uint8_t cmd)
{
 8023e94:	b510      	push	{r4, lr}

	uint8_t *dataPointer = CommLink_GetPrtDataFrame();
 8023e96:	f001 f92f 	bl	80250f8 <CommLink_GetPrtDataFrame>
 8023e9a:	4604      	mov	r4, r0
	uint16_t data_size = CommLink_GetDataSize();
 8023e9c:	f001 f930 	bl	8025100 <CommLink_GetDataSize>
 8023ea0:	4601      	mov	r1, r0

	// PRINTF_APP("ota_body %d\r\n",data_size);
	OTC_Body(dataPointer, data_size);
 8023ea2:	4620      	mov	r0, r4
	// CommLink_SendData(Sensor.configuration.sensor_ID, cmd, 0, 0, 0);
}
 8023ea4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	OTC_Body(dataPointer, data_size);
 8023ea8:	f003 bf04 	b.w	8027cb4 <OTC_Body>

08023eac <handler_setID>:
{
 8023eac:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (!Sensor.addressing_by_MAC)
 8023eae:	4e42      	ldr	r6, [pc, #264]	@ (8023fb8 <handler_setID+0x10c>)
 8023eb0:	7874      	ldrb	r4, [r6, #1]
{
 8023eb2:	b095      	sub	sp, #84	@ 0x54
 8023eb4:	4605      	mov	r5, r0
	if (!Sensor.addressing_by_MAC)
 8023eb6:	b99c      	cbnz	r4, 8023ee0 <handler_setID+0x34>
		PRINTF_APP("Addressing by SensorID\n");
 8023eb8:	4940      	ldr	r1, [pc, #256]	@ (8023fbc <handler_setID+0x110>)
 8023eba:	4620      	mov	r0, r4
 8023ebc:	f004 f8b4 	bl	8028028 <LOG_fprintf>
		PRINTF_APP("Set ID\r\n");
 8023ec0:	493f      	ldr	r1, [pc, #252]	@ (8023fc0 <handler_setID+0x114>)
 8023ec2:	4620      	mov	r0, r4
 8023ec4:	f004 f8b0 	bl	8028028 <LOG_fprintf>
		if (CommLink_GetDataSize() != 13)
 8023ec8:	f001 f91a 	bl	8025100 <CommLink_GetDataSize>
 8023ecc:	280d      	cmp	r0, #13
 8023ece:	d037      	beq.n	8023f40 <handler_setID+0x94>
			PRINTF_APP("%s bad CommLink_GetDataSize - should be 13\n", __FUNCTION__);
 8023ed0:	4a3c      	ldr	r2, [pc, #240]	@ (8023fc4 <handler_setID+0x118>)
 8023ed2:	493d      	ldr	r1, [pc, #244]	@ (8023fc8 <handler_setID+0x11c>)
 8023ed4:	2000      	movs	r0, #0
}
 8023ed6:	b015      	add	sp, #84	@ 0x54
 8023ed8:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
			PRINTF_APP("%s bad CommLink_GetDataSize - should be 13\n", __FUNCTION__);
 8023edc:	f004 b8a4 	b.w	8028028 <LOG_fprintf>
		PRINTF_APP("Addressing by MAC\n");
 8023ee0:	493a      	ldr	r1, [pc, #232]	@ (8023fcc <handler_setID+0x120>)
 8023ee2:	2000      	movs	r0, #0
 8023ee4:	f004 f8a0 	bl	8028028 <LOG_fprintf>
		PRINTF_APP("Set ID\r\n");
 8023ee8:	4935      	ldr	r1, [pc, #212]	@ (8023fc0 <handler_setID+0x114>)
 8023eea:	2000      	movs	r0, #0
 8023eec:	f004 f89c 	bl	8028028 <LOG_fprintf>
		if (CommLink_GetDataSize() != 13)
 8023ef0:	f001 f906 	bl	8025100 <CommLink_GetDataSize>
 8023ef4:	280d      	cmp	r0, #13
 8023ef6:	d1eb      	bne.n	8023ed0 <handler_setID+0x24>
		uint8_t *dataPointer = CommLink_GetPrtDataFrame();
 8023ef8:	f001 f8fe 	bl	80250f8 <CommLink_GetPrtDataFrame>
 8023efc:	4604      	mov	r4, r0
		Memory_TakeConfig(&newConfig);
 8023efe:	a802      	add	r0, sp, #8
 8023f00:	f003 f852 	bl	8026fa8 <Memory_TakeConfig>
		if (memcmp(newConfig.MAC, dataPointer, 12) == 0)
 8023f04:	220c      	movs	r2, #12
 8023f06:	4621      	mov	r1, r4
 8023f08:	f10d 000f 	add.w	r0, sp, #15
 8023f0c:	f005 fdfe 	bl	8029b0c <memcmp>
 8023f10:	4607      	mov	r7, r0
 8023f12:	2800      	cmp	r0, #0
 8023f14:	d13d      	bne.n	8023f92 <handler_setID+0xe6>
			newConfig.sensor_ID = dataPointer[12];
 8023f16:	7b22      	ldrb	r2, [r4, #12]
			PRINTF_APP("New config send_id: %d\n", newConfig.sensor_ID);
 8023f18:	492d      	ldr	r1, [pc, #180]	@ (8023fd0 <handler_setID+0x124>)
			newConfig.sensor_ID = dataPointer[12];
 8023f1a:	f88d 200e 	strb.w	r2, [sp, #14]
			PRINTF_APP("New config send_id: %d\n", newConfig.sensor_ID);
 8023f1e:	f004 f883 	bl	8028028 <LOG_fprintf>
			flash_save_success = Memory_SaveConfig(&newConfig);
 8023f22:	a802      	add	r0, sp, #8
 8023f24:	f003 f80c 	bl	8026f40 <Memory_SaveConfig>
			if (flash_save_success)
 8023f28:	4604      	mov	r4, r0
 8023f2a:	2800      	cmp	r0, #0
 8023f2c:	d037      	beq.n	8023f9e <handler_setID+0xf2>
				CommLink_SendData(Sensor.configuration.sensor_ID, cmd, flags, 0, 0);
 8023f2e:	f896 006e 	ldrb.w	r0, [r6, #110]	@ 0x6e
 8023f32:	9700      	str	r7, [sp, #0]
 8023f34:	463b      	mov	r3, r7
 8023f36:	2201      	movs	r2, #1
 8023f38:	4629      	mov	r1, r5
 8023f3a:	f000 ff8b 	bl	8024e54 <CommLink_SendData>
 8023f3e:	e01c      	b.n	8023f7a <handler_setID+0xce>
		uint8_t *dataPointer = CommLink_GetPrtDataFrame();
 8023f40:	f001 f8da 	bl	80250f8 <CommLink_GetPrtDataFrame>
 8023f44:	4607      	mov	r7, r0
		Memory_TakeConfig(&newConfig);
 8023f46:	a802      	add	r0, sp, #8
 8023f48:	f003 f82e 	bl	8026fa8 <Memory_TakeConfig>
		newConfig.sensor_ID = dataPointer[12];
 8023f4c:	7b3a      	ldrb	r2, [r7, #12]
		PRINTF_APP("New config send_id: %d\n", newConfig.sensor_ID);
 8023f4e:	4920      	ldr	r1, [pc, #128]	@ (8023fd0 <handler_setID+0x124>)
		newConfig.sensor_ID = dataPointer[12];
 8023f50:	f88d 200e 	strb.w	r2, [sp, #14]
		PRINTF_APP("New config send_id: %d\n", newConfig.sensor_ID);
 8023f54:	4620      	mov	r0, r4
 8023f56:	f004 f867 	bl	8028028 <LOG_fprintf>
		flash_save_success = Memory_SaveConfig(&newConfig);
 8023f5a:	a802      	add	r0, sp, #8
 8023f5c:	f002 fff0 	bl	8026f40 <Memory_SaveConfig>
		if (flash_save_success)
 8023f60:	4607      	mov	r7, r0
 8023f62:	b960      	cbnz	r0, 8023f7e <handler_setID+0xd2>
			PRINTF_APP("Flash not writen ... error");
 8023f64:	491b      	ldr	r1, [pc, #108]	@ (8023fd4 <handler_setID+0x128>)
 8023f66:	f004 f85f 	bl	8028028 <LOG_fprintf>
			CommLink_SendData(Sensor.configuration.sensor_ID, cmd, flags, 0, 0);
 8023f6a:	f896 006e 	ldrb.w	r0, [r6, #110]	@ 0x6e
 8023f6e:	9700      	str	r7, [sp, #0]
 8023f70:	2202      	movs	r2, #2
 8023f72:	463b      	mov	r3, r7
 8023f74:	4629      	mov	r1, r5
 8023f76:	f000 ff6d 	bl	8024e54 <CommLink_SendData>
}
 8023f7a:	b015      	add	sp, #84	@ 0x54
 8023f7c:	bdf0      	pop	{r4, r5, r6, r7, pc}
			CommLink_SendData(Sensor.configuration.sensor_ID, cmd, flags, 0, 0);
 8023f7e:	f896 006e 	ldrb.w	r0, [r6, #110]	@ 0x6e
 8023f82:	9400      	str	r4, [sp, #0]
 8023f84:	4623      	mov	r3, r4
 8023f86:	2201      	movs	r2, #1
 8023f88:	4629      	mov	r1, r5
 8023f8a:	f000 ff63 	bl	8024e54 <CommLink_SendData>
}
 8023f8e:	b015      	add	sp, #84	@ 0x54
 8023f90:	bdf0      	pop	{r4, r5, r6, r7, pc}
			PRINTF_APP("Config ignored: BAD MAC\n"); // dSetFlag_NACK(flags);
 8023f92:	4911      	ldr	r1, [pc, #68]	@ (8023fd8 <handler_setID+0x12c>)
 8023f94:	2000      	movs	r0, #0
 8023f96:	f004 f847 	bl	8028028 <LOG_fprintf>
}
 8023f9a:	b015      	add	sp, #84	@ 0x54
 8023f9c:	bdf0      	pop	{r4, r5, r6, r7, pc}
				PRINTF_APP("Flash not writen ... error");
 8023f9e:	490d      	ldr	r1, [pc, #52]	@ (8023fd4 <handler_setID+0x128>)
 8023fa0:	f004 f842 	bl	8028028 <LOG_fprintf>
				CommLink_SendData(Sensor.configuration.sensor_ID, cmd, flags, 0, 0);
 8023fa4:	f896 006e 	ldrb.w	r0, [r6, #110]	@ 0x6e
 8023fa8:	9400      	str	r4, [sp, #0]
 8023faa:	2202      	movs	r2, #2
 8023fac:	4623      	mov	r3, r4
 8023fae:	4629      	mov	r1, r5
 8023fb0:	f000 ff50 	bl	8024e54 <CommLink_SendData>
 8023fb4:	e7e1      	b.n	8023f7a <handler_setID+0xce>
 8023fb6:	bf00      	nop
 8023fb8:	20000008 	.word	0x20000008
 8023fbc:	0802e26c 	.word	0x0802e26c
 8023fc0:	0802e284 	.word	0x0802e284
 8023fc4:	0802ace0 	.word	0x0802ace0
 8023fc8:	0802e290 	.word	0x0802e290
 8023fcc:	0802e2f0 	.word	0x0802e2f0
 8023fd0:	0802e2bc 	.word	0x0802e2bc
 8023fd4:	0802e2d4 	.word	0x0802e2d4
 8023fd8:	0802e304 	.word	0x0802e304

08023fdc <handler_setConfig>:
{
 8023fdc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	PRINTF_APP("Set configuration\r\n");
 8023fe0:	499c      	ldr	r1, [pc, #624]	@ (8024254 <handler_setConfig+0x278>)
	if (!Sensor.addressing_by_MAC)
 8023fe2:	f8df 82a4 	ldr.w	r8, [pc, #676]	@ 8024288 <handler_setConfig+0x2ac>
{
 8023fe6:	b0a6      	sub	sp, #152	@ 0x98
 8023fe8:	4607      	mov	r7, r0
	PRINTF_APP("Set configuration\r\n");
 8023fea:	2000      	movs	r0, #0
 8023fec:	f004 f81c 	bl	8028028 <LOG_fprintf>
	uint8_t *dataPointer = CommLink_GetPrtDataFrame();
 8023ff0:	f001 f882 	bl	80250f8 <CommLink_GetPrtDataFrame>
 8023ff4:	4604      	mov	r4, r0
	uint8_t data_size = CommLink_GetDataSize();
 8023ff6:	f001 f883 	bl	8025100 <CommLink_GetDataSize>
	PRINTF_APP("Odczytano konfiguracje\r\n");
 8023ffa:	4997      	ldr	r1, [pc, #604]	@ (8024258 <handler_setConfig+0x27c>)
	uint8_t data_size = CommLink_GetDataSize();
 8023ffc:	4605      	mov	r5, r0
	PRINTF_APP("Odczytano konfiguracje\r\n");
 8023ffe:	2000      	movs	r0, #0
 8024000:	f004 f812 	bl	8028028 <LOG_fprintf>
	Memory_TakeConfig(&fromMemoryConfig);
 8024004:	a802      	add	r0, sp, #8
 8024006:	f002 ffcf 	bl	8026fa8 <Memory_TakeConfig>
	Memory_ShowConfig(&fromMemoryConfig);
 802400a:	a802      	add	r0, sp, #8
 802400c:	f002 ffdc 	bl	8026fc8 <Memory_ShowConfig>
	PRINTF_APP("Otrzymane dane w ramce:\r\n");
 8024010:	4992      	ldr	r1, [pc, #584]	@ (802425c <handler_setConfig+0x280>)
 8024012:	2000      	movs	r0, #0
 8024014:	f004 f808 	bl	8028028 <LOG_fprintf>
	if (!Sensor.addressing_by_MAC)
 8024018:	f898 6001 	ldrb.w	r6, [r8, #1]
	uint8_t data_size = CommLink_GetDataSize();
 802401c:	b2ed      	uxtb	r5, r5
	if (!Sensor.addressing_by_MAC)
 802401e:	2e00      	cmp	r6, #0
 8024020:	d16d      	bne.n	80240fe <handler_setConfig+0x122>
		PRINTF_APP("Addressing by SensorID\n");
 8024022:	498f      	ldr	r1, [pc, #572]	@ (8024260 <handler_setConfig+0x284>)
 8024024:	4630      	mov	r0, r6
 8024026:	f003 ffff 	bl	8028028 <LOG_fprintf>
		PRINTF_APP("Get config!\r\n");
 802402a:	498e      	ldr	r1, [pc, #568]	@ (8024264 <handler_setConfig+0x288>)
 802402c:	4630      	mov	r0, r6
 802402e:	f003 fffb 	bl	8028028 <LOG_fprintf>
		if (data_size == 60)
 8024032:	2d3c      	cmp	r5, #60	@ 0x3c
 8024034:	f000 80fb 	beq.w	802422e <handler_setConfig+0x252>
		else if (data_size == 36)
 8024038:	2d24      	cmp	r5, #36	@ 0x24
 802403a:	f040 80f0 	bne.w	802421e <handler_setConfig+0x242>
			PRINTF_APP("%s Data size ok! for 1 sensor\n", __FUNCTION__);
 802403e:	4a8a      	ldr	r2, [pc, #552]	@ (8024268 <handler_setConfig+0x28c>)
 8024040:	498a      	ldr	r1, [pc, #552]	@ (802426c <handler_setConfig+0x290>)
 8024042:	4630      	mov	r0, r6
 8024044:	f003 fff0 	bl	8028028 <LOG_fprintf>
			sensor = 1;
 8024048:	2301      	movs	r3, #1
		fromMemoryConfig.sensor_type[0] = *(dataPointer + 12);
 802404a:	7b22      	ldrb	r2, [r4, #12]
 802404c:	f88d 201d 	strb.w	r2, [sp, #29]
		fromMemoryConfig.sensor_type[1] = *(dataPointer + 13);
 8024050:	7b62      	ldrb	r2, [r4, #13]
 8024052:	f88d 201e 	strb.w	r2, [sp, #30]
		fromMemoryConfig.sensor_type[2] = *(dataPointer + 14);
 8024056:	7ba2      	ldrb	r2, [r4, #14]
 8024058:	f88d 201f 	strb.w	r2, [sp, #31]
		fromMemoryConfig.sensor_type[3] = *(dataPointer + 15);
 802405c:	7be2      	ldrb	r2, [r4, #15]
 802405e:	f88d 2020 	strb.w	r2, [sp, #32]
		fromMemoryConfig.sensor_type[4] = *(dataPointer + 16);
 8024062:	7c22      	ldrb	r2, [r4, #16]
 8024064:	f88d 2021 	strb.w	r2, [sp, #33]	@ 0x21
		fromMemoryConfig.sensor_type[5] = *(dataPointer + 17);
 8024068:	7c62      	ldrb	r2, [r4, #17]
 802406a:	f88d 2022 	strb.w	r2, [sp, #34]	@ 0x22
		fromMemoryConfig.sensor_type[6] = *(dataPointer + 18);
 802406e:	7ca2      	ldrb	r2, [r4, #18]
 8024070:	f88d 2023 	strb.w	r2, [sp, #35]	@ 0x23
		fromMemoryConfig.sensor_type[7] = *(dataPointer + 19);
 8024074:	7ce2      	ldrb	r2, [r4, #19]
 8024076:	f88d 2024 	strb.w	r2, [sp, #36]	@ 0x24
		fromMemoryConfig.sensor_type[8] = *(dataPointer + 20);
 802407a:	7d22      	ldrb	r2, [r4, #20]
 802407c:	f88d 2025 	strb.w	r2, [sp, #37]	@ 0x25
		fromMemoryConfig.sensor_type[9] = *(dataPointer + 21);
 8024080:	7d62      	ldrb	r2, [r4, #21]
 8024082:	f88d 2026 	strb.w	r2, [sp, #38]	@ 0x26
		fromMemoryConfig.sensor_type[10] = *(dataPointer + 22);
 8024086:	7da2      	ldrb	r2, [r4, #22]
 8024088:	f88d 2027 	strb.w	r2, [sp, #39]	@ 0x27
		fromMemoryConfig.sensor_type[11] = *(dataPointer + 23);
 802408c:	7de2      	ldrb	r2, [r4, #23]
 802408e:	f88d 2028 	strb.w	r2, [sp, #40]	@ 0x28
		if (sensor == 3)
 8024092:	2b03      	cmp	r3, #3
			memcpy(&fromMemoryConfig.X_Calibration_A, dataPointer + 24, 4);
 8024094:	69a3      	ldr	r3, [r4, #24]
 8024096:	f8cd 3029 	str.w	r3, [sp, #41]	@ 0x29
			memcpy(&fromMemoryConfig.X_Calibration_B, dataPointer + 28, 4);
 802409a:	69e3      	ldr	r3, [r4, #28]
 802409c:	f8cd 302d 	str.w	r3, [sp, #45]	@ 0x2d
			memcpy(&fromMemoryConfig.X_Calibration_Sensitivity, dataPointer + 32, 4);
 80240a0:	6a23      	ldr	r3, [r4, #32]
 80240a2:	f8cd 3031 	str.w	r3, [sp, #49]	@ 0x31
		if (sensor == 3)
 80240a6:	d111      	bne.n	80240cc <handler_setConfig+0xf0>
			memcpy(&fromMemoryConfig.Y_Calibration_A, dataPointer + 36, 4);
 80240a8:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 80240aa:	f8cd 3035 	str.w	r3, [sp, #53]	@ 0x35
			memcpy(&fromMemoryConfig.Y_Calibration_B, dataPointer + 40, 4);
 80240ae:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
 80240b0:	f8cd 3039 	str.w	r3, [sp, #57]	@ 0x39
			memcpy(&fromMemoryConfig.Y_Calibration_Sensitivity, dataPointer + 44, 4);
 80240b4:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
 80240b6:	f8cd 303d 	str.w	r3, [sp, #61]	@ 0x3d
			memcpy(&fromMemoryConfig.Z_Calibration_A, dataPointer + 48, 4);
 80240ba:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 80240bc:	f8cd 3041 	str.w	r3, [sp, #65]	@ 0x41
			memcpy(&fromMemoryConfig.Z_Calibration_B, dataPointer + 52, 4);
 80240c0:	6b63      	ldr	r3, [r4, #52]	@ 0x34
 80240c2:	f8cd 3045 	str.w	r3, [sp, #69]	@ 0x45
			memcpy(&fromMemoryConfig.Z_Calibration_Sensitivity, dataPointer + 56, 4);
 80240c6:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
 80240c8:	f8cd 3049 	str.w	r3, [sp, #73]	@ 0x49
		flash_write_success = Memory_SaveConfig(&fromMemoryConfig);
 80240cc:	a802      	add	r0, sp, #8
 80240ce:	f002 ff37 	bl	8026f40 <Memory_SaveConfig>
		PRINTF_APP("Odczytano konfiguracje po zapisie\r\n");
 80240d2:	4967      	ldr	r1, [pc, #412]	@ (8024270 <handler_setConfig+0x294>)
		flash_write_success = Memory_SaveConfig(&fromMemoryConfig);
 80240d4:	4604      	mov	r4, r0
		PRINTF_APP("Odczytano konfiguracje po zapisie\r\n");
 80240d6:	2000      	movs	r0, #0
 80240d8:	f003 ffa6 	bl	8028028 <LOG_fprintf>
		Memory_ShowConfig(&fromMemoryConfig);
 80240dc:	a802      	add	r0, sp, #8
 80240de:	f002 ff73 	bl	8026fc8 <Memory_ShowConfig>
		if (flash_write_success == true)
 80240e2:	2c00      	cmp	r4, #0
 80240e4:	f040 8090 	bne.w	8024208 <handler_setConfig+0x22c>
				CommLink_SendData(Sensor.configuration.sensor_ID, cmd, flags, 0, 0);
 80240e8:	f898 006e 	ldrb.w	r0, [r8, #110]	@ 0x6e
 80240ec:	9400      	str	r4, [sp, #0]
 80240ee:	4623      	mov	r3, r4
 80240f0:	2202      	movs	r2, #2
 80240f2:	4639      	mov	r1, r7
 80240f4:	f000 feae 	bl	8024e54 <CommLink_SendData>
}
 80240f8:	b026      	add	sp, #152	@ 0x98
 80240fa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		PRINTF_APP("Addressing by MAC\n");
 80240fe:	495d      	ldr	r1, [pc, #372]	@ (8024274 <handler_setConfig+0x298>)
 8024100:	2000      	movs	r0, #0
 8024102:	f003 ff91 	bl	8028028 <LOG_fprintf>
		if (memcmp(fromMemoryConfig.MAC, dataPointer, 12) == 0)
 8024106:	220c      	movs	r2, #12
 8024108:	4621      	mov	r1, r4
 802410a:	f10d 000f 	add.w	r0, sp, #15
 802410e:	f005 fcfd 	bl	8029b0c <memcmp>
 8024112:	4606      	mov	r6, r0
 8024114:	b130      	cbz	r0, 8024124 <handler_setConfig+0x148>
			PRINTF_APP("Config ignored: BAD MAC\n");
 8024116:	4958      	ldr	r1, [pc, #352]	@ (8024278 <handler_setConfig+0x29c>)
 8024118:	2000      	movs	r0, #0
 802411a:	f003 ff85 	bl	8028028 <LOG_fprintf>
}
 802411e:	b026      	add	sp, #152	@ 0x98
 8024120:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			PRINTF_APP("Config: MAC ok!\n");
 8024124:	4955      	ldr	r1, [pc, #340]	@ (802427c <handler_setConfig+0x2a0>)
 8024126:	f003 ff7f 	bl	8028028 <LOG_fprintf>
			PRINTF_APP("Otrzymane dane w ramce:\r\n");
 802412a:	494c      	ldr	r1, [pc, #304]	@ (802425c <handler_setConfig+0x280>)
 802412c:	4630      	mov	r0, r6
 802412e:	f003 ff7b 	bl	8028028 <LOG_fprintf>
			PRINTF_APP("Addressing by SensorID\n");
 8024132:	494b      	ldr	r1, [pc, #300]	@ (8024260 <handler_setConfig+0x284>)
 8024134:	4630      	mov	r0, r6
 8024136:	f003 ff77 	bl	8028028 <LOG_fprintf>
			PRINTF_APP("Get config!\r\n");
 802413a:	494a      	ldr	r1, [pc, #296]	@ (8024264 <handler_setConfig+0x288>)
 802413c:	4630      	mov	r0, r6
 802413e:	f003 ff73 	bl	8028028 <LOG_fprintf>
			if (data_size == 60)
 8024142:	2d3c      	cmp	r5, #60	@ 0x3c
				PRINTF_APP("%s Data size ok! for 3 sensor\n", __FUNCTION__);
 8024144:	4a48      	ldr	r2, [pc, #288]	@ (8024268 <handler_setConfig+0x28c>)
			if (data_size == 60)
 8024146:	d079      	beq.n	802423c <handler_setConfig+0x260>
			else if (data_size == 36)
 8024148:	2d24      	cmp	r5, #36	@ 0x24
 802414a:	d17d      	bne.n	8024248 <handler_setConfig+0x26c>
				PRINTF_APP("%s Data size ok! for 1 sensor\n", __FUNCTION__);
 802414c:	4947      	ldr	r1, [pc, #284]	@ (802426c <handler_setConfig+0x290>)
 802414e:	4630      	mov	r0, r6
 8024150:	f003 ff6a 	bl	8028028 <LOG_fprintf>
				sensor = 1;
 8024154:	2501      	movs	r5, #1
			PRINTF_APP("Odczytano konfiguracje\r\n");
 8024156:	4940      	ldr	r1, [pc, #256]	@ (8024258 <handler_setConfig+0x27c>)
 8024158:	2000      	movs	r0, #0
 802415a:	f003 ff65 	bl	8028028 <LOG_fprintf>
			Memory_TakeConfig(&fromMemoryConfig);
 802415e:	a814      	add	r0, sp, #80	@ 0x50
 8024160:	f002 ff22 	bl	8026fa8 <Memory_TakeConfig>
			Memory_ShowConfig(&fromMemoryConfig);
 8024164:	a814      	add	r0, sp, #80	@ 0x50
 8024166:	f002 ff2f 	bl	8026fc8 <Memory_ShowConfig>
			fromMemoryConfig.sensor_type[0] = *(dataPointer + 12);
 802416a:	7b23      	ldrb	r3, [r4, #12]
 802416c:	f88d 3065 	strb.w	r3, [sp, #101]	@ 0x65
			fromMemoryConfig.sensor_type[1] = *(dataPointer + 13);
 8024170:	7b63      	ldrb	r3, [r4, #13]
 8024172:	f88d 3066 	strb.w	r3, [sp, #102]	@ 0x66
			fromMemoryConfig.sensor_type[2] = *(dataPointer + 14);
 8024176:	7ba3      	ldrb	r3, [r4, #14]
 8024178:	f88d 3067 	strb.w	r3, [sp, #103]	@ 0x67
			fromMemoryConfig.sensor_type[3] = *(dataPointer + 15);
 802417c:	7be3      	ldrb	r3, [r4, #15]
 802417e:	f88d 3068 	strb.w	r3, [sp, #104]	@ 0x68
			fromMemoryConfig.sensor_type[4] = *(dataPointer + 16);
 8024182:	7c23      	ldrb	r3, [r4, #16]
 8024184:	f88d 3069 	strb.w	r3, [sp, #105]	@ 0x69
			fromMemoryConfig.sensor_type[5] = *(dataPointer + 17);
 8024188:	7c63      	ldrb	r3, [r4, #17]
 802418a:	f88d 306a 	strb.w	r3, [sp, #106]	@ 0x6a
			fromMemoryConfig.sensor_type[6] = *(dataPointer + 18);
 802418e:	7ca3      	ldrb	r3, [r4, #18]
 8024190:	f88d 306b 	strb.w	r3, [sp, #107]	@ 0x6b
			fromMemoryConfig.sensor_type[7] = *(dataPointer + 19);
 8024194:	7ce3      	ldrb	r3, [r4, #19]
 8024196:	f88d 306c 	strb.w	r3, [sp, #108]	@ 0x6c
			fromMemoryConfig.sensor_type[8] = *(dataPointer + 20);
 802419a:	7d23      	ldrb	r3, [r4, #20]
 802419c:	f88d 306d 	strb.w	r3, [sp, #109]	@ 0x6d
			fromMemoryConfig.sensor_type[9] = *(dataPointer + 21);
 80241a0:	7d63      	ldrb	r3, [r4, #21]
 80241a2:	f88d 306e 	strb.w	r3, [sp, #110]	@ 0x6e
			fromMemoryConfig.sensor_type[10] = *(dataPointer + 22);
 80241a6:	7da3      	ldrb	r3, [r4, #22]
 80241a8:	f88d 306f 	strb.w	r3, [sp, #111]	@ 0x6f
			fromMemoryConfig.sensor_type[11] = *(dataPointer + 23);
 80241ac:	7de3      	ldrb	r3, [r4, #23]
 80241ae:	f88d 3070 	strb.w	r3, [sp, #112]	@ 0x70
				memcpy(&fromMemoryConfig.X_Calibration_A, dataPointer + 24, 4);
 80241b2:	69a3      	ldr	r3, [r4, #24]
 80241b4:	f8cd 3071 	str.w	r3, [sp, #113]	@ 0x71
				memcpy(&fromMemoryConfig.X_Calibration_B, dataPointer + 28, 4);
 80241b8:	69e3      	ldr	r3, [r4, #28]
 80241ba:	f8cd 3075 	str.w	r3, [sp, #117]	@ 0x75
				memcpy(&fromMemoryConfig.X_Calibration_Sensitivity, dataPointer + 32, 4);
 80241be:	6a23      	ldr	r3, [r4, #32]
 80241c0:	f8cd 3079 	str.w	r3, [sp, #121]	@ 0x79
			if (sensor == 3)
 80241c4:	2d03      	cmp	r5, #3
 80241c6:	d111      	bne.n	80241ec <handler_setConfig+0x210>
				memcpy(&fromMemoryConfig.Y_Calibration_A, dataPointer + 36, 4);
 80241c8:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 80241ca:	f8cd 307d 	str.w	r3, [sp, #125]	@ 0x7d
				memcpy(&fromMemoryConfig.Y_Calibration_B, dataPointer + 40, 4);
 80241ce:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
 80241d0:	f8cd 3081 	str.w	r3, [sp, #129]	@ 0x81
				memcpy(&fromMemoryConfig.Y_Calibration_Sensitivity, dataPointer + 44, 4);
 80241d4:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
 80241d6:	f8cd 3085 	str.w	r3, [sp, #133]	@ 0x85
				memcpy(&fromMemoryConfig.Z_Calibration_A, dataPointer + 48, 4);
 80241da:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 80241dc:	f8cd 3089 	str.w	r3, [sp, #137]	@ 0x89
				memcpy(&fromMemoryConfig.Z_Calibration_B, dataPointer + 52, 4);
 80241e0:	6b63      	ldr	r3, [r4, #52]	@ 0x34
 80241e2:	f8cd 308d 	str.w	r3, [sp, #141]	@ 0x8d
				memcpy(&fromMemoryConfig.Z_Calibration_Sensitivity, dataPointer + 56, 4);
 80241e6:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
 80241e8:	f8cd 3091 	str.w	r3, [sp, #145]	@ 0x91
			flash_write_success = Memory_SaveConfig(&fromMemoryConfig);
 80241ec:	a814      	add	r0, sp, #80	@ 0x50
 80241ee:	f002 fea7 	bl	8026f40 <Memory_SaveConfig>
			PRINTF_APP("Odczytano konfiguracje po zapisie\r\n");
 80241f2:	491f      	ldr	r1, [pc, #124]	@ (8024270 <handler_setConfig+0x294>)
			flash_write_success = Memory_SaveConfig(&fromMemoryConfig);
 80241f4:	4604      	mov	r4, r0
			PRINTF_APP("Odczytano konfiguracje po zapisie\r\n");
 80241f6:	2000      	movs	r0, #0
 80241f8:	f003 ff16 	bl	8028028 <LOG_fprintf>
			Memory_ShowConfig(&fromMemoryConfig);
 80241fc:	a814      	add	r0, sp, #80	@ 0x50
 80241fe:	f002 fee3 	bl	8026fc8 <Memory_ShowConfig>
			if (flash_write_success == true)
 8024202:	2c00      	cmp	r4, #0
 8024204:	f43f af70 	beq.w	80240e8 <handler_setConfig+0x10c>
				CommLink_SendData(Sensor.configuration.sensor_ID, cmd, flags, 0, 0);
 8024208:	2300      	movs	r3, #0
 802420a:	f898 006e 	ldrb.w	r0, [r8, #110]	@ 0x6e
 802420e:	9300      	str	r3, [sp, #0]
 8024210:	2201      	movs	r2, #1
 8024212:	4639      	mov	r1, r7
 8024214:	f000 fe1e 	bl	8024e54 <CommLink_SendData>
}
 8024218:	b026      	add	sp, #152	@ 0x98
 802421a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			PRINTF_APP("%s Data size not ok  at all ! \n", __FUNCTION__);
 802421e:	4a12      	ldr	r2, [pc, #72]	@ (8024268 <handler_setConfig+0x28c>)
 8024220:	4917      	ldr	r1, [pc, #92]	@ (8024280 <handler_setConfig+0x2a4>)
 8024222:	4630      	mov	r0, r6
 8024224:	f003 ff00 	bl	8028028 <LOG_fprintf>
}
 8024228:	b026      	add	sp, #152	@ 0x98
 802422a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			PRINTF_APP("%s Data size ok! for 3 sensor\n", __FUNCTION__);
 802422e:	4a0e      	ldr	r2, [pc, #56]	@ (8024268 <handler_setConfig+0x28c>)
 8024230:	4914      	ldr	r1, [pc, #80]	@ (8024284 <handler_setConfig+0x2a8>)
 8024232:	4630      	mov	r0, r6
 8024234:	f003 fef8 	bl	8028028 <LOG_fprintf>
			sensor = 3;
 8024238:	2303      	movs	r3, #3
 802423a:	e706      	b.n	802404a <handler_setConfig+0x6e>
				PRINTF_APP("%s Data size ok! for 3 sensor\n", __FUNCTION__);
 802423c:	4911      	ldr	r1, [pc, #68]	@ (8024284 <handler_setConfig+0x2a8>)
 802423e:	4630      	mov	r0, r6
 8024240:	f003 fef2 	bl	8028028 <LOG_fprintf>
				sensor = 3;
 8024244:	2503      	movs	r5, #3
 8024246:	e786      	b.n	8024156 <handler_setConfig+0x17a>
				PRINTF_APP("%s Data size not ok  at all ! \n", __FUNCTION__);
 8024248:	490d      	ldr	r1, [pc, #52]	@ (8024280 <handler_setConfig+0x2a4>)
 802424a:	4630      	mov	r0, r6
 802424c:	f003 feec 	bl	8028028 <LOG_fprintf>
				return;
 8024250:	e765      	b.n	802411e <handler_setConfig+0x142>
 8024252:	bf00      	nop
 8024254:	0802e320 	.word	0x0802e320
 8024258:	0802e334 	.word	0x0802e334
 802425c:	0802e350 	.word	0x0802e350
 8024260:	0802e26c 	.word	0x0802e26c
 8024264:	0802e36c 	.word	0x0802e36c
 8024268:	0802acf0 	.word	0x0802acf0
 802426c:	0802e39c 	.word	0x0802e39c
 8024270:	0802e3dc 	.word	0x0802e3dc
 8024274:	0802e2f0 	.word	0x0802e2f0
 8024278:	0802e304 	.word	0x0802e304
 802427c:	0802e400 	.word	0x0802e400
 8024280:	0802e3bc 	.word	0x0802e3bc
 8024284:	0802e37c 	.word	0x0802e37c
 8024288:	20000008 	.word	0x20000008

0802428c <handler_getConfig>:
{
 802428c:	b5f0      	push	{r4, r5, r6, r7, lr}
 802428e:	b0ad      	sub	sp, #180	@ 0xb4
 8024290:	4605      	mov	r5, r0
	uint8_t *dataPointer = CommLink_GetPrtDataFrame();
 8024292:	f000 ff31 	bl	80250f8 <CommLink_GetPrtDataFrame>
	if (Sensor.addressing_by_MAC)
 8024296:	4c74      	ldr	r4, [pc, #464]	@ (8024468 <handler_getConfig+0x1dc>)
	PRINTF_APP("Odczytano konfiguracje\r\n");
 8024298:	4974      	ldr	r1, [pc, #464]	@ (802446c <handler_getConfig+0x1e0>)
	uint8_t *dataPointer = CommLink_GetPrtDataFrame();
 802429a:	4606      	mov	r6, r0
	PRINTF_APP("Odczytano konfiguracje\r\n");
 802429c:	2000      	movs	r0, #0
 802429e:	f003 fec3 	bl	8028028 <LOG_fprintf>
	Memory_TakeConfig(&fromMemoryConfig);
 80242a2:	a802      	add	r0, sp, #8
 80242a4:	f002 fe80 	bl	8026fa8 <Memory_TakeConfig>
	if (Sensor.addressing_by_MAC)
 80242a8:	7867      	ldrb	r7, [r4, #1]
		PRINTF_APP("Addressing by SensorID\n");
 80242aa:	4971      	ldr	r1, [pc, #452]	@ (8024470 <handler_getConfig+0x1e4>)
	if (Sensor.addressing_by_MAC)
 80242ac:	2f00      	cmp	r7, #0
 80242ae:	d06e      	beq.n	802438e <handler_getConfig+0x102>
		PRINTF_APP("Addressing by SensorID\n");
 80242b0:	2000      	movs	r0, #0
 80242b2:	f003 feb9 	bl	8028028 <LOG_fprintf>
		PRINTF_APP("COMM_APP: Get configuration\r\n");
 80242b6:	496f      	ldr	r1, [pc, #444]	@ (8024474 <handler_getConfig+0x1e8>)
 80242b8:	2000      	movs	r0, #0
 80242ba:	f003 feb5 	bl	8028028 <LOG_fprintf>
		if (memcmp(fromMemoryConfig.MAC, dataPointer, 12) == 0)
 80242be:	4631      	mov	r1, r6
 80242c0:	220c      	movs	r2, #12
 80242c2:	f10d 000f 	add.w	r0, sp, #15
 80242c6:	f005 fc21 	bl	8029b0c <memcmp>
 80242ca:	4606      	mov	r6, r0
 80242cc:	2800      	cmp	r0, #0
 80242ce:	f040 80c5 	bne.w	802445c <handler_getConfig+0x1d0>
			PRINTF_APP("Addressing by SensorID\n");
 80242d2:	4967      	ldr	r1, [pc, #412]	@ (8024470 <handler_getConfig+0x1e4>)
 80242d4:	f003 fea8 	bl	8028028 <LOG_fprintf>
			PRINTF_APP("COMM_APP: Get configuration\r\n");
 80242d8:	4630      	mov	r0, r6
 80242da:	4966      	ldr	r1, [pc, #408]	@ (8024474 <handler_getConfig+0x1e8>)
 80242dc:	f003 fea4 	bl	8028028 <LOG_fprintf>
			memcpy(Conf_Table.MAC, &Sensor.configuration.MAC, 12);
 80242e0:	f8d4 006f 	ldr.w	r0, [r4, #111]	@ 0x6f
 80242e4:	f8d4 1073 	ldr.w	r1, [r4, #115]	@ 0x73
 80242e8:	f8d4 2077 	ldr.w	r2, [r4, #119]	@ 0x77
 80242ec:	ab14      	add	r3, sp, #80	@ 0x50
 80242ee:	c307      	stmia	r3!, {r0, r1, r2}
			memcpy(Conf_Table.sensor_type, &fromMemoryConfig.sensor_type, 12);
 80242f0:	f8dd 001d 	ldr.w	r0, [sp, #29]
 80242f4:	f8dd 1021 	ldr.w	r1, [sp, #33]	@ 0x21
 80242f8:	f8dd 2025 	ldr.w	r2, [sp, #37]	@ 0x25
 80242fc:	c307      	stmia	r3!, {r0, r1, r2}
			Conf_Table.RS485_speed = Sensor.configuration.RS485_speed;
 80242fe:	f894 107b 	ldrb.w	r1, [r4, #123]	@ 0x7b
			Conf_Table.DataBufferSize = Sensor.parameters.DataBufferSize;
 8024302:	6a23      	ldr	r3, [r4, #32]
			Conf_Table.SampleRate = Sensor.parameters.SampleRate;
 8024304:	8ca2      	ldrh	r2, [r4, #36]	@ 0x24
			Conf_Table.RS485_speed = Sensor.configuration.RS485_speed;
 8024306:	f88d 1068 	strb.w	r1, [sp, #104]	@ 0x68
			CommLink_SendData(Sensor.configuration.sensor_ID, cmd, flags, (const void *)&Conf_Table, sizeof(Conf_Table));
 802430a:	4629      	mov	r1, r5
 802430c:	255f      	movs	r5, #95	@ 0x5f
			Conf_Table.DataBufferSize = Sensor.parameters.DataBufferSize;
 802430e:	f8cd 3069 	str.w	r3, [sp, #105]	@ 0x69
			Conf_Table.SampleRate = Sensor.parameters.SampleRate;
 8024312:	f8ad 206d 	strh.w	r2, [sp, #109]	@ 0x6d
			Conf_Table.BitResolution = Sensor.parameters.BitResolution;
 8024316:	f8d4 3026 	ldr.w	r3, [r4, #38]	@ 0x26
 802431a:	f8cd 306f 	str.w	r3, [sp, #111]	@ 0x6f
			Conf_Table.X_Calibration_A = Sensor.parameters.X_Calibration_A;
 802431e:	e9d4 0213 	ldrd	r0, r2, [r4, #76]	@ 0x4c
			CommLink_SendData(Sensor.configuration.sensor_ID, cmd, flags, (const void *)&Conf_Table, sizeof(Conf_Table));
 8024322:	9500      	str	r5, [sp, #0]
			Conf_Table.X_Calibration_A = Sensor.parameters.X_Calibration_A;
 8024324:	6b25      	ldr	r5, [r4, #48]	@ 0x30
 8024326:	f8cd 5077 	str.w	r5, [sp, #119]	@ 0x77
 802432a:	6b65      	ldr	r5, [r4, #52]	@ 0x34
 802432c:	f8cd 507b 	str.w	r5, [sp, #123]	@ 0x7b
 8024330:	6ba5      	ldr	r5, [r4, #56]	@ 0x38
 8024332:	f8cd 507f 	str.w	r5, [sp, #127]	@ 0x7f
 8024336:	6be5      	ldr	r5, [r4, #60]	@ 0x3c
 8024338:	f8cd 5083 	str.w	r5, [sp, #131]	@ 0x83
 802433c:	6c25      	ldr	r5, [r4, #64]	@ 0x40
 802433e:	f8cd 5087 	str.w	r5, [sp, #135]	@ 0x87
 8024342:	6c65      	ldr	r5, [r4, #68]	@ 0x44
 8024344:	f8cd 2097 	str.w	r2, [sp, #151]	@ 0x97
 8024348:	6d62      	ldr	r2, [r4, #84]	@ 0x54
 802434a:	f8cd 508b 	str.w	r5, [sp, #139]	@ 0x8b
 802434e:	f8cd 209b 	str.w	r2, [sp, #155]	@ 0x9b
 8024352:	6ca5      	ldr	r5, [r4, #72]	@ 0x48
 8024354:	6da2      	ldr	r2, [r4, #88]	@ 0x58
 8024356:	f8cd 508f 	str.w	r5, [sp, #143]	@ 0x8f
 802435a:	f8cd 209f 	str.w	r2, [sp, #159]	@ 0x9f
 802435e:	6e25      	ldr	r5, [r4, #96]	@ 0x60
 8024360:	6de2      	ldr	r2, [r4, #92]	@ 0x5c
 8024362:	f8cd 0093 	str.w	r0, [sp, #147]	@ 0x93
			CommLink_SendData(Sensor.configuration.sensor_ID, cmd, flags, (const void *)&Conf_Table, sizeof(Conf_Table));
 8024366:	ab14      	add	r3, sp, #80	@ 0x50
			Conf_Table.X_Calibration_A = Sensor.parameters.X_Calibration_A;
 8024368:	f8cd 20a3 	str.w	r2, [sp, #163]	@ 0xa3
 802436c:	f8cd 50a7 	str.w	r5, [sp, #167]	@ 0xa7
			CommLink_SendData(Sensor.configuration.sensor_ID, cmd, flags, (const void *)&Conf_Table, sizeof(Conf_Table));
 8024370:	2201      	movs	r2, #1
			Conf_Table.X_Calibration_A = Sensor.parameters.X_Calibration_A;
 8024372:	6e65      	ldr	r5, [r4, #100]	@ 0x64
			CommLink_SendData(Sensor.configuration.sensor_ID, cmd, flags, (const void *)&Conf_Table, sizeof(Conf_Table));
 8024374:	f894 006e 	ldrb.w	r0, [r4, #110]	@ 0x6e
			Conf_Table.X_Calibration_A = Sensor.parameters.X_Calibration_A;
 8024378:	6ae4      	ldr	r4, [r4, #44]	@ 0x2c
 802437a:	f8cd 4073 	str.w	r4, [sp, #115]	@ 0x73
 802437e:	f8cd 50ab 	str.w	r5, [sp, #171]	@ 0xab
			CommLink_SendData(Sensor.configuration.sensor_ID, cmd, flags, (const void *)&Conf_Table, sizeof(Conf_Table));
 8024382:	f000 fd67 	bl	8024e54 <CommLink_SendData>
			ACQ_Stop();
 8024386:	f7ff fa77 	bl	8023878 <ACQ_Stop>
}
 802438a:	b02d      	add	sp, #180	@ 0xb4
 802438c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		PRINTF_APP("Addressing by SensorID\n");
 802438e:	4638      	mov	r0, r7
 8024390:	f003 fe4a 	bl	8028028 <LOG_fprintf>
		PRINTF_APP("COMM_APP: Get configuration\r\n");
 8024394:	4638      	mov	r0, r7
 8024396:	4937      	ldr	r1, [pc, #220]	@ (8024474 <handler_getConfig+0x1e8>)
 8024398:	f003 fe46 	bl	8028028 <LOG_fprintf>
		memcpy(Conf_Table, &Sensor.configuration.MAC, 12);
 802439c:	f8d4 006f 	ldr.w	r0, [r4, #111]	@ 0x6f
 80243a0:	f8d4 1073 	ldr.w	r1, [r4, #115]	@ 0x73
 80243a4:	f8d4 2077 	ldr.w	r2, [r4, #119]	@ 0x77
 80243a8:	ab14      	add	r3, sp, #80	@ 0x50
 80243aa:	c307      	stmia	r3!, {r0, r1, r2}
		memcpy(Conf_Table + 12, &fromMemoryConfig.sensor_type, 12);
 80243ac:	f8dd 001d 	ldr.w	r0, [sp, #29]
 80243b0:	f8dd 1021 	ldr.w	r1, [sp, #33]	@ 0x21
 80243b4:	f8dd 2025 	ldr.w	r2, [sp, #37]	@ 0x25
 80243b8:	c307      	stmia	r3!, {r0, r1, r2}
		memcpy(Conf_Table + 24, &Sensor.configuration.RS485_speed, 1);
 80243ba:	f894 207b 	ldrb.w	r2, [r4, #123]	@ 0x7b
		memcpy(Conf_Table + 25, &Sensor.parameters.DataBufferSize, 4);
 80243be:	6a23      	ldr	r3, [r4, #32]
		memcpy(Conf_Table + 24, &Sensor.configuration.RS485_speed, 1);
 80243c0:	f88d 2068 	strb.w	r2, [sp, #104]	@ 0x68
		memcpy(Conf_Table + 25, &Sensor.parameters.DataBufferSize, 4);
 80243c4:	f8cd 3069 	str.w	r3, [sp, #105]	@ 0x69
		memcpy(Conf_Table + 31, &Sensor.parameters.BitResolution, 1);
 80243c8:	f8d4 2026 	ldr.w	r2, [r4, #38]	@ 0x26
		memcpy(Conf_Table + 35, &fromMemoryConfig.X_Calibration_A, 4);
 80243cc:	f8dd 302d 	ldr.w	r3, [sp, #45]	@ 0x2d
		memcpy(Conf_Table + 29, &Sensor.parameters.SampleRate, 2);
 80243d0:	8ca1      	ldrh	r1, [r4, #36]	@ 0x24
		memcpy(Conf_Table + 35, &fromMemoryConfig.X_Calibration_A, 4);
 80243d2:	f8cd 3077 	str.w	r3, [sp, #119]	@ 0x77
		memcpy(Conf_Table + 31, &Sensor.parameters.BitResolution, 1);
 80243d6:	f8cd 206f 	str.w	r2, [sp, #111]	@ 0x6f
		memcpy(Conf_Table + 43, &Sensor.parameters.X_Calibration_Gain, 4);
 80243da:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
 80243dc:	6b62      	ldr	r2, [r4, #52]	@ 0x34
 80243de:	f8cd 307f 	str.w	r3, [sp, #127]	@ 0x7f
		memcpy(Conf_Table + 29, &Sensor.parameters.SampleRate, 2);
 80243e2:	f8ad 106d 	strh.w	r1, [sp, #109]	@ 0x6d
		memcpy(Conf_Table + 51, &fromMemoryConfig.X_Calibration_Sensitivity, 4);
 80243e6:	f8dd 3035 	ldr.w	r3, [sp, #53]	@ 0x35
		memcpy(Conf_Table + 35, &fromMemoryConfig.X_Calibration_A, 4);
 80243ea:	f8dd 1029 	ldr.w	r1, [sp, #41]	@ 0x29
		memcpy(Conf_Table + 43, &Sensor.parameters.X_Calibration_Gain, 4);
 80243ee:	f8cd 207b 	str.w	r2, [sp, #123]	@ 0x7b
		memcpy(Conf_Table + 51, &fromMemoryConfig.X_Calibration_Sensitivity, 4);
 80243f2:	f8dd 2031 	ldr.w	r2, [sp, #49]	@ 0x31
 80243f6:	f8dd 0039 	ldr.w	r0, [sp, #57]	@ 0x39
		memcpy(Conf_Table + 35, &fromMemoryConfig.X_Calibration_A, 4);
 80243fa:	f8cd 1073 	str.w	r1, [sp, #115]	@ 0x73
		memcpy(Conf_Table + 51, &fromMemoryConfig.X_Calibration_Sensitivity, 4);
 80243fe:	f8cd 2083 	str.w	r2, [sp, #131]	@ 0x83
 8024402:	f8cd 3087 	str.w	r3, [sp, #135]	@ 0x87
		memcpy(Conf_Table + 63, &Sensor.parameters.Y_Calibration_Gain, 4);
 8024406:	e9d4 3212 	ldrd	r3, r2, [r4, #72]	@ 0x48
 802440a:	f8cd 308f 	str.w	r3, [sp, #143]	@ 0x8f
		memcpy(Conf_Table + 71, &fromMemoryConfig.Y_Calibration_Sensitivity, 4);
 802440e:	f8dd 3041 	ldr.w	r3, [sp, #65]	@ 0x41
 8024412:	f8cd 309b 	str.w	r3, [sp, #155]	@ 0x9b
		memcpy(Conf_Table + 63, &Sensor.parameters.Y_Calibration_Gain, 4);
 8024416:	f8cd 2093 	str.w	r2, [sp, #147]	@ 0x93
		memcpy(Conf_Table + 71, &fromMemoryConfig.Y_Calibration_Sensitivity, 4);
 802441a:	f8dd 303d 	ldr.w	r3, [sp, #61]	@ 0x3d
 802441e:	f8cd 3097 	str.w	r3, [sp, #151]	@ 0x97
		CommLink_SendData(Sensor.configuration.sensor_ID, cmd, flags, Conf_Table, 95);
 8024422:	225f      	movs	r2, #95	@ 0x5f
		memcpy(Conf_Table + 83, &Sensor.parameters.Z_Calibration_Gain, 4);
 8024424:	6e23      	ldr	r3, [r4, #96]	@ 0x60
		CommLink_SendData(Sensor.configuration.sensor_ID, cmd, flags, Conf_Table, 95);
 8024426:	9200      	str	r2, [sp, #0]
		memcpy(Conf_Table + 91, &fromMemoryConfig.Z_Calibration_Sensitivity, 4);
 8024428:	f8dd 2049 	ldr.w	r2, [sp, #73]	@ 0x49
		memcpy(Conf_Table + 51, &fromMemoryConfig.X_Calibration_Sensitivity, 4);
 802442c:	f8cd 008b 	str.w	r0, [sp, #139]	@ 0x8b
		memcpy(Conf_Table + 91, &fromMemoryConfig.Z_Calibration_Sensitivity, 4);
 8024430:	f8cd 20ab 	str.w	r2, [sp, #171]	@ 0xab
		memcpy(Conf_Table + 71, &fromMemoryConfig.Y_Calibration_Sensitivity, 4);
 8024434:	f8dd 0045 	ldr.w	r0, [sp, #69]	@ 0x45
		memcpy(Conf_Table + 83, &Sensor.parameters.Z_Calibration_Gain, 4);
 8024438:	6de2      	ldr	r2, [r4, #92]	@ 0x5c
 802443a:	f8cd 30a7 	str.w	r3, [sp, #167]	@ 0xa7
		CommLink_SendData(Sensor.configuration.sensor_ID, cmd, flags, Conf_Table, 95);
 802443e:	4629      	mov	r1, r5
 8024440:	ab14      	add	r3, sp, #80	@ 0x50
		memcpy(Conf_Table + 71, &fromMemoryConfig.Y_Calibration_Sensitivity, 4);
 8024442:	f8cd 009f 	str.w	r0, [sp, #159]	@ 0x9f
		memcpy(Conf_Table + 83, &Sensor.parameters.Z_Calibration_Gain, 4);
 8024446:	f8cd 20a3 	str.w	r2, [sp, #163]	@ 0xa3
		CommLink_SendData(Sensor.configuration.sensor_ID, cmd, flags, Conf_Table, 95);
 802444a:	f894 006e 	ldrb.w	r0, [r4, #110]	@ 0x6e
 802444e:	2201      	movs	r2, #1
 8024450:	f000 fd00 	bl	8024e54 <CommLink_SendData>
		ACQ_Stop();
 8024454:	f7ff fa10 	bl	8023878 <ACQ_Stop>
}
 8024458:	b02d      	add	sp, #180	@ 0xb4
 802445a:	bdf0      	pop	{r4, r5, r6, r7, pc}
			PRINTF_APP("GetConf ignored: BAD MAC\n");
 802445c:	4906      	ldr	r1, [pc, #24]	@ (8024478 <handler_getConfig+0x1ec>)
 802445e:	2000      	movs	r0, #0
 8024460:	f003 fde2 	bl	8028028 <LOG_fprintf>
}
 8024464:	b02d      	add	sp, #180	@ 0xb4
 8024466:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8024468:	20000008 	.word	0x20000008
 802446c:	0802e334 	.word	0x0802e334
 8024470:	0802e26c 	.word	0x0802e26c
 8024474:	0802e414 	.word	0x0802e414
 8024478:	0802e434 	.word	0x0802e434

0802447c <swap_t>:

void swap_t(uint8_t cmd)
{
 802447c:	b5f0      	push	{r4, r5, r6, r7, lr}
	AdiConf_t newConfig;
	Memory_TakeConfig(&newConfig);
	switch (Protocol)
 802447e:	4c24      	ldr	r4, [pc, #144]	@ (8024510 <swap_t+0x94>)
{
 8024480:	b095      	sub	sp, #84	@ 0x54
 8024482:	4607      	mov	r7, r0
	Memory_TakeConfig(&newConfig);
 8024484:	a802      	add	r0, sp, #8
 8024486:	f002 fd8f 	bl	8026fa8 <Memory_TakeConfig>
	switch (Protocol)
 802448a:	7826      	ldrb	r6, [r4, #0]
 802448c:	bbb6      	cbnz	r6, 80244fc <swap_t+0x80>
	{
	case SLS:
		Protocol = MODBUS;
 802448e:	2301      	movs	r3, #1
 8024490:	7023      	strb	r3, [r4, #0]
		newConfig.RS485_speed = speed_9600;
 8024492:	2330      	movs	r3, #48	@ 0x30
 8024494:	f88d 301b 	strb.w	r3, [sp, #27]
		modbus_coils_table[1].coil_state = false;
 8024498:	4b1e      	ldr	r3, [pc, #120]	@ (8024514 <swap_t+0x98>)
		flushSLSBuffer();
		CommLink_SendData(Sensor.configuration.sensor_ID, cmd, 0, 0, 0);
 802449a:	4d1f      	ldr	r5, [pc, #124]	@ (8024518 <swap_t+0x9c>)
		modbus_coils_table[1].coil_state = false;
 802449c:	719e      	strb	r6, [r3, #6]
		flushSLSBuffer();
 802449e:	f001 f8d3 	bl	8025648 <flushSLSBuffer>
		CommLink_SendData(Sensor.configuration.sensor_ID, cmd, 0, 0, 0);
 80244a2:	9600      	str	r6, [sp, #0]
 80244a4:	f895 006e 	ldrb.w	r0, [r5, #110]	@ 0x6e
 80244a8:	4639      	mov	r1, r7
 80244aa:	4633      	mov	r3, r6
 80244ac:	4632      	mov	r2, r6
 80244ae:	f000 fcd1 	bl	8024e54 <CommLink_SendData>
		Protocol = SLS;
		newConfig.RS485_speed = speed_1500k;
		modbusRTU_BufferFlush();
		break;
	}
	newConfig.protocol = Protocol;
 80244b2:	7823      	ldrb	r3, [r4, #0]
 80244b4:	f88d 301c 	strb.w	r3, [sp, #28]
	Memory_SaveConfig(&newConfig);
 80244b8:	a802      	add	r0, sp, #8
 80244ba:	f002 fd41 	bl	8026f40 <Memory_SaveConfig>
	PRINTF_APP("Protocol changed to: %s \n", enum2str(Protocol));
 80244be:	7820      	ldrb	r0, [r4, #0]
 80244c0:	f003 fda2 	bl	8028008 <enum2str>
 80244c4:	4915      	ldr	r1, [pc, #84]	@ (802451c <swap_t+0xa0>)
 80244c6:	4602      	mov	r2, r0
 80244c8:	2000      	movs	r0, #0
 80244ca:	f003 fdad 	bl	8028028 <LOG_fprintf>
    Sensor.configuration.sensor_ID = newConfig.sensor_ID;
    memcpy(Sensor.configuration.MAC, newConfig.MAC, 12);
 80244ce:	4b14      	ldr	r3, [pc, #80]	@ (8024520 <swap_t+0xa4>)
 80244d0:	f8dd 200f 	ldr.w	r2, [sp, #15]
 80244d4:	f8c5 206f 	str.w	r2, [r5, #111]	@ 0x6f
 80244d8:	f8dd 2013 	ldr.w	r2, [sp, #19]
 80244dc:	605a      	str	r2, [r3, #4]
    Sensor.configuration.sensor_ID = newConfig.sensor_ID;
 80244de:	f89d 100e 	ldrb.w	r1, [sp, #14]
    memcpy(Sensor.configuration.MAC, newConfig.MAC, 12);
 80244e2:	f8dd 0017 	ldr.w	r0, [sp, #23]
    Sensor.configuration.RS485_speed = newConfig.RS485_speed;
 80244e6:	f89d 201b 	ldrb.w	r2, [sp, #27]
    memcpy(Sensor.configuration.MAC, newConfig.MAC, 12);
 80244ea:	6098      	str	r0, [r3, #8]
    Sensor.configuration.sensor_ID = newConfig.sensor_ID;
 80244ec:	f885 106e 	strb.w	r1, [r5, #110]	@ 0x6e
    Sensor.configuration.RS485_speed = newConfig.RS485_speed;
 80244f0:	f885 207b 	strb.w	r2, [r5, #123]	@ 0x7b
	ACQ_Init();
 80244f4:	f7ff f94a 	bl	802378c <ACQ_Init>
}
 80244f8:	b015      	add	sp, #84	@ 0x54
 80244fa:	bdf0      	pop	{r4, r5, r6, r7, pc}
		Protocol = SLS;
 80244fc:	2200      	movs	r2, #0
		newConfig.RS485_speed = speed_1500k;
 80244fe:	23d0      	movs	r3, #208	@ 0xd0
		Protocol = SLS;
 8024500:	7022      	strb	r2, [r4, #0]
		newConfig.RS485_speed = speed_1500k;
 8024502:	f88d 301b 	strb.w	r3, [sp, #27]
		modbusRTU_BufferFlush();
 8024506:	4d04      	ldr	r5, [pc, #16]	@ (8024518 <swap_t+0x9c>)
 8024508:	f003 f962 	bl	80277d0 <modbusRTU_BufferFlush>
		break;
 802450c:	e7d1      	b.n	80244b2 <swap_t+0x36>
 802450e:	bf00      	nop
 8024510:	20023e5c 	.word	0x20023e5c
 8024514:	20000100 	.word	0x20000100
 8024518:	20000008 	.word	0x20000008
 802451c:	0802e450 	.word	0x0802e450
 8024520:	20000077 	.word	0x20000077

08024524 <handler_getStatus>:
{
 8024524:	b570      	push	{r4, r5, r6, lr}
	if (Sensor.addressing_by_MAC)
 8024526:	4e13      	ldr	r6, [pc, #76]	@ (8024574 <handler_getStatus+0x50>)
 8024528:	7874      	ldrb	r4, [r6, #1]
{
 802452a:	b082      	sub	sp, #8
	if (Sensor.addressing_by_MAC)
 802452c:	b134      	cbz	r4, 802453c <handler_getStatus+0x18>
		PRINTF_APP("No response - addressing by MAC\n");
 802452e:	4912      	ldr	r1, [pc, #72]	@ (8024578 <handler_getStatus+0x54>)
 8024530:	2000      	movs	r0, #0
}
 8024532:	b002      	add	sp, #8
 8024534:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		PRINTF_APP("No response - addressing by MAC\n");
 8024538:	f003 bd76 	b.w	8028028 <LOG_fprintf>
 802453c:	4605      	mov	r5, r0
		PRINTF_APP("Addressing by SensorID\n");
 802453e:	490f      	ldr	r1, [pc, #60]	@ (802457c <handler_getStatus+0x58>)
 8024540:	4620      	mov	r0, r4
 8024542:	f003 fd71 	bl	8028028 <LOG_fprintf>
		PRINTF_APP("Get status\r\n");
 8024546:	4620      	mov	r0, r4
 8024548:	490d      	ldr	r1, [pc, #52]	@ (8024580 <handler_getStatus+0x5c>)
 802454a:	f003 fd6d 	bl	8028028 <LOG_fprintf>
		PRINTF_APP("ToDo\r\n");
 802454e:	4620      	mov	r0, r4
 8024550:	490c      	ldr	r1, [pc, #48]	@ (8024584 <handler_getStatus+0x60>)
 8024552:	f003 fd69 	bl	8028028 <LOG_fprintf>
		if (Sensor.aqusition)
 8024556:	78f3      	ldrb	r3, [r6, #3]
		CommLink_SendData(Sensor.configuration.sensor_ID, cmd, flags, 0, 0);
 8024558:	f896 006e 	ldrb.w	r0, [r6, #110]	@ 0x6e
 802455c:	9400      	str	r4, [sp, #0]
		dSetFlag_ACK(flags);
 802455e:	2b00      	cmp	r3, #0
		CommLink_SendData(Sensor.configuration.sensor_ID, cmd, flags, 0, 0);
 8024560:	bf18      	it	ne
 8024562:	2205      	movne	r2, #5
 8024564:	4623      	mov	r3, r4
 8024566:	bf08      	it	eq
 8024568:	2201      	moveq	r2, #1
 802456a:	4629      	mov	r1, r5
 802456c:	f000 fc72 	bl	8024e54 <CommLink_SendData>
}
 8024570:	b002      	add	sp, #8
 8024572:	bd70      	pop	{r4, r5, r6, pc}
 8024574:	20000008 	.word	0x20000008
 8024578:	0802e46c 	.word	0x0802e46c
 802457c:	0802e26c 	.word	0x0802e26c
 8024580:	0802e490 	.word	0x0802e490
 8024584:	0802e264 	.word	0x0802e264

08024588 <handler_reset>:
{
 8024588:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (!Sensor.addressing_by_MAC)
 802458a:	4e2b      	ldr	r6, [pc, #172]	@ (8024638 <handler_reset+0xb0>)
 802458c:	7874      	ldrb	r4, [r6, #1]
{
 802458e:	b095      	sub	sp, #84	@ 0x54
 8024590:	4605      	mov	r5, r0
	if (!Sensor.addressing_by_MAC)
 8024592:	b9bc      	cbnz	r4, 80245c4 <handler_reset+0x3c>
		PRINTF_APP("Addressing by SensorID\n");
 8024594:	4929      	ldr	r1, [pc, #164]	@ (802463c <handler_reset+0xb4>)
 8024596:	4620      	mov	r0, r4
 8024598:	f003 fd46 	bl	8028028 <LOG_fprintf>
		PRINTF_APP("reset\r\n");
 802459c:	4928      	ldr	r1, [pc, #160]	@ (8024640 <handler_reset+0xb8>)
 802459e:	4620      	mov	r0, r4
 80245a0:	f003 fd42 	bl	8028028 <LOG_fprintf>
		if (CommLink_GetDataSize() != 12)
 80245a4:	f000 fdac 	bl	8025100 <CommLink_GetDataSize>
 80245a8:	280c      	cmp	r0, #12
 80245aa:	d034      	beq.n	8024616 <handler_reset+0x8e>
			PRINTF_APP("%s bad CommLink_GetDataSize - should be 12\n", __FUNCTION__);
 80245ac:	4620      	mov	r0, r4
 80245ae:	4a25      	ldr	r2, [pc, #148]	@ (8024644 <handler_reset+0xbc>)
 80245b0:	4925      	ldr	r1, [pc, #148]	@ (8024648 <handler_reset+0xc0>)
 80245b2:	f003 fd39 	bl	8028028 <LOG_fprintf>
			PRINTF_APP("ERROR");
 80245b6:	4925      	ldr	r1, [pc, #148]	@ (802464c <handler_reset+0xc4>)
 80245b8:	4620      	mov	r0, r4
}
 80245ba:	b015      	add	sp, #84	@ 0x54
 80245bc:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
			PRINTF_APP("ERROR");
 80245c0:	f003 bd32 	b.w	8028028 <LOG_fprintf>
		PRINTF_APP("Addressing by MAC\n");
 80245c4:	4922      	ldr	r1, [pc, #136]	@ (8024650 <handler_reset+0xc8>)
 80245c6:	2000      	movs	r0, #0
 80245c8:	f003 fd2e 	bl	8028028 <LOG_fprintf>
		PRINTF("COMM_APP: reset\r\n");
 80245cc:	4921      	ldr	r1, [pc, #132]	@ (8024654 <handler_reset+0xcc>)
 80245ce:	2006      	movs	r0, #6
 80245d0:	f003 fd2a 	bl	8028028 <LOG_fprintf>
		if (CommLink_GetDataSize() != 12)
 80245d4:	f000 fd94 	bl	8025100 <CommLink_GetDataSize>
 80245d8:	280c      	cmp	r0, #12
 80245da:	4604      	mov	r4, r0
 80245dc:	d113      	bne.n	8024606 <handler_reset+0x7e>
		uint8_t *dataPointer = CommLink_GetPrtDataFrame();
 80245de:	f000 fd8b 	bl	80250f8 <CommLink_GetPrtDataFrame>
 80245e2:	4607      	mov	r7, r0
		Memory_TakeConfig(&Config);
 80245e4:	a802      	add	r0, sp, #8
 80245e6:	f002 fcdf 	bl	8026fa8 <Memory_TakeConfig>
		if (memcmp(Config.MAC, dataPointer, 12) == 0)
 80245ea:	4622      	mov	r2, r4
 80245ec:	4639      	mov	r1, r7
 80245ee:	f10d 000f 	add.w	r0, sp, #15
 80245f2:	f005 fa8b 	bl	8029b0c <memcmp>
 80245f6:	4603      	mov	r3, r0
 80245f8:	b1d0      	cbz	r0, 8024630 <handler_reset+0xa8>
			PRINTF_APP("Config ignored: BAD MAC\n"); // dSetFlag_NACK(flags);
 80245fa:	4917      	ldr	r1, [pc, #92]	@ (8024658 <handler_reset+0xd0>)
 80245fc:	2000      	movs	r0, #0
 80245fe:	f003 fd13 	bl	8028028 <LOG_fprintf>
}
 8024602:	b015      	add	sp, #84	@ 0x54
 8024604:	bdf0      	pop	{r4, r5, r6, r7, pc}
			PRINTF_APP("%s bad CommLink_GetDataSize - should be 2\n", __FUNCTION__);
 8024606:	4a0f      	ldr	r2, [pc, #60]	@ (8024644 <handler_reset+0xbc>)
 8024608:	4914      	ldr	r1, [pc, #80]	@ (802465c <handler_reset+0xd4>)
 802460a:	2000      	movs	r0, #0
}
 802460c:	b015      	add	sp, #84	@ 0x54
 802460e:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
			PRINTF_APP("%s bad CommLink_GetDataSize - should be 2\n", __FUNCTION__);
 8024612:	f003 bd09 	b.w	8028028 <LOG_fprintf>
		CommLink_SendData(Sensor.configuration.sensor_ID, cmd, flags, 0, 0);
 8024616:	f896 006e 	ldrb.w	r0, [r6, #110]	@ 0x6e
 802461a:	9400      	str	r4, [sp, #0]
 802461c:	4623      	mov	r3, r4
			CommLink_SendData(Sensor.configuration.sensor_ID, cmd, flags, 0, 0);
 802461e:	2201      	movs	r2, #1
 8024620:	4629      	mov	r1, r5
 8024622:	f000 fc17 	bl	8024e54 <CommLink_SendData>
			HAL_Delay(200);
 8024626:	20c8      	movs	r0, #200	@ 0xc8
 8024628:	f7fc fd5c 	bl	80210e4 <HAL_Delay>
			NVIC_SystemReset();
 802462c:	f7ff fc10 	bl	8023e50 <__NVIC_SystemReset>
			CommLink_SendData(Sensor.configuration.sensor_ID, cmd, flags, 0, 0);
 8024630:	f896 006e 	ldrb.w	r0, [r6, #110]	@ 0x6e
 8024634:	9300      	str	r3, [sp, #0]
 8024636:	e7f2      	b.n	802461e <handler_reset+0x96>
 8024638:	20000008 	.word	0x20000008
 802463c:	0802e26c 	.word	0x0802e26c
 8024640:	0802e4a0 	.word	0x0802e4a0
 8024644:	0802ad04 	.word	0x0802ad04
 8024648:	0802e4a8 	.word	0x0802e4a8
 802464c:	0802e4d4 	.word	0x0802e4d4
 8024650:	0802e2f0 	.word	0x0802e2f0
 8024654:	0802e4dc 	.word	0x0802e4dc
 8024658:	0802e304 	.word	0x0802e304
 802465c:	0802e4f0 	.word	0x0802e4f0

08024660 <handler_stopAcq>:
{
 8024660:	b570      	push	{r4, r5, r6, lr}
	if (Sensor.addressing_by_MAC)
 8024662:	4e14      	ldr	r6, [pc, #80]	@ (80246b4 <handler_stopAcq+0x54>)
 8024664:	7874      	ldrb	r4, [r6, #1]
{
 8024666:	b082      	sub	sp, #8
	if (Sensor.addressing_by_MAC)
 8024668:	b134      	cbz	r4, 8024678 <handler_stopAcq+0x18>
		PRINTF_APP("No response - addressing by MAC\n");
 802466a:	4913      	ldr	r1, [pc, #76]	@ (80246b8 <handler_stopAcq+0x58>)
 802466c:	2000      	movs	r0, #0
}
 802466e:	b002      	add	sp, #8
 8024670:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			PRINTF_APP("No response - broadcast mode");
 8024674:	f003 bcd8 	b.w	8028028 <LOG_fprintf>
		PRINTF_APP("Addressing by SensorID\n");
 8024678:	4910      	ldr	r1, [pc, #64]	@ (80246bc <handler_stopAcq+0x5c>)
 802467a:	4605      	mov	r5, r0
 802467c:	4620      	mov	r0, r4
 802467e:	f003 fcd3 	bl	8028028 <LOG_fprintf>
		PRINTF_APP("Stop acquisition\r\n");
 8024682:	4620      	mov	r0, r4
 8024684:	490e      	ldr	r1, [pc, #56]	@ (80246c0 <handler_stopAcq+0x60>)
 8024686:	f003 fccf 	bl	8028028 <LOG_fprintf>
		ACQ_Stop();
 802468a:	f7ff f8f5 	bl	8023878 <ACQ_Stop>
		if (Sensor.not_broadcast_mode)
 802468e:	78b0      	ldrb	r0, [r6, #2]
 8024690:	b148      	cbz	r0, 80246a6 <handler_stopAcq+0x46>
			CommLink_SendData(Sensor.configuration.sensor_ID, cmd, flags, 0, 0);
 8024692:	f896 006e 	ldrb.w	r0, [r6, #110]	@ 0x6e
 8024696:	9400      	str	r4, [sp, #0]
 8024698:	4623      	mov	r3, r4
 802469a:	2201      	movs	r2, #1
 802469c:	4629      	mov	r1, r5
 802469e:	f000 fbd9 	bl	8024e54 <CommLink_SendData>
}
 80246a2:	b002      	add	sp, #8
 80246a4:	bd70      	pop	{r4, r5, r6, pc}
			PRINTF_APP("No response - broadcast mode");
 80246a6:	4907      	ldr	r1, [pc, #28]	@ (80246c4 <handler_stopAcq+0x64>)
}
 80246a8:	b002      	add	sp, #8
 80246aa:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			PRINTF_APP("No response - broadcast mode");
 80246ae:	f003 bcbb 	b.w	8028028 <LOG_fprintf>
 80246b2:	bf00      	nop
 80246b4:	20000008 	.word	0x20000008
 80246b8:	0802e46c 	.word	0x0802e46c
 80246bc:	0802e26c 	.word	0x0802e26c
 80246c0:	0802e51c 	.word	0x0802e51c
 80246c4:	0802e530 	.word	0x0802e530

080246c8 <handler_getData>:
{
 80246c8:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (Sensor.addressing_by_MAC) // jesli trwa adresowanie
 80246ca:	4e20      	ldr	r6, [pc, #128]	@ (802474c <handler_getData+0x84>)
 80246cc:	7874      	ldrb	r4, [r6, #1]
{
 80246ce:	b083      	sub	sp, #12
	if (Sensor.addressing_by_MAC) // jesli trwa adresowanie
 80246d0:	b10c      	cbz	r4, 80246d6 <handler_getData+0xe>
}
 80246d2:	b003      	add	sp, #12
 80246d4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80246d6:	4605      	mov	r5, r0
		if (CommLink_GetDataSize() != 2) // powinno miec 2 znaki
 80246d8:	f000 fd12 	bl	8025100 <CommLink_GetDataSize>
 80246dc:	2802      	cmp	r0, #2
 80246de:	d1f8      	bne.n	80246d2 <handler_getData+0xa>
		memcpy(&samplesRequested, CommLink_GetPrtDataFrame(), 2); // wsad do samplesRequested 2 pierwsze znaki z commlink_getdata
 80246e0:	f000 fd0a 	bl	80250f8 <CommLink_GetPrtDataFrame>
 80246e4:	8803      	ldrh	r3, [r0, #0]
 80246e6:	f363 040f 	bfi	r4, r3, #0, #16
		if (samplesRequested > MAX_SAMPLES_AT_ONCE)				 // jeli jest wiksze od max
 80246ea:	f5b4 6f80 	cmp.w	r4, #1024	@ 0x400
 80246ee:	d8f0      	bhi.n	80246d2 <handler_getData+0xa>
		if (samplesRequested == 0) // jesli nie ma zadnych probek
 80246f0:	b30c      	cbz	r4, 8024736 <handler_getData+0x6e>
		respLen = ACQ_GetSamples(respData + (sizeof(float) * Sensor.parameters.ScalarCount), 3 * samplesRequested) + sizeof(float) * Sensor.parameters.ScalarCount;
 80246f2:	eb04 0444 	add.w	r4, r4, r4, lsl #1
		if (Sensor.parameters.ScalarCount == 1)
 80246f6:	f896 0028 	ldrb.w	r0, [r6, #40]	@ 0x28
 80246fa:	2801      	cmp	r0, #1
 80246fc:	d020      	beq.n	8024740 <handler_getData+0x78>
		respLen = ACQ_GetSamples(respData + (sizeof(float) * Sensor.parameters.ScalarCount), 3 * samplesRequested) + sizeof(float) * Sensor.parameters.ScalarCount;
 80246fe:	4f14      	ldr	r7, [pc, #80]	@ (8024750 <handler_getData+0x88>)
 8024700:	4621      	mov	r1, r4
 8024702:	eb07 0080 	add.w	r0, r7, r0, lsl #2
 8024706:	f7ff fac1 	bl	8023c8c <ACQ_GetSamples>
 802470a:	f896 3028 	ldrb.w	r3, [r6, #40]	@ 0x28
 802470e:	eb00 0483 	add.w	r4, r0, r3, lsl #2
		if (Sensor.overflow)
 8024712:	7933      	ldrb	r3, [r6, #4]
		respLen = ACQ_GetSamples(respData + (sizeof(float) * Sensor.parameters.ScalarCount), 3 * samplesRequested) + sizeof(float) * Sensor.parameters.ScalarCount;
 8024714:	b2a4      	uxth	r4, r4
		if (Sensor.overflow)
 8024716:	b18b      	cbz	r3, 802473c <handler_getData+0x74>
			respData[respLen] = 1;
 8024718:	2301      	movs	r3, #1
 802471a:	553b      	strb	r3, [r7, r4]
		ACQ_clearOverFlow();
 802471c:	f7ff fb92 	bl	8023e44 <ACQ_clearOverFlow>
		CommLink_SendData(Sensor.configuration.sensor_ID, cmd, flags, respData, respLen + 1);
 8024720:	2201      	movs	r2, #1
 8024722:	4414      	add	r4, r2
 8024724:	b2a4      	uxth	r4, r4
 8024726:	f896 006e 	ldrb.w	r0, [r6, #110]	@ 0x6e
 802472a:	4b09      	ldr	r3, [pc, #36]	@ (8024750 <handler_getData+0x88>)
 802472c:	9400      	str	r4, [sp, #0]
 802472e:	4629      	mov	r1, r5
 8024730:	f000 fb90 	bl	8024e54 <CommLink_SendData>
		PRINTF_COMM(" Send %d bytes\r\n", respLen + 1);
 8024734:	e7cd      	b.n	80246d2 <handler_getData+0xa>
 8024736:	f44f 6440 	mov.w	r4, #3072	@ 0xc00
 802473a:	e7dc      	b.n	80246f6 <handler_getData+0x2e>
			respData[respLen] = 0;
 802473c:	553b      	strb	r3, [r7, r4]
 802473e:	e7ed      	b.n	802471c <handler_getData+0x54>
			Temp_SampleGet(respData);
 8024740:	4803      	ldr	r0, [pc, #12]	@ (8024750 <handler_getData+0x88>)
 8024742:	f001 fb53 	bl	8025dec <Temp_SampleGet>
		respLen = ACQ_GetSamples(respData + (sizeof(float) * Sensor.parameters.ScalarCount), 3 * samplesRequested) + sizeof(float) * Sensor.parameters.ScalarCount;
 8024746:	f896 0028 	ldrb.w	r0, [r6, #40]	@ 0x28
 802474a:	e7d8      	b.n	80246fe <handler_getData+0x36>
 802474c:	20000008 	.word	0x20000008
 8024750:	2001f7b4 	.word	0x2001f7b4

08024754 <handler_getAddrMac>:
{
 8024754:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (Sensor.addressing_by_MAC)
 8024756:	4f2c      	ldr	r7, [pc, #176]	@ (8024808 <handler_getAddrMac+0xb4>)
 8024758:	787d      	ldrb	r5, [r7, #1]
{
 802475a:	b09b      	sub	sp, #108	@ 0x6c
	if (Sensor.addressing_by_MAC)
 802475c:	b135      	cbz	r5, 802476c <handler_getAddrMac+0x18>
		PRINTF_APP("No response - addressing by MAC\n");
 802475e:	492b      	ldr	r1, [pc, #172]	@ (802480c <handler_getAddrMac+0xb8>)
 8024760:	2000      	movs	r0, #0
}
 8024762:	b01b      	add	sp, #108	@ 0x6c
 8024764:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		PRINTF_APP("No response - addressing by MAC\n");
 8024768:	f003 bc5e 	b.w	8028028 <LOG_fprintf>
		if (CommLink_GetDataSize() == 0)
 802476c:	4606      	mov	r6, r0
 802476e:	f000 fcc7 	bl	8025100 <CommLink_GetDataSize>
			PRINTF_APP("%s CommLink_GetDataSize - ok \n", __FUNCTION__);
 8024772:	4a27      	ldr	r2, [pc, #156]	@ (8024810 <handler_getAddrMac+0xbc>)
		if (CommLink_GetDataSize() == 0)
 8024774:	4604      	mov	r4, r0
 8024776:	2800      	cmp	r0, #0
 8024778:	d13f      	bne.n	80247fa <handler_getAddrMac+0xa6>
			PRINTF_APP("%s CommLink_GetDataSize - ok \n", __FUNCTION__);
 802477a:	4926      	ldr	r1, [pc, #152]	@ (8024814 <handler_getAddrMac+0xc0>)
 802477c:	f003 fc54 	bl	8028028 <LOG_fprintf>
			uint8_t delay_tmp = ACQ_getRandom();
 8024780:	f7fe fffc 	bl	802377c <ACQ_getRandom>
			PRINTF_APP("=====================================\n");
 8024784:	4924      	ldr	r1, [pc, #144]	@ (8024818 <handler_getAddrMac+0xc4>)
			delay_tmp = delay_tmp & 0x3f;
 8024786:	f000 053f 	and.w	r5, r0, #63	@ 0x3f
			PRINTF_APP("=====================================\n");
 802478a:	4620      	mov	r0, r4
 802478c:	f003 fc4c 	bl	8028028 <LOG_fprintf>
			PRINTF_APP("Number passed to HAL_Delay: %i\n", delay_tmp);
 8024790:	462a      	mov	r2, r5
 8024792:	4620      	mov	r0, r4
 8024794:	4921      	ldr	r1, [pc, #132]	@ (802481c <handler_getAddrMac+0xc8>)
 8024796:	f003 fc47 	bl	8028028 <LOG_fprintf>
			PRINTF_APP("=====================================\n");
 802479a:	491f      	ldr	r1, [pc, #124]	@ (8024818 <handler_getAddrMac+0xc4>)
 802479c:	4620      	mov	r0, r4
 802479e:	f003 fc43 	bl	8028028 <LOG_fprintf>
			HAL_Delay(delay_tmp);
 80247a2:	4628      	mov	r0, r5
 80247a4:	f7fc fc9e 	bl	80210e4 <HAL_Delay>
			PRINTF_APP("Addressing by SensorID\n");
 80247a8:	4620      	mov	r0, r4
 80247aa:	491d      	ldr	r1, [pc, #116]	@ (8024820 <handler_getAddrMac+0xcc>)
 80247ac:	f003 fc3c 	bl	8028028 <LOG_fprintf>
			PRINTF_APP("Get MAC address\r\n");
 80247b0:	4620      	mov	r0, r4
 80247b2:	491c      	ldr	r1, [pc, #112]	@ (8024824 <handler_getAddrMac+0xd0>)
 80247b4:	f003 fc38 	bl	8028028 <LOG_fprintf>
			PRINTF_APP("Odczytano konfiguracje\r\n");
 80247b8:	491b      	ldr	r1, [pc, #108]	@ (8024828 <handler_getAddrMac+0xd4>)
 80247ba:	4620      	mov	r0, r4
 80247bc:	f003 fc34 	bl	8028028 <LOG_fprintf>
			Memory_TakeConfig(&fromMemoryConfig);
 80247c0:	a808      	add	r0, sp, #32
 80247c2:	f002 fbf1 	bl	8026fa8 <Memory_TakeConfig>
			memcpy(tmp, GetMACAddress(), 12);
 80247c6:	f000 fd03 	bl	80251d0 <GetMACAddress>
 80247ca:	4602      	mov	r2, r0
 80247cc:	6800      	ldr	r0, [r0, #0]
 80247ce:	6851      	ldr	r1, [r2, #4]
 80247d0:	6892      	ldr	r2, [r2, #8]
 80247d2:	ac02      	add	r4, sp, #8
			CommLink_SendData(Sensor.configuration.sensor_ID, cmd, flags, tmp, 24);
 80247d4:	4623      	mov	r3, r4
			memcpy(tmp, GetMACAddress(), 12);
 80247d6:	c407      	stmia	r4!, {r0, r1, r2}
			memcpy(tmp + 12, fromMemoryConfig.sensor_type, 12);
 80247d8:	f8dd 0035 	ldr.w	r0, [sp, #53]	@ 0x35
 80247dc:	f8dd 1039 	ldr.w	r1, [sp, #57]	@ 0x39
 80247e0:	f8dd 203d 	ldr.w	r2, [sp, #61]	@ 0x3d
 80247e4:	c407      	stmia	r4!, {r0, r1, r2}
			CommLink_SendData(Sensor.configuration.sensor_ID, cmd, flags, tmp, 24);
 80247e6:	2218      	movs	r2, #24
 80247e8:	f897 006e 	ldrb.w	r0, [r7, #110]	@ 0x6e
 80247ec:	9200      	str	r2, [sp, #0]
 80247ee:	4631      	mov	r1, r6
 80247f0:	2201      	movs	r2, #1
 80247f2:	f000 fb2f 	bl	8024e54 <CommLink_SendData>
}
 80247f6:	b01b      	add	sp, #108	@ 0x6c
 80247f8:	bdf0      	pop	{r4, r5, r6, r7, pc}
			PRINTF_APP("%s CommLink_GetDataSize != 0 Not ok \n", __FUNCTION__);
 80247fa:	490c      	ldr	r1, [pc, #48]	@ (802482c <handler_getAddrMac+0xd8>)
 80247fc:	4628      	mov	r0, r5
}
 80247fe:	b01b      	add	sp, #108	@ 0x6c
 8024800:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
			PRINTF_APP("%s CommLink_GetDataSize != 0 Not ok \n", __FUNCTION__);
 8024804:	f003 bc10 	b.w	8028028 <LOG_fprintf>
 8024808:	20000008 	.word	0x20000008
 802480c:	0802e46c 	.word	0x0802e46c
 8024810:	0802ad14 	.word	0x0802ad14
 8024814:	0802e550 	.word	0x0802e550
 8024818:	0802e570 	.word	0x0802e570
 802481c:	0802e598 	.word	0x0802e598
 8024820:	0802e26c 	.word	0x0802e26c
 8024824:	0802e5b8 	.word	0x0802e5b8
 8024828:	0802e334 	.word	0x0802e334
 802482c:	0802e5cc 	.word	0x0802e5cc

08024830 <handler_starAcq>:
{
 8024830:	b570      	push	{r4, r5, r6, lr}
	if (Sensor.addressing_by_MAC)
 8024832:	4c2b      	ldr	r4, [pc, #172]	@ (80248e0 <handler_starAcq+0xb0>)
 8024834:	7863      	ldrb	r3, [r4, #1]
{
 8024836:	b082      	sub	sp, #8
	if (Sensor.addressing_by_MAC)
 8024838:	b133      	cbz	r3, 8024848 <handler_starAcq+0x18>
		PRINTF_APP("No response - addressing by MAC\n");
 802483a:	492a      	ldr	r1, [pc, #168]	@ (80248e4 <handler_starAcq+0xb4>)
 802483c:	2000      	movs	r0, #0
}
 802483e:	b002      	add	sp, #8
 8024840:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		PRINTF_APP("No response - addressing by MAC\n");
 8024844:	f003 bbf0 	b.w	8028028 <LOG_fprintf>
		PRINTF_APP("Addressing by SensorID\n");
 8024848:	4927      	ldr	r1, [pc, #156]	@ (80248e8 <handler_starAcq+0xb8>)
 802484a:	4606      	mov	r6, r0
 802484c:	4618      	mov	r0, r3
 802484e:	f003 fbeb 	bl	8028028 <LOG_fprintf>
		memcpy(&millis, CommLink_GetPrtDataFrame(), 4);
 8024852:	f000 fc51 	bl	80250f8 <CommLink_GetPrtDataFrame>
 8024856:	6805      	ldr	r5, [r0, #0]
		if (millis == 0)
 8024858:	2d00      	cmp	r5, #0
 802485a:	d03c      	beq.n	80248d6 <handler_starAcq+0xa6>
		uint32_t counter_number = floor((float)Sensor.parameters.SampleRate * scalledMilis);
 802485c:	8ca3      	ldrh	r3, [r4, #36]	@ 0x24
 802485e:	eddf 6a23 	vldr	s13, [pc, #140]	@ 80248ec <handler_starAcq+0xbc>
 8024862:	ee07 3a90 	vmov	s15, r3
		float scalledMilis = millis / millisInFullSampleRate;
 8024866:	ee07 5a10 	vmov	s14, r5
		uint32_t counter_number = floor((float)Sensor.parameters.SampleRate * scalledMilis);
 802486a:	eef8 7a67 	vcvt.f32.u32	s15, s15
		float scalledMilis = millis / millisInFullSampleRate;
 802486e:	eeb8 7a47 	vcvt.f32.u32	s14, s14
		uint32_t counter_number = floor((float)Sensor.parameters.SampleRate * scalledMilis);
 8024872:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8024876:	ee67 7a87 	vmul.f32	s15, s15, s14
 802487a:	ee17 0a90 	vmov	r0, s15
 802487e:	f7fb feeb 	bl	8020658 <__aeabi_f2d>
 8024882:	ec41 0b10 	vmov	d0, r0, r1
 8024886:	f006 f99f 	bl	802abc8 <floor>
 802488a:	ec51 0b10 	vmov	r0, r1, d0
 802488e:	f7fc f9d5 	bl	8020c3c <__aeabi_d2uiz>
		PRINTF_APP("Start acquisition %d samples\r\n", counter_number);
 8024892:	4917      	ldr	r1, [pc, #92]	@ (80248f0 <handler_starAcq+0xc0>)
 8024894:	4602      	mov	r2, r0
		uint32_t counter_number = floor((float)Sensor.parameters.SampleRate * scalledMilis);
 8024896:	4605      	mov	r5, r0
		PRINTF_APP("Start acquisition %d samples\r\n", counter_number);
 8024898:	2000      	movs	r0, #0
 802489a:	f003 fbc5 	bl	8028028 <LOG_fprintf>
		ACQ_Start();
 802489e:	f7fe ffcf 	bl	8023840 <ACQ_Start>
		if (Sensor.not_broadcast_mode)
 80248a2:	78a0      	ldrb	r0, [r4, #2]
		Sensor.number_of_samples = 3 * counter_number;
 80248a4:	eb05 0345 	add.w	r3, r5, r5, lsl #1
 80248a8:	60a3      	str	r3, [r4, #8]
		if (Sensor.not_broadcast_mode)
 80248aa:	b958      	cbnz	r0, 80248c4 <handler_starAcq+0x94>
			PRINTF_APP("No response - broadcast mode\n");
 80248ac:	4911      	ldr	r1, [pc, #68]	@ (80248f4 <handler_starAcq+0xc4>)
 80248ae:	f003 fbbb 	bl	8028028 <LOG_fprintf>
		PRINTF_APP("Gathering %d SamplesXYZ, %d single samples\r\n", counter_number, Sensor.number_of_samples);
 80248b2:	68a3      	ldr	r3, [r4, #8]
 80248b4:	4910      	ldr	r1, [pc, #64]	@ (80248f8 <handler_starAcq+0xc8>)
 80248b6:	462a      	mov	r2, r5
 80248b8:	2000      	movs	r0, #0
}
 80248ba:	b002      	add	sp, #8
 80248bc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		PRINTF_APP("Gathering %d SamplesXYZ, %d single samples\r\n", counter_number, Sensor.number_of_samples);
 80248c0:	f003 bbb2 	b.w	8028028 <LOG_fprintf>
			CommLink_SendData(Sensor.configuration.sensor_ID, cmd, flags, 0, 0);
 80248c4:	2300      	movs	r3, #0
 80248c6:	9300      	str	r3, [sp, #0]
 80248c8:	f894 006e 	ldrb.w	r0, [r4, #110]	@ 0x6e
 80248cc:	4631      	mov	r1, r6
 80248ce:	2201      	movs	r2, #1
 80248d0:	f000 fac0 	bl	8024e54 <CommLink_SendData>
 80248d4:	e7ed      	b.n	80248b2 <handler_starAcq+0x82>
			PRINTF_APP("Infinite Acquisition\n");
 80248d6:	4909      	ldr	r1, [pc, #36]	@ (80248fc <handler_starAcq+0xcc>)
 80248d8:	4628      	mov	r0, r5
 80248da:	f003 fba5 	bl	8028028 <LOG_fprintf>
 80248de:	e7bd      	b.n	802485c <handler_starAcq+0x2c>
 80248e0:	20000008 	.word	0x20000008
 80248e4:	0802e46c 	.word	0x0802e46c
 80248e8:	0802e26c 	.word	0x0802e26c
 80248ec:	3a83126f 	.word	0x3a83126f
 80248f0:	0802e60c 	.word	0x0802e60c
 80248f4:	0802e62c 	.word	0x0802e62c
 80248f8:	0802e64c 	.word	0x0802e64c
 80248fc:	0802e5f4 	.word	0x0802e5f4

08024900 <handler_setSpeed>:
{
 8024900:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (!Sensor.addressing_by_MAC)
 8024904:	4ea2      	ldr	r6, [pc, #648]	@ (8024b90 <handler_setSpeed+0x290>)
 8024906:	7874      	ldrb	r4, [r6, #1]
{
 8024908:	b09a      	sub	sp, #104	@ 0x68
 802490a:	4605      	mov	r5, r0
	if (!Sensor.addressing_by_MAC)
 802490c:	2c00      	cmp	r4, #0
 802490e:	d13a      	bne.n	8024986 <handler_setSpeed+0x86>
		PRINTF_APP("Addressing by SensorID\n");
 8024910:	49a0      	ldr	r1, [pc, #640]	@ (8024b94 <handler_setSpeed+0x294>)
 8024912:	4620      	mov	r0, r4
 8024914:	f003 fb88 	bl	8028028 <LOG_fprintf>
		PRINTF_APP("Set speed\r\n");
 8024918:	499f      	ldr	r1, [pc, #636]	@ (8024b98 <handler_setSpeed+0x298>)
 802491a:	4620      	mov	r0, r4
 802491c:	f003 fb84 	bl	8028028 <LOG_fprintf>
		if (CommLink_GetDataSize() != 13)
 8024920:	f000 fbee 	bl	8025100 <CommLink_GetDataSize>
 8024924:	280d      	cmp	r0, #13
 8024926:	d126      	bne.n	8024976 <handler_setSpeed+0x76>
		uint8_t *dataPointer = CommLink_GetPrtDataFrame();
 8024928:	f000 fbe6 	bl	80250f8 <CommLink_GetPrtDataFrame>
		Memory_TakeConfig(&newConfig);
 802492c:	af08      	add	r7, sp, #32
		uint8_t *dataPointer = CommLink_GetPrtDataFrame();
 802492e:	4604      	mov	r4, r0
		Memory_TakeConfig(&newConfig);
 8024930:	4638      	mov	r0, r7
 8024932:	f002 fb39 	bl	8026fa8 <Memory_TakeConfig>
		newConfig.RS485_speed = dataPointer[12];
 8024936:	7b23      	ldrb	r3, [r4, #12]
 8024938:	f88d 3033 	strb.w	r3, [sp, #51]	@ 0x33
	switch (spd)
 802493c:	2b70      	cmp	r3, #112	@ 0x70
 802493e:	f000 8083 	beq.w	8024a48 <handler_setSpeed+0x148>
 8024942:	d878      	bhi.n	8024a36 <handler_setSpeed+0x136>
 8024944:	2b40      	cmp	r3, #64	@ 0x40
 8024946:	d07f      	beq.n	8024a48 <handler_setSpeed+0x148>
 8024948:	f200 80cd 	bhi.w	8024ae6 <handler_setSpeed+0x1e6>
 802494c:	2b20      	cmp	r3, #32
 802494e:	d07b      	beq.n	8024a48 <handler_setSpeed+0x148>
 8024950:	f003 03df 	and.w	r3, r3, #223	@ 0xdf
 8024954:	2b10      	cmp	r3, #16
 8024956:	d077      	beq.n	8024a48 <handler_setSpeed+0x148>
				PRINTF_APP("Config ignored: BAD SPEED\n");
 8024958:	4990      	ldr	r1, [pc, #576]	@ (8024b9c <handler_setSpeed+0x29c>)
 802495a:	2000      	movs	r0, #0
 802495c:	f003 fb64 	bl	8028028 <LOG_fprintf>
				dSetFlag_NACK(flags);
 8024960:	2202      	movs	r2, #2
			CommLink_SendData(Sensor.configuration.sensor_ID, cmd, flags, 0, 0);
 8024962:	2300      	movs	r3, #0
 8024964:	f896 006e 	ldrb.w	r0, [r6, #110]	@ 0x6e
 8024968:	9300      	str	r3, [sp, #0]
 802496a:	4629      	mov	r1, r5
 802496c:	f000 fa72 	bl	8024e54 <CommLink_SendData>
}
 8024970:	b01a      	add	sp, #104	@ 0x68
 8024972:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			PRINTF_APP("%s bad CommLink_GetDataSize - should be 2\n", __FUNCTION__);
 8024976:	4a8a      	ldr	r2, [pc, #552]	@ (8024ba0 <handler_setSpeed+0x2a0>)
 8024978:	498a      	ldr	r1, [pc, #552]	@ (8024ba4 <handler_setSpeed+0x2a4>)
 802497a:	2000      	movs	r0, #0
}
 802497c:	b01a      	add	sp, #104	@ 0x68
 802497e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
			PRINTF_APP("%s bad CommLink_GetDataSize - should be 2\n", __FUNCTION__);
 8024982:	f003 bb51 	b.w	8028028 <LOG_fprintf>
		PRINTF_APP("Addressing by MAC\n");
 8024986:	4988      	ldr	r1, [pc, #544]	@ (8024ba8 <handler_setSpeed+0x2a8>)
 8024988:	2000      	movs	r0, #0
 802498a:	f003 fb4d 	bl	8028028 <LOG_fprintf>
		PRINTF_APP("Set speed\r\n");
 802498e:	4982      	ldr	r1, [pc, #520]	@ (8024b98 <handler_setSpeed+0x298>)
 8024990:	2000      	movs	r0, #0
 8024992:	f003 fb49 	bl	8028028 <LOG_fprintf>
		if (CommLink_GetDataSize() != 13)
 8024996:	f000 fbb3 	bl	8025100 <CommLink_GetDataSize>
 802499a:	280d      	cmp	r0, #13
 802499c:	d1eb      	bne.n	8024976 <handler_setSpeed+0x76>
		uint8_t *dataPointer = CommLink_GetPrtDataFrame();
 802499e:	f000 fbab 	bl	80250f8 <CommLink_GetPrtDataFrame>
		Memory_TakeConfig(&newConfig);
 80249a2:	af08      	add	r7, sp, #32
		uint8_t *dataPointer = CommLink_GetPrtDataFrame();
 80249a4:	4604      	mov	r4, r0
		Memory_TakeConfig(&newConfig);
 80249a6:	4638      	mov	r0, r7
 80249a8:	f002 fafe 	bl	8026fa8 <Memory_TakeConfig>
		newConfig.RS485_speed = dataPointer[12];
 80249ac:	f894 800c 	ldrb.w	r8, [r4, #12]
 80249b0:	f88d 8033 	strb.w	r8, [sp, #51]	@ 0x33
		if (memcmp(newConfig.MAC, dataPointer, 12) == 0)
 80249b4:	4621      	mov	r1, r4
 80249b6:	220c      	movs	r2, #12
 80249b8:	f10d 0027 	add.w	r0, sp, #39	@ 0x27
 80249bc:	f005 f8a6 	bl	8029b0c <memcmp>
 80249c0:	2800      	cmp	r0, #0
 80249c2:	d161      	bne.n	8024a88 <handler_setSpeed+0x188>
	switch (spd)
 80249c4:	f1b8 0f70 	cmp.w	r8, #112	@ 0x70
 80249c8:	d00d      	beq.n	80249e6 <handler_setSpeed+0xe6>
 80249ca:	d864      	bhi.n	8024a96 <handler_setSpeed+0x196>
 80249cc:	f1b8 0f40 	cmp.w	r8, #64	@ 0x40
 80249d0:	d009      	beq.n	80249e6 <handler_setSpeed+0xe6>
 80249d2:	f200 80a1 	bhi.w	8024b18 <handler_setSpeed+0x218>
 80249d6:	f1b8 0f20 	cmp.w	r8, #32
 80249da:	d004      	beq.n	80249e6 <handler_setSpeed+0xe6>
 80249dc:	f008 08df 	and.w	r8, r8, #223	@ 0xdf
 80249e0:	f1b8 0f10 	cmp.w	r8, #16
 80249e4:	d1b8      	bne.n	8024958 <handler_setSpeed+0x58>
				Memory_SaveConfig(&newConfig);
 80249e6:	4638      	mov	r0, r7
 80249e8:	f002 faaa 	bl	8026f40 <Memory_SaveConfig>
				PRINTF_APP("New config send_id: %d\n", newConfig.sensor_ID);
 80249ec:	496f      	ldr	r1, [pc, #444]	@ (8024bac <handler_setSpeed+0x2ac>)
 80249ee:	f89d 2026 	ldrb.w	r2, [sp, #38]	@ 0x26
 80249f2:	2000      	movs	r0, #0
 80249f4:	f003 fb18 	bl	8028028 <LOG_fprintf>
				switch (newConfig.RS485_speed)
 80249f8:	f89d 1033 	ldrb.w	r1, [sp, #51]	@ 0x33
				memset(name, 0, 20);
 80249fc:	2200      	movs	r2, #0
 80249fe:	ab03      	add	r3, sp, #12
				switch (newConfig.RS485_speed)
 8024a00:	2970      	cmp	r1, #112	@ 0x70
				memset(name, 0, 20);
 8024a02:	9203      	str	r2, [sp, #12]
 8024a04:	e9c3 2201 	strd	r2, r2, [r3, #4]
 8024a08:	e9c3 2203 	strd	r2, r2, [r3, #12]
				switch (newConfig.RS485_speed)
 8024a0c:	f000 8091 	beq.w	8024b32 <handler_setSpeed+0x232>
 8024a10:	d96f      	bls.n	8024af2 <handler_setSpeed+0x1f2>
 8024a12:	29b0      	cmp	r1, #176	@ 0xb0
 8024a14:	f000 8094 	beq.w	8024b40 <handler_setSpeed+0x240>
 8024a18:	f200 8094 	bhi.w	8024b44 <handler_setSpeed+0x244>
 8024a1c:	2990      	cmp	r1, #144	@ 0x90
 8024a1e:	f000 809a 	beq.w	8024b56 <handler_setSpeed+0x256>
 8024a22:	29a0      	cmp	r1, #160	@ 0xa0
 8024a24:	d04b      	beq.n	8024abe <handler_setSpeed+0x1be>
 8024a26:	2980      	cmp	r1, #128	@ 0x80
 8024a28:	f040 80a6 	bne.w	8024b78 <handler_setSpeed+0x278>
					sprintf(name, "speed_38400");
 8024a2c:	4a60      	ldr	r2, [pc, #384]	@ (8024bb0 <handler_setSpeed+0x2b0>)
 8024a2e:	ca07      	ldmia	r2, {r0, r1, r2}
 8024a30:	e883 0007 	stmia.w	r3, {r0, r1, r2}
					break;
 8024a34:	e04a      	b.n	8024acc <handler_setSpeed+0x1cc>
	switch (spd)
 8024a36:	2bb0      	cmp	r3, #176	@ 0xb0
 8024a38:	d006      	beq.n	8024a48 <handler_setSpeed+0x148>
 8024a3a:	d84e      	bhi.n	8024ada <handler_setSpeed+0x1da>
 8024a3c:	f003 02ef 	and.w	r2, r3, #239	@ 0xef
 8024a40:	2a80      	cmp	r2, #128	@ 0x80
 8024a42:	d001      	beq.n	8024a48 <handler_setSpeed+0x148>
 8024a44:	2ba0      	cmp	r3, #160	@ 0xa0
 8024a46:	d187      	bne.n	8024958 <handler_setSpeed+0x58>
			Memory_SaveConfig(&newConfig);
 8024a48:	4638      	mov	r0, r7
 8024a4a:	f002 fa79 	bl	8026f40 <Memory_SaveConfig>
			PRINTF_APP("New config send_id: %d\n", newConfig.sensor_ID);
 8024a4e:	4957      	ldr	r1, [pc, #348]	@ (8024bac <handler_setSpeed+0x2ac>)
 8024a50:	f89d 2026 	ldrb.w	r2, [sp, #38]	@ 0x26
 8024a54:	2000      	movs	r0, #0
 8024a56:	f003 fae7 	bl	8028028 <LOG_fprintf>
			switch (newConfig.RS485_speed)
 8024a5a:	f89d 1033 	ldrb.w	r1, [sp, #51]	@ 0x33
			memset(name, 0, 20);
 8024a5e:	2200      	movs	r2, #0
 8024a60:	ab03      	add	r3, sp, #12
			switch (newConfig.RS485_speed)
 8024a62:	2980      	cmp	r1, #128	@ 0x80
			memset(name, 0, 20);
 8024a64:	9203      	str	r2, [sp, #12]
 8024a66:	e9c3 2201 	strd	r2, r2, [r3, #4]
 8024a6a:	e9c3 2203 	strd	r2, r2, [r3, #12]
			switch (newConfig.RS485_speed)
 8024a6e:	d0dd      	beq.n	8024a2c <handler_setSpeed+0x12c>
 8024a70:	d81e      	bhi.n	8024ab0 <handler_setSpeed+0x1b0>
 8024a72:	2940      	cmp	r1, #64	@ 0x40
 8024a74:	d079      	beq.n	8024b6a <handler_setSpeed+0x26a>
 8024a76:	d858      	bhi.n	8024b2a <handler_setSpeed+0x22a>
				switch (newConfig.RS485_speed)
 8024a78:	2920      	cmp	r1, #32
 8024a7a:	d05f      	beq.n	8024b3c <handler_setSpeed+0x23c>
 8024a7c:	2930      	cmp	r1, #48	@ 0x30
 8024a7e:	d079      	beq.n	8024b74 <handler_setSpeed+0x274>
 8024a80:	2910      	cmp	r1, #16
 8024a82:	d179      	bne.n	8024b78 <handler_setSpeed+0x278>
					sprintf(name, "speed_4800");
 8024a84:	4a4b      	ldr	r2, [pc, #300]	@ (8024bb4 <handler_setSpeed+0x2b4>)
 8024a86:	e01b      	b.n	8024ac0 <handler_setSpeed+0x1c0>
			PRINTF_APP("Config ignored: BAD MAC\n");
 8024a88:	494b      	ldr	r1, [pc, #300]	@ (8024bb8 <handler_setSpeed+0x2b8>)
 8024a8a:	2000      	movs	r0, #0
 8024a8c:	f003 facc 	bl	8028028 <LOG_fprintf>
}
 8024a90:	b01a      	add	sp, #104	@ 0x68
 8024a92:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	switch (spd)
 8024a96:	f1b8 0fb0 	cmp.w	r8, #176	@ 0xb0
 8024a9a:	d0a4      	beq.n	80249e6 <handler_setSpeed+0xe6>
 8024a9c:	d835      	bhi.n	8024b0a <handler_setSpeed+0x20a>
 8024a9e:	f008 03ef 	and.w	r3, r8, #239	@ 0xef
 8024aa2:	2b80      	cmp	r3, #128	@ 0x80
 8024aa4:	d09f      	beq.n	80249e6 <handler_setSpeed+0xe6>
 8024aa6:	f1b8 0fa0 	cmp.w	r8, #160	@ 0xa0
 8024aaa:	f47f af55 	bne.w	8024958 <handler_setSpeed+0x58>
 8024aae:	e79a      	b.n	80249e6 <handler_setSpeed+0xe6>
			switch (newConfig.RS485_speed)
 8024ab0:	29b0      	cmp	r1, #176	@ 0xb0
 8024ab2:	d045      	beq.n	8024b40 <handler_setSpeed+0x240>
 8024ab4:	d846      	bhi.n	8024b44 <handler_setSpeed+0x244>
 8024ab6:	2990      	cmp	r1, #144	@ 0x90
 8024ab8:	d04d      	beq.n	8024b56 <handler_setSpeed+0x256>
 8024aba:	29a0      	cmp	r1, #160	@ 0xa0
 8024abc:	d15c      	bne.n	8024b78 <handler_setSpeed+0x278>
					sprintf(name, "speed_115k");
 8024abe:	4a3f      	ldr	r2, [pc, #252]	@ (8024bbc <handler_setSpeed+0x2bc>)
					sprintf(name, "speed_7200");
 8024ac0:	ca07      	ldmia	r2, {r0, r1, r2}
 8024ac2:	461c      	mov	r4, r3
 8024ac4:	c403      	stmia	r4!, {r0, r1}
 8024ac6:	8022      	strh	r2, [r4, #0]
 8024ac8:	0c12      	lsrs	r2, r2, #16
 8024aca:	729a      	strb	r2, [r3, #10]
				PRINTF_APP("New config speed: %s\n", name);
 8024acc:	461a      	mov	r2, r3
 8024ace:	493c      	ldr	r1, [pc, #240]	@ (8024bc0 <handler_setSpeed+0x2c0>)
 8024ad0:	2000      	movs	r0, #0
 8024ad2:	f003 faa9 	bl	8028028 <LOG_fprintf>
				dSetFlag_ACK(flags);
 8024ad6:	2201      	movs	r2, #1
 8024ad8:	e743      	b.n	8024962 <handler_setSpeed+0x62>
	switch (spd)
 8024ada:	f003 03ef 	and.w	r3, r3, #239	@ 0xef
 8024ade:	2bc0      	cmp	r3, #192	@ 0xc0
 8024ae0:	f47f af3a 	bne.w	8024958 <handler_setSpeed+0x58>
 8024ae4:	e7b0      	b.n	8024a48 <handler_setSpeed+0x148>
 8024ae6:	2b50      	cmp	r3, #80	@ 0x50
 8024ae8:	d0ae      	beq.n	8024a48 <handler_setSpeed+0x148>
 8024aea:	2b60      	cmp	r3, #96	@ 0x60
 8024aec:	f47f af34 	bne.w	8024958 <handler_setSpeed+0x58>
 8024af0:	e7aa      	b.n	8024a48 <handler_setSpeed+0x148>
				switch (newConfig.RS485_speed)
 8024af2:	2940      	cmp	r1, #64	@ 0x40
 8024af4:	d039      	beq.n	8024b6a <handler_setSpeed+0x26a>
 8024af6:	d9bf      	bls.n	8024a78 <handler_setSpeed+0x178>
 8024af8:	2950      	cmp	r1, #80	@ 0x50
 8024afa:	d043      	beq.n	8024b84 <handler_setSpeed+0x284>
 8024afc:	2960      	cmp	r1, #96	@ 0x60
 8024afe:	d13b      	bne.n	8024b78 <handler_setSpeed+0x278>
					sprintf(name, "speed_28800");
 8024b00:	4a30      	ldr	r2, [pc, #192]	@ (8024bc4 <handler_setSpeed+0x2c4>)
 8024b02:	ca07      	ldmia	r2, {r0, r1, r2}
 8024b04:	e883 0007 	stmia.w	r3, {r0, r1, r2}
					break;
 8024b08:	e7e0      	b.n	8024acc <handler_setSpeed+0x1cc>
	switch (spd)
 8024b0a:	f008 08ef 	and.w	r8, r8, #239	@ 0xef
 8024b0e:	f1b8 0fc0 	cmp.w	r8, #192	@ 0xc0
 8024b12:	f47f af21 	bne.w	8024958 <handler_setSpeed+0x58>
 8024b16:	e766      	b.n	80249e6 <handler_setSpeed+0xe6>
 8024b18:	f1b8 0f50 	cmp.w	r8, #80	@ 0x50
 8024b1c:	f43f af63 	beq.w	80249e6 <handler_setSpeed+0xe6>
 8024b20:	f1b8 0f60 	cmp.w	r8, #96	@ 0x60
 8024b24:	f47f af18 	bne.w	8024958 <handler_setSpeed+0x58>
 8024b28:	e75d      	b.n	80249e6 <handler_setSpeed+0xe6>
			switch (newConfig.RS485_speed)
 8024b2a:	2960      	cmp	r1, #96	@ 0x60
 8024b2c:	d0e8      	beq.n	8024b00 <handler_setSpeed+0x200>
 8024b2e:	2970      	cmp	r1, #112	@ 0x70
 8024b30:	d122      	bne.n	8024b78 <handler_setSpeed+0x278>
					sprintf(name, "speed_33600");
 8024b32:	4a25      	ldr	r2, [pc, #148]	@ (8024bc8 <handler_setSpeed+0x2c8>)
 8024b34:	ca07      	ldmia	r2, {r0, r1, r2}
 8024b36:	e883 0007 	stmia.w	r3, {r0, r1, r2}
					break;
 8024b3a:	e7c7      	b.n	8024acc <handler_setSpeed+0x1cc>
					sprintf(name, "speed_7200");
 8024b3c:	4a23      	ldr	r2, [pc, #140]	@ (8024bcc <handler_setSpeed+0x2cc>)
 8024b3e:	e7bf      	b.n	8024ac0 <handler_setSpeed+0x1c0>
					sprintf(name, "speed_500k");
 8024b40:	4a23      	ldr	r2, [pc, #140]	@ (8024bd0 <handler_setSpeed+0x2d0>)
 8024b42:	e7bd      	b.n	8024ac0 <handler_setSpeed+0x1c0>
				switch (newConfig.RS485_speed)
 8024b44:	29c0      	cmp	r1, #192	@ 0xc0
 8024b46:	d00b      	beq.n	8024b60 <handler_setSpeed+0x260>
 8024b48:	29d0      	cmp	r1, #208	@ 0xd0
 8024b4a:	d115      	bne.n	8024b78 <handler_setSpeed+0x278>
					sprintf(name, "speed_1500k");
 8024b4c:	4a21      	ldr	r2, [pc, #132]	@ (8024bd4 <handler_setSpeed+0x2d4>)
 8024b4e:	ca07      	ldmia	r2, {r0, r1, r2}
 8024b50:	e883 0007 	stmia.w	r3, {r0, r1, r2}
					break;
 8024b54:	e7ba      	b.n	8024acc <handler_setSpeed+0x1cc>
					sprintf(name, "speed_57600");
 8024b56:	4a20      	ldr	r2, [pc, #128]	@ (8024bd8 <handler_setSpeed+0x2d8>)
 8024b58:	ca07      	ldmia	r2, {r0, r1, r2}
 8024b5a:	e883 0007 	stmia.w	r3, {r0, r1, r2}
					break;
 8024b5e:	e7b5      	b.n	8024acc <handler_setSpeed+0x1cc>
					sprintf(name, "speed_1000k");
 8024b60:	4a1e      	ldr	r2, [pc, #120]	@ (8024bdc <handler_setSpeed+0x2dc>)
 8024b62:	ca07      	ldmia	r2, {r0, r1, r2}
 8024b64:	e883 0007 	stmia.w	r3, {r0, r1, r2}
					break;
 8024b68:	e7b0      	b.n	8024acc <handler_setSpeed+0x1cc>
					sprintf(name, "speed_14400");
 8024b6a:	4a1d      	ldr	r2, [pc, #116]	@ (8024be0 <handler_setSpeed+0x2e0>)
 8024b6c:	ca07      	ldmia	r2, {r0, r1, r2}
 8024b6e:	e883 0007 	stmia.w	r3, {r0, r1, r2}
					break;
 8024b72:	e7ab      	b.n	8024acc <handler_setSpeed+0x1cc>
					sprintf(name, "speed_9600");
 8024b74:	4a1b      	ldr	r2, [pc, #108]	@ (8024be4 <handler_setSpeed+0x2e4>)
 8024b76:	e7a3      	b.n	8024ac0 <handler_setSpeed+0x1c0>
					sprintf(name, "bad speed");
 8024b78:	4a1b      	ldr	r2, [pc, #108]	@ (8024be8 <handler_setSpeed+0x2e8>)
 8024b7a:	ca07      	ldmia	r2, {r0, r1, r2}
 8024b7c:	461c      	mov	r4, r3
 8024b7e:	c403      	stmia	r4!, {r0, r1}
 8024b80:	8022      	strh	r2, [r4, #0]
					break;
 8024b82:	e7a3      	b.n	8024acc <handler_setSpeed+0x1cc>
					sprintf(name, "speed_19200");
 8024b84:	4a19      	ldr	r2, [pc, #100]	@ (8024bec <handler_setSpeed+0x2ec>)
 8024b86:	ca07      	ldmia	r2, {r0, r1, r2}
 8024b88:	e883 0007 	stmia.w	r3, {r0, r1, r2}
					break;
 8024b8c:	e79e      	b.n	8024acc <handler_setSpeed+0x1cc>
 8024b8e:	bf00      	nop
 8024b90:	20000008 	.word	0x20000008
 8024b94:	0802e26c 	.word	0x0802e26c
 8024b98:	0802e67c 	.word	0x0802e67c
 8024b9c:	0802e688 	.word	0x0802e688
 8024ba0:	0802ad28 	.word	0x0802ad28
 8024ba4:	0802e4f0 	.word	0x0802e4f0
 8024ba8:	0802e2f0 	.word	0x0802e2f0
 8024bac:	0802e2bc 	.word	0x0802e2bc
 8024bb0:	0802e6ec 	.word	0x0802e6ec
 8024bb4:	0802e6a4 	.word	0x0802e6a4
 8024bb8:	0802e304 	.word	0x0802e304
 8024bbc:	0802e704 	.word	0x0802e704
 8024bc0:	0802e740 	.word	0x0802e740
 8024bc4:	0802e6d4 	.word	0x0802e6d4
 8024bc8:	0802e6e0 	.word	0x0802e6e0
 8024bcc:	0802e6b0 	.word	0x0802e6b0
 8024bd0:	0802e710 	.word	0x0802e710
 8024bd4:	0802e728 	.word	0x0802e728
 8024bd8:	0802e6f8 	.word	0x0802e6f8
 8024bdc:	0802e71c 	.word	0x0802e71c
 8024be0:	0802e6c8 	.word	0x0802e6c8
 8024be4:	0802e6bc 	.word	0x0802e6bc
 8024be8:	0802e734 	.word	0x0802e734
 8024bec:	0802e758 	.word	0x0802e758

08024bf0 <Comm_Process>:
{
 8024bf0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8024bf2:	b083      	sub	sp, #12
	if (FrameReady == CommLink_Process())
 8024bf4:	f000 f9ce 	bl	8024f94 <CommLink_Process>
 8024bf8:	2802      	cmp	r0, #2
 8024bfa:	d001      	beq.n	8024c00 <Comm_Process+0x10>
}
 8024bfc:	b003      	add	sp, #12
 8024bfe:	bdf0      	pop	{r4, r5, r6, r7, pc}
	Sensor.addressing_by_MAC = false;
 8024c00:	4e79      	ldr	r6, [pc, #484]	@ (8024de8 <Comm_Process+0x1f8>)
 8024c02:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8024c06:	f8a6 3001 	strh.w	r3, [r6, #1]
	if ((CommLink_GetCommand() > 0x21 && CommLink_GetCommand() != 0x23) && Sensor.aqusition)
 8024c0a:	f000 fa87 	bl	802511c <CommLink_GetCommand>
 8024c0e:	2821      	cmp	r0, #33	@ 0x21
 8024c10:	d837      	bhi.n	8024c82 <Comm_Process+0x92>
		uint8_t cmd = CommLink_GetCommand();
 8024c12:	f000 fa83 	bl	802511c <CommLink_GetCommand>
 8024c16:	4604      	mov	r4, r0
		if (CommLink_GetAddr() == 0x00) // Adresowanie po MAC
 8024c18:	f000 fa7a 	bl	8025110 <CommLink_GetAddr>
 8024c1c:	4605      	mov	r5, r0
 8024c1e:	2800      	cmp	r0, #0
 8024c20:	d139      	bne.n	8024c96 <Comm_Process+0xa6>
			if (cmd == getAddrMac && CommLink_GetAddr() == Sensor.configuration.sensor_ID) // Wysyanie GetMac do kadego czujnika z ID=0
 8024c22:	2c12      	cmp	r4, #18
 8024c24:	d074      	beq.n	8024d10 <Comm_Process+0x120>
				Sensor.addressing_by_MAC = true;
 8024c26:	2701      	movs	r7, #1
				PRINTF_APP("COMM_APP: Adresowanie po MAC\r\n");
 8024c28:	4970      	ldr	r1, [pc, #448]	@ (8024dec <Comm_Process+0x1fc>)
				Sensor.addressing_by_MAC = true;
 8024c2a:	7077      	strb	r7, [r6, #1]
				PRINTF_APP("COMM_APP: Adresowanie po MAC\r\n");
 8024c2c:	f003 f9fc 	bl	8028028 <LOG_fprintf>
					if (cmd == _handlers[i].cmd)
 8024c30:	42bc      	cmp	r4, r7
 8024c32:	d021      	beq.n	8024c78 <Comm_Process+0x88>
 8024c34:	2c02      	cmp	r4, #2
 8024c36:	f000 8098 	beq.w	8024d6a <Comm_Process+0x17a>
 8024c3a:	2c11      	cmp	r4, #17
 8024c3c:	f000 8097 	beq.w	8024d6e <Comm_Process+0x17e>
 8024c40:	2c21      	cmp	r4, #33	@ 0x21
 8024c42:	f000 8096 	beq.w	8024d72 <Comm_Process+0x182>
 8024c46:	2c22      	cmp	r4, #34	@ 0x22
 8024c48:	f000 8095 	beq.w	8024d76 <Comm_Process+0x186>
 8024c4c:	2c23      	cmp	r4, #35	@ 0x23
 8024c4e:	f000 8094 	beq.w	8024d7a <Comm_Process+0x18a>
 8024c52:	2c24      	cmp	r4, #36	@ 0x24
 8024c54:	f000 8093 	beq.w	8024d7e <Comm_Process+0x18e>
 8024c58:	2c25      	cmp	r4, #37	@ 0x25
 8024c5a:	f000 80a7 	beq.w	8024dac <Comm_Process+0x1bc>
 8024c5e:	2c2f      	cmp	r4, #47	@ 0x2f
 8024c60:	f000 80a6 	beq.w	8024db0 <Comm_Process+0x1c0>
 8024c64:	2c26      	cmp	r4, #38	@ 0x26
 8024c66:	f000 80a5 	beq.w	8024db4 <Comm_Process+0x1c4>
 8024c6a:	2c31      	cmp	r4, #49	@ 0x31
 8024c6c:	f000 80a4 	beq.w	8024db8 <Comm_Process+0x1c8>
 8024c70:	2c19      	cmp	r4, #25
 8024c72:	bf08      	it	eq
 8024c74:	250c      	moveq	r5, #12
 8024c76:	d1c1      	bne.n	8024bfc <Comm_Process+0xc>
						_handlers[i].func(_handlers[i].cmd);
 8024c78:	4b5d      	ldr	r3, [pc, #372]	@ (8024df0 <Comm_Process+0x200>)
 8024c7a:	4620      	mov	r0, r4
 8024c7c:	eb03 03c5 	add.w	r3, r3, r5, lsl #3
 8024c80:	e041      	b.n	8024d06 <Comm_Process+0x116>
	if ((CommLink_GetCommand() > 0x21 && CommLink_GetCommand() != 0x23) && Sensor.aqusition)
 8024c82:	f000 fa4b 	bl	802511c <CommLink_GetCommand>
 8024c86:	2823      	cmp	r0, #35	@ 0x23
 8024c88:	d0c3      	beq.n	8024c12 <Comm_Process+0x22>
 8024c8a:	78f3      	ldrb	r3, [r6, #3]
 8024c8c:	2b00      	cmp	r3, #0
 8024c8e:	d0c0      	beq.n	8024c12 <Comm_Process+0x22>
		PRINTF_APP("COMM_APP: Sorry trwa akwizycja, komenda nieobsugiwana\r\n");
 8024c90:	4958      	ldr	r1, [pc, #352]	@ (8024df4 <Comm_Process+0x204>)
 8024c92:	2000      	movs	r0, #0
 8024c94:	e00b      	b.n	8024cae <Comm_Process+0xbe>
		else if (CommLink_GetAddr() == 0xff) // Tryb Broadcast
 8024c96:	f000 fa3b 	bl	8025110 <CommLink_GetAddr>
 8024c9a:	28ff      	cmp	r0, #255	@ 0xff
 8024c9c:	d10c      	bne.n	8024cb8 <Comm_Process+0xc8>
			Sensor.not_broadcast_mode = false;
 8024c9e:	2500      	movs	r5, #0
			if (cmd == starAcq)
 8024ca0:	2c01      	cmp	r4, #1
			Sensor.not_broadcast_mode = false;
 8024ca2:	70b5      	strb	r5, [r6, #2]
			if (cmd == starAcq)
 8024ca4:	d057      	beq.n	8024d56 <Comm_Process+0x166>
			else if (cmd == stopAcq)
 8024ca6:	2c02      	cmp	r4, #2
 8024ca8:	d043      	beq.n	8024d32 <Comm_Process+0x142>
				PRINTF_APP("COMM_APP: Polecenie rozgoszeniowe niedozwolona komenda w trybie broadcast \r\n");
 8024caa:	4953      	ldr	r1, [pc, #332]	@ (8024df8 <Comm_Process+0x208>)
 8024cac:	4628      	mov	r0, r5
}
 8024cae:	b003      	add	sp, #12
 8024cb0:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
			PRINTF("COMM_APP: Nie nasz adres\r\n");
 8024cb4:	f003 b9b8 	b.w	8028028 <LOG_fprintf>
		else if (CommLink_GetAddr() == Sensor.configuration.sensor_ID) // Adresowanie po ID
 8024cb8:	f000 fa2a 	bl	8025110 <CommLink_GetAddr>
 8024cbc:	f896 306e 	ldrb.w	r3, [r6, #110]	@ 0x6e
 8024cc0:	4283      	cmp	r3, r0
 8024cc2:	d133      	bne.n	8024d2c <Comm_Process+0x13c>
			if ((cmd == reset) || (cmd == setSpeed)) // Reset i setSpeed nieobsugiwane po ID
 8024cc4:	2c2f      	cmp	r4, #47	@ 0x2f
 8024cc6:	d043      	beq.n	8024d50 <Comm_Process+0x160>
 8024cc8:	2c25      	cmp	r4, #37	@ 0x25
 8024cca:	d041      	beq.n	8024d50 <Comm_Process+0x160>
					if (cmd == _handlers[i].cmd)
 8024ccc:	2c01      	cmp	r4, #1
 8024cce:	d079      	beq.n	8024dc4 <Comm_Process+0x1d4>
 8024cd0:	2c02      	cmp	r4, #2
 8024cd2:	d075      	beq.n	8024dc0 <Comm_Process+0x1d0>
 8024cd4:	2c11      	cmp	r4, #17
 8024cd6:	d079      	beq.n	8024dcc <Comm_Process+0x1dc>
 8024cd8:	2c12      	cmp	r4, #18
 8024cda:	d075      	beq.n	8024dc8 <Comm_Process+0x1d8>
 8024cdc:	2c21      	cmp	r4, #33	@ 0x21
 8024cde:	d079      	beq.n	8024dd4 <Comm_Process+0x1e4>
 8024ce0:	2c22      	cmp	r4, #34	@ 0x22
 8024ce2:	d075      	beq.n	8024dd0 <Comm_Process+0x1e0>
 8024ce4:	2c23      	cmp	r4, #35	@ 0x23
 8024ce6:	d079      	beq.n	8024ddc <Comm_Process+0x1ec>
 8024ce8:	2c24      	cmp	r4, #36	@ 0x24
 8024cea:	d075      	beq.n	8024dd8 <Comm_Process+0x1e8>
 8024cec:	2c26      	cmp	r4, #38	@ 0x26
 8024cee:	d079      	beq.n	8024de4 <Comm_Process+0x1f4>
 8024cf0:	2c31      	cmp	r4, #49	@ 0x31
 8024cf2:	d075      	beq.n	8024de0 <Comm_Process+0x1f0>
 8024cf4:	2c19      	cmp	r4, #25
 8024cf6:	bf08      	it	eq
 8024cf8:	230c      	moveq	r3, #12
 8024cfa:	f47f af7f 	bne.w	8024bfc <Comm_Process+0xc>
						_handlers[i].func(_handlers[i].cmd);
 8024cfe:	4a3c      	ldr	r2, [pc, #240]	@ (8024df0 <Comm_Process+0x200>)
 8024d00:	4620      	mov	r0, r4
 8024d02:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 8024d06:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
}
 8024d08:	b003      	add	sp, #12
 8024d0a:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
						_handlers[i].func(_handlers[i].cmd);
 8024d0e:	4718      	bx	r3
			if (cmd == getAddrMac && CommLink_GetAddr() == Sensor.configuration.sensor_ID) // Wysyanie GetMac do kadego czujnika z ID=0
 8024d10:	f000 f9fe 	bl	8025110 <CommLink_GetAddr>
 8024d14:	f896 306e 	ldrb.w	r3, [r6, #110]	@ 0x6e
 8024d18:	4283      	cmp	r3, r0
 8024d1a:	d013      	beq.n	8024d44 <Comm_Process+0x154>
				Sensor.addressing_by_MAC = true;
 8024d1c:	2301      	movs	r3, #1
				PRINTF_APP("COMM_APP: Adresowanie po MAC\r\n");
 8024d1e:	4628      	mov	r0, r5
 8024d20:	4932      	ldr	r1, [pc, #200]	@ (8024dec <Comm_Process+0x1fc>)
				Sensor.addressing_by_MAC = true;
 8024d22:	7073      	strb	r3, [r6, #1]
				for (uint32_t i = 0; i < sizeof(_handlers) / sizeof(_handlers[0]); ++i)
 8024d24:	2503      	movs	r5, #3
				PRINTF_APP("COMM_APP: Adresowanie po MAC\r\n");
 8024d26:	f003 f97f 	bl	8028028 <LOG_fprintf>
					if (cmd == _handlers[i].cmd)
 8024d2a:	e7a5      	b.n	8024c78 <Comm_Process+0x88>
			PRINTF("COMM_APP: Nie nasz adres\r\n");
 8024d2c:	4933      	ldr	r1, [pc, #204]	@ (8024dfc <Comm_Process+0x20c>)
 8024d2e:	2006      	movs	r0, #6
 8024d30:	e7bd      	b.n	8024cae <Comm_Process+0xbe>
				PRINTF_APP("COMM_APP: Polecenie rozgoszeniowe stopAcq \r\n");
 8024d32:	4933      	ldr	r1, [pc, #204]	@ (8024e00 <Comm_Process+0x210>)
 8024d34:	4628      	mov	r0, r5
 8024d36:	f003 f977 	bl	8028028 <LOG_fprintf>
	if (Sensor.addressing_by_MAC)
 8024d3a:	7877      	ldrb	r7, [r6, #1]
 8024d3c:	b30f      	cbz	r7, 8024d82 <Comm_Process+0x192>
		PRINTF_APP("No response - addressing by MAC\n");
 8024d3e:	4931      	ldr	r1, [pc, #196]	@ (8024e04 <Comm_Process+0x214>)
 8024d40:	4628      	mov	r0, r5
 8024d42:	e7b4      	b.n	8024cae <Comm_Process+0xbe>
				handler_getAddrMac(cmd);
 8024d44:	4620      	mov	r0, r4
}
 8024d46:	b003      	add	sp, #12
 8024d48:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
				handler_getAddrMac(cmd);
 8024d4c:	f7ff bd02 	b.w	8024754 <handler_getAddrMac>
				PRINTF_APP("Komenda nie obsugiwana po ID\r\n");
 8024d50:	492d      	ldr	r1, [pc, #180]	@ (8024e08 <Comm_Process+0x218>)
 8024d52:	2000      	movs	r0, #0
 8024d54:	e7ab      	b.n	8024cae <Comm_Process+0xbe>
				PRINTF_APP("COMM_APP: Polecenie rozgoszeniowe StartACQ \r\n");
 8024d56:	4628      	mov	r0, r5
 8024d58:	492c      	ldr	r1, [pc, #176]	@ (8024e0c <Comm_Process+0x21c>)
 8024d5a:	f003 f965 	bl	8028028 <LOG_fprintf>
				handler_starAcq(cmd);
 8024d5e:	4620      	mov	r0, r4
}
 8024d60:	b003      	add	sp, #12
 8024d62:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
				handler_starAcq(cmd);
 8024d66:	f7ff bd63 	b.w	8024830 <handler_starAcq>
				for (uint32_t i = 0; i < sizeof(_handlers) / sizeof(_handlers[0]); ++i)
 8024d6a:	463d      	mov	r5, r7
 8024d6c:	e784      	b.n	8024c78 <Comm_Process+0x88>
 8024d6e:	2502      	movs	r5, #2
 8024d70:	e782      	b.n	8024c78 <Comm_Process+0x88>
 8024d72:	2504      	movs	r5, #4
 8024d74:	e780      	b.n	8024c78 <Comm_Process+0x88>
 8024d76:	2505      	movs	r5, #5
 8024d78:	e77e      	b.n	8024c78 <Comm_Process+0x88>
 8024d7a:	2506      	movs	r5, #6
 8024d7c:	e77c      	b.n	8024c78 <Comm_Process+0x88>
 8024d7e:	2507      	movs	r5, #7
 8024d80:	e77a      	b.n	8024c78 <Comm_Process+0x88>
		PRINTF_APP("Addressing by SensorID\n");
 8024d82:	4923      	ldr	r1, [pc, #140]	@ (8024e10 <Comm_Process+0x220>)
 8024d84:	4638      	mov	r0, r7
 8024d86:	f003 f94f 	bl	8028028 <LOG_fprintf>
		PRINTF_APP("Stop acquisition\r\n");
 8024d8a:	4638      	mov	r0, r7
 8024d8c:	4921      	ldr	r1, [pc, #132]	@ (8024e14 <Comm_Process+0x224>)
 8024d8e:	f003 f94b 	bl	8028028 <LOG_fprintf>
		ACQ_Stop();
 8024d92:	f7fe fd71 	bl	8023878 <ACQ_Stop>
		if (Sensor.not_broadcast_mode)
 8024d96:	78b0      	ldrb	r0, [r6, #2]
 8024d98:	b180      	cbz	r0, 8024dbc <Comm_Process+0x1cc>
			CommLink_SendData(Sensor.configuration.sensor_ID, cmd, flags, 0, 0);
 8024d9a:	f896 006e 	ldrb.w	r0, [r6, #110]	@ 0x6e
 8024d9e:	9700      	str	r7, [sp, #0]
 8024da0:	463b      	mov	r3, r7
 8024da2:	2201      	movs	r2, #1
 8024da4:	4621      	mov	r1, r4
 8024da6:	f000 f855 	bl	8024e54 <CommLink_SendData>
}
 8024daa:	e727      	b.n	8024bfc <Comm_Process+0xc>
				for (uint32_t i = 0; i < sizeof(_handlers) / sizeof(_handlers[0]); ++i)
 8024dac:	2508      	movs	r5, #8
 8024dae:	e763      	b.n	8024c78 <Comm_Process+0x88>
 8024db0:	2509      	movs	r5, #9
 8024db2:	e761      	b.n	8024c78 <Comm_Process+0x88>
 8024db4:	250a      	movs	r5, #10
 8024db6:	e75f      	b.n	8024c78 <Comm_Process+0x88>
 8024db8:	250b      	movs	r5, #11
 8024dba:	e75d      	b.n	8024c78 <Comm_Process+0x88>
			PRINTF_APP("No response - broadcast mode");
 8024dbc:	4916      	ldr	r1, [pc, #88]	@ (8024e18 <Comm_Process+0x228>)
 8024dbe:	e776      	b.n	8024cae <Comm_Process+0xbe>
				for (int i = 0; i < sizeof(_handlers) / sizeof(_handlers[0]); ++i)
 8024dc0:	2301      	movs	r3, #1
 8024dc2:	e79c      	b.n	8024cfe <Comm_Process+0x10e>
 8024dc4:	2300      	movs	r3, #0
 8024dc6:	e79a      	b.n	8024cfe <Comm_Process+0x10e>
 8024dc8:	2303      	movs	r3, #3
 8024dca:	e798      	b.n	8024cfe <Comm_Process+0x10e>
 8024dcc:	2302      	movs	r3, #2
 8024dce:	e796      	b.n	8024cfe <Comm_Process+0x10e>
 8024dd0:	2305      	movs	r3, #5
 8024dd2:	e794      	b.n	8024cfe <Comm_Process+0x10e>
 8024dd4:	2304      	movs	r3, #4
 8024dd6:	e792      	b.n	8024cfe <Comm_Process+0x10e>
 8024dd8:	2307      	movs	r3, #7
 8024dda:	e790      	b.n	8024cfe <Comm_Process+0x10e>
 8024ddc:	2306      	movs	r3, #6
 8024dde:	e78e      	b.n	8024cfe <Comm_Process+0x10e>
 8024de0:	230b      	movs	r3, #11
 8024de2:	e78c      	b.n	8024cfe <Comm_Process+0x10e>
 8024de4:	230a      	movs	r3, #10
 8024de6:	e78a      	b.n	8024cfe <Comm_Process+0x10e>
 8024de8:	20000008 	.word	0x20000008
 8024dec:	0802e7a0 	.word	0x0802e7a0
 8024df0:	0802ace0 	.word	0x0802ace0
 8024df4:	0802e764 	.word	0x0802e764
 8024df8:	0802e824 	.word	0x0802e824
 8024dfc:	0802e898 	.word	0x0802e898
 8024e00:	0802e7f4 	.word	0x0802e7f4
 8024e04:	0802e46c 	.word	0x0802e46c
 8024e08:	0802e874 	.word	0x0802e874
 8024e0c:	0802e7c0 	.word	0x0802e7c0
 8024e10:	0802e26c 	.word	0x0802e26c
 8024e14:	0802e51c 	.word	0x0802e51c
 8024e18:	0802e530 	.word	0x0802e530

08024e1c <Comm_ModbusMath>:

uint8_t *Comm_ModbusMath()
{
 8024e1c:	b508      	push	{r3, lr}

	//

#ifdef SENSOR_TYPE_LF
	if (Sensor.parameters.ScalarCount == 1)
 8024e1e:	4b08      	ldr	r3, [pc, #32]	@ (8024e40 <Comm_ModbusMath+0x24>)
 8024e20:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 8024e24:	2b01      	cmp	r3, #1
 8024e26:	d007      	beq.n	8024e38 <Comm_ModbusMath+0x1c>
		Temp_SampleGet(respData);
	}
	// respLen = ACQ_GetSamples(respData+(sizeof(float)*Sensor.parameters.ScalarCount),samplesRequested) + sizeof(float)*Sensor.parameters.ScalarCount;
#endif

	ACQ_clearOverFlow();
 8024e28:	f7ff f80c 	bl	8023e44 <ACQ_clearOverFlow>

	PRINTF_APP("COMM_APP: Get measurement\r\n");
 8024e2c:	4905      	ldr	r1, [pc, #20]	@ (8024e44 <Comm_ModbusMath+0x28>)
 8024e2e:	2000      	movs	r0, #0
 8024e30:	f003 f8fa 	bl	8028028 <LOG_fprintf>
	return respData;
}
 8024e34:	4804      	ldr	r0, [pc, #16]	@ (8024e48 <Comm_ModbusMath+0x2c>)
 8024e36:	bd08      	pop	{r3, pc}
		Temp_SampleGet(respData);
 8024e38:	4803      	ldr	r0, [pc, #12]	@ (8024e48 <Comm_ModbusMath+0x2c>)
 8024e3a:	f000 ffd7 	bl	8025dec <Temp_SampleGet>
 8024e3e:	e7f3      	b.n	8024e28 <Comm_ModbusMath+0xc>
 8024e40:	20000008 	.word	0x20000008
 8024e44:	0802e8b4 	.word	0x0802e8b4
 8024e48:	2001f7b4 	.word	0x2001f7b4

08024e4c <Comm_Modbus_MaxSampleAtOnce>:

uint32_t Comm_Modbus_MaxSampleAtOnce()
{
	return MAX_SAMPLES_AT_ONCE;
}
 8024e4c:	f44f 6080 	mov.w	r0, #1024	@ 0x400
 8024e50:	4770      	bx	lr
 8024e52:	bf00      	nop

08024e54 <CommLink_SendData>:
	OTC_RegisterResponseHandler(CommLink_SendData);
}

/******************************************************************************/
bool CommLink_SendData(uint8_t addrSensor, uint8_t command, uint8_t flags, const void * const data, uint16_t len)
{
 8024e54:	b5f0      	push	{r4, r5, r6, r7, lr}
 8024e56:	b089      	sub	sp, #36	@ 0x24
	if(data == 0 && len != 0)
 8024e58:	461e      	mov	r6, r3
{
 8024e5a:	f8bd 5038 	ldrh.w	r5, [sp, #56]	@ 0x38
 8024e5e:	f88d 0007 	strb.w	r0, [sp, #7]
 8024e62:	f88d 1006 	strb.w	r1, [sp, #6]
 8024e66:	f88d 2005 	strb.w	r2, [sp, #5]
	if(data == 0 && len != 0)
 8024e6a:	2b00      	cmp	r3, #0
 8024e6c:	d06d      	beq.n	8024f4a <CommLink_SendData+0xf6>
		return false;
	if(_phySend_func == 0)
 8024e6e:	4f39      	ldr	r7, [pc, #228]	@ (8024f54 <CommLink_SendData+0x100>)
 8024e70:	6838      	ldr	r0, [r7, #0]
 8024e72:	2800      	cmp	r0, #0
 8024e74:	d067      	beq.n	8024f46 <CommLink_SendData+0xf2>
		return false;
	uint16_t ret, crcHeader;
	uint16_t length = len + dFrameSize_Length + dFrameSize_AddrSensor + dFrameSize_Command + dFrameSize_Flags + dFrameSize_CrcHeader + dFrameSize_Crc;
 8024e76:	f105 0309 	add.w	r3, r5, #9
	uint16_t crc = CalCrc16(0, &length, sizeof(length));
 8024e7a:	2202      	movs	r2, #2
 8024e7c:	a904      	add	r1, sp, #16
 8024e7e:	2000      	movs	r0, #0
	uint16_t length = len + dFrameSize_Length + dFrameSize_AddrSensor + dFrameSize_Command + dFrameSize_Flags + dFrameSize_CrcHeader + dFrameSize_Crc;
 8024e80:	f8ad 3010 	strh.w	r3, [sp, #16]
	uint16_t crc = CalCrc16(0, &length, sizeof(length));
 8024e84:	f000 f950 	bl	8025128 <CalCrc16>
	crc = CalCrc16(crc, &addrSensor, sizeof(addrSensor));
 8024e88:	2201      	movs	r2, #1
 8024e8a:	f10d 0107 	add.w	r1, sp, #7
	uint16_t crc = CalCrc16(0, &length, sizeof(length));
 8024e8e:	f8ad 0012 	strh.w	r0, [sp, #18]
	crc = CalCrc16(crc, &addrSensor, sizeof(addrSensor));
 8024e92:	f000 f949 	bl	8025128 <CalCrc16>
	crc = CalCrc16(crc, &command, sizeof(command));
 8024e96:	2201      	movs	r2, #1
 8024e98:	f10d 0106 	add.w	r1, sp, #6
	crc = CalCrc16(crc, &addrSensor, sizeof(addrSensor));
 8024e9c:	f8ad 0012 	strh.w	r0, [sp, #18]
	crc = CalCrc16(crc, &command, sizeof(command));
 8024ea0:	f000 f942 	bl	8025128 <CalCrc16>
	crc = CalCrc16(crc, &flags, sizeof(flags));
 8024ea4:	2201      	movs	r2, #1
 8024ea6:	f10d 0105 	add.w	r1, sp, #5
	crc = CalCrc16(crc, &command, sizeof(command));
 8024eaa:	f8ad 0012 	strh.w	r0, [sp, #18]
	crc = CalCrc16(crc, &flags, sizeof(flags));
 8024eae:	f000 f93b 	bl	8025128 <CalCrc16>
	crcHeader = crc;
	crc = CalCrc16(crc, &crcHeader, sizeof(crcHeader));
 8024eb2:	2202      	movs	r2, #2
 8024eb4:	f10d 010e 	add.w	r1, sp, #14
	crc = CalCrc16(crc, &flags, sizeof(flags));
 8024eb8:	f8ad 0012 	strh.w	r0, [sp, #18]
	crcHeader = crc;
 8024ebc:	f8ad 000e 	strh.w	r0, [sp, #14]
	crc = CalCrc16(crc, &crcHeader, sizeof(crcHeader));
 8024ec0:	f000 f932 	bl	8025128 <CalCrc16>
	crc = CalCrc16(crc, data, len);
 8024ec4:	462a      	mov	r2, r5
 8024ec6:	4631      	mov	r1, r6
	crc = CalCrc16(crc, &crcHeader, sizeof(crcHeader));
 8024ec8:	f8ad 0012 	strh.w	r0, [sp, #18]
	crc = CalCrc16(crc, data, len);
 8024ecc:	f000 f92c 	bl	8025128 <CalCrc16>
	uint8_t header[11];
	memcpy(header, &_preamble, 4);
 8024ed0:	4921      	ldr	r1, [pc, #132]	@ (8024f58 <CommLink_SendData+0x104>)
 8024ed2:	9105      	str	r1, [sp, #20]
	memcpy(header+4, &length, 2);
	header[6] = addrSensor;
 8024ed4:	f89d 1007 	ldrb.w	r1, [sp, #7]
	header[7] = command;
	header[8] = flags;
	header[9] = crcHeader & 0x0ff;
 8024ed8:	f8bd 200e 	ldrh.w	r2, [sp, #14]
	crc = CalCrc16(crc, data, len);
 8024edc:	f8ad 0012 	strh.w	r0, [sp, #18]
	header[6] = addrSensor;
 8024ee0:	2300      	movs	r3, #0
 8024ee2:	f361 0307 	bfi	r3, r1, #0, #8
 8024ee6:	f89d 1006 	ldrb.w	r1, [sp, #6]
 8024eea:	f361 230f 	bfi	r3, r1, #8, #8
 8024eee:	f89d 1005 	ldrb.w	r1, [sp, #5]
 8024ef2:	f361 4317 	bfi	r3, r1, #16, #8
 8024ef6:	f362 631f 	bfi	r3, r2, #24, #8
 8024efa:	f8cd 301a 	str.w	r3, [sp, #26]
	header[10] = (crcHeader>>8) & 0x0ff;
 8024efe:	0a12      	lsrs	r2, r2, #8
	if(_phyTransmitOn_func)
 8024f00:	687b      	ldr	r3, [r7, #4]
	header[10] = (crcHeader>>8) & 0x0ff;
 8024f02:	f88d 201e 	strb.w	r2, [sp, #30]
	memcpy(header+4, &length, 2);
 8024f06:	f8bd 2010 	ldrh.w	r2, [sp, #16]
 8024f0a:	f8ad 2018 	strh.w	r2, [sp, #24]
	if(_phyTransmitOn_func)
 8024f0e:	b103      	cbz	r3, 8024f12 <CommLink_SendData+0xbe>
		_phyTransmitOn_func();
 8024f10:	4798      	blx	r3
	CommLink_TransmitOn();
	ret =  _phySend_func(&header, sizeof(header));
 8024f12:	683b      	ldr	r3, [r7, #0]
 8024f14:	210b      	movs	r1, #11
 8024f16:	a805      	add	r0, sp, #20
 8024f18:	4798      	blx	r3
	ret += _phySend_func(data, len);
 8024f1a:	683b      	ldr	r3, [r7, #0]
	ret =  _phySend_func(&header, sizeof(header));
 8024f1c:	4604      	mov	r4, r0
	ret += _phySend_func(data, len);
 8024f1e:	4629      	mov	r1, r5
 8024f20:	4630      	mov	r0, r6
 8024f22:	4798      	blx	r3
	ret += _phySend_func(&crc, dFrameSize_Crc);
 8024f24:	683b      	ldr	r3, [r7, #0]
	ret += _phySend_func(data, len);
 8024f26:	4404      	add	r4, r0
	ret += _phySend_func(&crc, dFrameSize_Crc);
 8024f28:	2102      	movs	r1, #2
 8024f2a:	f10d 0012 	add.w	r0, sp, #18
 8024f2e:	4798      	blx	r3
	ret += _phySend_func(data, len);
 8024f30:	b2a4      	uxth	r4, r4
	if(_phyTransmitOff_func)
 8024f32:	68bb      	ldr	r3, [r7, #8]
	ret += _phySend_func(&crc, dFrameSize_Crc);
 8024f34:	4420      	add	r0, r4
 8024f36:	b284      	uxth	r4, r0
	if(_phyTransmitOff_func)
 8024f38:	b103      	cbz	r3, 8024f3c <CommLink_SendData+0xe8>
		_phyTransmitOff_func();
 8024f3a:	4798      	blx	r3
	CommLink_TransmitOff();
	if(ret == dFrameSize_Preamble + dFrameSize_Length + dFrameSize_AddrSensor + dFrameSize_Command + dFrameSize_Flags + dFrameSize_CrcHeader + len + dFrameSize_Crc)
 8024f3c:	350d      	adds	r5, #13
 8024f3e:	1b28      	subs	r0, r5, r4
 8024f40:	fab0 f080 	clz	r0, r0
 8024f44:	0940      	lsrs	r0, r0, #5
		return true;
	else
		return false;
}
 8024f46:	b009      	add	sp, #36	@ 0x24
 8024f48:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if(data == 0 && len != 0)
 8024f4a:	2d00      	cmp	r5, #0
 8024f4c:	d08f      	beq.n	8024e6e <CommLink_SendData+0x1a>
		return false;
 8024f4e:	4618      	mov	r0, r3
}
 8024f50:	b009      	add	sp, #36	@ 0x24
 8024f52:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8024f54:	20021bb8 	.word	0x20021bb8
 8024f58:	a5aaaaaa 	.word	0xa5aaaaaa

08024f5c <CommLink_Init>:
	_phySend_func = RS485_Send;
 8024f5c:	4b07      	ldr	r3, [pc, #28]	@ (8024f7c <CommLink_Init+0x20>)
	_phyGetChar_func = RS485_GetByte;
 8024f5e:	4808      	ldr	r0, [pc, #32]	@ (8024f80 <CommLink_Init+0x24>)
	_phyTransmitOn_func = RS485_TransmitOn;
 8024f60:	4908      	ldr	r1, [pc, #32]	@ (8024f84 <CommLink_Init+0x28>)
	_phyTransmitOff_func = RS485_TransmitOff;
 8024f62:	4a09      	ldr	r2, [pc, #36]	@ (8024f88 <CommLink_Init+0x2c>)
{
 8024f64:	b410      	push	{r4}
	_phySend_func = RS485_Send;
 8024f66:	4c09      	ldr	r4, [pc, #36]	@ (8024f8c <CommLink_Init+0x30>)
 8024f68:	601c      	str	r4, [r3, #0]
	_phyGetChar_func = RS485_GetByte;
 8024f6a:	60d8      	str	r0, [r3, #12]
}
 8024f6c:	f85d 4b04 	ldr.w	r4, [sp], #4
	OTC_RegisterResponseHandler(CommLink_SendData);
 8024f70:	4807      	ldr	r0, [pc, #28]	@ (8024f90 <CommLink_Init+0x34>)
	_phyTransmitOff_func = RS485_TransmitOff;
 8024f72:	e9c3 1201 	strd	r1, r2, [r3, #4]
	OTC_RegisterResponseHandler(CommLink_SendData);
 8024f76:	f002 bf51 	b.w	8027e1c <OTC_RegisterResponseHandler>
 8024f7a:	bf00      	nop
 8024f7c:	20021bb8 	.word	0x20021bb8
 8024f80:	0802574d 	.word	0x0802574d
 8024f84:	0802569d 	.word	0x0802569d
 8024f88:	080256e5 	.word	0x080256e5
 8024f8c:	08025659 	.word	0x08025659
 8024f90:	08024e55 	.word	0x08024e55

08024f94 <CommLink_Process>:
		_phySendChar_func(byte);
}

/******************************************************************************/
Comm_FrameError_t CommLink_Process(void)
{
 8024f94:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint8_t byte;
	Comm_FrameError_t status = FrameNotReady;

	if(_phyGetChar_func == 0)
 8024f96:	4c50      	ldr	r4, [pc, #320]	@ (80250d8 <CommLink_Process+0x144>)
 8024f98:	68e3      	ldr	r3, [r4, #12]
{
 8024f9a:	b083      	sub	sp, #12
		return FrameNotReady;
 8024f9c:	2701      	movs	r7, #1
	if(_phyGetChar_func == 0)
 8024f9e:	b313      	cbz	r3, 8024fe6 <CommLink_Process+0x52>
	while(_phyGetChar_func(&byte))
 8024fa0:	f10d 0007 	add.w	r0, sp, #7
	if((idx > dFrameOffset_Data) && (idx-dFrameOffset_Data >= dFrameSize))
 8024fa4:	f240 352a 	movw	r5, #810	@ 0x32a
			idx = 0;
 8024fa8:	2600      	movs	r6, #0
	while(_phyGetChar_func(&byte))
 8024faa:	4798      	blx	r3
 8024fac:	b1d8      	cbz	r0, 8024fe6 <CommLink_Process+0x52>
	if((idx > dFrameOffset_Data) && (idx-dFrameOffset_Data >= dFrameSize))
 8024fae:	8a23      	ldrh	r3, [r4, #16]
	{
		status = CommLink_ProcessByte(byte);
 8024fb0:	f89d 2007 	ldrb.w	r2, [sp, #7]
	if((idx > dFrameOffset_Data) && (idx-dFrameOffset_Data >= dFrameSize))
 8024fb4:	42ab      	cmp	r3, r5
 8024fb6:	d81d      	bhi.n	8024ff4 <CommLink_Process+0x60>
	if(idx < dFrameOffset_Length)
 8024fb8:	2b0a      	cmp	r3, #10
 8024fba:	d852      	bhi.n	8025062 <CommLink_Process+0xce>
 8024fbc:	e8df f003 	tbb	[pc, r3]
 8024fc0:	16161616 	.word	0x16161616
 8024fc4:	4a4c0609 	.word	0x4a4c0609
 8024fc8:	3739      	.short	0x3739
 8024fca:	1d          	.byte	0x1d
 8024fcb:	00          	.byte	0x00
		Comm_RxMessage.length |= proc_byte << 8;
 8024fcc:	8aa1      	ldrh	r1, [r4, #20]
 8024fce:	ea41 2202 	orr.w	r2, r1, r2, lsl #8
 8024fd2:	82a2      	strh	r2, [r4, #20]
	idx++;
 8024fd4:	3301      	adds	r3, #1
 8024fd6:	8223      	strh	r3, [r4, #16]
	return FrameNotReady;
 8024fd8:	2701      	movs	r7, #1
	while(_phyGetChar_func(&byte))
 8024fda:	68e3      	ldr	r3, [r4, #12]
 8024fdc:	f10d 0007 	add.w	r0, sp, #7
 8024fe0:	4798      	blx	r3
 8024fe2:	2800      	cmp	r0, #0
 8024fe4:	d1e3      	bne.n	8024fae <CommLink_Process+0x1a>
		{
			RS485_Clear();
		}
	}
	return status;
}
 8024fe6:	4638      	mov	r0, r7
 8024fe8:	b003      	add	sp, #12
 8024fea:	bdf0      	pop	{r4, r5, r6, r7, pc}
		switch(idx)
 8024fec:	2b03      	cmp	r3, #3
 8024fee:	d035      	beq.n	802505c <CommLink_Process+0xc8>
			if(proc_byte != 0xAA)
 8024ff0:	2aaa      	cmp	r2, #170	@ 0xaa
 8024ff2:	d0ef      	beq.n	8024fd4 <CommLink_Process+0x40>
		idx = 0;
 8024ff4:	8226      	strh	r6, [r4, #16]
 8024ff6:	2700      	movs	r7, #0
 8024ff8:	e7ef      	b.n	8024fda <CommLink_Process+0x46>
	Comm_RxMessage.crcHeader |= proc_byte << 8;
 8024ffa:	8b63      	ldrh	r3, [r4, #26]
	uint16_t crcHeader = CalCrc16(0, &Comm_RxMessage.length, sizeof(Comm_RxMessage.length));
 8024ffc:	4937      	ldr	r1, [pc, #220]	@ (80250dc <CommLink_Process+0x148>)
	Comm_RxMessage.crcHeader |= proc_byte << 8;
 8024ffe:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	uint16_t crcHeader = CalCrc16(0, &Comm_RxMessage.length, sizeof(Comm_RxMessage.length));
 8025002:	2000      	movs	r0, #0
 8025004:	2202      	movs	r2, #2
	Comm_RxMessage.crcHeader |= proc_byte << 8;
 8025006:	8363      	strh	r3, [r4, #26]
	uint16_t crcHeader = CalCrc16(0, &Comm_RxMessage.length, sizeof(Comm_RxMessage.length));
 8025008:	f000 f88e 	bl	8025128 <CalCrc16>
	crcHeader = CalCrc16(crcHeader, &Comm_RxMessage.addrSensor, sizeof(Comm_RxMessage.addrSensor));
 802500c:	4934      	ldr	r1, [pc, #208]	@ (80250e0 <CommLink_Process+0x14c>)
 802500e:	2201      	movs	r2, #1
 8025010:	f000 f88a 	bl	8025128 <CalCrc16>
	crcHeader = CalCrc16(crcHeader, &Comm_RxMessage.command, sizeof(Comm_RxMessage.command));
 8025014:	4933      	ldr	r1, [pc, #204]	@ (80250e4 <CommLink_Process+0x150>)
 8025016:	2201      	movs	r2, #1
 8025018:	f000 f886 	bl	8025128 <CalCrc16>
	crcHeader = CalCrc16(crcHeader, &Comm_RxMessage.flags, sizeof(Comm_RxMessage.flags));
 802501c:	4932      	ldr	r1, [pc, #200]	@ (80250e8 <CommLink_Process+0x154>)
 802501e:	2201      	movs	r2, #1
 8025020:	f000 f882 	bl	8025128 <CalCrc16>
	if(crcHeader != Comm_RxMessage.crcHeader)
 8025024:	8b63      	ldrh	r3, [r4, #26]
 8025026:	4283      	cmp	r3, r0
 8025028:	d1e4      	bne.n	8024ff4 <CommLink_Process+0x60>
	idx++;
 802502a:	8a23      	ldrh	r3, [r4, #16]
 802502c:	e7d2      	b.n	8024fd4 <CommLink_Process+0x40>
		Comm_RxMessage.crcHeader = proc_byte;
 802502e:	8362      	strh	r2, [r4, #26]
 8025030:	e7d0      	b.n	8024fd4 <CommLink_Process+0x40>
		if (Comm_RxMessage.command == getData && Comm_RxMessage.addrSensor != Sensor.configuration.sensor_ID && Comm_RxMessage.flags != 0)
 8025032:	7de1      	ldrb	r1, [r4, #23]
		Comm_RxMessage.flags = proc_byte;
 8025034:	7622      	strb	r2, [r4, #24]
		if (Comm_RxMessage.command == getData && Comm_RxMessage.addrSensor != Sensor.configuration.sensor_ID && Comm_RxMessage.flags != 0)
 8025036:	2911      	cmp	r1, #17
 8025038:	d1cc      	bne.n	8024fd4 <CommLink_Process+0x40>
 802503a:	492c      	ldr	r1, [pc, #176]	@ (80250ec <CommLink_Process+0x158>)
 802503c:	7da0      	ldrb	r0, [r4, #22]
 802503e:	f891 106e 	ldrb.w	r1, [r1, #110]	@ 0x6e
 8025042:	4288      	cmp	r0, r1
 8025044:	d0c6      	beq.n	8024fd4 <CommLink_Process+0x40>
 8025046:	2a00      	cmp	r2, #0
 8025048:	d0c4      	beq.n	8024fd4 <CommLink_Process+0x40>
			idx = 0;
 802504a:	8226      	strh	r6, [r4, #16]
		status = CommLink_ProcessByte(byte);
 802504c:	2704      	movs	r7, #4
			RS485_Clear();
 802504e:	f000 fb75 	bl	802573c <RS485_Clear>
 8025052:	e7c2      	b.n	8024fda <CommLink_Process+0x46>
		Comm_RxMessage.command = proc_byte;
 8025054:	75e2      	strb	r2, [r4, #23]
 8025056:	e7bd      	b.n	8024fd4 <CommLink_Process+0x40>
		Comm_RxMessage.addrSensor = proc_byte;
 8025058:	75a2      	strb	r2, [r4, #22]
 802505a:	e7bb      	b.n	8024fd4 <CommLink_Process+0x40>
			if(proc_byte != 0xA5)
 802505c:	2aa5      	cmp	r2, #165	@ 0xa5
 802505e:	d1c9      	bne.n	8024ff4 <CommLink_Process+0x60>
 8025060:	e7b8      	b.n	8024fd4 <CommLink_Process+0x40>
		if(idx < (Comm_RxMessage.length-dFrameSize_Length-dFrameSize_AddrSensor-dFrameSize_Command-dFrameSize_Flags-dFrameSize_CrcHeader-dFrameSize_Crc) + dFrameOffset_Data)
 8025062:	8aa1      	ldrh	r1, [r4, #20]
 8025064:	1c48      	adds	r0, r1, #1
 8025066:	4298      	cmp	r0, r3
 8025068:	db02      	blt.n	8025070 <CommLink_Process+0xdc>
			Comm_RxMessage.data[idx - dFrameOffset_Data] = proc_byte;
 802506a:	18e1      	adds	r1, r4, r3
 802506c:	744a      	strb	r2, [r1, #17]
 802506e:	e7b1      	b.n	8024fd4 <CommLink_Process+0x40>
			if(idx == Comm_RxMessage.length-dFrameSize_Crc + dFrameSize_Preamble)
 8025070:	1c88      	adds	r0, r1, #2
 8025072:	4283      	cmp	r3, r0
 8025074:	d029      	beq.n	80250ca <CommLink_Process+0x136>
			else if(idx == Comm_RxMessage.length-dFrameSize_Crc + dFrameSize_Preamble + 1)
 8025076:	3103      	adds	r1, #3
 8025078:	428b      	cmp	r3, r1
 802507a:	d1ab      	bne.n	8024fd4 <CommLink_Process+0x40>
				Comm_RxMessage.crc += proc_byte << 8;
 802507c:	f8b4 733c 	ldrh.w	r7, [r4, #828]	@ 0x33c
	crc = CalCrc16(crc, &mess->length, sizeof(mess->length));
 8025080:	4916      	ldr	r1, [pc, #88]	@ (80250dc <CommLink_Process+0x148>)
				Comm_RxMessage.crc += proc_byte << 8;
 8025082:	eb07 2702 	add.w	r7, r7, r2, lsl #8
 8025086:	b2bf      	uxth	r7, r7
				idx = 0;
 8025088:	2000      	movs	r0, #0
	crc = CalCrc16(crc, &mess->length, sizeof(mess->length));
 802508a:	2202      	movs	r2, #2
				Comm_RxMessage.crc += proc_byte << 8;
 802508c:	f8a4 733c 	strh.w	r7, [r4, #828]	@ 0x33c
				idx = 0;
 8025090:	8220      	strh	r0, [r4, #16]
	crc = CalCrc16(crc, &mess->length, sizeof(mess->length));
 8025092:	f000 f849 	bl	8025128 <CalCrc16>
	crc = CalCrc16(crc, &mess->addrSensor, sizeof(mess->addrSensor));
 8025096:	4912      	ldr	r1, [pc, #72]	@ (80250e0 <CommLink_Process+0x14c>)
 8025098:	2201      	movs	r2, #1
 802509a:	f000 f845 	bl	8025128 <CalCrc16>
	crc = CalCrc16(crc, &mess->command, sizeof(mess->command));
 802509e:	4911      	ldr	r1, [pc, #68]	@ (80250e4 <CommLink_Process+0x150>)
 80250a0:	2201      	movs	r2, #1
 80250a2:	f000 f841 	bl	8025128 <CalCrc16>
	crc = CalCrc16(crc, &mess->flags, sizeof(mess->flags));
 80250a6:	4910      	ldr	r1, [pc, #64]	@ (80250e8 <CommLink_Process+0x154>)
 80250a8:	2201      	movs	r2, #1
 80250aa:	f000 f83d 	bl	8025128 <CalCrc16>
	crc = CalCrc16(crc, &mess->crcHeader, sizeof(mess->crcHeader));
 80250ae:	4910      	ldr	r1, [pc, #64]	@ (80250f0 <CommLink_Process+0x15c>)
 80250b0:	2202      	movs	r2, #2
 80250b2:	f000 f839 	bl	8025128 <CalCrc16>
	crc = CalCrc16(crc, mess->data, mess->length - dFrameSize_Length - dFrameSize_AddrSensor - dFrameSize_Command - dFrameSize_Flags - dFrameSize_CrcHeader - dFrameSize_Crc);
 80250b6:	8aa2      	ldrh	r2, [r4, #20]
 80250b8:	490e      	ldr	r1, [pc, #56]	@ (80250f4 <CommLink_Process+0x160>)
 80250ba:	3a09      	subs	r2, #9
 80250bc:	b292      	uxth	r2, r2
 80250be:	f000 f833 	bl	8025128 <CalCrc16>
				if(Comm_RxMessage.crc == CommLink_CalcFrameCrc(&Comm_RxMessage)){
 80250c2:	4287      	cmp	r7, r0
 80250c4:	d004      	beq.n	80250d0 <CommLink_Process+0x13c>
 80250c6:	2703      	movs	r7, #3
 80250c8:	e787      	b.n	8024fda <CommLink_Process+0x46>
				Comm_RxMessage.crc = proc_byte;
 80250ca:	f8a4 233c 	strh.w	r2, [r4, #828]	@ 0x33c
 80250ce:	e781      	b.n	8024fd4 <CommLink_Process+0x40>
LED_green_Toggle();
 80250d0:	f000 fa2a 	bl	8025528 <LED_green_Toggle>
 80250d4:	2702      	movs	r7, #2
 80250d6:	e780      	b.n	8024fda <CommLink_Process+0x46>
 80250d8:	20021bb8 	.word	0x20021bb8
 80250dc:	20021bcc 	.word	0x20021bcc
 80250e0:	20021bce 	.word	0x20021bce
 80250e4:	20021bcf 	.word	0x20021bcf
 80250e8:	20021bd0 	.word	0x20021bd0
 80250ec:	20000008 	.word	0x20000008
 80250f0:	20021bd2 	.word	0x20021bd2
 80250f4:	20021bd4 	.word	0x20021bd4

080250f8 <CommLink_GetPrtDataFrame>:

/******************************************************************************/
void *CommLink_GetPrtDataFrame(void)
{
	return Comm_RxMessage.data;
}
 80250f8:	4800      	ldr	r0, [pc, #0]	@ (80250fc <CommLink_GetPrtDataFrame+0x4>)
 80250fa:	4770      	bx	lr
 80250fc:	20021bd4 	.word	0x20021bd4

08025100 <CommLink_GetDataSize>:

/******************************************************************************/
uint16_t CommLink_GetDataSize(void)
{
	return (Comm_RxMessage.length - dFrameSize_Length - dFrameSize_AddrSensor - dFrameSize_Command - dFrameSize_Flags - dFrameSize_CrcHeader - dFrameSize_Crc);
 8025100:	4b02      	ldr	r3, [pc, #8]	@ (802510c <CommLink_GetDataSize+0xc>)
 8025102:	8a98      	ldrh	r0, [r3, #20]
 8025104:	3809      	subs	r0, #9
}
 8025106:	b280      	uxth	r0, r0
 8025108:	4770      	bx	lr
 802510a:	bf00      	nop
 802510c:	20021bb8 	.word	0x20021bb8

08025110 <CommLink_GetAddr>:

/******************************************************************************/
uint8_t CommLink_GetAddr(void)
{
	return Comm_RxMessage.addrSensor;
 8025110:	4b01      	ldr	r3, [pc, #4]	@ (8025118 <CommLink_GetAddr+0x8>)
}
 8025112:	7d98      	ldrb	r0, [r3, #22]
 8025114:	4770      	bx	lr
 8025116:	bf00      	nop
 8025118:	20021bb8 	.word	0x20021bb8

0802511c <CommLink_GetCommand>:

/******************************************************************************/
uint8_t CommLink_GetCommand(void)
{
	return Comm_RxMessage.command;
 802511c:	4b01      	ldr	r3, [pc, #4]	@ (8025124 <CommLink_GetCommand+0x8>)
}
 802511e:	7dd8      	ldrb	r0, [r3, #23]
 8025120:	4770      	bx	lr
 8025122:	bf00      	nop
 8025124:	20021bb8 	.word	0x20021bb8

08025128 <CalCrc16>:
------------------------------------------------------------------------------*/
uint16_t CalCrc16(uint16_t crc, const void *ptr, uint16_t len)
{
    const uint8_t *c = ptr;

    while (len--)
 8025128:	b1ba      	cbz	r2, 802515a <CalCrc16+0x32>
 802512a:	f102 3cff 	add.w	ip, r2, #4294967295
 802512e:	fa1f fc8c 	uxth.w	ip, ip
{
 8025132:	b410      	push	{r4}
 8025134:	f10c 0c01 	add.w	ip, ip, #1
 8025138:	4c08      	ldr	r4, [pc, #32]	@ (802515c <CalCrc16+0x34>)
 802513a:	448c      	add	ip, r1
        crc = (crc << 8) ^ crctable[((crc >> 8) ^ *c++)];
 802513c:	f811 2b01 	ldrb.w	r2, [r1], #1
 8025140:	ea82 2210 	eor.w	r2, r2, r0, lsr #8
 8025144:	0203      	lsls	r3, r0, #8
 8025146:	f834 0012 	ldrh.w	r0, [r4, r2, lsl #1]
 802514a:	b29b      	uxth	r3, r3
    while (len--)
 802514c:	4561      	cmp	r1, ip
        crc = (crc << 8) ^ crctable[((crc >> 8) ^ *c++)];
 802514e:	ea80 0003 	eor.w	r0, r0, r3
    while (len--)
 8025152:	d1f3      	bne.n	802513c <CalCrc16+0x14>

    return crc;
}
 8025154:	f85d 4b04 	ldr.w	r4, [sp], #4
 8025158:	4770      	bx	lr
 802515a:	4770      	bx	lr
 802515c:	0802ada4 	.word	0x0802ada4

08025160 <getEstimates>:
#include "estimates_calc.h"

static calculated_estimates_t estimates;

calculated_estimates_t getEstimates(void)
{
 8025160:	b510      	push	{r4, lr}
	return estimates;
 8025162:	4c07      	ldr	r4, [pc, #28]	@ (8025180 <getEstimates+0x20>)
{
 8025164:	4686      	mov	lr, r0
	return estimates;
 8025166:	4684      	mov	ip, r0
 8025168:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 802516a:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 802516e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8025170:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 8025174:	6823      	ldr	r3, [r4, #0]
 8025176:	f8cc 3000 	str.w	r3, [ip]
}
 802517a:	4670      	mov	r0, lr
 802517c:	bd10      	pop	{r4, pc}
 802517e:	bf00      	nop
 8025180:	20021ef8 	.word	0x20021ef8

08025184 <calculateEstimates>:
#if defined SENSOR_TYPE_LF
#include "../Estimates_Lib/FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s.h"
#define MODBUS_SAMPLES_AMOUNT 4000

void calculateEstimates(float* collectedData)
{
 8025184:	b510      	push	{r4, lr}
 8025186:	b08a      	sub	sp, #40	@ 0x28
 8025188:	4604      	mov	r4, r0
	calculated_estimates_t newEstimates;
	FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s(collectedData,
 802518a:	ab03      	add	r3, sp, #12
 802518c:	aa02      	add	r2, sp, #8
 802518e:	a901      	add	r1, sp, #4
 8025190:	f000 ff68 	bl	8026064 <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s>
		&newEstimates.x_PP, &newEstimates.x_RMS, &newEstimates.x_VRMS);

	FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s(collectedData + MODBUS_SAMPLES_AMOUNT,
 8025194:	ab06      	add	r3, sp, #24
 8025196:	aa05      	add	r2, sp, #20
 8025198:	a904      	add	r1, sp, #16
 802519a:	f504 507a 	add.w	r0, r4, #16000	@ 0x3e80
 802519e:	f000 ff61 	bl	8026064 <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s>
		&newEstimates.y_PP, &newEstimates.y_RMS, &newEstimates.y_VRMS);

	FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s(collectedData + (2 * MODBUS_SAMPLES_AMOUNT),
 80251a2:	ab09      	add	r3, sp, #36	@ 0x24
 80251a4:	aa08      	add	r2, sp, #32
 80251a6:	a907      	add	r1, sp, #28
 80251a8:	f504 40fa 	add.w	r0, r4, #32000	@ 0x7d00
 80251ac:	f000 ff5a 	bl	8026064 <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s>
		&newEstimates.z_PP, &newEstimates.z_RMS, &newEstimates.z_VRMS);

	memcpy(&estimates, &newEstimates, sizeof(calculated_estimates_t));
 80251b0:	f10d 0c04 	add.w	ip, sp, #4
 80251b4:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80251b8:	4c04      	ldr	r4, [pc, #16]	@ (80251cc <calculateEstimates+0x48>)
 80251ba:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80251bc:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80251c0:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80251c2:	f8dc 3000 	ldr.w	r3, [ip]
 80251c6:	6023      	str	r3, [r4, #0]
}
 80251c8:	b00a      	add	sp, #40	@ 0x28
 80251ca:	bd10      	pop	{r4, pc}
 80251cc:	20021ef8 	.word	0x20021ef8

080251d0 <GetMACAddress>:
 * Use like this: STM32_UUID[0], STM32_UUID[1], STM32_UUID[2]
 */
#define STM32_UUID ((uint32_t *)0x1FFF7A10)

char* GetMACAddress(void)
{
 80251d0:	b510      	push	{r4, lr}
 80251d2:	b092      	sub	sp, #72	@ 0x48

	AdiConf_t currentConf;
	Memory_TakeConfig(&currentConf);
	static char MAC_Table[12];

	memcpy(MAC_Table,currentConf.MAC,12);
 80251d4:	4c07      	ldr	r4, [pc, #28]	@ (80251f4 <GetMACAddress+0x24>)
	Memory_TakeConfig(&currentConf);
 80251d6:	4668      	mov	r0, sp
 80251d8:	f001 fee6 	bl	8026fa8 <Memory_TakeConfig>
	memcpy(MAC_Table,currentConf.MAC,12);
 80251dc:	f8dd 0007 	ldr.w	r0, [sp, #7]
 80251e0:	f8dd 100b 	ldr.w	r1, [sp, #11]
 80251e4:	f8dd 200f 	ldr.w	r2, [sp, #15]
 80251e8:	4623      	mov	r3, r4
 80251ea:	c307      	stmia	r3!, {r0, r1, r2}
	return MAC_Table;
}
 80251ec:	4620      	mov	r0, r4
 80251ee:	b012      	add	sp, #72	@ 0x48
 80251f0:	bd10      	pop	{r4, pc}
 80251f2:	bf00      	nop
 80251f4:	20021f1c 	.word	0x20021f1c

080251f8 <adxl_read>:
	int volatile i = 0;
	for(i = 0; i<time; ++i){
	}
}

uint8_t adxl_read(uint8_t address){
 80251f8:	b510      	push	{r4, lr}

	  //reading value form address

	  uint8_t data_rec = 0;
	  address = address << 1;
 80251fa:	0043      	lsls	r3, r0, #1
uint8_t adxl_read(uint8_t address){
 80251fc:	b086      	sub	sp, #24
	  uint8_t data_rec = 0;
 80251fe:	2400      	movs	r4, #0
	  address = address | 0x01;
 8025200:	f043 0301 	orr.w	r3, r3, #1
	  HAL_GPIO_WritePin (GPIOA, GPIO_PIN_4, GPIO_PIN_RESET);
 8025204:	481b      	ldr	r0, [pc, #108]	@ (8025274 <adxl_read+0x7c>)
	  address = address | 0x01;
 8025206:	f88d 3007 	strb.w	r3, [sp, #7]
	  HAL_GPIO_WritePin (GPIOA, GPIO_PIN_4, GPIO_PIN_RESET);
 802520a:	4622      	mov	r2, r4
 802520c:	2110      	movs	r1, #16
	  uint8_t data_rec = 0;
 802520e:	f88d 400f 	strb.w	r4, [sp, #15]
	  HAL_GPIO_WritePin (GPIOA, GPIO_PIN_4, GPIO_PIN_RESET);
 8025212:	f7fc ff21 	bl	8022058 <HAL_GPIO_WritePin>
	int volatile i = 0;
 8025216:	9405      	str	r4, [sp, #20]
	for(i = 0; i<time; ++i){
 8025218:	9405      	str	r4, [sp, #20]
 802521a:	9b05      	ldr	r3, [sp, #20]
 802521c:	2b01      	cmp	r3, #1
 802521e:	dc05      	bgt.n	802522c <adxl_read+0x34>
 8025220:	9b05      	ldr	r3, [sp, #20]
 8025222:	3301      	adds	r3, #1
 8025224:	9305      	str	r3, [sp, #20]
 8025226:	9b05      	ldr	r3, [sp, #20]
 8025228:	2b01      	cmp	r3, #1
 802522a:	ddf9      	ble.n	8025220 <adxl_read+0x28>
	  delay_normal(2);
	  HAL_SPI_Transmit(&hspi1, &address, 1, 100);
 802522c:	2364      	movs	r3, #100	@ 0x64
 802522e:	4812      	ldr	r0, [pc, #72]	@ (8025278 <adxl_read+0x80>)
 8025230:	2201      	movs	r2, #1
 8025232:	f10d 0107 	add.w	r1, sp, #7
 8025236:	f7fd fa65 	bl	8022704 <HAL_SPI_Transmit>
	int volatile i = 0;
 802523a:	2300      	movs	r3, #0
 802523c:	9304      	str	r3, [sp, #16]
	for(i = 0; i<time; ++i){
 802523e:	9304      	str	r3, [sp, #16]
 8025240:	9b04      	ldr	r3, [sp, #16]
 8025242:	2b01      	cmp	r3, #1
 8025244:	dc05      	bgt.n	8025252 <adxl_read+0x5a>
 8025246:	9b04      	ldr	r3, [sp, #16]
 8025248:	3301      	adds	r3, #1
 802524a:	9304      	str	r3, [sp, #16]
 802524c:	9b04      	ldr	r3, [sp, #16]
 802524e:	2b01      	cmp	r3, #1
 8025250:	ddf9      	ble.n	8025246 <adxl_read+0x4e>
	  delay_normal(2);
	  HAL_SPI_Receive(&hspi1, &data_rec, 1, 100);
 8025252:	2364      	movs	r3, #100	@ 0x64
 8025254:	f10d 010f 	add.w	r1, sp, #15
 8025258:	2201      	movs	r2, #1
 802525a:	4807      	ldr	r0, [pc, #28]	@ (8025278 <adxl_read+0x80>)
 802525c:	f7fd fcac 	bl	8022bb8 <HAL_SPI_Receive>
	  HAL_GPIO_WritePin (GPIOA, GPIO_PIN_4, GPIO_PIN_SET);
 8025260:	4804      	ldr	r0, [pc, #16]	@ (8025274 <adxl_read+0x7c>)
 8025262:	2201      	movs	r2, #1
 8025264:	2110      	movs	r1, #16
 8025266:	f7fc fef7 	bl	8022058 <HAL_GPIO_WritePin>

	  return data_rec;
}
 802526a:	f89d 000f 	ldrb.w	r0, [sp, #15]
 802526e:	b006      	add	sp, #24
 8025270:	bd10      	pop	{r4, pc}
 8025272:	bf00      	nop
 8025274:	40020000 	.word	0x40020000
 8025278:	20022380 	.word	0x20022380

0802527c <adxl_read_fast>:

void adxl_read_fast(uint8_t address, uint8_t* data_rec){
 802527c:	b510      	push	{r4, lr}

	  //reading value form address

	  address = address << 1;
 802527e:	0043      	lsls	r3, r0, #1
void adxl_read_fast(uint8_t address, uint8_t* data_rec){
 8025280:	b084      	sub	sp, #16
	  address = address | 0x01;
 8025282:	f043 0301 	orr.w	r3, r3, #1
	  HAL_GPIO_WritePin (GPIOA, GPIO_PIN_4, GPIO_PIN_RESET);
 8025286:	481a      	ldr	r0, [pc, #104]	@ (80252f0 <adxl_read_fast+0x74>)
	  address = address | 0x01;
 8025288:	f88d 3007 	strb.w	r3, [sp, #7]
void adxl_read_fast(uint8_t address, uint8_t* data_rec){
 802528c:	460c      	mov	r4, r1
	  HAL_GPIO_WritePin (GPIOA, GPIO_PIN_4, GPIO_PIN_RESET);
 802528e:	2200      	movs	r2, #0
 8025290:	2110      	movs	r1, #16
 8025292:	f7fc fee1 	bl	8022058 <HAL_GPIO_WritePin>
	int volatile i = 0;
 8025296:	2300      	movs	r3, #0
 8025298:	9303      	str	r3, [sp, #12]
	for(i = 0; i<time; ++i){
 802529a:	9303      	str	r3, [sp, #12]
 802529c:	9b03      	ldr	r3, [sp, #12]
 802529e:	2b01      	cmp	r3, #1
 80252a0:	dc05      	bgt.n	80252ae <adxl_read_fast+0x32>
 80252a2:	9b03      	ldr	r3, [sp, #12]
 80252a4:	3301      	adds	r3, #1
 80252a6:	9303      	str	r3, [sp, #12]
 80252a8:	9b03      	ldr	r3, [sp, #12]
 80252aa:	2b01      	cmp	r3, #1
 80252ac:	ddf9      	ble.n	80252a2 <adxl_read_fast+0x26>
	  delay_normal(2);
	  HAL_SPI_Transmit(&hspi1, &address, 1, 100);
 80252ae:	2364      	movs	r3, #100	@ 0x64
 80252b0:	4810      	ldr	r0, [pc, #64]	@ (80252f4 <adxl_read_fast+0x78>)
 80252b2:	2201      	movs	r2, #1
 80252b4:	f10d 0107 	add.w	r1, sp, #7
 80252b8:	f7fd fa24 	bl	8022704 <HAL_SPI_Transmit>
	int volatile i = 0;
 80252bc:	2300      	movs	r3, #0
 80252be:	9302      	str	r3, [sp, #8]
	for(i = 0; i<time; ++i){
 80252c0:	9302      	str	r3, [sp, #8]
 80252c2:	9b02      	ldr	r3, [sp, #8]
 80252c4:	2b01      	cmp	r3, #1
 80252c6:	dc05      	bgt.n	80252d4 <adxl_read_fast+0x58>
 80252c8:	9b02      	ldr	r3, [sp, #8]
 80252ca:	3301      	adds	r3, #1
 80252cc:	9302      	str	r3, [sp, #8]
 80252ce:	9b02      	ldr	r3, [sp, #8]
 80252d0:	2b01      	cmp	r3, #1
 80252d2:	ddf9      	ble.n	80252c8 <adxl_read_fast+0x4c>
	  delay_normal(2);
	  HAL_SPI_Receive(&hspi1, data_rec, 9, 100);
 80252d4:	2364      	movs	r3, #100	@ 0x64
 80252d6:	4621      	mov	r1, r4
 80252d8:	2209      	movs	r2, #9
 80252da:	4806      	ldr	r0, [pc, #24]	@ (80252f4 <adxl_read_fast+0x78>)
 80252dc:	f7fd fc6c 	bl	8022bb8 <HAL_SPI_Receive>
	  HAL_GPIO_WritePin (GPIOA, GPIO_PIN_4, GPIO_PIN_SET);
 80252e0:	4803      	ldr	r0, [pc, #12]	@ (80252f0 <adxl_read_fast+0x74>)
 80252e2:	2201      	movs	r2, #1
 80252e4:	2110      	movs	r1, #16
 80252e6:	f7fc feb7 	bl	8022058 <HAL_GPIO_WritePin>
}
 80252ea:	b004      	add	sp, #16
 80252ec:	bd10      	pop	{r4, pc}
 80252ee:	bf00      	nop
 80252f0:	40020000 	.word	0x40020000
 80252f4:	20022380 	.word	0x20022380

080252f8 <adxl_Init>:
	  data_rec=adxl_read(0x02);
	  return data_rec;
}

void adxl_Init(void)
{
 80252f8:	b500      	push	{lr}
 80252fa:	b085      	sub	sp, #20
	uint8_t data[2];
	uint8_t address = 0x2D << 1;
	data[0] = address;
 80252fc:	235a      	movs	r3, #90	@ 0x5a
	data[1] = 0x00;

	HAL_GPIO_WritePin (GPIOA, GPIO_PIN_4, GPIO_PIN_RESET);
 80252fe:	4816      	ldr	r0, [pc, #88]	@ (8025358 <adxl_Init+0x60>)
	data[0] = address;
 8025300:	f8ad 3004 	strh.w	r3, [sp, #4]
	HAL_GPIO_WritePin (GPIOA, GPIO_PIN_4, GPIO_PIN_RESET);
 8025304:	2200      	movs	r2, #0
 8025306:	2110      	movs	r1, #16
 8025308:	f7fc fea6 	bl	8022058 <HAL_GPIO_WritePin>
	int volatile i = 0;
 802530c:	2300      	movs	r3, #0
 802530e:	9303      	str	r3, [sp, #12]
	for(i = 0; i<time; ++i){
 8025310:	9303      	str	r3, [sp, #12]
 8025312:	9b03      	ldr	r3, [sp, #12]
 8025314:	2b13      	cmp	r3, #19
 8025316:	dc05      	bgt.n	8025324 <adxl_Init+0x2c>
 8025318:	9b03      	ldr	r3, [sp, #12]
 802531a:	3301      	adds	r3, #1
 802531c:	9303      	str	r3, [sp, #12]
 802531e:	9b03      	ldr	r3, [sp, #12]
 8025320:	2b13      	cmp	r3, #19
 8025322:	ddf9      	ble.n	8025318 <adxl_Init+0x20>
	delay_normal(20);
	HAL_SPI_Transmit(&hspi1, data, 2, 100);
 8025324:	2364      	movs	r3, #100	@ 0x64
 8025326:	480d      	ldr	r0, [pc, #52]	@ (802535c <adxl_Init+0x64>)
 8025328:	2202      	movs	r2, #2
 802532a:	a901      	add	r1, sp, #4
 802532c:	f7fd f9ea 	bl	8022704 <HAL_SPI_Transmit>
	int volatile i = 0;
 8025330:	2300      	movs	r3, #0
 8025332:	9302      	str	r3, [sp, #8]
	for(i = 0; i<time; ++i){
 8025334:	9302      	str	r3, [sp, #8]
 8025336:	9b02      	ldr	r3, [sp, #8]
 8025338:	2b13      	cmp	r3, #19
 802533a:	dc05      	bgt.n	8025348 <adxl_Init+0x50>
 802533c:	9b02      	ldr	r3, [sp, #8]
 802533e:	3301      	adds	r3, #1
 8025340:	9302      	str	r3, [sp, #8]
 8025342:	9b02      	ldr	r3, [sp, #8]
 8025344:	2b13      	cmp	r3, #19
 8025346:	ddf9      	ble.n	802533c <adxl_Init+0x44>
	delay_normal(20);
	HAL_GPIO_WritePin (GPIOA, GPIO_PIN_4, GPIO_PIN_SET);
 8025348:	4803      	ldr	r0, [pc, #12]	@ (8025358 <adxl_Init+0x60>)
 802534a:	2201      	movs	r2, #1
 802534c:	2110      	movs	r1, #16
 802534e:	f7fc fe83 	bl	8022058 <HAL_GPIO_WritePin>
}
 8025352:	b005      	add	sp, #20
 8025354:	f85d fb04 	ldr.w	pc, [sp], #4
 8025358:	40020000 	.word	0x40020000
 802535c:	20022380 	.word	0x20022380

08025360 <adxl_GetAxisData_fast>:
	delay_normal(20);
	HAL_GPIO_WritePin (GPIOA, GPIO_PIN_4, GPIO_PIN_SET);
}

void adxl_GetAxisData_fast(uint8_t* data)
{
 8025360:	4601      	mov	r1, r0
//LED_red_On();
	adxl_read_fast(ADXL_XDATA3_ADDRESS,data);
 8025362:	2008      	movs	r0, #8
 8025364:	f7ff bf8a 	b.w	802527c <adxl_read_fast>

08025368 <adxl_GetAxisData>:
uint32_t adxl_GetAxisData(ADXL_AXIS Ax)
{
	//LED_red_On();
	uint32_t out = 0;

	switch (Ax){
 8025368:	2801      	cmp	r0, #1
{
 802536a:	b510      	push	{r4, lr}
	switch (Ax){
 802536c:	d024      	beq.n	80253b8 <adxl_GetAxisData+0x50>
 802536e:	2802      	cmp	r0, #2
 8025370:	d002      	beq.n	8025378 <adxl_GetAxisData+0x10>
 8025372:	b188      	cbz	r0, 8025398 <adxl_GetAxisData+0x30>
 8025374:	2000      	movs	r0, #0

		break;
	}
//LED_red_Off();
	return out;
}
 8025376:	bd10      	pop	{r4, pc}
		out = (adxl_read(ADXL_XDATA3_ADDRESS)<<16);
 8025378:	2008      	movs	r0, #8
 802537a:	f7ff ff3d 	bl	80251f8 <adxl_read>
 802537e:	4604      	mov	r4, r0
		out += (adxl_read(ADXL_XDATA2_ADDRESS)<<8);
 8025380:	2009      	movs	r0, #9
 8025382:	f7ff ff39 	bl	80251f8 <adxl_read>
		out = (adxl_read(ADXL_XDATA3_ADDRESS)<<16);
 8025386:	0424      	lsls	r4, r4, #16
		out += (adxl_read(ADXL_XDATA2_ADDRESS)<<8);
 8025388:	4603      	mov	r3, r0
		out += (adxl_read(ADXL_XDATA1_ADDRESS));
 802538a:	200a      	movs	r0, #10
		out += (adxl_read(ADXL_XDATA2_ADDRESS)<<8);
 802538c:	eb04 2403 	add.w	r4, r4, r3, lsl #8
		out += (adxl_read(ADXL_XDATA1_ADDRESS));
 8025390:	f7ff ff32 	bl	80251f8 <adxl_read>
 8025394:	4420      	add	r0, r4
}
 8025396:	bd10      	pop	{r4, pc}
		out = (adxl_read(ADXL_ZDATA3_ADDRESS)<<16);
 8025398:	200e      	movs	r0, #14
 802539a:	f7ff ff2d 	bl	80251f8 <adxl_read>
 802539e:	4604      	mov	r4, r0
		out += (adxl_read(ADXL_ZDATA2_ADDRESS)<<8);
 80253a0:	200f      	movs	r0, #15
 80253a2:	f7ff ff29 	bl	80251f8 <adxl_read>
		out = (adxl_read(ADXL_ZDATA3_ADDRESS)<<16);
 80253a6:	0424      	lsls	r4, r4, #16
		out += (adxl_read(ADXL_ZDATA2_ADDRESS)<<8);
 80253a8:	4603      	mov	r3, r0
		out += (adxl_read(ADXL_ZDATA1_ADDRESS));
 80253aa:	2010      	movs	r0, #16
		out += (adxl_read(ADXL_ZDATA2_ADDRESS)<<8);
 80253ac:	eb04 2403 	add.w	r4, r4, r3, lsl #8
		out += (adxl_read(ADXL_ZDATA1_ADDRESS));
 80253b0:	f7ff ff22 	bl	80251f8 <adxl_read>
 80253b4:	4420      	add	r0, r4
}
 80253b6:	bd10      	pop	{r4, pc}
		out = (adxl_read(ADXL_YDATA3_ADDRESS)<<16);
 80253b8:	200b      	movs	r0, #11
 80253ba:	f7ff ff1d 	bl	80251f8 <adxl_read>
 80253be:	4604      	mov	r4, r0
		out += (adxl_read(ADXL_YDATA2_ADDRESS)<<8);
 80253c0:	200c      	movs	r0, #12
 80253c2:	f7ff ff19 	bl	80251f8 <adxl_read>
		out = (adxl_read(ADXL_YDATA3_ADDRESS)<<16);
 80253c6:	0424      	lsls	r4, r4, #16
		out += (adxl_read(ADXL_YDATA2_ADDRESS)<<8);
 80253c8:	4603      	mov	r3, r0
		out += (adxl_read(ADXL_YDATA1_ADDRESS));
 80253ca:	200d      	movs	r0, #13
		out += (adxl_read(ADXL_YDATA2_ADDRESS)<<8);
 80253cc:	eb04 2403 	add.w	r4, r4, r3, lsl #8
		out += (adxl_read(ADXL_YDATA1_ADDRESS));
 80253d0:	f7ff ff12 	bl	80251f8 <adxl_read>
 80253d4:	4420      	add	r0, r4
}
 80253d6:	bd10      	pop	{r4, pc}

080253d8 <Get_Speed>:
uint32_t Get_Speed(ADI_rs485_speed spd)
{

	uint32_t speed;

	switch (spd)
 80253d8:	2870      	cmp	r0, #112	@ 0x70
{
 80253da:	4603      	mov	r3, r0
	switch (spd)
 80253dc:	d03c      	beq.n	8025458 <Get_Speed+0x80>
 80253de:	d80c      	bhi.n	80253fa <Get_Speed+0x22>
 80253e0:	2840      	cmp	r0, #64	@ 0x40
 80253e2:	d036      	beq.n	8025452 <Get_Speed+0x7a>
 80253e4:	d81f      	bhi.n	8025426 <Get_Speed+0x4e>
 80253e6:	2820      	cmp	r0, #32
 80253e8:	d01a      	beq.n	8025420 <Get_Speed+0x48>
 80253ea:	2830      	cmp	r0, #48	@ 0x30
 80253ec:	d026      	beq.n	802543c <Get_Speed+0x64>
	{
	case speed_4800:
		speed=4800;
		return speed;
 80253ee:	2b10      	cmp	r3, #16
 80253f0:	481b      	ldr	r0, [pc, #108]	@ (8025460 <Get_Speed+0x88>)
 80253f2:	bf08      	it	eq
 80253f4:	f44f 5096 	moveq.w	r0, #4800	@ 0x12c0
 80253f8:	4770      	bx	lr
	switch (spd)
 80253fa:	28a0      	cmp	r0, #160	@ 0xa0
 80253fc:	d01b      	beq.n	8025436 <Get_Speed+0x5e>
 80253fe:	d907      	bls.n	8025410 <Get_Speed+0x38>
 8025400:	28b0      	cmp	r0, #176	@ 0xb0
 8025402:	d021      	beq.n	8025448 <Get_Speed+0x70>
	case speed_1500k:
		speed=1500000;
		return speed;
	case speed_1000k:
		speed=1000000;
		return speed;
 8025404:	4a17      	ldr	r2, [pc, #92]	@ (8025464 <Get_Speed+0x8c>)
 8025406:	4816      	ldr	r0, [pc, #88]	@ (8025460 <Get_Speed+0x88>)
 8025408:	2bc0      	cmp	r3, #192	@ 0xc0
 802540a:	bf08      	it	eq
 802540c:	4610      	moveq	r0, r2
 802540e:	4770      	bx	lr
	switch (spd)
 8025410:	2880      	cmp	r0, #128	@ 0x80
 8025412:	d01b      	beq.n	802544c <Get_Speed+0x74>
		return speed;
 8025414:	2b90      	cmp	r3, #144	@ 0x90
 8025416:	4812      	ldr	r0, [pc, #72]	@ (8025460 <Get_Speed+0x88>)
 8025418:	bf08      	it	eq
 802541a:	f44f 4061 	moveq.w	r0, #57600	@ 0xe100
 802541e:	4770      	bx	lr
	switch (spd)
 8025420:	f44f 50e1 	mov.w	r0, #7200	@ 0x1c20
 8025424:	4770      	bx	lr
 8025426:	2850      	cmp	r0, #80	@ 0x50
 8025428:	d00b      	beq.n	8025442 <Get_Speed+0x6a>
		return speed;
 802542a:	2b60      	cmp	r3, #96	@ 0x60
 802542c:	480c      	ldr	r0, [pc, #48]	@ (8025460 <Get_Speed+0x88>)
 802542e:	bf08      	it	eq
 8025430:	f44f 40e1 	moveq.w	r0, #28800	@ 0x7080
 8025434:	4770      	bx	lr
		return speed;
 8025436:	f44f 30e1 	mov.w	r0, #115200	@ 0x1c200
 802543a:	4770      	bx	lr
		return speed;
 802543c:	f44f 5016 	mov.w	r0, #9600	@ 0x2580
 8025440:	4770      	bx	lr
		return speed;
 8025442:	f44f 4096 	mov.w	r0, #19200	@ 0x4b00
 8025446:	4770      	bx	lr
		return speed;
 8025448:	4807      	ldr	r0, [pc, #28]	@ (8025468 <Get_Speed+0x90>)
	default:
		speed=1500000;
		return speed;
	}
}
 802544a:	4770      	bx	lr
		return speed;
 802544c:	f44f 4016 	mov.w	r0, #38400	@ 0x9600
 8025450:	4770      	bx	lr
		return speed;
 8025452:	f44f 5061 	mov.w	r0, #14400	@ 0x3840
 8025456:	4770      	bx	lr
		return speed;
 8025458:	f248 3040 	movw	r0, #33600	@ 0x8340
 802545c:	4770      	bx	lr
 802545e:	bf00      	nop
 8025460:	0016e360 	.word	0x0016e360
 8025464:	000f4240 	.word	0x000f4240
 8025468:	0007a120 	.word	0x0007a120

0802546c <Error_Handler>:

void Error_Handler(void)
{
 802546c:	b508      	push	{r3, lr}
	while(1)
	{
		HAL_Delay(100);
 802546e:	2064      	movs	r0, #100	@ 0x64
 8025470:	f7fb fe38 	bl	80210e4 <HAL_Delay>
		LED_red_Toggle();
 8025474:	f000 f860 	bl	8025538 <LED_red_Toggle>
	while(1)
 8025478:	e7f9      	b.n	802546e <Error_Handler+0x2>
 802547a:	bf00      	nop
 802547c:	0000      	movs	r0, r0
	...

08025480 <SystemClock_Config>:
	}
}

#ifdef EXTRNAL_OSC
void SystemClock_Config(void)
{
 8025480:	b510      	push	{r4, lr}
	  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 8025482:	2300      	movs	r3, #0
{
 8025484:	b096      	sub	sp, #88	@ 0x58
	  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 8025486:	e9cd 330a 	strd	r3, r3, [sp, #40]	@ 0x28
 802548a:	e9cd 330c 	strd	r3, r3, [sp, #48]	@ 0x30
	  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 802548e:	e9cd 3303 	strd	r3, r3, [sp, #12]
 8025492:	e9cd 3305 	strd	r3, r3, [sp, #20]

	  /** Configure the main internal regulator output voltage
	  */
	  __HAL_RCC_PWR_CLK_ENABLE();
 8025496:	4922      	ldr	r1, [pc, #136]	@ (8025520 <SystemClock_Config+0xa0>)
 8025498:	9301      	str	r3, [sp, #4]
	  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 802549a:	9307      	str	r3, [sp, #28]
	  __HAL_RCC_PWR_CLK_ENABLE();
 802549c:	6c08      	ldr	r0, [r1, #64]	@ 0x40
	  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 802549e:	4a21      	ldr	r2, [pc, #132]	@ (8025524 <SystemClock_Config+0xa4>)
	  __HAL_RCC_PWR_CLK_ENABLE();
 80254a0:	f040 5080 	orr.w	r0, r0, #268435456	@ 0x10000000
 80254a4:	6408      	str	r0, [r1, #64]	@ 0x40
 80254a6:	6c09      	ldr	r1, [r1, #64]	@ 0x40
 80254a8:	f001 5180 	and.w	r1, r1, #268435456	@ 0x10000000
 80254ac:	9101      	str	r1, [sp, #4]
 80254ae:	9901      	ldr	r1, [sp, #4]
	  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 80254b0:	9302      	str	r3, [sp, #8]
 80254b2:	6813      	ldr	r3, [r2, #0]
 80254b4:	f443 4340 	orr.w	r3, r3, #49152	@ 0xc000
 80254b8:	6013      	str	r3, [r2, #0]
 80254ba:	6813      	ldr	r3, [r2, #0]
 80254bc:	f403 4340 	and.w	r3, r3, #49152	@ 0xc000
//	  }
	  /** Initializes the CPU, AHB and APB busses clocks
	  */
	  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
	  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
	  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 80254c0:	2402      	movs	r4, #2
	  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 80254c2:	9302      	str	r3, [sp, #8]
	  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 80254c4:	f44f 0180 	mov.w	r1, #4194304	@ 0x400000
	  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 80254c8:	ed9f 7b13 	vldr	d7, [pc, #76]	@ 8025518 <SystemClock_Config+0x98>
	  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 80254cc:	e9cd 410e 	strd	r4, r1, [sp, #56]	@ 0x38
	  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 80254d0:	9802      	ldr	r0, [sp, #8]
#else
	  RCC_OscInitStruct.PLL.PLLN = 100;
#endif
	  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
	  RCC_OscInitStruct.PLL.PLLQ = 2;
	  RCC_OscInitStruct.PLL.PLLR = 2;
 80254d2:	9414      	str	r4, [sp, #80]	@ 0x50
	  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 80254d4:	2002      	movs	r0, #2
 80254d6:	2102      	movs	r1, #2
 80254d8:	e9cd 0112 	strd	r0, r1, [sp, #72]	@ 0x48
	  RCC_OscInitStruct.PLL.PLLM = 6;
 80254dc:	2206      	movs	r2, #6
	  RCC_OscInitStruct.PLL.PLLN = 80;
 80254de:	2350      	movs	r3, #80	@ 0x50
	  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 80254e0:	a808      	add	r0, sp, #32
	  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 80254e2:	ed8d 7b08 	vstr	d7, [sp, #32]
	  RCC_OscInitStruct.PLL.PLLM = 6;
 80254e6:	9210      	str	r2, [sp, #64]	@ 0x40
	  RCC_OscInitStruct.PLL.PLLN = 80;
 80254e8:	9311      	str	r3, [sp, #68]	@ 0x44
	  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 80254ea:	f7fc feaf 	bl	802224c <HAL_RCC_OscConfig>
 80254ee:	b978      	cbnz	r0, 8025510 <SystemClock_Config+0x90>
	  {
	    Error_Handler();
	  }
	  /** Initializes the CPU, AHB and APB busses clocks
	  */
	  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 80254f0:	210f      	movs	r1, #15
 80254f2:	4603      	mov	r3, r0
	                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
	  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 80254f4:	e9cd 1403 	strd	r1, r4, [sp, #12]
	  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
	  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
 80254f8:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
	  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

	  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
 80254fc:	a803      	add	r0, sp, #12
 80254fe:	2103      	movs	r1, #3
	  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
 8025500:	e9cd 3205 	strd	r3, r2, [sp, #20]
	  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 8025504:	9307      	str	r3, [sp, #28]
	  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
 8025506:	f7fc fde7 	bl	80220d8 <HAL_RCC_ClockConfig>
 802550a:	b908      	cbnz	r0, 8025510 <SystemClock_Config+0x90>
	  {
	    Error_Handler();
	  }

}
 802550c:	b016      	add	sp, #88	@ 0x58
 802550e:	bd10      	pop	{r4, pc}
	    Error_Handler();
 8025510:	f7ff ffac 	bl	802546c <Error_Handler>
 8025514:	f3af 8000 	nop.w
 8025518:	00000001 	.word	0x00000001
 802551c:	00010000 	.word	0x00010000
 8025520:	40023800 	.word	0x40023800
 8025524:	40007000 	.word	0x40007000

08025528 <LED_green_Toggle>:

#include "acquisition.h"

void LED_green_Toggle(void)
{
	HAL_GPIO_TogglePin(LED_G_GPIO_Port,LED_G_Pin);
 8025528:	4802      	ldr	r0, [pc, #8]	@ (8025534 <LED_green_Toggle+0xc>)
 802552a:	f44f 7180 	mov.w	r1, #256	@ 0x100
 802552e:	f7fc bd97 	b.w	8022060 <HAL_GPIO_TogglePin>
 8025532:	bf00      	nop
 8025534:	40020400 	.word	0x40020400

08025538 <LED_red_Toggle>:
	HAL_GPIO_WritePin(LED_G_GPIO_Port,LED_G_Pin,GPIO_PIN_SET);
}

void LED_red_Toggle(void)
{
	HAL_GPIO_TogglePin(LED_R_GPIO_Port,LED_R_Pin);
 8025538:	4802      	ldr	r0, [pc, #8]	@ (8025544 <LED_red_Toggle+0xc>)
 802553a:	f44f 7100 	mov.w	r1, #512	@ 0x200
 802553e:	f7fc bd8f 	b.w	8022060 <HAL_GPIO_TogglePin>
 8025542:	bf00      	nop
 8025544:	40020400 	.word	0x40020400

08025548 <GPIO_Init>:
{
	HAL_GPIO_WritePin(LED_R_GPIO_Port,LED_R_Pin,GPIO_PIN_SET);
}

void GPIO_Init(void)
{
 8025548:	b530      	push	{r4, r5, lr}
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 802554a:	2200      	movs	r2, #0
{
 802554c:	b08b      	sub	sp, #44	@ 0x2c
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 802554e:	e9cd 2204 	strd	r2, r2, [sp, #16]
 8025552:	e9cd 2206 	strd	r2, r2, [sp, #24]

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8025556:	4b29      	ldr	r3, [pc, #164]	@ (80255fc <GPIO_Init+0xb4>)
 8025558:	9201      	str	r2, [sp, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 802555a:	9208      	str	r2, [sp, #32]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 802555c:	6b19      	ldr	r1, [r3, #48]	@ 0x30
  __HAL_RCC_GPIOB_CLK_ENABLE();
  __HAL_RCC_GPIOH_CLK_ENABLE();


  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, LED_G_Pin|LED_R_Pin, GPIO_PIN_RESET);
 802555e:	4d28      	ldr	r5, [pc, #160]	@ (8025600 <GPIO_Init+0xb8>)
  HAL_GPIO_WritePin(GPIOA, CS_ADXL_Pin, GPIO_PIN_SET);
 8025560:	4c28      	ldr	r4, [pc, #160]	@ (8025604 <GPIO_Init+0xbc>)
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8025562:	f041 0101 	orr.w	r1, r1, #1
 8025566:	6319      	str	r1, [r3, #48]	@ 0x30
 8025568:	6b19      	ldr	r1, [r3, #48]	@ 0x30
 802556a:	f001 0101 	and.w	r1, r1, #1
 802556e:	9101      	str	r1, [sp, #4]
 8025570:	9901      	ldr	r1, [sp, #4]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8025572:	9202      	str	r2, [sp, #8]
 8025574:	6b19      	ldr	r1, [r3, #48]	@ 0x30
 8025576:	f041 0102 	orr.w	r1, r1, #2
 802557a:	6319      	str	r1, [r3, #48]	@ 0x30
 802557c:	6b19      	ldr	r1, [r3, #48]	@ 0x30
 802557e:	f001 0102 	and.w	r1, r1, #2
 8025582:	9102      	str	r1, [sp, #8]
 8025584:	9902      	ldr	r1, [sp, #8]
  __HAL_RCC_GPIOH_CLK_ENABLE();
 8025586:	9203      	str	r2, [sp, #12]
 8025588:	6b19      	ldr	r1, [r3, #48]	@ 0x30
 802558a:	f041 0180 	orr.w	r1, r1, #128	@ 0x80
 802558e:	6319      	str	r1, [r3, #48]	@ 0x30
 8025590:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8025592:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8025596:	9303      	str	r3, [sp, #12]
  HAL_GPIO_WritePin(GPIOB, LED_G_Pin|LED_R_Pin, GPIO_PIN_RESET);
 8025598:	4628      	mov	r0, r5
 802559a:	f44f 7140 	mov.w	r1, #768	@ 0x300
  __HAL_RCC_GPIOH_CLK_ENABLE();
 802559e:	9b03      	ldr	r3, [sp, #12]
  HAL_GPIO_WritePin(GPIOB, LED_G_Pin|LED_R_Pin, GPIO_PIN_RESET);
 80255a0:	f7fc fd5a 	bl	8022058 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIOA, CS_ADXL_Pin, GPIO_PIN_SET);
 80255a4:	4620      	mov	r0, r4
 80255a6:	2201      	movs	r2, #1
 80255a8:	2110      	movs	r1, #16
 80255aa:	f7fc fd55 	bl	8022058 <HAL_GPIO_WritePin>


  /*Configure GPIO pins : LED_G_Pin LED_R_Pin */
  GPIO_InitStruct.Pin = USART_DE_Pin|USART__R_E_Pin|LED_G_Pin|LED_R_Pin;
 80255ae:	f44f 52b8 	mov.w	r2, #5888	@ 0x1700
 80255b2:	2301      	movs	r3, #1
 80255b4:	e9cd 2304 	strd	r2, r3, [sp, #16]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80255b8:	4628      	mov	r0, r5
  GPIO_InitStruct.Pin = USART_DE_Pin|USART__R_E_Pin|LED_G_Pin|LED_R_Pin;
 80255ba:	2200      	movs	r2, #0
 80255bc:	2300      	movs	r3, #0
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80255be:	a904      	add	r1, sp, #16
  GPIO_InitStruct.Pin = USART_DE_Pin|USART__R_E_Pin|LED_G_Pin|LED_R_Pin;
 80255c0:	e9cd 2306 	strd	r2, r3, [sp, #24]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80255c4:	f7fc fb7e 	bl	8021cc4 <HAL_GPIO_Init>

  GPIO_InitStruct.Pin = CS_ADXL_Pin;
 80255c8:	2210      	movs	r2, #16
 80255ca:	2301      	movs	r3, #1
 80255cc:	e9cd 2304 	strd	r2, r3, [sp, #16]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80255d0:	a904      	add	r1, sp, #16
  GPIO_InitStruct.Pin = CS_ADXL_Pin;
 80255d2:	2200      	movs	r2, #0
 80255d4:	2303      	movs	r3, #3
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80255d6:	4620      	mov	r0, r4
  GPIO_InitStruct.Pin = CS_ADXL_Pin;
 80255d8:	e9cd 2306 	strd	r2, r3, [sp, #24]
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80255dc:	f7fc fb72 	bl	8021cc4 <HAL_GPIO_Init>

  GPIO_InitStruct.Pin = DRDY_ADXL_Pin;
 80255e0:	4b09      	ldr	r3, [pc, #36]	@ (8025608 <GPIO_Init+0xc0>)
 80255e2:	2208      	movs	r2, #8
 80255e4:	e9cd 2304 	strd	r2, r3, [sp, #16]
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
  GPIO_InitStruct.Pull = GPIO_PULLDOWN;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80255e8:	a904      	add	r1, sp, #16
  GPIO_InitStruct.Pin = DRDY_ADXL_Pin;
 80255ea:	2202      	movs	r2, #2
 80255ec:	2303      	movs	r3, #3
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80255ee:	4620      	mov	r0, r4
  GPIO_InitStruct.Pin = DRDY_ADXL_Pin;
 80255f0:	e9cd 2306 	strd	r2, r3, [sp, #24]
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80255f4:	f7fc fb66 	bl	8021cc4 <HAL_GPIO_Init>
}
 80255f8:	b00b      	add	sp, #44	@ 0x2c
 80255fa:	bd30      	pop	{r4, r5, pc}
 80255fc:	40023800 	.word	0x40023800
 8025600:	40020400 	.word	0x40020400
 8025604:	40020000 	.word	0x40020000
 8025608:	10110000 	.word	0x10110000

0802560c <EXTI3_IRQHandler>:

void EXTI3_IRQHandler(void)
{
 802560c:	b508      	push	{r3, lr}
	ACQ_DoJob();
 802560e:	f7fe fb2d 	bl	8023c6c <ACQ_DoJob>
    __HAL_GPIO_EXTI_CLEAR_IT(DRDY_ADXL_Pin);
 8025612:	4b05      	ldr	r3, [pc, #20]	@ (8025628 <EXTI3_IRQHandler+0x1c>)

	HAL_GPIO_TogglePin(LED_R_GPIO_Port,LED_R_Pin);
 8025614:	4805      	ldr	r0, [pc, #20]	@ (802562c <EXTI3_IRQHandler+0x20>)
    __HAL_GPIO_EXTI_CLEAR_IT(DRDY_ADXL_Pin);
 8025616:	2208      	movs	r2, #8
 8025618:	615a      	str	r2, [r3, #20]
	HAL_GPIO_TogglePin(LED_R_GPIO_Port,LED_R_Pin);
 802561a:	f44f 7100 	mov.w	r1, #512	@ 0x200
    //ACQ_DoJob();
}
 802561e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	HAL_GPIO_TogglePin(LED_R_GPIO_Port,LED_R_Pin);
 8025622:	f7fc bd1d 	b.w	8022060 <HAL_GPIO_TogglePin>
 8025626:	bf00      	nop
 8025628:	40013c00 	.word	0x40013c00
 802562c:	40020400 	.word	0x40020400

08025630 <RS485_RX_SleepDone>:
	_LL_USART1_CR1_RXNEIE_BIT_DISABLE();
}

void MX_UART1_RX_ReInit(void)
{
	_LL_USART1_CR1_RE_BIT_ENABLE();
 8025630:	4b04      	ldr	r3, [pc, #16]	@ (8025644 <RS485_RX_SleepDone+0x14>)
 8025632:	68da      	ldr	r2, [r3, #12]
 8025634:	f042 0204 	orr.w	r2, r2, #4
 8025638:	60da      	str	r2, [r3, #12]
	_LL_USART1_CR1_RXNEIE_BIT_ENABLE();
 802563a:	68da      	ldr	r2, [r3, #12]
 802563c:	f042 0220 	orr.w	r2, r2, #32
 8025640:	60da      	str	r2, [r3, #12]
}
 8025642:	4770      	bx	lr
 8025644:	40011000 	.word	0x40011000

08025648 <flushSLSBuffer>:
}

static uint8_t _buff[1024];
static struct CyclicBuffer _rxBuff = { 0, 0, 0, sizeof(_buff), _buff};

void flushSLSBuffer(void)
 8025648:	4b02      	ldr	r3, [pc, #8]	@ (8025654 <flushSLSBuffer+0xc>)
 802564a:	2200      	movs	r2, #0
 802564c:	601a      	str	r2, [r3, #0]
 802564e:	809a      	strh	r2, [r3, #4]
 8025650:	4770      	bx	lr
 8025652:	bf00      	nop
 8025654:	200000b8 	.word	0x200000b8

08025658 <RS485_Send>:
}

uint16_t RS485_Send(const void *data, uint16_t len)
{

	if(data == 0 || len == 0)
 8025658:	b108      	cbz	r0, 802565e <RS485_Send+0x6>
 802565a:	b909      	cbnz	r1, 8025660 <RS485_Send+0x8>
	uint8_t *ptr = (uint8_t *)data;
	UART_Transmit(&huart1, ptr, len);
	//HAL_UART_Transmit(&huart1, ptr, len, 5000);
	//HAL_UART_Transmit_IT(&huart1,ptr,len);

	return len;
 802565c:	4608      	mov	r0, r1
}
 802565e:	4770      	bx	lr
  if (huart->gState == HAL_UART_STATE_READY)
 8025660:	4b0d      	ldr	r3, [pc, #52]	@ (8025698 <RS485_Send+0x40>)
 8025662:	f893 2039 	ldrb.w	r2, [r3, #57]	@ 0x39
 8025666:	2a20      	cmp	r2, #32
 8025668:	d1f8      	bne.n	802565c <RS485_Send+0x4>
{
 802566a:	b410      	push	{r4}
		while ((huart->Instance->SR & UART_FLAG_TXE) == RESET)
 802566c:	681c      	ldr	r4, [r3, #0]
 802566e:	eb00 0c01 	add.w	ip, r0, r1
 8025672:	f242 7311 	movw	r3, #10001	@ 0x2711
 8025676:	e001      	b.n	802567c <RS485_Send+0x24>
			if (waitCounter > 10000)
 8025678:	3b01      	subs	r3, #1
 802567a:	d008      	beq.n	802568e <RS485_Send+0x36>
		while ((huart->Instance->SR & UART_FLAG_TXE) == RESET)
 802567c:	6822      	ldr	r2, [r4, #0]
 802567e:	0612      	lsls	r2, r2, #24
 8025680:	d5fa      	bpl.n	8025678 <RS485_Send+0x20>
		huart->Instance->DR = (*pData++ & (uint8_t) 0xFF);
 8025682:	f810 3b01 	ldrb.w	r3, [r0], #1
 8025686:	6063      	str	r3, [r4, #4]
	while (TxXferSize > 0U)
 8025688:	4560      	cmp	r0, ip
 802568a:	d1f2      	bne.n	8025672 <RS485_Send+0x1a>
	while ((huart->Instance->SR & UART_FLAG_TXE) == RESET)
 802568c:	6823      	ldr	r3, [r4, #0]
}
 802568e:	f85d 4b04 	ldr.w	r4, [sp], #4
	return len;
 8025692:	4608      	mov	r0, r1
}
 8025694:	4770      	bx	lr
 8025696:	bf00      	nop
 8025698:	20021f34 	.word	0x20021f34

0802569c <RS485_TransmitOn>:

void RS485_TransmitOn(void)
{
 802569c:	b510      	push	{r4, lr}
	_LL_USART1_CR1_RE_BIT_DISABLE();
 802569e:	4c0f      	ldr	r4, [pc, #60]	@ (80256dc <RS485_TransmitOn+0x40>)
	//HAL_UART_MspDeInit_UART7();
	MX_UART1_RX_DeInit();
	HAL_GPIO_WritePin(USART__R_E_GPIO_Port, USART__R_E_Pin, GPIO_PIN_SET);
 80256a0:	480f      	ldr	r0, [pc, #60]	@ (80256e0 <RS485_TransmitOn+0x44>)
	_LL_USART1_CR1_RE_BIT_DISABLE();
 80256a2:	68e3      	ldr	r3, [r4, #12]
 80256a4:	f023 0304 	bic.w	r3, r3, #4
 80256a8:	60e3      	str	r3, [r4, #12]
	_LL_USART1_CR1_RXNEIE_BIT_DISABLE();
 80256aa:	68e3      	ldr	r3, [r4, #12]
 80256ac:	f023 0320 	bic.w	r3, r3, #32
 80256b0:	60e3      	str	r3, [r4, #12]
	HAL_GPIO_WritePin(USART__R_E_GPIO_Port, USART__R_E_Pin, GPIO_PIN_SET);
 80256b2:	2201      	movs	r2, #1
 80256b4:	f44f 5180 	mov.w	r1, #4096	@ 0x1000
 80256b8:	f7fc fcce 	bl	8022058 <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(USART_DE_GPIO_Port, USART_DE_Pin, GPIO_PIN_SET);
 80256bc:	2201      	movs	r2, #1
 80256be:	4808      	ldr	r0, [pc, #32]	@ (80256e0 <RS485_TransmitOn+0x44>)
 80256c0:	f44f 6180 	mov.w	r1, #1024	@ 0x400
 80256c4:	f7fc fcc8 	bl	8022058 <HAL_GPIO_WritePin>
	_LL_USART1_CR1_TE_BIT_ENABLE();
 80256c8:	68e2      	ldr	r2, [r4, #12]
 80256ca:	f042 0208 	orr.w	r2, r2, #8
 80256ce:	f44f 73c8 	mov.w	r3, #400	@ 0x190
 80256d2:	60e2      	str	r2, [r4, #12]
	MX_UART1_TX_ReInit();

	for(int i = 0; i < NOP_WAIT_AMMOUNT; i++)
	{
		__asm("nop");
 80256d4:	bf00      	nop
	for(int i = 0; i < NOP_WAIT_AMMOUNT; i++)
 80256d6:	3b01      	subs	r3, #1
 80256d8:	d1fc      	bne.n	80256d4 <RS485_TransmitOn+0x38>
	}
	//__disable_irq();
}
 80256da:	bd10      	pop	{r4, pc}
 80256dc:	40011000 	.word	0x40011000
 80256e0:	40020400 	.word	0x40020400

080256e4 <RS485_TransmitOff>:

void RS485_TransmitOff(void)
{
 80256e4:	b538      	push	{r3, r4, r5, lr}
 80256e6:	f44f 74c8 	mov.w	r4, #400	@ 0x190
	//HAL_UART_MspDeInit_UART7();
	for(int i = 0; i < NOP_WAIT_AMMOUNT; i++)
	{
		__asm("nop");
 80256ea:	bf00      	nop
	for(int i = 0; i < NOP_WAIT_AMMOUNT; i++)
 80256ec:	3c01      	subs	r4, #1
 80256ee:	d1fc      	bne.n	80256ea <RS485_TransmitOff+0x6>
	_LL_USART1_CR1_TE_BIT_DISABLE();
 80256f0:	4d10      	ldr	r5, [pc, #64]	@ (8025734 <RS485_TransmitOff+0x50>)
	}
	MX_UART1_TX_DeInit();
	HAL_GPIO_WritePin(USART__R_E_GPIO_Port, USART__R_E_Pin, GPIO_PIN_RESET);
 80256f2:	4811      	ldr	r0, [pc, #68]	@ (8025738 <RS485_TransmitOff+0x54>)
	_LL_USART1_CR1_TE_BIT_DISABLE();
 80256f4:	68eb      	ldr	r3, [r5, #12]
 80256f6:	f023 0308 	bic.w	r3, r3, #8
 80256fa:	60eb      	str	r3, [r5, #12]
	HAL_GPIO_WritePin(USART__R_E_GPIO_Port, USART__R_E_Pin, GPIO_PIN_RESET);
 80256fc:	4622      	mov	r2, r4
 80256fe:	f44f 5180 	mov.w	r1, #4096	@ 0x1000
 8025702:	f7fc fca9 	bl	8022058 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(USART_DE_GPIO_Port, USART_DE_Pin, GPIO_PIN_RESET);
 8025706:	480c      	ldr	r0, [pc, #48]	@ (8025738 <RS485_TransmitOff+0x54>)
 8025708:	4622      	mov	r2, r4
 802570a:	f44f 6180 	mov.w	r1, #1024	@ 0x400
 802570e:	f7fc fca3 	bl	8022058 <HAL_GPIO_WritePin>
 8025712:	2364      	movs	r3, #100	@ 0x64
	for(uint16_t i=0; i<100; ++i)
 8025714:	3b01      	subs	r3, #1
 8025716:	b29b      	uxth	r3, r3
	{
		uint32_t tmp;
		UNUSED(tmp);
		tmp = USART1->SR;
 8025718:	682a      	ldr	r2, [r5, #0]
		tmp = USART1->DR;
 802571a:	686a      	ldr	r2, [r5, #4]
	for(uint16_t i=0; i<100; ++i)
 802571c:	2b00      	cmp	r3, #0
 802571e:	d1f9      	bne.n	8025714 <RS485_TransmitOff+0x30>
	_LL_USART1_CR1_RE_BIT_ENABLE();
 8025720:	68eb      	ldr	r3, [r5, #12]
 8025722:	f043 0304 	orr.w	r3, r3, #4
 8025726:	60eb      	str	r3, [r5, #12]
	_LL_USART1_CR1_RXNEIE_BIT_ENABLE();
 8025728:	68eb      	ldr	r3, [r5, #12]
 802572a:	f043 0320 	orr.w	r3, r3, #32
 802572e:	60eb      	str	r3, [r5, #12]
	}

	MX_UART1_RX_ReInit();
}
 8025730:	bd38      	pop	{r3, r4, r5, pc}
 8025732:	bf00      	nop
 8025734:	40011000 	.word	0x40011000
 8025738:	40020400 	.word	0x40020400

0802573c <RS485_Clear>:
	uint8_t * const data;

};
//*********************************************************************//
static inline void CyclicBuffer_init(struct CyclicBuffer * buff) {
	buff->writePtr = 0;
 802573c:	4b02      	ldr	r3, [pc, #8]	@ (8025748 <RS485_Clear+0xc>)
 802573e:	2200      	movs	r2, #0
 8025740:	601a      	str	r2, [r3, #0]
	buff->readPtr = 0;
	buff->count = 0;
 8025742:	809a      	strh	r2, [r3, #4]

void RS485_Clear(void)
{
	CyclicBuffer_flush(&_rxBuff);
}
 8025744:	4770      	bx	lr
 8025746:	bf00      	nop
 8025748:	200000b8 	.word	0x200000b8

0802574c <RS485_GetByte>:
		return false;
	}
}
//*********************************************************************//
static inline int8_t CyclicBuffer_isNotEmpty(struct CyclicBuffer * buff) {
	return (buff->writePtr != buff->readPtr);
 802574c:	4b0d      	ldr	r3, [pc, #52]	@ (8025784 <RS485_GetByte+0x38>)
 802574e:	885a      	ldrh	r2, [r3, #2]

bool RS485_GetByte(uint8_t *ch)
{
   if(CyclicBuffer_isNotEmpty(&_rxBuff))
 8025750:	8819      	ldrh	r1, [r3, #0]
 8025752:	4291      	cmp	r1, r2
 8025754:	d013      	beq.n	802577e <RS485_GetByte+0x32>
	return (tmpWrite != buff->readPtr);
}
//*********************************************************************//
static inline uint8_t CyclicBuffer_get(struct CyclicBuffer * buff) {
	//__disable_irq();
	char c = buff->data[(++buff->readPtr) % buff->size];
 8025756:	f8b3 c006 	ldrh.w	ip, [r3, #6]
 802575a:	3201      	adds	r2, #1
 802575c:	b292      	uxth	r2, r2
 802575e:	fbb2 f1fc 	udiv	r1, r2, ip
 8025762:	fb0c 2111 	mls	r1, ip, r1, r2
 8025766:	805a      	strh	r2, [r3, #2]
	buff->count--;
 8025768:	f8b3 c004 	ldrh.w	ip, [r3, #4]
	char c = buff->data[(++buff->readPtr) % buff->size];
 802576c:	b28a      	uxth	r2, r1
 802576e:	6899      	ldr	r1, [r3, #8]
 8025770:	5c89      	ldrb	r1, [r1, r2]
   {
      *ch = CyclicBuffer_get(&_rxBuff);
 8025772:	7001      	strb	r1, [r0, #0]
	buff->count--;
 8025774:	f10c 32ff 	add.w	r2, ip, #4294967295
 8025778:	809a      	strh	r2, [r3, #4]
      return true;
 802577a:	2001      	movs	r0, #1
 802577c:	4770      	bx	lr
   }
   return false;
 802577e:	2000      	movs	r0, #0
}
 8025780:	4770      	bx	lr
 8025782:	bf00      	nop
 8025784:	200000b8 	.word	0x200000b8

08025788 <FAST_UART_RX_Start>:
{
	_timerRunning = false;
}

void FAST_UART_RX_Start(void)
{
 8025788:	b510      	push	{r4, lr}
	HAL_GPIO_WritePin(USART__R_E_GPIO_Port, USART__R_E_Pin, GPIO_PIN_RESET);
 802578a:	4c0a      	ldr	r4, [pc, #40]	@ (80257b4 <FAST_UART_RX_Start+0x2c>)
 802578c:	2200      	movs	r2, #0
 802578e:	f44f 5180 	mov.w	r1, #4096	@ 0x1000
 8025792:	4620      	mov	r0, r4
 8025794:	f7fc fc60 	bl	8022058 <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(USART_DE_GPIO_Port, USART_DE_Pin, GPIO_PIN_RESET);
 8025798:	2200      	movs	r2, #0
 802579a:	f44f 6180 	mov.w	r1, #1024	@ 0x400
 802579e:	4620      	mov	r0, r4
 80257a0:	f7fc fc5a 	bl	8022058 <HAL_GPIO_WritePin>


    __HAL_UART_ENABLE_IT(&huart1, UART_IT_RXNE);
 80257a4:	4b04      	ldr	r3, [pc, #16]	@ (80257b8 <FAST_UART_RX_Start+0x30>)
 80257a6:	681a      	ldr	r2, [r3, #0]
 80257a8:	68d3      	ldr	r3, [r2, #12]
 80257aa:	f043 0320 	orr.w	r3, r3, #32
 80257ae:	60d3      	str	r3, [r2, #12]
}
 80257b0:	bd10      	pop	{r4, pc}
 80257b2:	bf00      	nop
 80257b4:	40020400 	.word	0x40020400
 80257b8:	20021f34 	.word	0x20021f34

080257bc <USART1_IRQHandler>:
}



void USART1_IRQHandler(void)
{
 80257bc:	b530      	push	{r4, r5, lr}
    __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
 80257be:	4c29      	ldr	r4, [pc, #164]	@ (8025864 <USART1_IRQHandler+0xa8>)
	switch(Protocol)
 80257c0:	4929      	ldr	r1, [pc, #164]	@ (8025868 <USART1_IRQHandler+0xac>)
    __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
 80257c2:	6823      	ldr	r3, [r4, #0]
	switch(Protocol)
 80257c4:	7809      	ldrb	r1, [r1, #0]
    __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
 80257c6:	68da      	ldr	r2, [r3, #12]
 80257c8:	f022 0220 	bic.w	r2, r2, #32
{
 80257cc:	b083      	sub	sp, #12
    __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
 80257ce:	60da      	str	r2, [r3, #12]
    __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
 80257d0:	68da      	ldr	r2, [r3, #12]
 80257d2:	f422 7280 	bic.w	r2, r2, #256	@ 0x100
 80257d6:	60da      	str	r2, [r3, #12]
    __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
 80257d8:	695a      	ldr	r2, [r3, #20]
    __HAL_UART_CLEAR_OREFLAG(&huart1);
 80257da:	2000      	movs	r0, #0
    __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
 80257dc:	f022 0201 	bic.w	r2, r2, #1
 80257e0:	615a      	str	r2, [r3, #20]
    __HAL_UART_CLEAR_OREFLAG(&huart1);
 80257e2:	9001      	str	r0, [sp, #4]
 80257e4:	681a      	ldr	r2, [r3, #0]
 80257e6:	9201      	str	r2, [sp, #4]
 80257e8:	685a      	ldr	r2, [r3, #4]
 80257ea:	9201      	str	r2, [sp, #4]
 80257ec:	9a01      	ldr	r2, [sp, #4]
  	tmp = huart1.Instance->DR;
 80257ee:	685a      	ldr	r2, [r3, #4]
 80257f0:	6462      	str	r2, [r4, #68]	@ 0x44
	switch(Protocol)
 80257f2:	b1a9      	cbz	r1, 8025820 <USART1_IRQHandler+0x64>
 80257f4:	2901      	cmp	r1, #1
 80257f6:	d10d      	bne.n	8025814 <USART1_IRQHandler+0x58>
		if (HAL_GetTick() - lastTime >= 5)
 80257f8:	f7fb fc6e 	bl	80210d8 <HAL_GetTick>
 80257fc:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
 80257fe:	1ac0      	subs	r0, r0, r3
 8025800:	2804      	cmp	r0, #4
 8025802:	d82c      	bhi.n	802585e <USART1_IRQHandler+0xa2>
	    modbusRTU_getChar(tmp);
 8025804:	6c60      	ldr	r0, [r4, #68]	@ 0x44
 8025806:	b2c0      	uxtb	r0, r0
 8025808:	f001 ff74 	bl	80276f4 <modbusRTU_getChar>
	    lastTime = HAL_GetTick();
 802580c:	f7fb fc64 	bl	80210d8 <HAL_GetTick>
    __HAL_UART_ENABLE_IT(&huart1, UART_IT_RXNE);
 8025810:	6823      	ldr	r3, [r4, #0]
	    lastTime = HAL_GetTick();
 8025812:	64a0      	str	r0, [r4, #72]	@ 0x48
    __HAL_UART_ENABLE_IT(&huart1, UART_IT_RXNE);
 8025814:	68da      	ldr	r2, [r3, #12]
 8025816:	f042 0220 	orr.w	r2, r2, #32
 802581a:	60da      	str	r2, [r3, #12]

	FAST_UART_Receive_IT(&huart1);

}
 802581c:	b003      	add	sp, #12
 802581e:	bd30      	pop	{r4, r5, pc}
	uint16_t tmpWrite = buff->writePtr;
 8025820:	4912      	ldr	r1, [pc, #72]	@ (802586c <USART1_IRQHandler+0xb0>)
		CyclicBuffer_append(&_rxBuff, tmp);
 8025822:	6c60      	ldr	r0, [r4, #68]	@ 0x44
 8025824:	880a      	ldrh	r2, [r1, #0]
	tmpWrite = (tmpWrite + 1) % buff->size;
 8025826:	f8b1 c006 	ldrh.w	ip, [r1, #6]
	return c;
}
//*********************************************************************//
static inline int8_t CyclicBuffer_append(struct CyclicBuffer * buff, uint8_t c) {
	///__disable_irq();
	if (CyclicBuffer_isFull(buff)){
 802582a:	884d      	ldrh	r5, [r1, #2]
	tmpWrite = (tmpWrite + 1) % buff->size;
 802582c:	3201      	adds	r2, #1
 802582e:	fa5f fe80 	uxtb.w	lr, r0
 8025832:	fbb2 f0fc 	udiv	r0, r2, ip
 8025836:	fb0c 2010 	mls	r0, ip, r0, r2
	if (CyclicBuffer_isFull(buff)){
 802583a:	b280      	uxth	r0, r0
 802583c:	4285      	cmp	r5, r0
 802583e:	d0e9      	beq.n	8025814 <USART1_IRQHandler+0x58>
		//__enable_irq();
		return -1;
	}
	buff->data[(++buff->writePtr) % buff->size] = c;
 8025840:	b292      	uxth	r2, r2
 8025842:	800a      	strh	r2, [r1, #0]
 8025844:	fbb2 f3fc 	udiv	r3, r2, ip
 8025848:	fb0c 2213 	mls	r2, ip, r3, r2
	buff->count++;
 802584c:	888b      	ldrh	r3, [r1, #4]
 802584e:	3301      	adds	r3, #1
	buff->data[(++buff->writePtr) % buff->size] = c;
 8025850:	b292      	uxth	r2, r2
	buff->count++;
 8025852:	808b      	strh	r3, [r1, #4]
	buff->data[(++buff->writePtr) % buff->size] = c;
 8025854:	688b      	ldr	r3, [r1, #8]
 8025856:	f803 e002 	strb.w	lr, [r3, r2]
    __HAL_UART_ENABLE_IT(&huart1, UART_IT_RXNE);
 802585a:	6823      	ldr	r3, [r4, #0]
	//__enable_irq();
	return 1;
 802585c:	e7da      	b.n	8025814 <USART1_IRQHandler+0x58>
			modbusRTU_BufferFlush();
 802585e:	f001 ffb7 	bl	80277d0 <modbusRTU_BufferFlush>
 8025862:	e7cf      	b.n	8025804 <USART1_IRQHandler+0x48>
 8025864:	20021f34 	.word	0x20021f34
 8025868:	20023e5c 	.word	0x20023e5c
 802586c:	200000b8 	.word	0x200000b8

08025870 <RS485_Init>:
    }
  }
}

void RS485_Init(ADI_rs485_speed spd)
{
 8025870:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}

	HAL_GPIO_WritePin(USART__R_E_GPIO_Port, USART__R_E_Pin, GPIO_PIN_RESET);
 8025874:	2200      	movs	r2, #0
{
 8025876:	b089      	sub	sp, #36	@ 0x24
 8025878:	4606      	mov	r6, r0
	HAL_GPIO_WritePin(USART__R_E_GPIO_Port, USART__R_E_Pin, GPIO_PIN_RESET);
 802587a:	f44f 5180 	mov.w	r1, #4096	@ 0x1000
 802587e:	48c4      	ldr	r0, [pc, #784]	@ (8025b90 <RS485_Init+0x320>)
	HAL_GPIO_WritePin(USART_DE_GPIO_Port, USART_DE_Pin, GPIO_PIN_RESET);
  _timerRunning = false;
 8025880:	4cc4      	ldr	r4, [pc, #784]	@ (8025b94 <RS485_Init+0x324>)
	HAL_GPIO_WritePin(USART__R_E_GPIO_Port, USART__R_E_Pin, GPIO_PIN_RESET);
 8025882:	f7fc fbe9 	bl	8022058 <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(USART_DE_GPIO_Port, USART_DE_Pin, GPIO_PIN_RESET);
 8025886:	f44f 6180 	mov.w	r1, #1024	@ 0x400
 802588a:	48c1      	ldr	r0, [pc, #772]	@ (8025b90 <RS485_Init+0x320>)
 802588c:	2200      	movs	r2, #0
 802588e:	f7fc fbe3 	bl	8022058 <HAL_GPIO_WritePin>
  _timerRunning = false;
 8025892:	2500      	movs	r5, #0
  huart1.Instance = USART1;
 8025894:	4bc0      	ldr	r3, [pc, #768]	@ (8025b98 <RS485_Init+0x328>)
 8025896:	6023      	str	r3, [r4, #0]

  huart1.Init.BaudRate = Get_Speed(spd);
 8025898:	4630      	mov	r0, r6
  _timerRunning = false;
 802589a:	f884 5041 	strb.w	r5, [r4, #65]	@ 0x41
  huart1.Init.BaudRate = Get_Speed(spd);
 802589e:	f7ff fd9b 	bl	80253d8 <Get_Speed>
  huart1.Init.Parity = UART_PARITY_NONE;
  huart1.Init.Mode = UART_MODE_RX;
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;

  if (huart1.gState == HAL_UART_STATE_RESET)
 80258a2:	f894 1039 	ldrb.w	r1, [r4, #57]	@ 0x39
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;
 80258a6:	61e5      	str	r5, [r4, #28]
  huart1.Init.Mode = UART_MODE_RX;
 80258a8:	2304      	movs	r3, #4
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
 80258aa:	e9c4 0501 	strd	r0, r5, [r4, #4]
  huart1.Init.Parity = UART_PARITY_NONE;
 80258ae:	e9c4 5503 	strd	r5, r5, [r4, #12]
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 80258b2:	e9c4 3505 	strd	r3, r5, [r4, #20]
  if (huart1.gState == HAL_UART_STATE_RESET)
 80258b6:	2900      	cmp	r1, #0
 80258b8:	f000 812f 	beq.w	8025b1a <RS485_Init+0x2aa>
 80258bc:	4619      	mov	r1, r3
 80258be:	4628      	mov	r0, r5
 80258c0:	462e      	mov	r6, r5
    FastUartMspInit();
  }

  huart1.gState = HAL_UART_STATE_BUSY;

  __HAL_UART_DISABLE(&huart1);
 80258c2:	6823      	ldr	r3, [r4, #0]
  huart1.gState = HAL_UART_STATE_BUSY;
 80258c4:	2224      	movs	r2, #36	@ 0x24
 80258c6:	f884 2039 	strb.w	r2, [r4, #57]	@ 0x39
  __HAL_UART_DISABLE(&huart1);
 80258ca:	68da      	ldr	r2, [r3, #12]
 80258cc:	f422 5200 	bic.w	r2, r2, #8192	@ 0x2000
 80258d0:	60da      	str	r2, [r3, #12]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 80258d2:	691a      	ldr	r2, [r3, #16]
 80258d4:	f422 5240 	bic.w	r2, r2, #12288	@ 0x3000
 80258d8:	4332      	orrs	r2, r6
 80258da:	611a      	str	r2, [r3, #16]
  MODIFY_REG(huart->Instance->CR1,
 80258dc:	68da      	ldr	r2, [r3, #12]
 80258de:	f422 4216 	bic.w	r2, r2, #38400	@ 0x9600
 80258e2:	f022 020c 	bic.w	r2, r2, #12
 80258e6:	430a      	orrs	r2, r1
 80258e8:	60da      	str	r2, [r3, #12]
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart->Init.HwFlowCtl);
 80258ea:	695a      	ldr	r2, [r3, #20]
 80258ec:	f422 7240 	bic.w	r2, r2, #768	@ 0x300
 80258f0:	432a      	orrs	r2, r5
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80258f2:	f5b0 4f00 	cmp.w	r0, #32768	@ 0x8000
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart->Init.HwFlowCtl);
 80258f6:	615a      	str	r2, [r3, #20]
    if ((huart->Instance == USART1) || (huart->Instance == USART6))
 80258f8:	4aa7      	ldr	r2, [pc, #668]	@ (8025b98 <RS485_Init+0x328>)
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80258fa:	f000 80b0 	beq.w	8025a5e <RS485_Init+0x1ee>
    if ((huart->Instance == USART1) || (huart->Instance == USART6))
 80258fe:	4293      	cmp	r3, r2
 8025900:	d06e      	beq.n	80259e0 <RS485_Init+0x170>
 8025902:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8025906:	4293      	cmp	r3, r2
 8025908:	d06a      	beq.n	80259e0 <RS485_Init+0x170>
      huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
 802590a:	f7fc fc7f 	bl	802220c <HAL_RCC_GetPCLK1Freq>
 802590e:	6863      	ldr	r3, [r4, #4]
 8025910:	f8df 8290 	ldr.w	r8, [pc, #656]	@ 8025ba4 <RS485_Init+0x334>
 8025914:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8025918:	009b      	lsls	r3, r3, #2
 802591a:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 802591e:	fbb0 f7f3 	udiv	r7, r0, r3
 8025922:	f7fc fc73 	bl	802220c <HAL_RCC_GetPCLK1Freq>
 8025926:	fba8 3707 	umull	r3, r7, r8, r7
 802592a:	6863      	ldr	r3, [r4, #4]
 802592c:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8025930:	009b      	lsls	r3, r3, #2
 8025932:	eb00 0680 	add.w	r6, r0, r0, lsl #2
 8025936:	fbb6 f6f3 	udiv	r6, r6, r3
 802593a:	f7fc fc67 	bl	802220c <HAL_RCC_GetPCLK1Freq>
 802593e:	6863      	ldr	r3, [r4, #4]
 8025940:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8025944:	009b      	lsls	r3, r3, #2
 8025946:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 802594a:	fbb0 f0f3 	udiv	r0, r0, r3
 802594e:	fba8 3000 	umull	r3, r0, r8, r0
 8025952:	0940      	lsrs	r0, r0, #5
 8025954:	f04f 0964 	mov.w	r9, #100	@ 0x64
 8025958:	fb09 6610 	mls	r6, r9, r0, r6
 802595c:	0136      	lsls	r6, r6, #4
 802595e:	f7fc fc55 	bl	802220c <HAL_RCC_GetPCLK1Freq>
 8025962:	3632      	adds	r6, #50	@ 0x32
 8025964:	fba8 3606 	umull	r3, r6, r8, r6
 8025968:	6863      	ldr	r3, [r4, #4]
 802596a:	097f      	lsrs	r7, r7, #5
 802596c:	0976      	lsrs	r6, r6, #5
 802596e:	eb00 0280 	add.w	r2, r0, r0, lsl #2
 8025972:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8025976:	009b      	lsls	r3, r3, #2
 8025978:	013f      	lsls	r7, r7, #4
 802597a:	f006 06f0 	and.w	r6, r6, #240	@ 0xf0
 802597e:	fbb2 f5f3 	udiv	r5, r2, r3
 8025982:	f7fc fc43 	bl	802220c <HAL_RCC_GetPCLK1Freq>
 8025986:	6863      	ldr	r3, [r4, #4]
 8025988:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 802598c:	009b      	lsls	r3, r3, #2
 802598e:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8025992:	fbb0 f0f3 	udiv	r0, r0, r3
 8025996:	fba8 3000 	umull	r3, r0, r8, r0
 802599a:	0940      	lsrs	r0, r0, #5
 802599c:	fb09 5210 	mls	r2, r9, r0, r5
 80259a0:	0112      	lsls	r2, r2, #4
 80259a2:	3232      	adds	r2, #50	@ 0x32
 80259a4:	fba8 8202 	umull	r8, r2, r8, r2
 80259a8:	f3c2 1243 	ubfx	r2, r2, #5, #4
 80259ac:	6823      	ldr	r3, [r4, #0]
 80259ae:	4332      	orrs	r2, r6
 80259b0:	443a      	add	r2, r7
 80259b2:	609a      	str	r2, [r3, #8]

  RS485_SetConfig(&huart1);

  CLEAR_BIT(huart1.Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 80259b4:	691a      	ldr	r2, [r3, #16]
 80259b6:	f422 4290 	bic.w	r2, r2, #18432	@ 0x4800
 80259ba:	611a      	str	r2, [r3, #16]
  CLEAR_BIT(huart1.Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 80259bc:	695a      	ldr	r2, [r3, #20]
 80259be:	f022 022a 	bic.w	r2, r2, #42	@ 0x2a
 80259c2:	615a      	str	r2, [r3, #20]

  __HAL_UART_ENABLE(&huart1);
 80259c4:	68da      	ldr	r2, [r3, #12]

  huart1.ErrorCode = HAL_UART_ERROR_NONE;
  huart1.gState = HAL_UART_STATE_READY;
 80259c6:	2120      	movs	r1, #32
  huart1.ErrorCode = HAL_UART_ERROR_NONE;
 80259c8:	2000      	movs	r0, #0
  __HAL_UART_ENABLE(&huart1);
 80259ca:	f442 5200 	orr.w	r2, r2, #8192	@ 0x2000
 80259ce:	60da      	str	r2, [r3, #12]
  huart1.ErrorCode = HAL_UART_ERROR_NONE;
 80259d0:	63e0      	str	r0, [r4, #60]	@ 0x3c
  huart1.gState = HAL_UART_STATE_READY;
 80259d2:	f884 1039 	strb.w	r1, [r4, #57]	@ 0x39
  huart1.RxState = HAL_UART_STATE_READY;
 80259d6:	f884 103a 	strb.w	r1, [r4, #58]	@ 0x3a
}
 80259da:	b009      	add	sp, #36	@ 0x24
 80259dc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
 80259e0:	f7fc fc24 	bl	802222c <HAL_RCC_GetPCLK2Freq>
 80259e4:	6863      	ldr	r3, [r4, #4]
 80259e6:	f8df 81bc 	ldr.w	r8, [pc, #444]	@ 8025ba4 <RS485_Init+0x334>
 80259ea:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 80259ee:	009b      	lsls	r3, r3, #2
 80259f0:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 80259f4:	fbb0 f7f3 	udiv	r7, r0, r3
 80259f8:	f7fc fc18 	bl	802222c <HAL_RCC_GetPCLK2Freq>
 80259fc:	fba8 3707 	umull	r3, r7, r8, r7
 8025a00:	6863      	ldr	r3, [r4, #4]
 8025a02:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8025a06:	009b      	lsls	r3, r3, #2
 8025a08:	eb00 0680 	add.w	r6, r0, r0, lsl #2
 8025a0c:	fbb6 f6f3 	udiv	r6, r6, r3
 8025a10:	f7fc fc0c 	bl	802222c <HAL_RCC_GetPCLK2Freq>
 8025a14:	6863      	ldr	r3, [r4, #4]
 8025a16:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8025a1a:	009b      	lsls	r3, r3, #2
 8025a1c:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8025a20:	fbb0 f0f3 	udiv	r0, r0, r3
 8025a24:	fba8 3000 	umull	r3, r0, r8, r0
 8025a28:	0940      	lsrs	r0, r0, #5
 8025a2a:	f04f 0964 	mov.w	r9, #100	@ 0x64
 8025a2e:	fb09 6610 	mls	r6, r9, r0, r6
 8025a32:	0136      	lsls	r6, r6, #4
 8025a34:	f7fc fbfa 	bl	802222c <HAL_RCC_GetPCLK2Freq>
 8025a38:	3632      	adds	r6, #50	@ 0x32
 8025a3a:	fba8 3606 	umull	r3, r6, r8, r6
 8025a3e:	6863      	ldr	r3, [r4, #4]
 8025a40:	097f      	lsrs	r7, r7, #5
 8025a42:	0976      	lsrs	r6, r6, #5
 8025a44:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8025a48:	009b      	lsls	r3, r3, #2
 8025a4a:	013f      	lsls	r7, r7, #4
 8025a4c:	f006 06f0 	and.w	r6, r6, #240	@ 0xf0
 8025a50:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8025a54:	fbb0 f5f3 	udiv	r5, r0, r3
 8025a58:	f7fc fbe8 	bl	802222c <HAL_RCC_GetPCLK2Freq>
 8025a5c:	e793      	b.n	8025986 <RS485_Init+0x116>
    if ((huart->Instance == USART1) || (huart->Instance == USART6))
 8025a5e:	4293      	cmp	r3, r2
 8025a60:	f000 80a2 	beq.w	8025ba8 <RS485_Init+0x338>
 8025a64:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8025a68:	4293      	cmp	r3, r2
 8025a6a:	f000 809d 	beq.w	8025ba8 <RS485_Init+0x338>
      huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
 8025a6e:	f7fc fbcd 	bl	802220c <HAL_RCC_GetPCLK1Freq>
 8025a72:	6863      	ldr	r3, [r4, #4]
 8025a74:	f8df 812c 	ldr.w	r8, [pc, #300]	@ 8025ba4 <RS485_Init+0x334>
 8025a78:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8025a7c:	005b      	lsls	r3, r3, #1
 8025a7e:	eb00 0780 	add.w	r7, r0, r0, lsl #2
 8025a82:	fbb7 f7f3 	udiv	r7, r7, r3
 8025a86:	f7fc fbc1 	bl	802220c <HAL_RCC_GetPCLK1Freq>
 8025a8a:	fba8 3707 	umull	r3, r7, r8, r7
 8025a8e:	6863      	ldr	r3, [r4, #4]
 8025a90:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8025a94:	005b      	lsls	r3, r3, #1
 8025a96:	eb00 0680 	add.w	r6, r0, r0, lsl #2
 8025a9a:	fbb6 f6f3 	udiv	r6, r6, r3
 8025a9e:	f7fc fbb5 	bl	802220c <HAL_RCC_GetPCLK1Freq>
 8025aa2:	6863      	ldr	r3, [r4, #4]
 8025aa4:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8025aa8:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8025aac:	005b      	lsls	r3, r3, #1
 8025aae:	fbb0 f3f3 	udiv	r3, r0, r3
 8025ab2:	fba8 2303 	umull	r2, r3, r8, r3
 8025ab6:	095b      	lsrs	r3, r3, #5
 8025ab8:	f04f 0964 	mov.w	r9, #100	@ 0x64
 8025abc:	fb09 6613 	mls	r6, r9, r3, r6
 8025ac0:	00f6      	lsls	r6, r6, #3
 8025ac2:	f7fc fba3 	bl	802220c <HAL_RCC_GetPCLK1Freq>
 8025ac6:	3632      	adds	r6, #50	@ 0x32
 8025ac8:	fba8 3606 	umull	r3, r6, r8, r6
 8025acc:	6863      	ldr	r3, [r4, #4]
 8025ace:	097f      	lsrs	r7, r7, #5
 8025ad0:	0936      	lsrs	r6, r6, #4
 8025ad2:	eb00 0280 	add.w	r2, r0, r0, lsl #2
 8025ad6:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8025ada:	005b      	lsls	r3, r3, #1
 8025adc:	013f      	lsls	r7, r7, #4
 8025ade:	f406 76f8 	and.w	r6, r6, #496	@ 0x1f0
 8025ae2:	fbb2 f5f3 	udiv	r5, r2, r3
 8025ae6:	f7fc fb91 	bl	802220c <HAL_RCC_GetPCLK1Freq>
 8025aea:	6863      	ldr	r3, [r4, #4]
 8025aec:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8025af0:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8025af4:	005b      	lsls	r3, r3, #1
 8025af6:	fbb0 f3f3 	udiv	r3, r0, r3
 8025afa:	fba8 2303 	umull	r2, r3, r8, r3
 8025afe:	095b      	lsrs	r3, r3, #5
 8025b00:	fb09 5213 	mls	r2, r9, r3, r5
 8025b04:	00d2      	lsls	r2, r2, #3
 8025b06:	3232      	adds	r2, #50	@ 0x32
 8025b08:	fba8 8202 	umull	r8, r2, r8, r2
 8025b0c:	f3c2 1242 	ubfx	r2, r2, #5, #3
 8025b10:	6823      	ldr	r3, [r4, #0]
 8025b12:	443a      	add	r2, r7
 8025b14:	4432      	add	r2, r6
 8025b16:	609a      	str	r2, [r3, #8]
 8025b18:	e74c      	b.n	80259b4 <RS485_Init+0x144>
	huart1.Lock = HAL_UNLOCKED;
 8025b1a:	f001 06ff 	and.w	r6, r1, #255	@ 0xff
    __HAL_RCC_USART1_CLK_ENABLE();
 8025b1e:	4b1f      	ldr	r3, [pc, #124]	@ (8025b9c <RS485_Init+0x32c>)
 8025b20:	9600      	str	r6, [sp, #0]
 8025b22:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
	huart1.Lock = HAL_UNLOCKED;
 8025b24:	f884 6038 	strb.w	r6, [r4, #56]	@ 0x38
    __HAL_RCC_USART1_CLK_ENABLE();
 8025b28:	f042 0210 	orr.w	r2, r2, #16
 8025b2c:	645a      	str	r2, [r3, #68]	@ 0x44
 8025b2e:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 8025b30:	f002 0210 	and.w	r2, r2, #16
 8025b34:	9200      	str	r2, [sp, #0]
 8025b36:	9a00      	ldr	r2, [sp, #0]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8025b38:	9601      	str	r6, [sp, #4]
 8025b3a:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8025b3c:	f042 0201 	orr.w	r2, r2, #1
 8025b40:	631a      	str	r2, [r3, #48]	@ 0x30
 8025b42:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
    GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10;
 8025b44:	f44f 60c0 	mov.w	r0, #1536	@ 0x600
 8025b48:	2102      	movs	r1, #2
 8025b4a:	e9cd 0102 	strd	r0, r1, [sp, #8]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8025b4e:	f003 0301 	and.w	r3, r3, #1
    GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10;
 8025b52:	2001      	movs	r0, #1
 8025b54:	2103      	movs	r1, #3
 8025b56:	e9cd 0104 	strd	r0, r1, [sp, #16]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8025b5a:	9301      	str	r3, [sp, #4]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8025b5c:	4810      	ldr	r0, [pc, #64]	@ (8025ba0 <RS485_Init+0x330>)
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8025b5e:	9a01      	ldr	r2, [sp, #4]
    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
 8025b60:	2307      	movs	r3, #7
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8025b62:	a902      	add	r1, sp, #8
    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
 8025b64:	9306      	str	r3, [sp, #24]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8025b66:	f7fc f8ad 	bl	8021cc4 <HAL_GPIO_Init>
    HAL_NVIC_SetPriority(USART1_IRQn, 0, 0);
 8025b6a:	4632      	mov	r2, r6
 8025b6c:	4631      	mov	r1, r6
 8025b6e:	2025      	movs	r0, #37	@ 0x25
 8025b70:	f7fb fd5e 	bl	8021630 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART1_IRQn);
 8025b74:	2025      	movs	r0, #37	@ 0x25
 8025b76:	f7fb fd97 	bl	80216a8 <HAL_NVIC_EnableIRQ>
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 8025b7a:	e9d4 1204 	ldrd	r1, r2, [r4, #16]
 8025b7e:	68a3      	ldr	r3, [r4, #8]
 8025b80:	69e0      	ldr	r0, [r4, #28]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 8025b82:	68e6      	ldr	r6, [r4, #12]
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart->Init.HwFlowCtl);
 8025b84:	69a5      	ldr	r5, [r4, #24]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 8025b86:	430b      	orrs	r3, r1
 8025b88:	4313      	orrs	r3, r2
 8025b8a:	ea43 0100 	orr.w	r1, r3, r0
}
 8025b8e:	e698      	b.n	80258c2 <RS485_Init+0x52>
 8025b90:	40020400 	.word	0x40020400
 8025b94:	20021f34 	.word	0x20021f34
 8025b98:	40011000 	.word	0x40011000
 8025b9c:	40023800 	.word	0x40023800
 8025ba0:	40020000 	.word	0x40020000
 8025ba4:	51eb851f 	.word	0x51eb851f
      huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
 8025ba8:	f7fc fb40 	bl	802222c <HAL_RCC_GetPCLK2Freq>
 8025bac:	6863      	ldr	r3, [r4, #4]
 8025bae:	f8df 8078 	ldr.w	r8, [pc, #120]	@ 8025c28 <RS485_Init+0x3b8>
 8025bb2:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8025bb6:	005b      	lsls	r3, r3, #1
 8025bb8:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8025bbc:	fbb0 f7f3 	udiv	r7, r0, r3
 8025bc0:	f7fc fb34 	bl	802222c <HAL_RCC_GetPCLK2Freq>
 8025bc4:	fba8 3707 	umull	r3, r7, r8, r7
 8025bc8:	6863      	ldr	r3, [r4, #4]
 8025bca:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8025bce:	005b      	lsls	r3, r3, #1
 8025bd0:	eb00 0680 	add.w	r6, r0, r0, lsl #2
 8025bd4:	fbb6 f6f3 	udiv	r6, r6, r3
 8025bd8:	f7fc fb28 	bl	802222c <HAL_RCC_GetPCLK2Freq>
 8025bdc:	6863      	ldr	r3, [r4, #4]
 8025bde:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8025be2:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8025be6:	005b      	lsls	r3, r3, #1
 8025be8:	fbb0 f3f3 	udiv	r3, r0, r3
 8025bec:	fba8 2303 	umull	r2, r3, r8, r3
 8025bf0:	095b      	lsrs	r3, r3, #5
 8025bf2:	f04f 0964 	mov.w	r9, #100	@ 0x64
 8025bf6:	fb09 6613 	mls	r6, r9, r3, r6
 8025bfa:	00f6      	lsls	r6, r6, #3
 8025bfc:	f7fc fb16 	bl	802222c <HAL_RCC_GetPCLK2Freq>
 8025c00:	3632      	adds	r6, #50	@ 0x32
 8025c02:	fba8 3606 	umull	r3, r6, r8, r6
 8025c06:	6863      	ldr	r3, [r4, #4]
 8025c08:	097f      	lsrs	r7, r7, #5
 8025c0a:	0936      	lsrs	r6, r6, #4
 8025c0c:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8025c10:	005b      	lsls	r3, r3, #1
 8025c12:	013f      	lsls	r7, r7, #4
 8025c14:	f406 76f8 	and.w	r6, r6, #496	@ 0x1f0
 8025c18:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8025c1c:	fbb0 f5f3 	udiv	r5, r0, r3
 8025c20:	f7fc fb04 	bl	802222c <HAL_RCC_GetPCLK2Freq>
 8025c24:	e761      	b.n	8025aea <RS485_Init+0x27a>
 8025c26:	bf00      	nop
 8025c28:	51eb851f 	.word	0x51eb851f

08025c2c <SPI1_Init>:
SPI_HandleTypeDef hspi1;
extern uint8_t sample[3];

void SPI1_Init(void)
{
	hspi1.Instance = SPI1;
 8025c2c:	480e      	ldr	r0, [pc, #56]	@ (8025c68 <SPI1_Init+0x3c>)
 8025c2e:	490f      	ldr	r1, [pc, #60]	@ (8025c6c <SPI1_Init+0x40>)
	hspi1.Init.Mode = SPI_MODE_MASTER;
 8025c30:	f44f 7282 	mov.w	r2, #260	@ 0x104
{
 8025c34:	b510      	push	{r4, lr}
	hspi1.Init.Direction = SPI_DIRECTION_2LINES;
 8025c36:	2300      	movs	r3, #0
	hspi1.Init.Mode = SPI_MODE_MASTER;
 8025c38:	e9c0 1200 	strd	r1, r2, [r0]
	hspi1.Init.CLKPhase = SPI_PHASE_2EDGE;
	hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;//4
#else
	hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
	hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
	hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_8;//4
 8025c3c:	2410      	movs	r4, #16
#endif
	hspi1.Init.NSS = SPI_NSS_SOFT;
 8025c3e:	f44f 7100 	mov.w	r1, #512	@ 0x200

	hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
	hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
	hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
	hspi1.Init.CRCPolynomial = 10;
 8025c42:	220a      	movs	r2, #10
	hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
 8025c44:	e9c0 3302 	strd	r3, r3, [r0, #8]
	hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
 8025c48:	e9c0 3304 	strd	r3, r3, [r0, #16]
	hspi1.Init.NSS = SPI_NSS_SOFT;
 8025c4c:	e9c0 1406 	strd	r1, r4, [r0, #24]
	hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
 8025c50:	e9c0 3308 	strd	r3, r3, [r0, #32]
	hspi1.Init.CRCPolynomial = 10;
 8025c54:	e9c0 320a 	strd	r3, r2, [r0, #40]	@ 0x28
	if (HAL_SPI_Init(&hspi1) != HAL_OK)
 8025c58:	f7fc fd14 	bl	8022684 <HAL_SPI_Init>
 8025c5c:	b900      	cbnz	r0, 8025c60 <SPI1_Init+0x34>
	{
		Error_Handler();
	}
}
 8025c5e:	bd10      	pop	{r4, pc}
 8025c60:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		Error_Handler();
 8025c64:	f7ff bc02 	b.w	802546c <Error_Handler>
 8025c68:	20022380 	.word	0x20022380
 8025c6c:	40013000 	.word	0x40013000

08025c70 <HAL_SPI_MspInit>:

void HAL_SPI_MspInit(SPI_HandleTypeDef* spiHandle)
{
 8025c70:	b500      	push	{lr}
	GPIO_InitTypeDef GPIO_InitStruct = {0};
	if(spiHandle->Instance==SPI1)
 8025c72:	4a23      	ldr	r2, [pc, #140]	@ (8025d00 <HAL_SPI_MspInit+0x90>)
 8025c74:	6801      	ldr	r1, [r0, #0]
{
 8025c76:	b089      	sub	sp, #36	@ 0x24
	GPIO_InitTypeDef GPIO_InitStruct = {0};
 8025c78:	2300      	movs	r3, #0
	if(spiHandle->Instance==SPI1)
 8025c7a:	4291      	cmp	r1, r2
	GPIO_InitTypeDef GPIO_InitStruct = {0};
 8025c7c:	e9cd 3302 	strd	r3, r3, [sp, #8]
 8025c80:	e9cd 3304 	strd	r3, r3, [sp, #16]
 8025c84:	9306      	str	r3, [sp, #24]
	if(spiHandle->Instance==SPI1)
 8025c86:	d002      	beq.n	8025c8e <HAL_SPI_MspInit+0x1e>
		GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
		HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
		HAL_NVIC_SetPriority(SPI1_IRQn, 1, 1);
		HAL_NVIC_EnableIRQ(SPI1_IRQn);
	}
}
 8025c88:	b009      	add	sp, #36	@ 0x24
 8025c8a:	f85d fb04 	ldr.w	pc, [sp], #4
		__HAL_RCC_SPI1_CLK_ENABLE();
 8025c8e:	f502 3284 	add.w	r2, r2, #67584	@ 0x10800
 8025c92:	9300      	str	r3, [sp, #0]
 8025c94:	6c50      	ldr	r0, [r2, #68]	@ 0x44
 8025c96:	f440 5080 	orr.w	r0, r0, #4096	@ 0x1000
 8025c9a:	6450      	str	r0, [r2, #68]	@ 0x44
 8025c9c:	6c50      	ldr	r0, [r2, #68]	@ 0x44
 8025c9e:	f400 5080 	and.w	r0, r0, #4096	@ 0x1000
 8025ca2:	9000      	str	r0, [sp, #0]
 8025ca4:	9800      	ldr	r0, [sp, #0]
		__HAL_RCC_GPIOA_CLK_ENABLE();
 8025ca6:	9301      	str	r3, [sp, #4]
 8025ca8:	6b13      	ldr	r3, [r2, #48]	@ 0x30
		HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8025caa:	4816      	ldr	r0, [pc, #88]	@ (8025d04 <HAL_SPI_MspInit+0x94>)
		GPIO_InitStruct.Pin = SCLK_ADXL_Pin|MISO_ADXL_Pin|MOSI_ADXL_Pin;
 8025cac:	ed9f 7b10 	vldr	d7, [pc, #64]	@ 8025cf0 <HAL_SPI_MspInit+0x80>
		__HAL_RCC_GPIOA_CLK_ENABLE();
 8025cb0:	f043 0301 	orr.w	r3, r3, #1
 8025cb4:	6313      	str	r3, [r2, #48]	@ 0x30
 8025cb6:	6b13      	ldr	r3, [r2, #48]	@ 0x30
		GPIO_InitStruct.Pin = SCLK_ADXL_Pin|MISO_ADXL_Pin|MOSI_ADXL_Pin;
 8025cb8:	ed8d 7b02 	vstr	d7, [sp, #8]
 8025cbc:	ed9f 7b0e 	vldr	d7, [pc, #56]	@ 8025cf8 <HAL_SPI_MspInit+0x88>
		__HAL_RCC_GPIOA_CLK_ENABLE();
 8025cc0:	f003 0301 	and.w	r3, r3, #1
 8025cc4:	9301      	str	r3, [sp, #4]
		HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8025cc6:	a902      	add	r1, sp, #8
		GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
 8025cc8:	2305      	movs	r3, #5
		GPIO_InitStruct.Pin = SCLK_ADXL_Pin|MISO_ADXL_Pin|MOSI_ADXL_Pin;
 8025cca:	ed8d 7b04 	vstr	d7, [sp, #16]
		GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
 8025cce:	9306      	str	r3, [sp, #24]
		__HAL_RCC_GPIOA_CLK_ENABLE();
 8025cd0:	9a01      	ldr	r2, [sp, #4]
		HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8025cd2:	f7fb fff7 	bl	8021cc4 <HAL_GPIO_Init>
		HAL_NVIC_SetPriority(SPI1_IRQn, 1, 1);
 8025cd6:	2201      	movs	r2, #1
 8025cd8:	4611      	mov	r1, r2
 8025cda:	2023      	movs	r0, #35	@ 0x23
 8025cdc:	f7fb fca8 	bl	8021630 <HAL_NVIC_SetPriority>
		HAL_NVIC_EnableIRQ(SPI1_IRQn);
 8025ce0:	2023      	movs	r0, #35	@ 0x23
 8025ce2:	f7fb fce1 	bl	80216a8 <HAL_NVIC_EnableIRQ>
}
 8025ce6:	b009      	add	sp, #36	@ 0x24
 8025ce8:	f85d fb04 	ldr.w	pc, [sp], #4
 8025cec:	f3af 8000 	nop.w
 8025cf0:	000000e0 	.word	0x000000e0
 8025cf4:	00000002 	.word	0x00000002
 8025cf8:	00000001 	.word	0x00000001
 8025cfc:	00000002 	.word	0x00000002
 8025d00:	40013000 	.word	0x40013000
 8025d04:	40020000 	.word	0x40020000

08025d08 <SPI1_IRQHandler>:
} 


void SPI1_IRQHandler(void)
{
	HAL_SPI_IRQHandler(&hspi1);
 8025d08:	4801      	ldr	r0, [pc, #4]	@ (8025d10 <SPI1_IRQHandler+0x8>)
 8025d0a:	f7fd b8ab 	b.w	8022e64 <HAL_SPI_IRQHandler>
 8025d0e:	bf00      	nop
 8025d10:	20022380 	.word	0x20022380

08025d14 <HAL_ADC_MspInit>:
#define ADC_REFERENCE_VOLTAGE_MV 3300.0f
#define ADC_MAX_OUTPUT_VALUE 4095.0f

void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)
{
  if(hadc->Instance==ADC1)
 8025d14:	4b0e      	ldr	r3, [pc, #56]	@ (8025d50 <HAL_ADC_MspInit+0x3c>)
 8025d16:	6802      	ldr	r2, [r0, #0]
 8025d18:	429a      	cmp	r2, r3
 8025d1a:	d000      	beq.n	8025d1e <HAL_ADC_MspInit+0xa>
 8025d1c:	4770      	bx	lr
{
 8025d1e:	b500      	push	{lr}
 8025d20:	b083      	sub	sp, #12
  {
    __HAL_RCC_ADC1_CLK_ENABLE();
 8025d22:	f503 338c 	add.w	r3, r3, #71680	@ 0x11800
 8025d26:	2200      	movs	r2, #0
 8025d28:	9201      	str	r2, [sp, #4]
 8025d2a:	6c59      	ldr	r1, [r3, #68]	@ 0x44
 8025d2c:	f441 7180 	orr.w	r1, r1, #256	@ 0x100
 8025d30:	6459      	str	r1, [r3, #68]	@ 0x44
 8025d32:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8025d34:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8025d38:	9301      	str	r3, [sp, #4]
    HAL_NVIC_SetPriority(ADC_IRQn, 5, 0);
 8025d3a:	2105      	movs	r1, #5
 8025d3c:	2012      	movs	r0, #18
    __HAL_RCC_ADC1_CLK_ENABLE();
 8025d3e:	9b01      	ldr	r3, [sp, #4]
    HAL_NVIC_SetPriority(ADC_IRQn, 5, 0);
 8025d40:	f7fb fc76 	bl	8021630 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(ADC_IRQn);
 8025d44:	2012      	movs	r0, #18
  }
}
 8025d46:	b003      	add	sp, #12
 8025d48:	f85d eb04 	ldr.w	lr, [sp], #4
    HAL_NVIC_EnableIRQ(ADC_IRQn);
 8025d4c:	f7fb bcac 	b.w	80216a8 <HAL_NVIC_EnableIRQ>
 8025d50:	40012000 	.word	0x40012000
 8025d54:	00000000 	.word	0x00000000

08025d58 <ADC_Temp_Init>:

void ADC_Temp_Init(void)
{
 8025d58:	b500      	push	{lr}
	  ADC_ChannelConfTypeDef sConfig = {0};

	  hadc1.Instance = ADC1;
 8025d5a:	481f      	ldr	r0, [pc, #124]	@ (8025dd8 <ADC_Temp_Init+0x80>)
 8025d5c:	491f      	ldr	r1, [pc, #124]	@ (8025ddc <ADC_Temp_Init+0x84>)
	  hadc1.Init.Resolution = ADC_RESOLUTION_12B;
	  hadc1.Init.ScanConvMode = DISABLE;
	  hadc1.Init.ContinuousConvMode = DISABLE;
	  hadc1.Init.DiscontinuousConvMode = DISABLE;
	  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
	  hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
 8025d5e:	ed9f 7b1a 	vldr	d7, [pc, #104]	@ 8025dc8 <ADC_Temp_Init+0x70>
	  hadc1.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV8;
 8025d62:	f44f 3240 	mov.w	r2, #196608	@ 0x30000
{
 8025d66:	b085      	sub	sp, #20
	  ADC_ChannelConfTypeDef sConfig = {0};
 8025d68:	2300      	movs	r3, #0
	  hadc1.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV8;
 8025d6a:	e9c0 1200 	strd	r1, r2, [r0]
	  hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
	  hadc1.Init.NbrOfConversion = 1;
 8025d6e:	2201      	movs	r2, #1
	  ADC_ChannelConfTypeDef sConfig = {0};
 8025d70:	e9cd 3300 	strd	r3, r3, [sp]
 8025d74:	e9cd 3302 	strd	r3, r3, [sp, #8]
	  hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
 8025d78:	ed80 7b0a 	vstr	d7, [r0, #40]	@ 0x28
	  hadc1.Init.Resolution = ADC_RESOLUTION_12B;
 8025d7c:	6083      	str	r3, [r0, #8]
	  hadc1.Init.ScanConvMode = DISABLE;
 8025d7e:	6103      	str	r3, [r0, #16]
	  hadc1.Init.ContinuousConvMode = DISABLE;
 8025d80:	7603      	strb	r3, [r0, #24]
	  hadc1.Init.DiscontinuousConvMode = DISABLE;
 8025d82:	f880 3020 	strb.w	r3, [r0, #32]
	  hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 8025d86:	60c3      	str	r3, [r0, #12]
	  hadc1.Init.NbrOfConversion = 1;
 8025d88:	61c2      	str	r2, [r0, #28]
	  hadc1.Init.DMAContinuousRequests = DISABLE;
 8025d8a:	f880 3030 	strb.w	r3, [r0, #48]	@ 0x30
	  hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 8025d8e:	6142      	str	r2, [r0, #20]
	  if (HAL_ADC_Init(&hadc1) != HAL_OK)
 8025d90:	f7fb f9cc 	bl	802112c <HAL_ADC_Init>
 8025d94:	b968      	cbnz	r0, 8025db2 <ADC_Temp_Init+0x5a>
	  {
	    Error_Handler();
	  }
	  sConfig.Channel = ADC_CHANNEL_TEMPSENSOR;
 8025d96:	ed9f 7b0e 	vldr	d7, [pc, #56]	@ 8025dd0 <ADC_Temp_Init+0x78>
	  sConfig.Rank = 1;
	  sConfig.SamplingTime = ADC_SAMPLETIME_144CYCLES;
 8025d9a:	2306      	movs	r3, #6
	  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8025d9c:	480e      	ldr	r0, [pc, #56]	@ (8025dd8 <ADC_Temp_Init+0x80>)
	  sConfig.SamplingTime = ADC_SAMPLETIME_144CYCLES;
 8025d9e:	9302      	str	r3, [sp, #8]
	  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8025da0:	4669      	mov	r1, sp
	  sConfig.Channel = ADC_CHANNEL_TEMPSENSOR;
 8025da2:	ed8d 7b00 	vstr	d7, [sp]
	  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8025da6:	f7fb fb79 	bl	802149c <HAL_ADC_ConfigChannel>
 8025daa:	b928      	cbnz	r0, 8025db8 <ADC_Temp_Init+0x60>
	  {
	    Error_Handler();
	  }
}
 8025dac:	b005      	add	sp, #20
 8025dae:	f85d fb04 	ldr.w	pc, [sp], #4
	    Error_Handler();
 8025db2:	f7ff fb5b 	bl	802546c <Error_Handler>
 8025db6:	e7ee      	b.n	8025d96 <ADC_Temp_Init+0x3e>
	    Error_Handler();
 8025db8:	f7ff fb58 	bl	802546c <Error_Handler>
}
 8025dbc:	b005      	add	sp, #20
 8025dbe:	f85d fb04 	ldr.w	pc, [sp], #4
 8025dc2:	bf00      	nop
 8025dc4:	f3af 8000 	nop.w
 8025dc8:	0f000001 	.word	0x0f000001
 8025dcc:	00000000 	.word	0x00000000
 8025dd0:	10000012 	.word	0x10000012
 8025dd4:	00000001 	.word	0x00000001
 8025dd8:	200223d8 	.word	0x200223d8
 8025ddc:	40012000 	.word	0x40012000

08025de0 <Temp_SampleMake>:

void Temp_SampleMake(void)
{
	HAL_ADC_Start_IT(&hadc1);
 8025de0:	4801      	ldr	r0, [pc, #4]	@ (8025de8 <Temp_SampleMake+0x8>)
 8025de2:	f7fb ba4f 	b.w	8021284 <HAL_ADC_Start_IT>
 8025de6:	bf00      	nop
 8025de8:	200223d8 	.word	0x200223d8

08025dec <Temp_SampleGet>:
static uint32_t readCounts = 10;
static float lastTemp = 0;

void Temp_SampleGet(uint8_t* dest)
{
	if (readCounts++ >= 10)
 8025dec:	4a0d      	ldr	r2, [pc, #52]	@ (8025e24 <Temp_SampleGet+0x38>)
 8025dee:	6813      	ldr	r3, [r2, #0]
 8025df0:	1c59      	adds	r1, r3, #1
 8025df2:	2b09      	cmp	r3, #9
 8025df4:	6011      	str	r1, [r2, #0]
	{
		lastTemp = tempSum/tempSumsCount;
 8025df6:	4b0c      	ldr	r3, [pc, #48]	@ (8025e28 <Temp_SampleGet+0x3c>)
	if (readCounts++ >= 10)
 8025df8:	d910      	bls.n	8025e1c <Temp_SampleGet+0x30>
		lastTemp = tempSum/tempSumsCount;
 8025dfa:	edd3 7a14 	vldr	s15, [r3, #80]	@ 0x50
 8025dfe:	edd3 6a13 	vldr	s13, [r3, #76]	@ 0x4c
 8025e02:	eef8 7a67 	vcvt.f32.u32	s15, s15
		tempSum = 0;
		tempSumsCount = 0;
 8025e06:	2100      	movs	r1, #0
		lastTemp = tempSum/tempSumsCount;
 8025e08:	ee86 7aa7 	vdiv.f32	s14, s13, s15
		tempSum = 0;
 8025e0c:	f04f 0c00 	mov.w	ip, #0
 8025e10:	f8c3 c04c 	str.w	ip, [r3, #76]	@ 0x4c
		tempSumsCount = 0;
 8025e14:	6519      	str	r1, [r3, #80]	@ 0x50
		readCounts = 0;
 8025e16:	6011      	str	r1, [r2, #0]
		lastTemp = tempSum/tempSumsCount;
 8025e18:	ed83 7a12 	vstr	s14, [r3, #72]	@ 0x48
	}
	memcpy(dest,&lastTemp,4);
 8025e1c:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 8025e1e:	6003      	str	r3, [r0, #0]
}
 8025e20:	4770      	bx	lr
 8025e22:	bf00      	nop
 8025e24:	200000c4 	.word	0x200000c4
 8025e28:	200223d8 	.word	0x200223d8

08025e2c <ADC_IRQHandler>:

void ADC_IRQHandler(void)
{
	HAL_ADC_IRQHandler(&hadc1);
 8025e2c:	4801      	ldr	r0, [pc, #4]	@ (8025e34 <ADC_IRQHandler+0x8>)
 8025e2e:	f7fb ba9f 	b.w	8021370 <HAL_ADC_IRQHandler>
 8025e32:	bf00      	nop
 8025e34:	200223d8 	.word	0x200223d8

08025e38 <HAL_ADC_ConvCpltCallback>:
const float Avg_slope = 0.0025; //[Volts/degree]
const float SupplyVoltage = 3.3; // [Volts]
const float ADCResolution = 4096.0;

void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc)
{
 8025e38:	b510      	push	{r4, lr}
	PomiarADC = HAL_ADC_GetValue(&hadc1); // Pobranie zmierzonej wartosci
 8025e3a:	4c13      	ldr	r4, [pc, #76]	@ (8025e88 <HAL_ADC_ConvCpltCallback+0x50>)
 8025e3c:	4620      	mov	r0, r4
 8025e3e:	f7fb fa8f 	bl	8021360 <HAL_ADC_GetValue>
	Vsense = (SupplyVoltage*PomiarADC)/(ADCResolution-1); // Przeliczenie wartosci zmierzonej na napiecie
 8025e42:	b283      	uxth	r3, r0
 8025e44:	ee07 3a90 	vmov	s15, r3
 8025e48:	ed9f 7a10 	vldr	s14, [pc, #64]	@ 8025e8c <HAL_ADC_ConvCpltCallback+0x54>
	Temperature = ((Vsense-V25)/Avg_slope)+25; // Obliczenie temperatury
 8025e4c:	eddf 6a10 	vldr	s13, [pc, #64]	@ 8025e90 <HAL_ADC_ConvCpltCallback+0x58>
 8025e50:	ed9f 6a10 	vldr	s12, [pc, #64]	@ 8025e94 <HAL_ADC_ConvCpltCallback+0x5c>
	tempSum += Temperature;
	tempSumsCount++;
 8025e54:	6d23      	ldr	r3, [r4, #80]	@ 0x50
	PomiarADC = HAL_ADC_GetValue(&hadc1); // Pobranie zmierzonej wartosci
 8025e56:	f8a4 0054 	strh.w	r0, [r4, #84]	@ 0x54
	Vsense = (SupplyVoltage*PomiarADC)/(ADCResolution-1); // Przeliczenie wartosci zmierzonej na napiecie
 8025e5a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
	tempSumsCount++;
 8025e5e:	3301      	adds	r3, #1
	Vsense = (SupplyVoltage*PomiarADC)/(ADCResolution-1); // Przeliczenie wartosci zmierzonej na napiecie
 8025e60:	ee67 7a87 	vmul.f32	s15, s15, s14
	Temperature = ((Vsense-V25)/Avg_slope)+25; // Obliczenie temperatury
 8025e64:	eeb3 7a09 	vmov.f32	s14, #57	@ 0x41c80000  25.0
 8025e68:	ee77 6ae6 	vsub.f32	s13, s15, s13
	Vsense = (SupplyVoltage*PomiarADC)/(ADCResolution-1); // Przeliczenie wartosci zmierzonej na napiecie
 8025e6c:	edc4 7a16 	vstr	s15, [r4, #88]	@ 0x58
	Temperature = ((Vsense-V25)/Avg_slope)+25; // Obliczenie temperatury
 8025e70:	eea6 7a86 	vfma.f32	s14, s13, s12
	tempSumsCount++;
 8025e74:	6523      	str	r3, [r4, #80]	@ 0x50
	tempSum += Temperature;
 8025e76:	edd4 6a13 	vldr	s13, [r4, #76]	@ 0x4c
	Temperature = ((Vsense-V25)/Avg_slope)+25; // Obliczenie temperatury
 8025e7a:	ed84 7a17 	vstr	s14, [r4, #92]	@ 0x5c
	tempSum += Temperature;
 8025e7e:	ee76 6a87 	vadd.f32	s13, s13, s14
 8025e82:	edc4 6a13 	vstr	s13, [r4, #76]	@ 0x4c
}
 8025e86:	bd10      	pop	{r4, pc}
 8025e88:	200223d8 	.word	0x200223d8
 8025e8c:	3a534068 	.word	0x3a534068
 8025e90:	3f428f5c 	.word	0x3f428f5c
 8025e94:	43c80000 	.word	0x43c80000

08025e98 <TimerTemperature_Start>:
	HAL_TIM_Base_Stop_IT(&htim7);
}

void TimerTemperature_Start(void)
{
	HAL_TIM_Base_Start_IT(&htim9);
 8025e98:	4801      	ldr	r0, [pc, #4]	@ (8025ea0 <TimerTemperature_Start+0x8>)
 8025e9a:	f7fd b90f 	b.w	80230bc <HAL_TIM_Base_Start_IT>
 8025e9e:	bf00      	nop
 8025ea0:	2002247c 	.word	0x2002247c

08025ea4 <TIMER_AcqSample_Init>:
	if (HAL_TIM_Base_Init(&htim7) != HAL_OK)
	{
		Error_Handler();
	}
#endif
}
 8025ea4:	4770      	bx	lr
 8025ea6:	bf00      	nop

08025ea8 <TIMER_TempSample_Init>:

void TIMER_TempSample_Init(void)
{
	htim9.Instance = TIM9;
 8025ea8:	4b0c      	ldr	r3, [pc, #48]	@ (8025edc <TIMER_TempSample_Init+0x34>)
 8025eaa:	480d      	ldr	r0, [pc, #52]	@ (8025ee0 <TIMER_TempSample_Init+0x38>)
	htim9.Init.Prescaler = 999; // 999 = 40Hz
 8025eac:	f240 31e7 	movw	r1, #999	@ 0x3e7
{
 8025eb0:	b510      	push	{r4, lr}
	htim9.Init.Prescaler = 999; // 999 = 40Hz
 8025eb2:	2200      	movs	r2, #0
 8025eb4:	e9c3 0110 	strd	r0, r1, [r3, #64]	@ 0x40
 8025eb8:	f240 74cf 	movw	r4, #1999	@ 0x7cf
	htim9.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim9.Init.Period = 1999;
	htim9.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
	htim9.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
 8025ebc:	2180      	movs	r1, #128	@ 0x80
	if (HAL_TIM_Base_Init(&htim9) != HAL_OK)
 8025ebe:	f103 0040 	add.w	r0, r3, #64	@ 0x40
	htim9.Init.Prescaler = 999; // 999 = 40Hz
 8025ec2:	e9c3 2412 	strd	r2, r4, [r3, #72]	@ 0x48
 8025ec6:	651a      	str	r2, [r3, #80]	@ 0x50
	htim9.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
 8025ec8:	6599      	str	r1, [r3, #88]	@ 0x58
	if (HAL_TIM_Base_Init(&htim9) != HAL_OK)
 8025eca:	f7fd f87b 	bl	8022fc4 <HAL_TIM_Base_Init>
 8025ece:	b900      	cbnz	r0, 8025ed2 <TIMER_TempSample_Init+0x2a>
	{
		Error_Handler();
	}
}
 8025ed0:	bd10      	pop	{r4, pc}
 8025ed2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		Error_Handler();
 8025ed6:	f7ff bac9 	b.w	802546c <Error_Handler>
 8025eda:	bf00      	nop
 8025edc:	2002243c 	.word	0x2002243c
 8025ee0:	40014000 	.word	0x40014000

08025ee4 <TIMER_Sleep_Init>:

void TIMER_Sleep_Init(void)
{
 8025ee4:	b510      	push	{r4, lr}
	htim10.Instance = TIM10;
 8025ee6:	4b0c      	ldr	r3, [pc, #48]	@ (8025f18 <TIMER_Sleep_Init+0x34>)
 8025ee8:	4c0c      	ldr	r4, [pc, #48]	@ (8025f1c <TIMER_Sleep_Init+0x38>)
	htim10.Init.Prescaler = 39999;
 8025eea:	f649 403f 	movw	r0, #39999	@ 0x9c3f
 8025eee:	2200      	movs	r2, #0
 8025ef0:	e9c3 4020 	strd	r4, r0, [r3, #128]	@ 0x80
 8025ef4:	210a      	movs	r1, #10
	htim10.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim10.Init.Period = 10;
	htim10.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
	htim10.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(&htim10) != HAL_OK)
 8025ef6:	f103 0080 	add.w	r0, r3, #128	@ 0x80
	htim10.Init.Prescaler = 39999;
 8025efa:	e9c3 2122 	strd	r2, r1, [r3, #136]	@ 0x88
 8025efe:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
	htim10.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8025f02:	f8c3 2098 	str.w	r2, [r3, #152]	@ 0x98
	if (HAL_TIM_Base_Init(&htim10) != HAL_OK)
 8025f06:	f7fd f85d 	bl	8022fc4 <HAL_TIM_Base_Init>
 8025f0a:	b900      	cbnz	r0, 8025f0e <TIMER_Sleep_Init+0x2a>
	{
		Error_Handler();
	}
}
 8025f0c:	bd10      	pop	{r4, pc}
 8025f0e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		Error_Handler();
 8025f12:	f7ff baab 	b.w	802546c <Error_Handler>
 8025f16:	bf00      	nop
 8025f18:	2002243c 	.word	0x2002243c
 8025f1c:	40014400 	.word	0x40014400

08025f20 <HAL_TIM_Base_MspInit>:
{
	Temp_SampleMake();
}
// INTERNALS BELOW
void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* htim_base)
{
 8025f20:	b500      	push	{lr}
	if (htim_base->Instance == TIM7)
 8025f22:	4a29      	ldr	r2, [pc, #164]	@ (8025fc8 <HAL_TIM_Base_MspInit+0xa8>)
 8025f24:	6803      	ldr	r3, [r0, #0]
 8025f26:	4293      	cmp	r3, r2
{
 8025f28:	b085      	sub	sp, #20
	if (htim_base->Instance == TIM7)
 8025f2a:	d020      	beq.n	8025f6e <HAL_TIM_Base_MspInit+0x4e>
	{
		__HAL_RCC_TIM7_CLK_ENABLE();
		HAL_NVIC_SetPriority(TIM7_IRQn, 1, 0);
		HAL_NVIC_EnableIRQ(TIM7_IRQn);
	}
	else if (htim_base->Instance == TIM9)
 8025f2c:	4a27      	ldr	r2, [pc, #156]	@ (8025fcc <HAL_TIM_Base_MspInit+0xac>)
 8025f2e:	4293      	cmp	r3, r2
 8025f30:	d033      	beq.n	8025f9a <HAL_TIM_Base_MspInit+0x7a>
	{
		__HAL_RCC_TIM9_CLK_ENABLE();
		HAL_NVIC_SetPriority(TIM1_BRK_TIM9_IRQn, 4, 0);
		HAL_NVIC_EnableIRQ(TIM1_BRK_TIM9_IRQn);
	}
	else if (htim_base->Instance == TIM10)
 8025f32:	4a27      	ldr	r2, [pc, #156]	@ (8025fd0 <HAL_TIM_Base_MspInit+0xb0>)
 8025f34:	4293      	cmp	r3, r2
 8025f36:	d004      	beq.n	8025f42 <HAL_TIM_Base_MspInit+0x22>
	}
	else
	{
		Error_Handler();
	}
}
 8025f38:	b005      	add	sp, #20
 8025f3a:	f85d eb04 	ldr.w	lr, [sp], #4
		Error_Handler();
 8025f3e:	f7ff ba95 	b.w	802546c <Error_Handler>
		__HAL_RCC_TIM10_CLK_ENABLE();
 8025f42:	4b24      	ldr	r3, [pc, #144]	@ (8025fd4 <HAL_TIM_Base_MspInit+0xb4>)
 8025f44:	2200      	movs	r2, #0
 8025f46:	9203      	str	r2, [sp, #12]
 8025f48:	6c59      	ldr	r1, [r3, #68]	@ 0x44
 8025f4a:	f441 3100 	orr.w	r1, r1, #131072	@ 0x20000
 8025f4e:	6459      	str	r1, [r3, #68]	@ 0x44
 8025f50:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8025f52:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8025f56:	9303      	str	r3, [sp, #12]
		HAL_NVIC_SetPriority(TIM1_UP_TIM10_IRQn, 2, 0);
 8025f58:	2102      	movs	r1, #2
 8025f5a:	2019      	movs	r0, #25
		__HAL_RCC_TIM10_CLK_ENABLE();
 8025f5c:	9b03      	ldr	r3, [sp, #12]
		HAL_NVIC_SetPriority(TIM1_UP_TIM10_IRQn, 2, 0);
 8025f5e:	f7fb fb67 	bl	8021630 <HAL_NVIC_SetPriority>
		HAL_NVIC_EnableIRQ(TIM1_UP_TIM10_IRQn);
 8025f62:	2019      	movs	r0, #25
}
 8025f64:	b005      	add	sp, #20
 8025f66:	f85d eb04 	ldr.w	lr, [sp], #4
		HAL_NVIC_EnableIRQ(TIM1_BRK_TIM9_IRQn);
 8025f6a:	f7fb bb9d 	b.w	80216a8 <HAL_NVIC_EnableIRQ>
		__HAL_RCC_TIM7_CLK_ENABLE();
 8025f6e:	4b19      	ldr	r3, [pc, #100]	@ (8025fd4 <HAL_TIM_Base_MspInit+0xb4>)
 8025f70:	2200      	movs	r2, #0
 8025f72:	9201      	str	r2, [sp, #4]
 8025f74:	6c19      	ldr	r1, [r3, #64]	@ 0x40
 8025f76:	f041 0120 	orr.w	r1, r1, #32
 8025f7a:	6419      	str	r1, [r3, #64]	@ 0x40
 8025f7c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8025f7e:	f003 0320 	and.w	r3, r3, #32
 8025f82:	9301      	str	r3, [sp, #4]
		HAL_NVIC_SetPriority(TIM7_IRQn, 1, 0);
 8025f84:	2101      	movs	r1, #1
 8025f86:	2037      	movs	r0, #55	@ 0x37
		__HAL_RCC_TIM7_CLK_ENABLE();
 8025f88:	9b01      	ldr	r3, [sp, #4]
		HAL_NVIC_SetPriority(TIM7_IRQn, 1, 0);
 8025f8a:	f7fb fb51 	bl	8021630 <HAL_NVIC_SetPriority>
		HAL_NVIC_EnableIRQ(TIM7_IRQn);
 8025f8e:	2037      	movs	r0, #55	@ 0x37
}
 8025f90:	b005      	add	sp, #20
 8025f92:	f85d eb04 	ldr.w	lr, [sp], #4
		HAL_NVIC_EnableIRQ(TIM1_BRK_TIM9_IRQn);
 8025f96:	f7fb bb87 	b.w	80216a8 <HAL_NVIC_EnableIRQ>
		__HAL_RCC_TIM9_CLK_ENABLE();
 8025f9a:	4b0e      	ldr	r3, [pc, #56]	@ (8025fd4 <HAL_TIM_Base_MspInit+0xb4>)
 8025f9c:	2200      	movs	r2, #0
 8025f9e:	9202      	str	r2, [sp, #8]
 8025fa0:	6c59      	ldr	r1, [r3, #68]	@ 0x44
 8025fa2:	f441 3180 	orr.w	r1, r1, #65536	@ 0x10000
 8025fa6:	6459      	str	r1, [r3, #68]	@ 0x44
 8025fa8:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8025faa:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 8025fae:	9302      	str	r3, [sp, #8]
		HAL_NVIC_SetPriority(TIM1_BRK_TIM9_IRQn, 4, 0);
 8025fb0:	2104      	movs	r1, #4
 8025fb2:	2018      	movs	r0, #24
		__HAL_RCC_TIM9_CLK_ENABLE();
 8025fb4:	9b02      	ldr	r3, [sp, #8]
		HAL_NVIC_SetPriority(TIM1_BRK_TIM9_IRQn, 4, 0);
 8025fb6:	f7fb fb3b 	bl	8021630 <HAL_NVIC_SetPriority>
		HAL_NVIC_EnableIRQ(TIM1_BRK_TIM9_IRQn);
 8025fba:	2018      	movs	r0, #24
}
 8025fbc:	b005      	add	sp, #20
 8025fbe:	f85d eb04 	ldr.w	lr, [sp], #4
		HAL_NVIC_EnableIRQ(TIM1_BRK_TIM9_IRQn);
 8025fc2:	f7fb bb71 	b.w	80216a8 <HAL_NVIC_EnableIRQ>
 8025fc6:	bf00      	nop
 8025fc8:	40001400 	.word	0x40001400
 8025fcc:	40014000 	.word	0x40014000
 8025fd0:	40014400 	.word	0x40014400
 8025fd4:	40023800 	.word	0x40023800

08025fd8 <TIM1_UP_TIM10_IRQHandler>:

void TIM1_UP_TIM10_IRQHandler(void)
{
 8025fd8:	b510      	push	{r4, lr}
	if (((htim10.Instance->SR & TIM_FLAG_UPDATE) == TIM_FLAG_UPDATE) != RESET)
 8025fda:	4c12      	ldr	r4, [pc, #72]	@ (8026024 <TIM1_UP_TIM10_IRQHandler+0x4c>)
 8025fdc:	f8d4 3080 	ldr.w	r3, [r4, #128]	@ 0x80
 8025fe0:	691a      	ldr	r2, [r3, #16]
 8025fe2:	07d1      	lsls	r1, r2, #31
 8025fe4:	d502      	bpl.n	8025fec <TIM1_UP_TIM10_IRQHandler+0x14>
	{
		if ((((htim10.Instance->DIER & (TIM_IT_UPDATE)) == (TIM_IT_UPDATE)) ? SET : RESET) != RESET)
 8025fe6:	68da      	ldr	r2, [r3, #12]
 8025fe8:	07d2      	lsls	r2, r2, #31
 8025fea:	d412      	bmi.n	8026012 <TIM1_UP_TIM10_IRQHandler+0x3a>
		{
			htim10.Instance->SR = ~(TIM_IT_UPDATE);
			TimerSleep_Elapsed_cb();
		}
	}
	htim10.Instance->DIER &= ~(TIM_IT_UPDATE);
 8025fec:	68da      	ldr	r2, [r3, #12]
 8025fee:	f022 0201 	bic.w	r2, r2, #1
 8025ff2:	60da      	str	r2, [r3, #12]
	__HAL_TIM_DISABLE(&htim10);
 8025ff4:	6a1a      	ldr	r2, [r3, #32]
 8025ff6:	f241 1111 	movw	r1, #4369	@ 0x1111
 8025ffa:	420a      	tst	r2, r1
 8025ffc:	d108      	bne.n	8026010 <TIM1_UP_TIM10_IRQHandler+0x38>
 8025ffe:	6a19      	ldr	r1, [r3, #32]
 8026000:	f240 4244 	movw	r2, #1092	@ 0x444
 8026004:	4211      	tst	r1, r2
 8026006:	d103      	bne.n	8026010 <TIM1_UP_TIM10_IRQHandler+0x38>
 8026008:	681a      	ldr	r2, [r3, #0]
 802600a:	f022 0201 	bic.w	r2, r2, #1
 802600e:	601a      	str	r2, [r3, #0]
}
 8026010:	bd10      	pop	{r4, pc}
			htim10.Instance->SR = ~(TIM_IT_UPDATE);
 8026012:	f06f 0201 	mvn.w	r2, #1
 8026016:	611a      	str	r2, [r3, #16]
	RS485_RX_SleepDone();
 8026018:	f7ff fb0a 	bl	8025630 <RS485_RX_SleepDone>
	htim10.Instance->DIER &= ~(TIM_IT_UPDATE);
 802601c:	f8d4 3080 	ldr.w	r3, [r4, #128]	@ 0x80
}
 8026020:	e7e4      	b.n	8025fec <TIM1_UP_TIM10_IRQHandler+0x14>
 8026022:	bf00      	nop
 8026024:	2002243c 	.word	0x2002243c

08026028 <TIM7_IRQHandler>:

void TIM7_IRQHandler(void)
{
	if (((htim7.Instance->SR & TIM_FLAG_UPDATE) == TIM_FLAG_UPDATE) != RESET)
 8026028:	4b05      	ldr	r3, [pc, #20]	@ (8026040 <TIM7_IRQHandler+0x18>)
 802602a:	681b      	ldr	r3, [r3, #0]
 802602c:	691a      	ldr	r2, [r3, #16]
 802602e:	07d1      	lsls	r1, r2, #31
 8026030:	d505      	bpl.n	802603e <TIM7_IRQHandler+0x16>
	{
		if ((((htim7.Instance->DIER & (TIM_IT_UPDATE)) == (TIM_IT_UPDATE)) ? SET : RESET) != RESET)
 8026032:	68da      	ldr	r2, [r3, #12]
 8026034:	07d2      	lsls	r2, r2, #31
		{
			htim7.Instance->SR = ~(TIM_IT_UPDATE);
 8026036:	bf44      	itt	mi
 8026038:	f06f 0201 	mvnmi.w	r2, #1
 802603c:	611a      	strmi	r2, [r3, #16]
			TimerSampling_Elapsed_cb();
		}
	}
}
 802603e:	4770      	bx	lr
 8026040:	2002243c 	.word	0x2002243c

08026044 <TIM1_BRK_TIM9_IRQHandler>:

void TIM1_BRK_TIM9_IRQHandler(void)
{
	if (((htim9.Instance->SR & TIM_FLAG_UPDATE) == TIM_FLAG_UPDATE) != RESET)
 8026044:	4b06      	ldr	r3, [pc, #24]	@ (8026060 <TIM1_BRK_TIM9_IRQHandler+0x1c>)
 8026046:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8026048:	691a      	ldr	r2, [r3, #16]
 802604a:	07d1      	lsls	r1, r2, #31
 802604c:	d502      	bpl.n	8026054 <TIM1_BRK_TIM9_IRQHandler+0x10>
	{
		if ((((htim9.Instance->DIER & (TIM_IT_UPDATE)) == (TIM_IT_UPDATE)) ? SET : RESET) != RESET)
 802604e:	68da      	ldr	r2, [r3, #12]
 8026050:	07d2      	lsls	r2, r2, #31
 8026052:	d400      	bmi.n	8026056 <TIM1_BRK_TIM9_IRQHandler+0x12>
		{
			htim9.Instance->SR = ~(TIM_IT_UPDATE);
			TimerTemperature_Elapsed_cb();
		}
	}
}
 8026054:	4770      	bx	lr
			htim9.Instance->SR = ~(TIM_IT_UPDATE);
 8026056:	f06f 0201 	mvn.w	r2, #1
 802605a:	611a      	str	r2, [r3, #16]
	Temp_SampleMake();
 802605c:	f7ff bec0 	b.w	8025de0 <Temp_SampleMake>
 8026060:	2002243c 	.word	0x2002243c

08026064 <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s>:
 *                float *VRMS
 * Return Type  : void
 */
void FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s(const float data[4000], float *PP,
                                          float *RMS, float *VRMS)
{
 8026064:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8026068:	ed2d 8b0a 	vpush	{d8-d12}
 802606c:	f5ad 4d28 	sub.w	sp, sp, #43008	@ 0xa800
 8026070:	b089      	sub	sp, #36	@ 0x24
 8026072:	460e      	mov	r6, r1
 8026074:	9002      	str	r0, [sp, #8]
    /*    x           = zeros(1,w_len_BB);            % ECoder-->Memory-->Static
     * size */
    /*    x           = data(index_from:index_till);  % ECoder-->Memory-->Static
     * size  */
    if (i + 1 == 1) {
      memcpy(&x[0], &data[0], 2048U * sizeof(float));
 8026076:	4601      	mov	r1, r0
 8026078:	f50d 5020 	add.w	r0, sp, #10240	@ 0x2800
{
 802607c:	e9cd 2304 	strd	r2, r3, [sp, #16]
      memcpy(&x[0], &data[0], 2048U * sizeof(float));
 8026080:	3020      	adds	r0, #32
 8026082:	ab0a      	add	r3, sp, #40	@ 0x28
 8026084:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
 8026088:	461c      	mov	r4, r3
 802608a:	9301      	str	r3, [sp, #4]
 802608c:	f50d 5560 	add.w	r5, sp, #14336	@ 0x3800
 8026090:	f003 fdc7 	bl	8029c22 <memcpy>
    for (k = 0; k < 1023; k++) {
      avg_end += x[k + 1];
      bsum += x[k + 1025];
    }
    avg_end += bsum;
    bsum = avg_end / 2048.0F;
 8026094:	ed9f 8a84 	vldr	s16, [pc, #528]	@ 80262a8 <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x244>
 */
__STATIC_FORCEINLINE arm_status arm_sqrt_f32(
  float32_t in,
  float32_t * pOut)
  {
    if (in >= 0.0f)
 8026098:	eddf 8a7d 	vldr	s17, [pc, #500]	@ 8026290 <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x22c>
 802609c:	9606      	str	r6, [sp, #24]
 802609e:	2300      	movs	r3, #0
 80260a0:	f10d 0b20 	add.w	fp, sp, #32
      memcpy(&x[0], &data[0], 2048U * sizeof(float));
 80260a4:	46a2      	mov	sl, r4
 80260a6:	9303      	str	r3, [sp, #12]
 80260a8:	3520      	adds	r5, #32
    avg_end = x[0];
 80260aa:	f50d 5720 	add.w	r7, sp, #10240	@ 0x2800
 80260ae:	3720      	adds	r7, #32
 80260b0:	ecf7 7a01 	vldmia	r7!, {s15}
    bsum = x[1024];
 80260b4:	ed95 7a00 	vldr	s14, [r5]
 80260b8:	f50d 5260 	add.w	r2, sp, #14336	@ 0x3800
 80260bc:	f50d 5560 	add.w	r5, sp, #14336	@ 0x3800
 80260c0:	3520      	adds	r5, #32
 80260c2:	3224      	adds	r2, #36	@ 0x24
 80260c4:	463b      	mov	r3, r7
      avg_end += x[k + 1];
 80260c6:	ecb3 6a01 	vldmia	r3!, {s12}
      bsum += x[k + 1025];
 80260ca:	ecf2 6a01 	vldmia	r2!, {s13}
    for (k = 0; k < 1023; k++) {
 80260ce:	429d      	cmp	r5, r3
      avg_end += x[k + 1];
 80260d0:	ee77 7a86 	vadd.f32	s15, s15, s12
      bsum += x[k + 1025];
 80260d4:	ee37 7a26 	vadd.f32	s14, s14, s13
    for (k = 0; k < 1023; k++) {
 80260d8:	d1f5      	bne.n	80260c6 <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x62>
    avg_end += bsum;
 80260da:	ee77 7a87 	vadd.f32	s15, s15, s14
    bsum = avg_end / 2048.0F;
 80260de:	f50d 5320 	add.w	r3, sp, #10240	@ 0x2800
 80260e2:	3320      	adds	r3, #32
 80260e4:	ee27 7a88 	vmul.f32	s14, s15, s16
    for (idx = 0; idx < 2048; idx++) {
 80260e8:	f503 5800 	add.w	r8, r3, #8192	@ 0x2000
      x[idx] -= bsum;
 80260ec:	edd3 7a00 	vldr	s15, [r3]
 80260f0:	ee77 7ac7 	vsub.f32	s15, s15, s14
 80260f4:	ece3 7a01 	vstmia	r3!, {s15}
    for (idx = 0; idx < 2048; idx++) {
 80260f8:	4598      	cmp	r8, r3
 80260fa:	d1f7      	bne.n	80260ec <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x88>
    }
    b = rtIsNaNF(x[0]);
 80260fc:	f50d 5320 	add.w	r3, sp, #10240	@ 0x2800
 8026100:	ed93 0a08 	vldr	s0, [r3, #32]
 8026104:	3320      	adds	r3, #32
 8026106:	f000 faef 	bl	80266e8 <rtIsNaNF>
    if (!b) {
 802610a:	4601      	mov	r1, r0
 802610c:	2800      	cmp	r0, #0
 802610e:	f000 8089 	beq.w	8026224 <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x1c0>
 8026112:	463c      	mov	r4, r7
      idx = 1;
    } else {
      idx = 0;
      k = 2;
 8026114:	2602      	movs	r6, #2
      exitg1 = false;
      while ((!exitg1) && (k < 2049)) {
 8026116:	f640 0901 	movw	r9, #2049	@ 0x801
 802611a:	9007      	str	r0, [sp, #28]
 802611c:	e003      	b.n	8026126 <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0xc2>
        if (!rtIsNaNF(x[k - 1])) {
          idx = k;
          exitg1 = true;
        } else {
          k++;
 802611e:	3601      	adds	r6, #1
      while ((!exitg1) && (k < 2049)) {
 8026120:	454e      	cmp	r6, r9
 8026122:	f000 825b 	beq.w	80265dc <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x578>
        if (!rtIsNaNF(x[k - 1])) {
 8026126:	ecb4 0a01 	vldmia	r4!, {s0}
 802612a:	f000 fadd 	bl	80266e8 <rtIsNaNF>
 802612e:	2800      	cmp	r0, #0
 8026130:	d1f5      	bne.n	802611e <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0xba>
      }
    }
    if (idx == 0) {
      bsum = x[0];
    } else {
      bsum = x[idx - 1];
 8026132:	f50d 5320 	add.w	r3, sp, #10240	@ 0x2800
 8026136:	3320      	adds	r3, #32
 8026138:	eb03 0286 	add.w	r2, r3, r6, lsl #2
      idx++;
      for (k = idx; k < 2049; k++) {
 802613c:	f5b6 6f00 	cmp.w	r6, #2048	@ 0x800
      bsum = x[idx - 1];
 8026140:	ed12 9a01 	vldr	s18, [r2, #-4]
 8026144:	9907      	ldr	r1, [sp, #28]
      for (k = idx; k < 2049; k++) {
 8026146:	f106 0201 	add.w	r2, r6, #1
 802614a:	d171      	bne.n	8026230 <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x1cc>
      idx++;
 802614c:	463c      	mov	r4, r7
    }
    if (!b) {
      idx = 1;
    } else {
      idx = 0;
      k = 2;
 802614e:	2602      	movs	r6, #2
      exitg1 = false;
      while ((!exitg1) && (k < 2049)) {
 8026150:	f640 0901 	movw	r9, #2049	@ 0x801
 8026154:	e003      	b.n	802615e <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0xfa>
        if (!rtIsNaNF(x[k - 1])) {
          idx = k;
          exitg1 = true;
        } else {
          k++;
 8026156:	3601      	adds	r6, #1
      while ((!exitg1) && (k < 2049)) {
 8026158:	454e      	cmp	r6, r9
 802615a:	f000 827a 	beq.w	8026652 <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x5ee>
        if (!rtIsNaNF(x[k - 1])) {
 802615e:	ecb4 0a01 	vldmia	r4!, {s0}
 8026162:	f000 fac1 	bl	80266e8 <rtIsNaNF>
 8026166:	2800      	cmp	r0, #0
 8026168:	d1f5      	bne.n	8026156 <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0xf2>
      }
    }
    if (idx == 0) {
      avg_end = x[0];
    } else {
      avg_end = x[idx - 1];
 802616a:	f50d 5320 	add.w	r3, sp, #10240	@ 0x2800
 802616e:	3320      	adds	r3, #32
 8026170:	eb03 0286 	add.w	r2, r3, r6, lsl #2
      idx++;
      for (k = idx; k < 2049; k++) {
 8026174:	f5b6 6f00 	cmp.w	r6, #2048	@ 0x800
      avg_end = x[idx - 1];
 8026178:	ed52 7a01 	vldr	s15, [r2, #-4]
      for (k = idx; k < 2049; k++) {
 802617c:	f106 0201 	add.w	r2, r6, #1
 8026180:	d172      	bne.n	8026268 <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x204>
        if (avg_end > avg_start) {
          avg_end = avg_start;
        }
      }
    }
    PP_frag[i] = bsum - avg_end;
 8026182:	ee39 9a67 	vsub.f32	s18, s18, s15
 8026186:	f50d 4290 	add.w	r2, sp, #18432	@ 0x4800
 802618a:	f50d 5320 	add.w	r3, sp, #10240	@ 0x2800
 802618e:	ed8b 9a00 	vstr	s18, [fp]
 8026192:	3220      	adds	r2, #32
 8026194:	3320      	adds	r3, #32
    for (k = 0; k < 2048; k++) {
      avg_start = x[k];
 8026196:	ecf3 7a01 	vldmia	r3!, {s15}
      y[k] = avg_start * avg_start;
 802619a:	ee67 7aa7 	vmul.f32	s15, s15, s15
    for (k = 0; k < 2048; k++) {
 802619e:	4598      	cmp	r8, r3
      y[k] = avg_start * avg_start;
 80261a0:	ece2 7a01 	vstmia	r2!, {s15}
    for (k = 0; k < 2048; k++) {
 80261a4:	d1f7      	bne.n	8026196 <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x132>
    }
    avg_end = y[0];
    bsum = y[1024];
 80261a6:	f50d 43b0 	add.w	r3, sp, #22528	@ 0x5800
 80261aa:	3320      	adds	r3, #32
 80261ac:	ed93 7a00 	vldr	s14, [r3]
    avg_end = y[0];
 80261b0:	f50d 4390 	add.w	r3, sp, #18432	@ 0x4800
 80261b4:	3320      	adds	r3, #32
 80261b6:	f50d 4190 	add.w	r1, sp, #18432	@ 0x4800
 80261ba:	f50d 42b0 	add.w	r2, sp, #22528	@ 0x5800
 80261be:	3120      	adds	r1, #32
 80261c0:	ecf3 7a01 	vldmia	r3!, {s15}
    for (k = 0; k < 1023; k++) {
 80261c4:	3224      	adds	r2, #36	@ 0x24
 80261c6:	f501 5180 	add.w	r1, r1, #4096	@ 0x1000
      avg_end += y[k + 1];
 80261ca:	ecb3 6a01 	vldmia	r3!, {s12}
      bsum += y[k + 1025];
 80261ce:	ecf2 6a01 	vldmia	r2!, {s13}
    for (k = 0; k < 1023; k++) {
 80261d2:	4299      	cmp	r1, r3
      avg_end += y[k + 1];
 80261d4:	ee77 7a86 	vadd.f32	s15, s15, s12
      bsum += y[k + 1025];
 80261d8:	ee37 7a26 	vadd.f32	s14, s14, s13
    for (k = 0; k < 1023; k++) {
 80261dc:	d1f5      	bne.n	80261ca <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x166>
    }
    avg_end += bsum;
 80261de:	ee77 7a87 	vadd.f32	s15, s15, s14
    mw_arm_sqrt_f32(0.00048828125F * avg_end, &RMS_frag[i]);
 80261e2:	ee67 7a88 	vmul.f32	s15, s15, s16
 80261e6:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 80261ea:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80261ee:	db5d      	blt.n	80262ac <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x248>
  #else
      *pOut = sqrtf(in);
  #endif

#else
      *pOut = sqrtf(in);
 80261f0:	eeb1 7ae7 	vsqrt.f32	s14, s15
#endif

      return (ARM_MATH_SUCCESS);
 80261f4:	ed8a 7a00 	vstr	s14, [sl]
    modbusRTU_loop();
 80261f8:	f000 ffee 	bl	80271d8 <modbusRTU_loop>
  for (i = 0; i < 2; i++) {
 80261fc:	9b03      	ldr	r3, [sp, #12]
 80261fe:	2b00      	cmp	r3, #0
 8026200:	d15b      	bne.n	80262ba <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x256>
      memcpy(&x[0], &data[1952], 2048U * sizeof(float));
 8026202:	9b02      	ldr	r3, [sp, #8]
 8026204:	f50d 5020 	add.w	r0, sp, #10240	@ 0x2800
 8026208:	f503 51f4 	add.w	r1, r3, #7808	@ 0x1e80
 802620c:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
 8026210:	3020      	adds	r0, #32
 8026212:	f003 fd06 	bl	8029c22 <memcpy>
 8026216:	2301      	movs	r3, #1
 8026218:	f10a 0a04 	add.w	sl, sl, #4
 802621c:	f10b 0b04 	add.w	fp, fp, #4
 8026220:	9303      	str	r3, [sp, #12]
 8026222:	e742      	b.n	80260aa <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x46>
      bsum = x[idx - 1];
 8026224:	f50d 5320 	add.w	r3, sp, #10240	@ 0x2800
 8026228:	ed93 9a08 	vldr	s18, [r3, #32]
 802622c:	3320      	adds	r3, #32
      idx++;
 802622e:	2202      	movs	r2, #2
 8026230:	f102 4380 	add.w	r3, r2, #1073741824	@ 0x40000000
 8026234:	f50d 5220 	add.w	r2, sp, #10240	@ 0x2800
 8026238:	3b01      	subs	r3, #1
 802623a:	3220      	adds	r2, #32
 802623c:	eb02 0383 	add.w	r3, r2, r3, lsl #2
        avg_start = x[k - 1];
 8026240:	ecf3 7a01 	vldmia	r3!, {s15}
        if (bsum < avg_start) {
 8026244:	eeb4 9ae7 	vcmpe.f32	s18, s15
 8026248:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802624c:	bfb8      	it	lt
 802624e:	eeb0 9a67 	vmovlt.f32	s18, s15
      for (k = idx; k < 2049; k++) {
 8026252:	4598      	cmp	r8, r3
 8026254:	d1f4      	bne.n	8026240 <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x1dc>
    if (!b) {
 8026256:	2900      	cmp	r1, #0
 8026258:	f47f af78 	bne.w	802614c <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0xe8>
      avg_end = x[idx - 1];
 802625c:	f50d 5320 	add.w	r3, sp, #10240	@ 0x2800
 8026260:	edd3 7a08 	vldr	s15, [r3, #32]
 8026264:	3320      	adds	r3, #32
      idx++;
 8026266:	2202      	movs	r2, #2
 8026268:	f102 4380 	add.w	r3, r2, #1073741824	@ 0x40000000
 802626c:	f50d 5220 	add.w	r2, sp, #10240	@ 0x2800
 8026270:	3b01      	subs	r3, #1
 8026272:	3220      	adds	r2, #32
 8026274:	eb02 0383 	add.w	r3, r2, r3, lsl #2
        avg_start = x[k - 1];
 8026278:	ecb3 7a01 	vldmia	r3!, {s14}
        if (avg_end > avg_start) {
 802627c:	eef4 7ac7 	vcmpe.f32	s15, s14
 8026280:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8026284:	bf88      	it	hi
 8026286:	eef0 7a47 	vmovhi.f32	s15, s14
      for (k = idx; k < 2049; k++) {
 802628a:	4598      	cmp	r8, r3
 802628c:	d1f4      	bne.n	8026278 <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x214>
 802628e:	e778      	b.n	8026182 <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x11e>
 8026290:	00000000 	.word	0x00000000
 8026294:	3c23d70a 	.word	0x3c23d70a
 8026298:	3dcccccd 	.word	0x3dcccccd
 802629c:	3fb504f3 	.word	0x3fb504f3
 80262a0:	42480000 	.word	0x42480000
 80262a4:	3a069223 	.word	0x3a069223
 80262a8:	3a000000 	.word	0x3a000000
 80262ac:	edca 8a00 	vstr	s17, [sl]
    modbusRTU_loop();
 80262b0:	f000 ff92 	bl	80271d8 <modbusRTU_loop>
  for (i = 0; i < 2; i++) {
 80262b4:	9b03      	ldr	r3, [sp, #12]
 80262b6:	2b00      	cmp	r3, #0
 80262b8:	d0a3      	beq.n	8026202 <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x19e>
  }
  if ((PP_frag[0] > PP_frag[1]) ||
 80262ba:	eddd 8a08 	vldr	s17, [sp, #32]
 80262be:	ed9d 8a09 	vldr	s16, [sp, #36]	@ 0x24
 80262c2:	9e06      	ldr	r6, [sp, #24]
 80262c4:	eef4 8ac8 	vcmpe.f32	s17, s16
 80262c8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80262cc:	4644      	mov	r4, r8
 80262ce:	f340 81b1 	ble.w	8026634 <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x5d0>
      (rtIsNaNF(PP_frag[0]) && (!rtIsNaNF(PP_frag[1])))) {
    *PP = PP_frag[1];
  } else {
    *PP = PP_frag[0];
  }
  *RMS = (RMS_frag[0] + RMS_frag[1]) / 2.0F;
 80262d2:	eddd 7a0a 	vldr	s15, [sp, #40]	@ 0x28
 80262d6:	eddd 6a0b 	vldr	s13, [sp, #44]	@ 0x2c
 80262da:	ed86 8a00 	vstr	s16, [r6]
 80262de:	ee77 7aa6 	vadd.f32	s15, s15, s13
 80262e2:	eeb6 7a00 	vmov.f32	s14, #96	@ 0x3f000000  0.5
 80262e6:	ab0a      	add	r3, sp, #40	@ 0x28
 80262e8:	ee67 7a87 	vmul.f32	s15, s15, s14
 80262ec:	9b04      	ldr	r3, [sp, #16]
  /*       % nowa sampling frequency:            1.953125 Hz */
  /*  wektor skalujacy A-->V:             <2048 x 1> */
  for (i = 0; i < 2; i++) {
    float b_y[508];
    if (i + 1 == 1) {
      memcpy(&x[0], &data[0], 2048U * sizeof(float));
 80262ee:	9902      	ldr	r1, [sp, #8]
  *RMS = (RMS_frag[0] + RMS_frag[1]) / 2.0F;
 80262f0:	edc3 7a00 	vstr	s15, [r3]
      memcpy(&x[0], &data[0], 2048U * sizeof(float));
 80262f4:	f50d 5020 	add.w	r0, sp, #10240	@ 0x2800
 80262f8:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
 80262fc:	3020      	adds	r0, #32
 80262fe:	f003 fc90 	bl	8029c22 <memcpy>
 8026302:	2300      	movs	r3, #0
 8026304:	9303      	str	r3, [sp, #12]
 8026306:	f50d 5320 	add.w	r3, sp, #10240	@ 0x2800
 802630a:	3320      	adds	r3, #32
    avg_end = x[1948];
    for (k = 0; k < 99; k++) {
      bsum += x[k + 1];
      avg_end += x[k + 1949];
    }
    avg_start = bsum / 100.0F;
 802630c:	ed5f 9a1f 	vldr	s19, [pc, #-124]	@ 8026294 <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x230>
    avg_end /= 100.0F;
    /*  end of signal */
    bsum = 0.1F * avg_start;
    PP_frag[0] = avg_start - bsum;
 8026310:	ed1f 9a1f 	vldr	s18, [pc, #-124]	@ 8026298 <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x234>
      for (idx = 0; idx < 2048; idx++) {
        x[idx] -= bsum;
      }
    } else {
      /*  linear detrend */
      PP_frag[1] = (avg_end - avg_start) / 1948.0F;
 8026314:	ed5f aa1d 	vldr	s21, [pc, #-116]	@ 80262a4 <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x240>
      PP_frag[0] = avg_start - PP_frag[1] * 50.0F;
 8026318:	ed1f aa1f 	vldr	s20, [pc, #-124]	@ 80262a0 <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x23c>
    y = a * 1.41421354F;
 802631c:	ed5f 8a21 	vldr	s17, [pc, #-132]	@ 802629c <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x238>
 8026320:	f503 7ac8 	add.w	sl, r3, #400	@ 0x190
 8026324:	f603 0604 	addw	r6, r3, #2052	@ 0x804
 8026328:	46b9      	mov	r9, r7
    bsum = x[0];
 802632a:	f50d 5320 	add.w	r3, sp, #10240	@ 0x2800
 802632e:	3320      	adds	r3, #32
 8026330:	f50d 428d 	add.w	r2, sp, #18048	@ 0x4680
 8026334:	edd3 7a00 	vldr	s15, [r3]
    avg_end = x[1948];
 8026338:	f505 6367 	add.w	r3, r5, #3696	@ 0xe70
 802633c:	ed93 7a00 	vldr	s14, [r3]
    for (k = 0; k < 99; k++) {
 8026340:	3214      	adds	r2, #20
    avg_end = x[1948];
 8026342:	464b      	mov	r3, r9
      bsum += x[k + 1];
 8026344:	ecb3 6a01 	vldmia	r3!, {s12}
      avg_end += x[k + 1949];
 8026348:	ecf2 6a01 	vldmia	r2!, {s13}
    for (k = 0; k < 99; k++) {
 802634c:	459a      	cmp	sl, r3
      bsum += x[k + 1];
 802634e:	ee77 7a86 	vadd.f32	s15, s15, s12
      avg_end += x[k + 1949];
 8026352:	ee37 7a26 	vadd.f32	s14, s14, s13
    for (k = 0; k < 99; k++) {
 8026356:	d1f5      	bne.n	8026344 <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x2e0>
    avg_start = bsum / 100.0F;
 8026358:	ee27 8aa9 	vmul.f32	s16, s15, s19
    avg_end /= 100.0F;
 802635c:	ee27 ba29 	vmul.f32	s22, s14, s19
    PP_frag[0] = avg_start - bsum;
 8026360:	eef0 ba48 	vmov.f32	s23, s16
    PP_frag[1] = avg_start + bsum;
 8026364:	eeb0 ca48 	vmov.f32	s24, s16
    PP_frag[0] = avg_start - bsum;
 8026368:	eee8 ba49 	vfms.f32	s23, s16, s18
    PP_frag[1] = avg_start + bsum;
 802636c:	eea8 ca09 	vfma.f32	s24, s16, s18
    if ((PP_frag[0] < PP_frag[1]) ||
 8026370:	eef4 bacc 	vcmpe.f32	s23, s24
 8026374:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8026378:	f140 8136 	bpl.w	80265e8 <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x584>
    if (avg_end > bsum) {
 802637c:	eeb4 cacb 	vcmpe.f32	s24, s22
 8026380:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8026384:	f100 80dd 	bmi.w	8026542 <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x4de>
          (rtIsNaNF(PP_frag[0]) && (!rtIsNaNF(PP_frag[1])))) {
 8026388:	eeb0 0a6b 	vmov.f32	s0, s23
 802638c:	f000 f9ac 	bl	80266e8 <rtIsNaNF>
      if ((PP_frag[0] > PP_frag[1]) ||
 8026390:	2800      	cmp	r0, #0
 8026392:	f040 8157 	bne.w	8026644 <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x5e0>
      if (avg_end < bsum) {
 8026396:	eef4 bacb 	vcmpe.f32	s23, s22
 802639a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802639e:	f300 80d0 	bgt.w	8026542 <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x4de>
      avg_end = x[0];
 80263a2:	f50d 5320 	add.w	r3, sp, #10240	@ 0x2800
      bsum = x[1024];
 80263a6:	f50d 5260 	add.w	r2, sp, #14336	@ 0x3800
 80263aa:	ed95 7a00 	vldr	s14, [r5]
      avg_end = x[0];
 80263ae:	edd3 7a08 	vldr	s15, [r3, #32]
 80263b2:	3320      	adds	r3, #32
      bsum = x[1024];
 80263b4:	3224      	adds	r2, #36	@ 0x24
 80263b6:	464b      	mov	r3, r9
        avg_end += x[k + 1];
 80263b8:	ecb3 6a01 	vldmia	r3!, {s12}
        bsum += x[k + 1025];
 80263bc:	ecf2 6a01 	vldmia	r2!, {s13}
      for (k = 0; k < 1023; k++) {
 80263c0:	429d      	cmp	r5, r3
        avg_end += x[k + 1];
 80263c2:	ee77 7a86 	vadd.f32	s15, s15, s12
        bsum += x[k + 1025];
 80263c6:	ee37 7a26 	vadd.f32	s14, s14, s13
      for (k = 0; k < 1023; k++) {
 80263ca:	d1f5      	bne.n	80263b8 <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x354>
      avg_end += bsum;
 80263cc:	ee77 7a87 	vadd.f32	s15, s15, s14
      bsum = avg_end / 2048.0F;
 80263d0:	ed1f 7a4b 	vldr	s14, [pc, #-300]	@ 80262a8 <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x244>
 80263d4:	f50d 5320 	add.w	r3, sp, #10240	@ 0x2800
 80263d8:	ee27 7a87 	vmul.f32	s14, s15, s14
 80263dc:	3320      	adds	r3, #32
        x[idx] -= bsum;
 80263de:	edd3 7a00 	vldr	s15, [r3]
 80263e2:	ee77 7ac7 	vsub.f32	s15, s15, s14
 80263e6:	ece3 7a01 	vstmia	r3!, {s15}
      for (idx = 0; idx < 2048; idx++) {
 80263ea:	429c      	cmp	r4, r3
 80263ec:	d1f7      	bne.n	80263de <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x37a>
      memcpy(&x[0], &fv[0], 2048U * sizeof(float));
    }
    /*  --------------------------------------------------------------------- */
    /*  Detrend STOP */
    /*  --------------------------------------------------------------------- */
    mw_arm_mult_f32(&x[0], &fv1[0], &y[0], 2048U);
 80263ee:	f50d 4290 	add.w	r2, sp, #18432	@ 0x4800
 80263f2:	f50d 5020 	add.w	r0, sp, #10240	@ 0x2800
 80263f6:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 80263fa:	49a0      	ldr	r1, [pc, #640]	@ (802667c <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x618>)
 80263fc:	3220      	adds	r2, #32
 80263fe:	3020      	adds	r0, #32
 8026400:	f002 fe96 	bl	8029130 <arm_mult_f32>
    memcpy(&x[0], &y[0], 2048U * sizeof(float));
 8026404:	f50d 4190 	add.w	r1, sp, #18432	@ 0x4800
 8026408:	f50d 5020 	add.w	r0, sp, #10240	@ 0x2800
 802640c:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
 8026410:	3120      	adds	r1, #32
 8026412:	3020      	adds	r0, #32
 8026414:	f003 fc05 	bl	8029c22 <memcpy>
    mw_cmsis_fft_do_real(&x[0], &fcnOutput[0], 2048U, 0U);
 8026418:	f50d 41d0 	add.w	r1, sp, #26624	@ 0x6800
 802641c:	f50d 5020 	add.w	r0, sp, #10240	@ 0x2800
 8026420:	2300      	movs	r3, #0
 8026422:	f44f 6200 	mov.w	r2, #2048	@ 0x800
 8026426:	3120      	adds	r1, #32
 8026428:	3020      	adds	r0, #32
 802642a:	f50d 48d0 	add.w	r8, sp, #26624	@ 0x6800
 802642e:	f50d 4728 	add.w	r7, sp, #43008	@ 0xa800
 8026432:	f50d 5b20 	add.w	fp, sp, #10240	@ 0x2800
 8026436:	f000 f927 	bl	8026688 <mw_cmsis_fft_do_real>
    mw_arm_sqrt_f32(y * y + 1.0F, &f);
 802643a:	eef7 ba00 	vmov.f32	s23, #112	@ 0x3f800000  1.0
 802643e:	f108 0820 	add.w	r8, r8, #32
 8026442:	3720      	adds	r7, #32
    mw_cmsis_fft_do_real(&x[0], &fcnOutput[0], 2048U, 0U);
 8026444:	f10b 0b20 	add.w	fp, fp, #32
 8026448:	e00f      	b.n	802646a <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x406>
    a /= y;
 802644a:	eec7 6a87 	vdiv.f32	s13, s15, s14
    mw_arm_sqrt_f32(a * a + 1.0F, &f);
 802644e:	eeb0 7a6b 	vmov.f32	s14, s23
 8026452:	eea6 7aa6 	vfma.f32	s14, s13, s13
      *pOut = sqrtf(in);
 8026456:	eef1 7ac7 	vsqrt.f32	s15, s14
    y *= f;
 802645a:	ee28 8a27 	vmul.f32	s16, s16, s15
    for (k = 0; k < 2048; k++) {
 802645e:	f108 0808 	add.w	r8, r8, #8
 8026462:	4547      	cmp	r7, r8
      x[k] = rt_hypotf_snf(fcnOutput[k].re, fcnOutput[k].im);
 8026464:	ecab 8a01 	vstmia	fp!, {s16}
    for (k = 0; k < 2048; k++) {
 8026468:	d01d      	beq.n	80264a6 <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x442>
      x[k] = rt_hypotf_snf(fcnOutput[k].re, fcnOutput[k].im);
 802646a:	edd8 7a00 	vldr	s15, [r8]
 802646e:	ed98 7a01 	vldr	s14, [r8, #4]
  a = fabsf(u0);
 8026472:	eeb0 bae7 	vabs.f32	s22, s15
  y = fabsf(u1);
 8026476:	eeb0 8ac7 	vabs.f32	s16, s14
  if (a < y) {
 802647a:	eeb4 bac8 	vcmpe.f32	s22, s16
 802647e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8026482:	d4e2      	bmi.n	802644a <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x3e6>
  } else if (a > y) {
 8026484:	dd54      	ble.n	8026530 <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x4cc>
    y /= a;
 8026486:	eec7 6a27 	vdiv.f32	s13, s14, s15
    for (k = 0; k < 2048; k++) {
 802648a:	f108 0808 	add.w	r8, r8, #8
 802648e:	4547      	cmp	r7, r8
    mw_arm_sqrt_f32(y * y + 1.0F, &f);
 8026490:	eef0 7a6b 	vmov.f32	s15, s23
 8026494:	eee6 7aa6 	vfma.f32	s15, s13, s13
 8026498:	eeb1 8ae7 	vsqrt.f32	s16, s15
    y = a * f;
 802649c:	ee2b 8a08 	vmul.f32	s16, s22, s16
      x[k] = rt_hypotf_snf(fcnOutput[k].re, fcnOutput[k].im);
 80264a0:	ecab 8a01 	vstmia	fp!, {s16}
    for (k = 0; k < 2048; k++) {
 80264a4:	d1e1      	bne.n	802646a <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x406>
 80264a6:	f50d 5320 	add.w	r3, sp, #10240	@ 0x2800
 80264aa:	3320      	adds	r3, #32
    /*  spectral Acceleration amplitudes */
    /*  spectral Velocity amplitudes  */
    /*  5 */
    /*  512 */
    for (k = 0; k < 508; k++) {
      avg_start = 9810.0F * (x[k + 5] / 1024.0F) / c_y[k + 4];
 80264ac:	ed9f 6a74 	vldr	s12, [pc, #464]	@ 8026680 <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x61c>
 80264b0:	4974      	ldr	r1, [pc, #464]	@ (8026684 <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x620>)
 80264b2:	3314      	adds	r3, #20
    for (k = 0; k < 2048; k++) {
 80264b4:	aa0c      	add	r2, sp, #48	@ 0x30
      avg_start = 9810.0F * (x[k + 5] / 1024.0F) / c_y[k + 4];
 80264b6:	ecb3 7a01 	vldmia	r3!, {s14}
 80264ba:	ecf1 6a01 	vldmia	r1!, {s13}
 80264be:	ee27 7a06 	vmul.f32	s14, s14, s12
    for (k = 0; k < 508; k++) {
 80264c2:	429e      	cmp	r6, r3
      avg_start = 9810.0F * (x[k + 5] / 1024.0F) / c_y[k + 4];
 80264c4:	eec7 7a26 	vdiv.f32	s15, s14, s13
      b_y[k] = avg_start * avg_start;
 80264c8:	ee67 7aa7 	vmul.f32	s15, s15, s15
 80264cc:	ece2 7a01 	vstmia	r2!, {s15}
    for (k = 0; k < 508; k++) {
 80264d0:	d1f1      	bne.n	80264b6 <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x452>
    }
    bsum = b_y[0];
 80264d2:	ab0c      	add	r3, sp, #48	@ 0x30
 80264d4:	edd3 7a00 	vldr	s15, [r3]
    for (k = 0; k < 507; k++) {
 80264d8:	f50d 6202 	add.w	r2, sp, #2080	@ 0x820
 80264dc:	ab0d      	add	r3, sp, #52	@ 0x34
      bsum += b_y[k + 1];
 80264de:	ecb3 7a01 	vldmia	r3!, {s14}
    for (k = 0; k < 507; k++) {
 80264e2:	429a      	cmp	r2, r3
      bsum += b_y[k + 1];
 80264e4:	ee77 7a87 	vadd.f32	s15, s15, s14
    for (k = 0; k < 507; k++) {
 80264e8:	d1f9      	bne.n	80264de <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x47a>
    }
    mw_arm_sqrt_f32(0.5F * bsum, &RMS_frag[i]);
 80264ea:	eeb6 7a00 	vmov.f32	s14, #96	@ 0x3f000000  0.5
 80264ee:	ee67 7a87 	vmul.f32	s15, s15, s14
    if (in >= 0.0f)
 80264f2:	2300      	movs	r3, #0
 80264f4:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 80264f8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80264fc:	db53      	blt.n	80265a6 <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x542>
      *pOut = sqrtf(in);
 80264fe:	eeb1 7ae7 	vsqrt.f32	s14, s15
      return (ARM_MATH_SUCCESS);
 8026502:	9f01      	ldr	r7, [sp, #4]
 8026504:	ed87 7a00 	vstr	s14, [r7]
    modbusRTU_loop();
 8026508:	f000 fe66 	bl	80271d8 <modbusRTU_loop>
  for (i = 0; i < 2; i++) {
 802650c:	9b03      	ldr	r3, [sp, #12]
 802650e:	2b00      	cmp	r3, #0
 8026510:	d150      	bne.n	80265b4 <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x550>
      memcpy(&x[0], &data[1952], 2048U * sizeof(float));
 8026512:	9b02      	ldr	r3, [sp, #8]
 8026514:	f50d 5020 	add.w	r0, sp, #10240	@ 0x2800
 8026518:	f503 51f4 	add.w	r1, r3, #7808	@ 0x1e80
 802651c:	3704      	adds	r7, #4
 802651e:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
 8026522:	3020      	adds	r0, #32
 8026524:	9701      	str	r7, [sp, #4]
 8026526:	f003 fb7c 	bl	8029c22 <memcpy>
 802652a:	2301      	movs	r3, #1
 802652c:	9303      	str	r3, [sp, #12]
 802652e:	e6fc      	b.n	802632a <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x2c6>
  } else if (!rtIsNaNF(y)) {
 8026530:	eeb0 0a48 	vmov.f32	s0, s16
 8026534:	f000 f8d8 	bl	80266e8 <rtIsNaNF>
 8026538:	2800      	cmp	r0, #0
 802653a:	d190      	bne.n	802645e <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x3fa>
    y = a * 1.41421354F;
 802653c:	ee2b 8a28 	vmul.f32	s16, s22, s17
 8026540:	e78d      	b.n	802645e <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x3fa>
      PP_frag[1] = (avg_end - avg_start) / 1948.0F;
 8026542:	ee3b 7a48 	vsub.f32	s14, s22, s16
      PP_frag[0] = avg_start - PP_frag[1] * 50.0F;
 8026546:	eef0 7a48 	vmov.f32	s15, s16
      PP_frag[1] = (avg_end - avg_start) / 1948.0F;
 802654a:	ee27 7a2a 	vmul.f32	s14, s14, s21
      PP_frag[0] = avg_start - PP_frag[1] * 50.0F;
 802654e:	f50d 4290 	add.w	r2, sp, #18432	@ 0x4800
 8026552:	eee7 7a4a 	vfms.f32	s15, s14, s20
 8026556:	3220      	adds	r2, #32
      for (idx = 0; idx < 2048; idx++) {
 8026558:	2300      	movs	r3, #0
        y[idx] = avg_start * ((float)idx + 1.0F) + bsum;
 802655a:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 802655e:	ee06 3a90 	vmov	s13, r3
 8026562:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 8026566:	eeb0 6a67 	vmov.f32	s12, s15
 802656a:	ee76 6aa5 	vadd.f32	s13, s13, s11
      for (idx = 0; idx < 2048; idx++) {
 802656e:	3301      	adds	r3, #1
        y[idx] = avg_start * ((float)idx + 1.0F) + bsum;
 8026570:	eea7 6a26 	vfma.f32	s12, s14, s13
      for (idx = 0; idx < 2048; idx++) {
 8026574:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
        y[idx] = avg_start * ((float)idx + 1.0F) + bsum;
 8026578:	eca2 6a01 	vstmia	r2!, {s12}
      for (idx = 0; idx < 2048; idx++) {
 802657c:	d1ef      	bne.n	802655e <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x4fa>
      mw_arm_sub_f32(&x[0], &y[0], &fv[0], 2048U);
 802657e:	f50d 4190 	add.w	r1, sp, #18432	@ 0x4800
 8026582:	f50d 5020 	add.w	r0, sp, #10240	@ 0x2800
 8026586:	f50d 6202 	add.w	r2, sp, #2080	@ 0x820
 802658a:	3120      	adds	r1, #32
 802658c:	3020      	adds	r0, #32
 802658e:	f002 fd89 	bl	80290a4 <arm_sub_f32>
      memcpy(&x[0], &fv[0], 2048U * sizeof(float));
 8026592:	f50d 5020 	add.w	r0, sp, #10240	@ 0x2800
 8026596:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
 802659a:	f50d 6102 	add.w	r1, sp, #2080	@ 0x820
 802659e:	3020      	adds	r0, #32
 80265a0:	f003 fb3f 	bl	8029c22 <memcpy>
 80265a4:	e723      	b.n	80263ee <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x38a>
 80265a6:	9f01      	ldr	r7, [sp, #4]
 80265a8:	603b      	str	r3, [r7, #0]
    modbusRTU_loop();
 80265aa:	f000 fe15 	bl	80271d8 <modbusRTU_loop>
  for (i = 0; i < 2; i++) {
 80265ae:	9b03      	ldr	r3, [sp, #12]
 80265b0:	2b00      	cmp	r3, #0
 80265b2:	d0ae      	beq.n	8026512 <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x4ae>
  }
  /*  clear data_down win Acc Vel x_det x_det_win Y scaling_int */
  if ((RMS_frag[0] > RMS_frag[1]) ||
 80265b4:	eddd 8a0a 	vldr	s17, [sp, #40]	@ 0x28
 80265b8:	ed9d 8a0b 	vldr	s16, [sp, #44]	@ 0x2c
 80265bc:	eef4 8ac8 	vcmpe.f32	s17, s16
 80265c0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80265c4:	ab0a      	add	r3, sp, #40	@ 0x28
 80265c6:	dd2d      	ble.n	8026624 <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x5c0>
 80265c8:	9b05      	ldr	r3, [sp, #20]
 80265ca:	ed83 8a00 	vstr	s16, [r3]
      (rtIsNaNF(RMS_frag[0]) && (!rtIsNaNF(RMS_frag[1])))) {
    *VRMS = RMS_frag[1];
  } else {
    *VRMS = RMS_frag[0];
  }
}
 80265ce:	f50d 4d28 	add.w	sp, sp, #43008	@ 0xa800
 80265d2:	b009      	add	sp, #36	@ 0x24
 80265d4:	ecbd 8b0a 	vpop	{d8-d12}
 80265d8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      bsum = x[0];
 80265dc:	f50d 5320 	add.w	r3, sp, #10240	@ 0x2800
 80265e0:	3320      	adds	r3, #32
 80265e2:	ed93 9a00 	vldr	s18, [r3]
    if (!b) {
 80265e6:	e5b1      	b.n	802614c <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0xe8>
        (rtIsNaNF(PP_frag[0]) && (!rtIsNaNF(PP_frag[1])))) {
 80265e8:	eeb0 0a6b 	vmov.f32	s0, s23
 80265ec:	f000 f87c 	bl	80266e8 <rtIsNaNF>
    if ((PP_frag[0] < PP_frag[1]) ||
 80265f0:	b978      	cbnz	r0, 8026612 <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x5ae>
      bsum = PP_frag[0];
 80265f2:	eef0 7a6b 	vmov.f32	s15, s23
    if (avg_end > bsum) {
 80265f6:	eef4 7acb 	vcmpe.f32	s15, s22
 80265fa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80265fe:	d4a0      	bmi.n	8026542 <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x4de>
      if ((PP_frag[0] > PP_frag[1]) ||
 8026600:	eef4 bacc 	vcmpe.f32	s23, s24
 8026604:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8026608:	f77f aebe 	ble.w	8026388 <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x324>
        bsum = PP_frag[1];
 802660c:	eef0 ba4c 	vmov.f32	s23, s24
 8026610:	e6c1      	b.n	8026396 <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x332>
        (rtIsNaNF(PP_frag[0]) && (!rtIsNaNF(PP_frag[1])))) {
 8026612:	eeb0 0a4c 	vmov.f32	s0, s24
 8026616:	f000 f867 	bl	80266e8 <rtIsNaNF>
 802661a:	2800      	cmp	r0, #0
 802661c:	d1e9      	bne.n	80265f2 <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x58e>
      bsum = PP_frag[1];
 802661e:	eef0 7a4c 	vmov.f32	s15, s24
 8026622:	e7e8      	b.n	80265f6 <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x592>
      (rtIsNaNF(RMS_frag[0]) && (!rtIsNaNF(RMS_frag[1])))) {
 8026624:	eeb0 0a68 	vmov.f32	s0, s17
 8026628:	f000 f85e 	bl	80266e8 <rtIsNaNF>
  if ((RMS_frag[0] > RMS_frag[1]) ||
 802662c:	b9f8      	cbnz	r0, 802666e <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x60a>
    *VRMS = RMS_frag[0];
 802662e:	eeb0 8a68 	vmov.f32	s16, s17
 8026632:	e7c9      	b.n	80265c8 <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x564>
      (rtIsNaNF(PP_frag[0]) && (!rtIsNaNF(PP_frag[1])))) {
 8026634:	eeb0 0a68 	vmov.f32	s0, s17
 8026638:	f000 f856 	bl	80266e8 <rtIsNaNF>
  if ((PP_frag[0] > PP_frag[1]) ||
 802663c:	b978      	cbnz	r0, 802665e <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x5fa>
    *PP = PP_frag[0];
 802663e:	eeb0 8a68 	vmov.f32	s16, s17
 8026642:	e646      	b.n	80262d2 <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x26e>
          (rtIsNaNF(PP_frag[0]) && (!rtIsNaNF(PP_frag[1])))) {
 8026644:	eeb0 0a4c 	vmov.f32	s0, s24
 8026648:	f000 f84e 	bl	80266e8 <rtIsNaNF>
 802664c:	2800      	cmp	r0, #0
 802664e:	d0dd      	beq.n	802660c <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x5a8>
 8026650:	e6a1      	b.n	8026396 <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x332>
      avg_end = x[0];
 8026652:	f50d 5320 	add.w	r3, sp, #10240	@ 0x2800
 8026656:	3320      	adds	r3, #32
 8026658:	edd3 7a00 	vldr	s15, [r3]
 802665c:	e591      	b.n	8026182 <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x11e>
      (rtIsNaNF(PP_frag[0]) && (!rtIsNaNF(PP_frag[1])))) {
 802665e:	eeb0 0a48 	vmov.f32	s0, s16
 8026662:	f000 f841 	bl	80266e8 <rtIsNaNF>
 8026666:	2800      	cmp	r0, #0
 8026668:	f43f ae33 	beq.w	80262d2 <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x26e>
 802666c:	e7e7      	b.n	802663e <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x5da>
      (rtIsNaNF(RMS_frag[0]) && (!rtIsNaNF(RMS_frag[1])))) {
 802666e:	eeb0 0a48 	vmov.f32	s0, s16
 8026672:	f000 f839 	bl	80266e8 <rtIsNaNF>
 8026676:	2800      	cmp	r0, #0
 8026678:	d0a6      	beq.n	80265c8 <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x564>
 802667a:	e7d8      	b.n	802662e <FD_PP_RMS_VRMS10_fs4000_nFFF4096_T1s+0x5ca>
 802667c:	0802bfa4 	.word	0x0802bfa4
 8026680:	41194800 	.word	0x41194800
 8026684:	0802afb4 	.word	0x0802afb4

08026688 <mw_cmsis_fft_do_real>:
}
/*
 * CMSIS FFT/IFFT : Real to complex.
 */

void mw_cmsis_fft_do_real(const real32_T* x, creal32_T* y, uint16_T fftLen, uint8_T ifftFlag) {
 8026688:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802668a:	460c      	mov	r4, r1
 802668c:	4606      	mov	r6, r0
    static arm_rfft_fast_instance_f32 S;
    // The parameter fftLen specifies the length of RFFT process.
    // Supported FFT Lengths are 32, 64, 128, 256, 512, 1024, 2048, 4096.
    arm_rfft_fast_init_f32(&S, fftLen);
 802668e:	4611      	mov	r1, r2
void mw_cmsis_fft_do_real(const real32_T* x, creal32_T* y, uint16_T fftLen, uint8_T ifftFlag) {
 8026690:	461f      	mov	r7, r3
    arm_rfft_fast_init_f32(&S, fftLen);
 8026692:	4814      	ldr	r0, [pc, #80]	@ (80266e4 <mw_cmsis_fft_do_real+0x5c>)
void mw_cmsis_fft_do_real(const real32_T* x, creal32_T* y, uint16_T fftLen, uint8_T ifftFlag) {
 8026694:	4615      	mov	r5, r2
    arm_rfft_fast_init_f32(&S, fftLen);
 8026696:	f002 f817 	bl	80286c8 <arm_rfft_fast_init_f32>
    
    arm_rfft_fast_f32(&S, (float*)&x[0], (float*)&y[0], ifftFlag);
 802669a:	4812      	ldr	r0, [pc, #72]	@ (80266e4 <mw_cmsis_fft_do_real+0x5c>)
 802669c:	463b      	mov	r3, r7
 802669e:	4622      	mov	r2, r4
 80266a0:	4631      	mov	r1, r6
 80266a2:	f002 f893 	bl	80287cc <arm_rfft_fast_f32>
    // Post processing for the Real FFT
    int k, q, halfLen;
    halfLen = fftLen / 2;
 80266a6:	086b      	lsrs	r3, r5, #1
    y[halfLen].re = ((float)y[0].im);
 80266a8:	eb04 00c3 	add.w	r0, r4, r3, lsl #3
    y[halfLen].im = (float)0;
    y[0].im = (float)0;
    
    q = halfLen - 1;
    
    for (k = halfLen + 1; k < fftLen; ++k) {
 80266ac:	3301      	adds	r3, #1
    y[halfLen].re = ((float)y[0].im);
 80266ae:	6861      	ldr	r1, [r4, #4]
 80266b0:	6001      	str	r1, [r0, #0]
    y[halfLen].im = (float)0;
 80266b2:	2200      	movs	r2, #0
    for (k = halfLen + 1; k < fftLen; ++k) {
 80266b4:	429d      	cmp	r5, r3
    y[halfLen].im = (float)0;
 80266b6:	6042      	str	r2, [r0, #4]
    y[0].im = (float)0;
 80266b8:	6062      	str	r2, [r4, #4]
    for (k = halfLen + 1; k < fftLen; ++k) {
 80266ba:	d911      	bls.n	80266e0 <mw_cmsis_fft_do_real+0x58>
 80266bc:	3c08      	subs	r4, #8
 80266be:	eb04 02c5 	add.w	r2, r4, r5, lsl #3
 80266c2:	4603      	mov	r3, r0
 80266c4:	3308      	adds	r3, #8
        y[k].re = (float)(y[q].re);
 80266c6:	f850 1c08 	ldr.w	r1, [r0, #-8]
 80266ca:	6019      	str	r1, [r3, #0]
        y[k].im = -((float)(y[q].im));
 80266cc:	ed50 7a01 	vldr	s15, [r0, #-4]
    for (k = halfLen + 1; k < fftLen; ++k) {
 80266d0:	4293      	cmp	r3, r2
        y[k].im = -((float)(y[q].im));
 80266d2:	eef1 7a67 	vneg.f32	s15, s15
    for (k = halfLen + 1; k < fftLen; ++k) {
 80266d6:	f1a0 0008 	sub.w	r0, r0, #8
        y[k].im = -((float)(y[q].im));
 80266da:	edc3 7a01 	vstr	s15, [r3, #4]
    for (k = halfLen + 1; k < fftLen; ++k) {
 80266de:	d1f1      	bne.n	80266c4 <mw_cmsis_fft_do_real+0x3c>
        q = q - 1;
    }
}
 80266e0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80266e2:	bf00      	nop
 80266e4:	20022504 	.word	0x20022504

080266e8 <rtIsNaNF>:
/*
 * Function: rtIsNaNF =================================================
 *  Abstract:
 *  Test if single-precision value is not a number
 */
boolean_T rtIsNaNF(real32_T value)
 80266e8:	2000      	movs	r0, #0
 80266ea:	4770      	bx	lr

080266ec <Flash_Error>:
 80266ec:	f3bf 8f4f 	dsb	sy
}

static void Flash_Error(void)
{
  __DSB();
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)|(SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk)|SCB_AIRCR_SYSRESETREQ_Msk);
 80266f0:	4905      	ldr	r1, [pc, #20]	@ (8026708 <Flash_Error+0x1c>)
 80266f2:	4b06      	ldr	r3, [pc, #24]	@ (802670c <Flash_Error+0x20>)
 80266f4:	68ca      	ldr	r2, [r1, #12]
 80266f6:	f402 62e0 	and.w	r2, r2, #1792	@ 0x700
 80266fa:	4313      	orrs	r3, r2
 80266fc:	60cb      	str	r3, [r1, #12]
 80266fe:	f3bf 8f4f 	dsb	sy
  __DSB();
  for(;;)
  {
    __NOP();
 8026702:	bf00      	nop
  for(;;)
 8026704:	e7fd      	b.n	8026702 <Flash_Error+0x16>
 8026706:	bf00      	nop
 8026708:	e000ed00 	.word	0xe000ed00
 802670c:	05fa0004 	.word	0x05fa0004

08026710 <Flash_Write>:

 	_flashState = OK;
}

static bool Flash_Write(uint32_t address, uint8_t data)
{
 8026710:	b538      	push	{r3, r4, r5, lr}
	while(_flashState == BUSY)
 8026712:	4d22      	ldr	r5, [pc, #136]	@ (802679c <Flash_Write+0x8c>)
 8026714:	782b      	ldrb	r3, [r5, #0]
 8026716:	b903      	cbnz	r3, 802671a <Flash_Write+0xa>
 8026718:	e7fe      	b.n	8026718 <Flash_Write+0x8>
	{;}
	_flashState = BUSY;
 802671a:	2300      	movs	r3, #0

	if (address >= MAX_USER_FLASH_SIZE)
 802671c:	f5b0 3f80 	cmp.w	r0, #65536	@ 0x10000
	_flashState = BUSY;
 8026720:	702b      	strb	r3, [r5, #0]
	if (address >= MAX_USER_FLASH_SIZE)
 8026722:	d22b      	bcs.n	802677c <Flash_Write+0x6c>
	  if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
 8026724:	4b1e      	ldr	r3, [pc, #120]	@ (80267a0 <Flash_Write+0x90>)
 8026726:	460a      	mov	r2, r1
 8026728:	6919      	ldr	r1, [r3, #16]
 802672a:	2900      	cmp	r1, #0
 802672c:	db18      	blt.n	8026760 <Flash_Write+0x50>
	{
	     PRINTF_MEM("Flash access error: %s\n", __FUNCTION__);
	     return false;
	}

    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | FLASH_FLAG_PGSERR );
 802672e:	4c1c      	ldr	r4, [pc, #112]	@ (80267a0 <Flash_Write+0x90>)
 8026730:	23b3      	movs	r3, #179	@ 0xb3
    HAL_FLASH_Program(TYPEPROGRAM_FASTBYTE, 0x080E0000 + address, data);
 8026732:	f100 6100 	add.w	r1, r0, #134217728	@ 0x8000000
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | FLASH_FLAG_PGSERR );
 8026736:	60e3      	str	r3, [r4, #12]
    HAL_FLASH_Program(TYPEPROGRAM_FASTBYTE, 0x080E0000 + address, data);
 8026738:	2300      	movs	r3, #0
 802673a:	4618      	mov	r0, r3
 802673c:	f501 2160 	add.w	r1, r1, #917504	@ 0xe0000
 8026740:	f7fb fa02 	bl	8021b48 <HAL_FLASH_Program>
	FLASH->CR |= FLASH_CR_LOCK;
 8026744:	6923      	ldr	r3, [r4, #16]
 8026746:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 802674a:	6123      	str	r3, [r4, #16]
    if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
 802674c:	6923      	ldr	r3, [r4, #16]
 802674e:	2b00      	cmp	r3, #0
 8026750:	db20      	blt.n	8026794 <Flash_Write+0x84>

    //PRINTF_MEM("Saved byte 0x%02X to address: 0x%08X\n",data,0x080E0000 + address);

    if (!Flash_Lock())
    {
        PRINTF_MEM("Flash could not been secured, system reset: %s\n", __FUNCTION__);
 8026752:	4a14      	ldr	r2, [pc, #80]	@ (80267a4 <Flash_Write+0x94>)
 8026754:	4914      	ldr	r1, [pc, #80]	@ (80267a8 <Flash_Write+0x98>)
 8026756:	2004      	movs	r0, #4
 8026758:	f001 fc66 	bl	8028028 <LOG_fprintf>
        Flash_Error();
 802675c:	f7ff ffc6 	bl	80266ec <Flash_Error>
	    WRITE_REG(FLASH->KEYR, FLASH_KEY1);
 8026760:	4912      	ldr	r1, [pc, #72]	@ (80267ac <Flash_Write+0x9c>)
 8026762:	6059      	str	r1, [r3, #4]
	    WRITE_REG(FLASH->KEYR, FLASH_KEY2);
 8026764:	f101 3188 	add.w	r1, r1, #2290649224	@ 0x88888888
 8026768:	6059      	str	r1, [r3, #4]
	    if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
 802676a:	691b      	ldr	r3, [r3, #16]
 802676c:	2b00      	cmp	r3, #0
 802676e:	dade      	bge.n	802672e <Flash_Write+0x1e>
	     PRINTF_MEM("Flash access error: %s\n", __FUNCTION__);
 8026770:	4a0c      	ldr	r2, [pc, #48]	@ (80267a4 <Flash_Write+0x94>)
 8026772:	490f      	ldr	r1, [pc, #60]	@ (80267b0 <Flash_Write+0xa0>)
 8026774:	2004      	movs	r0, #4
 8026776:	f001 fc57 	bl	8028028 <LOG_fprintf>
	     return false;
 802677a:	e009      	b.n	8026790 <Flash_Write+0x80>
		PRINTF_MEM("Address: 0x%08X\n",address);
 802677c:	4602      	mov	r2, r0
 802677e:	490d      	ldr	r1, [pc, #52]	@ (80267b4 <Flash_Write+0xa4>)
 8026780:	2004      	movs	r0, #4
 8026782:	f001 fc51 	bl	8028028 <LOG_fprintf>
		PRINTF_MEM("Write address overflows user flash size: %s\n", __FUNCTION__);
 8026786:	4a07      	ldr	r2, [pc, #28]	@ (80267a4 <Flash_Write+0x94>)
 8026788:	490b      	ldr	r1, [pc, #44]	@ (80267b8 <Flash_Write+0xa8>)
 802678a:	2004      	movs	r0, #4
 802678c:	f001 fc4c 	bl	8028028 <LOG_fprintf>
		return false;
 8026790:	2000      	movs	r0, #0
    }

 	_flashState = OK;
 	return true;
}
 8026792:	bd38      	pop	{r3, r4, r5, pc}
 	_flashState = OK;
 8026794:	2001      	movs	r0, #1
 8026796:	7028      	strb	r0, [r5, #0]
}
 8026798:	bd38      	pop	{r3, r4, r5, pc}
 802679a:	bf00      	nop
 802679c:	2002251c 	.word	0x2002251c
 80267a0:	40023c00 	.word	0x40023c00
 80267a4:	0802dfa4 	.word	0x0802dfa4
 80267a8:	0802e92c 	.word	0x0802e92c
 80267ac:	45670123 	.word	0x45670123
 80267b0:	0802e914 	.word	0x0802e914
 80267b4:	0802e8d0 	.word	0x0802e8d0
 80267b8:	0802e8e4 	.word	0x0802e8e4

080267bc <Flash_Erese_Internal>:
{
 80267bc:	b538      	push	{r3, r4, r5, lr}
	while(_flashState == BUSY)
 80267be:	4d1a      	ldr	r5, [pc, #104]	@ (8026828 <Flash_Erese_Internal+0x6c>)
 80267c0:	782b      	ldrb	r3, [r5, #0]
 80267c2:	b903      	cbnz	r3, 80267c6 <Flash_Erese_Internal+0xa>
 80267c4:	e7fe      	b.n	80267c4 <Flash_Erese_Internal+0x8>
	_flashState = BUSY;
 80267c6:	2200      	movs	r2, #0
	  if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
 80267c8:	4b18      	ldr	r3, [pc, #96]	@ (802682c <Flash_Erese_Internal+0x70>)
	_flashState = BUSY;
 80267ca:	702a      	strb	r2, [r5, #0]
	  if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
 80267cc:	691a      	ldr	r2, [r3, #16]
 80267ce:	2a00      	cmp	r2, #0
 80267d0:	db14      	blt.n	80267fc <Flash_Erese_Internal+0x40>
     __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | FLASH_FLAG_PGSERR );
 80267d2:	4c16      	ldr	r4, [pc, #88]	@ (802682c <Flash_Erese_Internal+0x70>)
 80267d4:	23b3      	movs	r3, #179	@ 0xb3
 80267d6:	60e3      	str	r3, [r4, #12]
     FLASH_Erase_Sector(FLASH_SECTOR_11, VOLTAGE_RANGE_3);
 80267d8:	2102      	movs	r1, #2
 80267da:	200b      	movs	r0, #11
 80267dc:	f7fb fa54 	bl	8021c88 <FLASH_Erase_Sector>
	FLASH->CR |= FLASH_CR_LOCK;
 80267e0:	6923      	ldr	r3, [r4, #16]
 80267e2:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 80267e6:	6123      	str	r3, [r4, #16]
    if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
 80267e8:	6923      	ldr	r3, [r4, #16]
 80267ea:	2b00      	cmp	r3, #0
 80267ec:	db14      	blt.n	8026818 <Flash_Erese_Internal+0x5c>
         PRINTF_MEM("Flash could not been secured, system reset: %s\n", __FUNCTION__);
 80267ee:	4a10      	ldr	r2, [pc, #64]	@ (8026830 <Flash_Erese_Internal+0x74>)
 80267f0:	4910      	ldr	r1, [pc, #64]	@ (8026834 <Flash_Erese_Internal+0x78>)
 80267f2:	2004      	movs	r0, #4
 80267f4:	f001 fc18 	bl	8028028 <LOG_fprintf>
         Flash_Error();
 80267f8:	f7ff ff78 	bl	80266ec <Flash_Error>
	    WRITE_REG(FLASH->KEYR, FLASH_KEY1);
 80267fc:	490e      	ldr	r1, [pc, #56]	@ (8026838 <Flash_Erese_Internal+0x7c>)
	    WRITE_REG(FLASH->KEYR, FLASH_KEY2);
 80267fe:	4a0f      	ldr	r2, [pc, #60]	@ (802683c <Flash_Erese_Internal+0x80>)
	    WRITE_REG(FLASH->KEYR, FLASH_KEY1);
 8026800:	6059      	str	r1, [r3, #4]
	    WRITE_REG(FLASH->KEYR, FLASH_KEY2);
 8026802:	605a      	str	r2, [r3, #4]
	    if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
 8026804:	691b      	ldr	r3, [r3, #16]
 8026806:	2b00      	cmp	r3, #0
 8026808:	dae3      	bge.n	80267d2 <Flash_Erese_Internal+0x16>
}
 802680a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	     PRINTF_MEM("Flash access error: %s\n", __FUNCTION__);
 802680e:	4a08      	ldr	r2, [pc, #32]	@ (8026830 <Flash_Erese_Internal+0x74>)
 8026810:	490b      	ldr	r1, [pc, #44]	@ (8026840 <Flash_Erese_Internal+0x84>)
 8026812:	2004      	movs	r0, #4
 8026814:	f001 bc08 	b.w	8028028 <LOG_fprintf>
     PRINTF_MEM("User flash has been erased\n");
 8026818:	490a      	ldr	r1, [pc, #40]	@ (8026844 <Flash_Erese_Internal+0x88>)
 802681a:	2004      	movs	r0, #4
 802681c:	f001 fc04 	bl	8028028 <LOG_fprintf>
 	_flashState = OK;
 8026820:	2301      	movs	r3, #1
 8026822:	702b      	strb	r3, [r5, #0]
}
 8026824:	bd38      	pop	{r3, r4, r5, pc}
 8026826:	bf00      	nop
 8026828:	2002251c 	.word	0x2002251c
 802682c:	40023c00 	.word	0x40023c00
 8026830:	0802dfb0 	.word	0x0802dfb0
 8026834:	0802e92c 	.word	0x0802e92c
 8026838:	45670123 	.word	0x45670123
 802683c:	cdef89ab 	.word	0xcdef89ab
 8026840:	0802e914 	.word	0x0802e914
 8026844:	0802e95c 	.word	0x0802e95c

08026848 <Flash_Init>:
 	_flashState = OK;
 	return true;
}

void Flash_Init(void)
{
 8026848:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    *data = *(__IO uint8_t*)address;
 802684c:	4e27      	ldr	r6, [pc, #156]	@ (80268ec <Flash_Init+0xa4>)
 	_flashState = OK;
 	uint8_t readedData[4];
 	Memory_LL_Read(FLASH_MAGIC_NUMBER_ADDRESS,readedData,4);
 	uint32_t readMagicNumber;
 	memcpy(&readMagicNumber,readedData,4);
 	while (readMagicNumber != FLASH_MAGIC_NUMBER)
 802684e:	f8df 80ac 	ldr.w	r8, [pc, #172]	@ 80268fc <Flash_Init+0xb4>
    *data = *(__IO uint8_t*)address;
 8026852:	7833      	ldrb	r3, [r6, #0]
 	_flashState = OK;
 8026854:	4f26      	ldr	r7, [pc, #152]	@ (80268f0 <Flash_Init+0xa8>)
{
 8026856:	b083      	sub	sp, #12
 	_flashState = OK;
 8026858:	2201      	movs	r2, #1
    *data = *(__IO uint8_t*)address;
 802685a:	f88d 3000 	strb.w	r3, [sp]
 802685e:	7873      	ldrb	r3, [r6, #1]
 8026860:	f88d 3001 	strb.w	r3, [sp, #1]
 8026864:	78b3      	ldrb	r3, [r6, #2]
 8026866:	f88d 3002 	strb.w	r3, [sp, #2]
 802686a:	78f3      	ldrb	r3, [r6, #3]
 802686c:	f88d 3003 	strb.w	r3, [sp, #3]
 	while (readMagicNumber != FLASH_MAGIC_NUMBER)
 8026870:	9b00      	ldr	r3, [sp, #0]
 	_flashState = OK;
 8026872:	703a      	strb	r2, [r7, #0]
 	while (readMagicNumber != FLASH_MAGIC_NUMBER)
 8026874:	4543      	cmp	r3, r8
 8026876:	d031      	beq.n	80268dc <Flash_Init+0x94>
 	{
 		PRINTF_MEM("Flash memory not initialized\n");
 8026878:	f8df 9084 	ldr.w	r9, [pc, #132]	@ 8026900 <Flash_Init+0xb8>
 802687c:	4649      	mov	r1, r9
 802687e:	2004      	movs	r0, #4
 8026880:	f001 fbd2 	bl	8028028 <LOG_fprintf>

bool Memory_LL_Save(uint32_t address, uint8_t* data, uint16_t length)
{
	//PRINTF_MEM("%s address: 0x%08X\n",__FUNCTION__,address);
	bool response = true;
	for (int i = 0; i < length; i++)
 8026884:	2400      	movs	r4, #0
 		Flash_Erese_Internal();
 8026886:	f7ff ff99 	bl	80267bc <Flash_Erese_Internal>
 		memcpy(dataToSave,&numberToSave,4);
 802688a:	ad01      	add	r5, sp, #4
 802688c:	f8cd 8004 	str.w	r8, [sp, #4]
	{
		response = Flash_Write(address+i,data[i]);
 8026890:	4620      	mov	r0, r4
 8026892:	f815 1b01 	ldrb.w	r1, [r5], #1
	for (int i = 0; i < length; i++)
 8026896:	3401      	adds	r4, #1
		response = Flash_Write(address+i,data[i]);
 8026898:	f7ff ff3a 	bl	8026710 <Flash_Write>
	for (int i = 0; i < length; i++)
 802689c:	2c04      	cmp	r4, #4
 802689e:	d1f7      	bne.n	8026890 <Flash_Init+0x48>
 80268a0:	783b      	ldrb	r3, [r7, #0]
 80268a2:	b903      	cbnz	r3, 80268a6 <Flash_Init+0x5e>
	while(_flashState == BUSY)
 80268a4:	e7fe      	b.n	80268a4 <Flash_Init+0x5c>
	_flashState = BUSY;
 80268a6:	2300      	movs	r3, #0
 80268a8:	703b      	strb	r3, [r7, #0]
    *data = *(__IO uint8_t*)address;
 80268aa:	7833      	ldrb	r3, [r6, #0]
 80268ac:	f88d 3000 	strb.w	r3, [sp]
 80268b0:	7873      	ldrb	r3, [r6, #1]
 80268b2:	f88d 3001 	strb.w	r3, [sp, #1]
 80268b6:	78b3      	ldrb	r3, [r6, #2]
 80268b8:	f88d 3002 	strb.w	r3, [sp, #2]
 80268bc:	78f3      	ldrb	r3, [r6, #3]
 80268be:	f88d 3003 	strb.w	r3, [sp, #3]
 	 	memcpy(&readMagicNumber,readedData,4);
 80268c2:	9d00      	ldr	r5, [sp, #0]
 	_flashState = OK;
 80268c4:	2301      	movs	r3, #1
 	 	HAL_Delay(1000);
 80268c6:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
 	_flashState = OK;
 80268ca:	703b      	strb	r3, [r7, #0]
 	 	HAL_Delay(1000);
 80268cc:	f7fa fc0a 	bl	80210e4 <HAL_Delay>
 	 	PRINTF_MEM("Initializing\n");
 80268d0:	4908      	ldr	r1, [pc, #32]	@ (80268f4 <Flash_Init+0xac>)
 80268d2:	4620      	mov	r0, r4
 80268d4:	f001 fba8 	bl	8028028 <LOG_fprintf>
 	while (readMagicNumber != FLASH_MAGIC_NUMBER)
 80268d8:	4545      	cmp	r5, r8
 80268da:	d1cf      	bne.n	802687c <Flash_Init+0x34>
 	PRINTF_MEM("Flash init done\n");
 80268dc:	4906      	ldr	r1, [pc, #24]	@ (80268f8 <Flash_Init+0xb0>)
 80268de:	2004      	movs	r0, #4
}
 80268e0:	b003      	add	sp, #12
 80268e2:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
 	PRINTF_MEM("Flash init done\n");
 80268e6:	f001 bb9f 	b.w	8028028 <LOG_fprintf>
 80268ea:	bf00      	nop
 80268ec:	080e0000 	.word	0x080e0000
 80268f0:	2002251c 	.word	0x2002251c
 80268f4:	0802e998 	.word	0x0802e998
 80268f8:	0802e9a8 	.word	0x0802e9a8
 80268fc:	dead666b 	.word	0xdead666b
 8026900:	0802e978 	.word	0x0802e978

08026904 <Memory_LL_Clear>:
{
 8026904:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	while(_flashState == BUSY)
 8026908:	4f25      	ldr	r7, [pc, #148]	@ (80269a0 <Memory_LL_Clear+0x9c>)
	PRINTF_MEM("Flash clearing\n");
 802690a:	4926      	ldr	r1, [pc, #152]	@ (80269a4 <Memory_LL_Clear+0xa0>)
{
 802690c:	b083      	sub	sp, #12
	PRINTF_MEM("Flash clearing\n");
 802690e:	2004      	movs	r0, #4
 8026910:	f001 fb8a 	bl	8028028 <LOG_fprintf>
	Flash_Erese_Internal();
 8026914:	f7ff ff52 	bl	80267bc <Flash_Erese_Internal>
	while(_flashState == BUSY)
 8026918:	783b      	ldrb	r3, [r7, #0]
 802691a:	b903      	cbnz	r3, 802691e <Memory_LL_Clear+0x1a>
 802691c:	e7fe      	b.n	802691c <Memory_LL_Clear+0x18>
    *data = *(__IO uint8_t*)address;
 802691e:	4e22      	ldr	r6, [pc, #136]	@ (80269a8 <Memory_LL_Clear+0xa4>)
	while (readMagicNumber != FLASH_MAGIC_NUMBER)
 8026920:	f8df 808c 	ldr.w	r8, [pc, #140]	@ 80269b0 <Memory_LL_Clear+0xac>
    *data = *(__IO uint8_t*)address;
 8026924:	7833      	ldrb	r3, [r6, #0]
 8026926:	f88d 3000 	strb.w	r3, [sp]
 802692a:	7873      	ldrb	r3, [r6, #1]
 802692c:	f88d 3001 	strb.w	r3, [sp, #1]
 8026930:	78b3      	ldrb	r3, [r6, #2]
 8026932:	f88d 3002 	strb.w	r3, [sp, #2]
 8026936:	78f3      	ldrb	r3, [r6, #3]
 8026938:	f88d 3003 	strb.w	r3, [sp, #3]
	while (readMagicNumber != FLASH_MAGIC_NUMBER)
 802693c:	9b00      	ldr	r3, [sp, #0]
 	_flashState = OK;
 802693e:	2201      	movs	r2, #1
	while (readMagicNumber != FLASH_MAGIC_NUMBER)
 8026940:	4543      	cmp	r3, r8
 	_flashState = OK;
 8026942:	703a      	strb	r2, [r7, #0]
	while (readMagicNumber != FLASH_MAGIC_NUMBER)
 8026944:	d025      	beq.n	8026992 <Memory_LL_Clear+0x8e>
	_flashState = BUSY;
 8026946:	f04f 0900 	mov.w	r9, #0
		Flash_Erese_Internal();
 802694a:	f7ff ff37 	bl	80267bc <Flash_Erese_Internal>
	for (int i = 0; i < length; i++)
 802694e:	2400      	movs	r4, #0
		memcpy(dataToSave, &numberToSave, 4);
 8026950:	f8cd 8004 	str.w	r8, [sp, #4]
	for (int i = 0; i < length; i++)
 8026954:	ad01      	add	r5, sp, #4
		response = Flash_Write(address+i,data[i]);
 8026956:	4620      	mov	r0, r4
 8026958:	f815 1b01 	ldrb.w	r1, [r5], #1
	for (int i = 0; i < length; i++)
 802695c:	3401      	adds	r4, #1
		response = Flash_Write(address+i,data[i]);
 802695e:	f7ff fed7 	bl	8026710 <Flash_Write>
	for (int i = 0; i < length; i++)
 8026962:	2c04      	cmp	r4, #4
 8026964:	d1f7      	bne.n	8026956 <Memory_LL_Clear+0x52>
 8026966:	783b      	ldrb	r3, [r7, #0]
 8026968:	b903      	cbnz	r3, 802696c <Memory_LL_Clear+0x68>
	while(_flashState == BUSY)
 802696a:	e7fe      	b.n	802696a <Memory_LL_Clear+0x66>
	_flashState = BUSY;
 802696c:	f887 9000 	strb.w	r9, [r7]
    *data = *(__IO uint8_t*)address;
 8026970:	7833      	ldrb	r3, [r6, #0]
 8026972:	f88d 3000 	strb.w	r3, [sp]
 8026976:	7873      	ldrb	r3, [r6, #1]
 8026978:	f88d 3001 	strb.w	r3, [sp, #1]
 802697c:	78b3      	ldrb	r3, [r6, #2]
 802697e:	f88d 3002 	strb.w	r3, [sp, #2]
 8026982:	78f3      	ldrb	r3, [r6, #3]
 8026984:	f88d 3003 	strb.w	r3, [sp, #3]
		memcpy(&readMagicNumber, readedData, 4);
 8026988:	9b00      	ldr	r3, [sp, #0]
 	_flashState = OK;
 802698a:	2201      	movs	r2, #1
	while (readMagicNumber != FLASH_MAGIC_NUMBER)
 802698c:	4543      	cmp	r3, r8
 	_flashState = OK;
 802698e:	703a      	strb	r2, [r7, #0]
	while (readMagicNumber != FLASH_MAGIC_NUMBER)
 8026990:	d1db      	bne.n	802694a <Memory_LL_Clear+0x46>
	PRINTF_MEM("Flash clear done\n");
 8026992:	4906      	ldr	r1, [pc, #24]	@ (80269ac <Memory_LL_Clear+0xa8>)
 8026994:	2004      	movs	r0, #4
}
 8026996:	b003      	add	sp, #12
 8026998:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
	PRINTF_MEM("Flash clear done\n");
 802699c:	f001 bb44 	b.w	8028028 <LOG_fprintf>
 80269a0:	2002251c 	.word	0x2002251c
 80269a4:	0802e9bc 	.word	0x0802e9bc
 80269a8:	080e0000 	.word	0x080e0000
 80269ac:	0802e9cc 	.word	0x0802e9cc
 80269b0:	dead666b 	.word	0xdead666b

080269b4 <Memory_LL_Save>:
	for (int i = 0; i < length; i++)
 80269b4:	2a00      	cmp	r2, #0
 80269b6:	d057      	beq.n	8026a68 <Memory_LL_Save+0xb4>
{
 80269b8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80269bc:	f8df 80c8 	ldr.w	r8, [pc, #200]	@ 8026a88 <Memory_LL_Save+0xd4>
	  if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
 80269c0:	4d2a      	ldr	r5, [pc, #168]	@ (8026a6c <Memory_LL_Save+0xb8>)
 80269c2:	4604      	mov	r4, r0
 80269c4:	1e4e      	subs	r6, r1, #1
 80269c6:	1817      	adds	r7, r2, r0
	_flashState = BUSY;
 80269c8:	f04f 0900 	mov.w	r9, #0
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | FLASH_FLAG_PGSERR );
 80269cc:	f04f 0ab3 	mov.w	sl, #179	@ 0xb3
		response = Flash_Write(address+i,data[i]);
 80269d0:	f898 3000 	ldrb.w	r3, [r8]
 80269d4:	f816 2f01 	ldrb.w	r2, [r6, #1]!
	while(_flashState == BUSY)
 80269d8:	b903      	cbnz	r3, 80269dc <Memory_LL_Save+0x28>
 80269da:	e7fe      	b.n	80269da <Memory_LL_Save+0x26>
	if (address >= MAX_USER_FLASH_SIZE)
 80269dc:	f5b4 3f80 	cmp.w	r4, #65536	@ 0x10000
	_flashState = BUSY;
 80269e0:	f888 9000 	strb.w	r9, [r8]
	if (address >= MAX_USER_FLASH_SIZE)
 80269e4:	d22d      	bcs.n	8026a42 <Memory_LL_Save+0x8e>
	  if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
 80269e6:	692b      	ldr	r3, [r5, #16]
 80269e8:	2b00      	cmp	r3, #0
 80269ea:	db17      	blt.n	8026a1c <Memory_LL_Save+0x68>
    HAL_FLASH_Program(TYPEPROGRAM_FASTBYTE, 0x080E0000 + address, data);
 80269ec:	2300      	movs	r3, #0
 80269ee:	f104 6100 	add.w	r1, r4, #134217728	@ 0x8000000
 80269f2:	4618      	mov	r0, r3
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | FLASH_FLAG_PGSERR );
 80269f4:	f8c5 a00c 	str.w	sl, [r5, #12]
    HAL_FLASH_Program(TYPEPROGRAM_FASTBYTE, 0x080E0000 + address, data);
 80269f8:	f501 2160 	add.w	r1, r1, #917504	@ 0xe0000
 80269fc:	f7fb f8a4 	bl	8021b48 <HAL_FLASH_Program>
	FLASH->CR |= FLASH_CR_LOCK;
 8026a00:	692b      	ldr	r3, [r5, #16]
 8026a02:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 8026a06:	612b      	str	r3, [r5, #16]
    if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
 8026a08:	692b      	ldr	r3, [r5, #16]
 8026a0a:	2b00      	cmp	r3, #0
 8026a0c:	db25      	blt.n	8026a5a <Memory_LL_Save+0xa6>
        PRINTF_MEM("Flash could not been secured, system reset: %s\n", __FUNCTION__);
 8026a0e:	4a18      	ldr	r2, [pc, #96]	@ (8026a70 <Memory_LL_Save+0xbc>)
 8026a10:	4918      	ldr	r1, [pc, #96]	@ (8026a74 <Memory_LL_Save+0xc0>)
 8026a12:	2004      	movs	r0, #4
 8026a14:	f001 fb08 	bl	8028028 <LOG_fprintf>
        Flash_Error();
 8026a18:	f7ff fe68 	bl	80266ec <Flash_Error>
	    WRITE_REG(FLASH->KEYR, FLASH_KEY1);
 8026a1c:	4b16      	ldr	r3, [pc, #88]	@ (8026a78 <Memory_LL_Save+0xc4>)
 8026a1e:	606b      	str	r3, [r5, #4]
	    WRITE_REG(FLASH->KEYR, FLASH_KEY2);
 8026a20:	f103 3388 	add.w	r3, r3, #2290649224	@ 0x88888888
 8026a24:	606b      	str	r3, [r5, #4]
	    if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
 8026a26:	692b      	ldr	r3, [r5, #16]
 8026a28:	2b00      	cmp	r3, #0
 8026a2a:	dadf      	bge.n	80269ec <Memory_LL_Save+0x38>
	     PRINTF_MEM("Flash access error: %s\n", __FUNCTION__);
 8026a2c:	2004      	movs	r0, #4
 8026a2e:	4a10      	ldr	r2, [pc, #64]	@ (8026a70 <Memory_LL_Save+0xbc>)
 8026a30:	4912      	ldr	r1, [pc, #72]	@ (8026a7c <Memory_LL_Save+0xc8>)
 8026a32:	f001 faf9 	bl	8028028 <LOG_fprintf>
		return false;
 8026a36:	2000      	movs	r0, #0
	for (int i = 0; i < length; i++)
 8026a38:	3401      	adds	r4, #1
 8026a3a:	42bc      	cmp	r4, r7
 8026a3c:	d1c8      	bne.n	80269d0 <Memory_LL_Save+0x1c>
	}
	return response;
}
 8026a3e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		PRINTF_MEM("Address: 0x%08X\n",address);
 8026a42:	490f      	ldr	r1, [pc, #60]	@ (8026a80 <Memory_LL_Save+0xcc>)
 8026a44:	4622      	mov	r2, r4
 8026a46:	2004      	movs	r0, #4
 8026a48:	f001 faee 	bl	8028028 <LOG_fprintf>
		PRINTF_MEM("Write address overflows user flash size: %s\n", __FUNCTION__);
 8026a4c:	2004      	movs	r0, #4
 8026a4e:	4a08      	ldr	r2, [pc, #32]	@ (8026a70 <Memory_LL_Save+0xbc>)
 8026a50:	490c      	ldr	r1, [pc, #48]	@ (8026a84 <Memory_LL_Save+0xd0>)
 8026a52:	f001 fae9 	bl	8028028 <LOG_fprintf>
		return false;
 8026a56:	2000      	movs	r0, #0
 8026a58:	e7ee      	b.n	8026a38 <Memory_LL_Save+0x84>
	for (int i = 0; i < length; i++)
 8026a5a:	3401      	adds	r4, #1
 	_flashState = OK;
 8026a5c:	2001      	movs	r0, #1
	for (int i = 0; i < length; i++)
 8026a5e:	42bc      	cmp	r4, r7
 	_flashState = OK;
 8026a60:	f888 0000 	strb.w	r0, [r8]
	for (int i = 0; i < length; i++)
 8026a64:	d1b4      	bne.n	80269d0 <Memory_LL_Save+0x1c>
 8026a66:	e7ea      	b.n	8026a3e <Memory_LL_Save+0x8a>
	bool response = true;
 8026a68:	2001      	movs	r0, #1
}
 8026a6a:	4770      	bx	lr
 8026a6c:	40023c00 	.word	0x40023c00
 8026a70:	0802dfa4 	.word	0x0802dfa4
 8026a74:	0802e92c 	.word	0x0802e92c
 8026a78:	45670123 	.word	0x45670123
 8026a7c:	0802e914 	.word	0x0802e914
 8026a80:	0802e8d0 	.word	0x0802e8d0
 8026a84:	0802e8e4 	.word	0x0802e8e4
 8026a88:	2002251c 	.word	0x2002251c

08026a8c <Memory_LL_Read>:

void Memory_LL_Read(uint32_t address, uint8_t* data, uint16_t length)
{
 8026a8c:	b510      	push	{r4, lr}
	while(_flashState == BUSY)
 8026a8e:	4c18      	ldr	r4, [pc, #96]	@ (8026af0 <Memory_LL_Read+0x64>)
 8026a90:	7823      	ldrb	r3, [r4, #0]
 8026a92:	b903      	cbnz	r3, 8026a96 <Memory_LL_Read+0xa>
 8026a94:	e7fe      	b.n	8026a94 <Memory_LL_Read+0x8>
	_flashState = BUSY;
 8026a96:	2300      	movs	r3, #0
	if (address >= MAX_USER_FLASH_SIZE)
 8026a98:	f5b0 3f80 	cmp.w	r0, #65536	@ 0x10000
	_flashState = BUSY;
 8026a9c:	7023      	strb	r3, [r4, #0]
	if (address >= MAX_USER_FLASH_SIZE)
 8026a9e:	d214      	bcs.n	8026aca <Memory_LL_Read+0x3e>
	if (length + address >= MAX_USER_FLASH_SIZE)
 8026aa0:	1883      	adds	r3, r0, r2
 8026aa2:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 8026aa6:	d21c      	bcs.n	8026ae2 <Memory_LL_Read+0x56>
	for(int i = 0; i < length; i++)
 8026aa8:	b162      	cbz	r2, 8026ac4 <Memory_LL_Read+0x38>
 8026aaa:	f100 6000 	add.w	r0, r0, #134217728	@ 0x8000000
 8026aae:	f500 2060 	add.w	r0, r0, #917504	@ 0xe0000
 8026ab2:	eb01 0c02 	add.w	ip, r1, r2
 8026ab6:	460b      	mov	r3, r1
 8026ab8:	1a42      	subs	r2, r0, r1
    *data = *(__IO uint8_t*)address;
 8026aba:	5cd1      	ldrb	r1, [r2, r3]
 8026abc:	f803 1b01 	strb.w	r1, [r3], #1
	for(int i = 0; i < length; i++)
 8026ac0:	4563      	cmp	r3, ip
 8026ac2:	d1fa      	bne.n	8026aba <Memory_LL_Read+0x2e>
 	_flashState = OK;
 8026ac4:	2301      	movs	r3, #1
 8026ac6:	7023      	strb	r3, [r4, #0]
	//PRINTF_MEM("%s address: 0x%08X\n",__FUNCTION__,address);
	Flash_Read(address,data,length);
}
 8026ac8:	bd10      	pop	{r4, pc}
		PRINTF_MEM("Address: 0x%08X\n",address);
 8026aca:	4602      	mov	r2, r0
 8026acc:	4909      	ldr	r1, [pc, #36]	@ (8026af4 <Memory_LL_Read+0x68>)
 8026ace:	2004      	movs	r0, #4
 8026ad0:	f001 faaa 	bl	8028028 <LOG_fprintf>
}
 8026ad4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		PRINTF_MEM("Read address overflows user flash size: %s\n", __FUNCTION__);
 8026ad8:	4a07      	ldr	r2, [pc, #28]	@ (8026af8 <Memory_LL_Read+0x6c>)
 8026ada:	4908      	ldr	r1, [pc, #32]	@ (8026afc <Memory_LL_Read+0x70>)
 8026adc:	2004      	movs	r0, #4
 8026ade:	f001 baa3 	b.w	8028028 <LOG_fprintf>
}
 8026ae2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		PRINTF_MEM("Data overflows user flash size: %s\n", __FUNCTION__);
 8026ae6:	4a04      	ldr	r2, [pc, #16]	@ (8026af8 <Memory_LL_Read+0x6c>)
 8026ae8:	4905      	ldr	r1, [pc, #20]	@ (8026b00 <Memory_LL_Read+0x74>)
 8026aea:	2004      	movs	r0, #4
 8026aec:	f001 ba9c 	b.w	8028028 <LOG_fprintf>
 8026af0:	2002251c 	.word	0x2002251c
 8026af4:	0802e8d0 	.word	0x0802e8d0
 8026af8:	0802dfc8 	.word	0x0802dfc8
 8026afc:	0802e9e0 	.word	0x0802e9e0
 8026b00:	0802ea0c 	.word	0x0802ea0c

08026b04 <Memory_MakeDefaultConfig>:
#define VALUE_TO_STRING(x)  STRINGIFY(x)


#ifdef  SENSOR_TYPE_LF
void Memory_MakeDefaultConfig(AdiConf_t* conf)
{
 8026b04:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	conf->magicNumber = MAGIC_FLASH_NUMBER;
 8026b06:	f06f 0325 	mvn.w	r3, #37	@ 0x25
 8026b0a:	2500      	movs	r5, #0
 8026b0c:	f06f 0212 	mvn.w	r2, #18
	conf->conf_id = 0;
	conf->sensor_ID = 1;
 8026b10:	2101      	movs	r1, #1
	conf->magicNumber = MAGIC_FLASH_NUMBER;
 8026b12:	7043      	strb	r3, [r0, #1]
 8026b14:	70c3      	strb	r3, [r0, #3]
	conf->RS485_speed = speed_9600;
 8026b16:	f44f 7398 	mov.w	r3, #304	@ 0x130
	conf->magicNumber = MAGIC_FLASH_NUMBER;
 8026b1a:	7002      	strb	r2, [r0, #0]
 8026b1c:	7082      	strb	r2, [r0, #2]
	conf->sensor_ID = 1;
 8026b1e:	7181      	strb	r1, [r0, #6]
	conf->RS485_speed = speed_9600;
 8026b20:	f8a0 3013 	strh.w	r3, [r0, #19]
	conf->conf_id = 0;
 8026b24:	7105      	strb	r5, [r0, #4]
 8026b26:	7145      	strb	r5, [r0, #5]
{
 8026b28:	4604      	mov	r4, r0
	conf->protocol = MODBUS;

	uint32_t idA = HAL_GetUIDw0();
 8026b2a:	f7fa faed 	bl	8021108 <HAL_GetUIDw0>
 8026b2e:	4607      	mov	r7, r0
	uint32_t idB = HAL_GetUIDw1();
 8026b30:	f7fa faf0 	bl	8021114 <HAL_GetUIDw1>
 8026b34:	4606      	mov	r6, r0
	uint32_t idC = HAL_GetUIDw2();
 8026b36:	f7fa faf3 	bl	8021120 <HAL_GetUIDw2>

	memcpy(conf->MAC,&idA,4);
	memcpy((conf->MAC)+4,&idB,4);
	memcpy((conf->MAC)+8,&idC,4);

	strcpy(conf->sensor_type, "AVS 1003LF");
 8026b3a:	4b2f      	ldr	r3, [pc, #188]	@ (8026bf8 <Memory_MakeDefaultConfig+0xf4>)
	memcpy((conf->MAC)+8,&idC,4);
 8026b3c:	f8c4 000f 	str.w	r0, [r4, #15]
	strcpy(conf->sensor_type, "AVS 1003LF");
 8026b40:	cb03      	ldmia	r3!, {r0, r1}
 8026b42:	881a      	ldrh	r2, [r3, #0]
 8026b44:	789b      	ldrb	r3, [r3, #2]
 8026b46:	f8c4 0015 	str.w	r0, [r4, #21]
 8026b4a:	f8a4 201d 	strh.w	r2, [r4, #29]

	conf->X_Calibration_A = 0x3f800000;				// 1
 8026b4e:	f06f 007f 	mvn.w	r0, #127	@ 0x7f
	conf->X_Calibration_B = 0;
	conf->X_Calibration_Sensitivity = 0x3fc00000;	// 1.5
 8026b52:	f06f 023f 	mvn.w	r2, #63	@ 0x3f
	strcpy(conf->sensor_type, "AVS 1003LF");
 8026b56:	77e3      	strb	r3, [r4, #31]
	conf->X_Calibration_A = 0x3f800000;				// 1
 8026b58:	233f      	movs	r3, #63	@ 0x3f
	memcpy(conf->MAC,&idA,4);
 8026b5a:	f8c4 7007 	str.w	r7, [r4, #7]
	memcpy((conf->MAC)+4,&idB,4);
 8026b5e:	f8c4 600b 	str.w	r6, [r4, #11]
	conf->X_Calibration_A = 0x3f800000;				// 1
 8026b62:	f884 5021 	strb.w	r5, [r4, #33]	@ 0x21
 8026b66:	f884 5022 	strb.w	r5, [r4, #34]	@ 0x22
	strcpy(conf->sensor_type, "AVS 1003LF");
 8026b6a:	f8c4 1019 	str.w	r1, [r4, #25]
	conf->X_Calibration_A = 0x3f800000;				// 1
 8026b6e:	f884 0023 	strb.w	r0, [r4, #35]	@ 0x23
 8026b72:	f884 3024 	strb.w	r3, [r4, #36]	@ 0x24
	conf->X_Calibration_B = 0;
 8026b76:	f884 5025 	strb.w	r5, [r4, #37]	@ 0x25
 8026b7a:	f884 5026 	strb.w	r5, [r4, #38]	@ 0x26
 8026b7e:	f884 5027 	strb.w	r5, [r4, #39]	@ 0x27
 8026b82:	f884 5028 	strb.w	r5, [r4, #40]	@ 0x28
	conf->X_Calibration_Sensitivity = 0x3fc00000;	// 1.5
 8026b86:	f884 5029 	strb.w	r5, [r4, #41]	@ 0x29
 8026b8a:	f884 502a 	strb.w	r5, [r4, #42]	@ 0x2a
 8026b8e:	f884 202b 	strb.w	r2, [r4, #43]	@ 0x2b
 8026b92:	f884 302c 	strb.w	r3, [r4, #44]	@ 0x2c

	conf->Y_Calibration_A = 0x3f800000;				// 1
 8026b96:	f884 502d 	strb.w	r5, [r4, #45]	@ 0x2d
 8026b9a:	f884 502e 	strb.w	r5, [r4, #46]	@ 0x2e
 8026b9e:	f884 002f 	strb.w	r0, [r4, #47]	@ 0x2f
 8026ba2:	f884 3030 	strb.w	r3, [r4, #48]	@ 0x30
	conf->Y_Calibration_B = 0;
 8026ba6:	f884 5031 	strb.w	r5, [r4, #49]	@ 0x31
 8026baa:	f884 5032 	strb.w	r5, [r4, #50]	@ 0x32
 8026bae:	f884 5033 	strb.w	r5, [r4, #51]	@ 0x33
 8026bb2:	f884 5034 	strb.w	r5, [r4, #52]	@ 0x34
	conf->Y_Calibration_Sensitivity = 0x3fc00000;	// 1.5
 8026bb6:	f884 5035 	strb.w	r5, [r4, #53]	@ 0x35
 8026bba:	f884 5036 	strb.w	r5, [r4, #54]	@ 0x36
 8026bbe:	f884 2037 	strb.w	r2, [r4, #55]	@ 0x37
 8026bc2:	f884 3038 	strb.w	r3, [r4, #56]	@ 0x38

	conf->Z_Calibration_A = 0x3f800000;				// 1
 8026bc6:	f884 5039 	strb.w	r5, [r4, #57]	@ 0x39
 8026bca:	f884 503a 	strb.w	r5, [r4, #58]	@ 0x3a
 8026bce:	f884 003b 	strb.w	r0, [r4, #59]	@ 0x3b
 8026bd2:	f884 303c 	strb.w	r3, [r4, #60]	@ 0x3c
	conf->Z_Calibration_B = 0;
 8026bd6:	f884 503d 	strb.w	r5, [r4, #61]	@ 0x3d
 8026bda:	f884 503e 	strb.w	r5, [r4, #62]	@ 0x3e
 8026bde:	f884 503f 	strb.w	r5, [r4, #63]	@ 0x3f
 8026be2:	f884 5040 	strb.w	r5, [r4, #64]	@ 0x40
	conf->Z_Calibration_Sensitivity = 0x3fc00000;	// 1.5
 8026be6:	f884 5041 	strb.w	r5, [r4, #65]	@ 0x41
 8026bea:	f884 5042 	strb.w	r5, [r4, #66]	@ 0x42
 8026bee:	f884 2043 	strb.w	r2, [r4, #67]	@ 0x43
 8026bf2:	f884 3044 	strb.w	r3, [r4, #68]	@ 0x44

}
 8026bf6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8026bf8:	0802ea30 	.word	0x0802ea30

08026bfc <Memory_Init>:

	memcpy(&currentConfig,&readedConf,sizeof(AdiConf_t));
}

void Memory_Init(void)
{
 8026bfc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	configsInMemory = 0;
 8026c00:	4dc6      	ldr	r5, [pc, #792]	@ (8026f1c <Memory_Init+0x320>)
		if (readedConf.magicNumber != (uint32_t)MAGIC_FLASH_NUMBER)
 8026c02:	4fc7      	ldr	r7, [pc, #796]	@ (8026f20 <Memory_Init+0x324>)
{
 8026c04:	b0a4      	sub	sp, #144	@ 0x90
	configsInMemory = 0;
 8026c06:	2300      	movs	r3, #0
 8026c08:	802b      	strh	r3, [r5, #0]
	Flash_Init();
 8026c0a:	2404      	movs	r4, #4
 8026c0c:	f7ff fe1c 	bl	8026848 <Flash_Init>
		if (readedConf.conf_id == 0xFFFF)
 8026c10:	f64f 76ff 	movw	r6, #65535	@ 0xffff
 8026c14:	e009      	b.n	8026c2a <Memory_Init+0x2e>
		if (readedConf.magicNumber != (uint32_t)MAGIC_FLASH_NUMBER)
 8026c16:	9b00      	ldr	r3, [sp, #0]
 8026c18:	42bb      	cmp	r3, r7
 8026c1a:	f040 80c8 	bne.w	8026dae <Memory_Init+0x1b2>
		configsInMemory++;
 8026c1e:	882b      	ldrh	r3, [r5, #0]
 8026c20:	3301      	adds	r3, #1
 8026c22:	b29b      	uxth	r3, r3
	for (int i = 0; i < MAX_CONFIGS; i++)
 8026c24:	4294      	cmp	r4, r2
		configsInMemory++;
 8026c26:	802b      	strh	r3, [r5, #0]
	for (int i = 0; i < MAX_CONFIGS; i++)
 8026c28:	d00d      	beq.n	8026c46 <Memory_Init+0x4a>
		Memory_LL_Read(MEMORY_FIRST_CONFIG_ADDRESS+i*sizeof(AdiConf_t),(uint8_t*)&readedConf,sizeof(AdiConf_t));
 8026c2a:	2245      	movs	r2, #69	@ 0x45
 8026c2c:	4620      	mov	r0, r4
 8026c2e:	4669      	mov	r1, sp
 8026c30:	f7ff ff2c 	bl	8026a8c <Memory_LL_Read>
		if (readedConf.conf_id == 0xFFFF)
 8026c34:	f8bd 3004 	ldrh.w	r3, [sp, #4]
 8026c38:	42b3      	cmp	r3, r6
	for (int i = 0; i < MAX_CONFIGS; i++)
 8026c3a:	f641 22f8 	movw	r2, #6904	@ 0x1af8
 8026c3e:	f104 0445 	add.w	r4, r4, #69	@ 0x45
		if (readedConf.conf_id == 0xFFFF)
 8026c42:	d1e8      	bne.n	8026c16 <Memory_Init+0x1a>
		configsInMemory++;
 8026c44:	882b      	ldrh	r3, [r5, #0]
	if (configsInMemory > 0)
 8026c46:	2b00      	cmp	r3, #0
 8026c48:	f040 8092 	bne.w	8026d70 <Memory_Init+0x174>
		PRINTF_MEM("No config found in memory, creating default\n");
 8026c4c:	49b5      	ldr	r1, [pc, #724]	@ (8026f24 <Memory_Init+0x328>)
	conf->magicNumber = MAGIC_FLASH_NUMBER;
 8026c4e:	f8df 82d0 	ldr.w	r8, [pc, #720]	@ 8026f20 <Memory_Init+0x324>
		PRINTF_MEM("No config found in memory, creating default\n");
 8026c52:	2004      	movs	r0, #4
 8026c54:	f001 f9e8 	bl	8028028 <LOG_fprintf>
	conf->sensor_ID = 1;
 8026c58:	2301      	movs	r3, #1
	conf->conf_id = 0;
 8026c5a:	2400      	movs	r4, #0
	conf->sensor_ID = 1;
 8026c5c:	f88d 3006 	strb.w	r3, [sp, #6]
	conf->RS485_speed = speed_9600;
 8026c60:	f44f 7398 	mov.w	r3, #304	@ 0x130
 8026c64:	f8ad 3013 	strh.w	r3, [sp, #19]
	conf->magicNumber = MAGIC_FLASH_NUMBER;
 8026c68:	f8cd 8000 	str.w	r8, [sp]
	conf->conf_id = 0;
 8026c6c:	f8ad 4004 	strh.w	r4, [sp, #4]
	uint32_t idA = HAL_GetUIDw0();
 8026c70:	f7fa fa4a 	bl	8021108 <HAL_GetUIDw0>
 8026c74:	4607      	mov	r7, r0
	uint32_t idB = HAL_GetUIDw1();
 8026c76:	f7fa fa4d 	bl	8021114 <HAL_GetUIDw1>
 8026c7a:	4606      	mov	r6, r0
	uint32_t idC = HAL_GetUIDw2();
 8026c7c:	f7fa fa50 	bl	8021120 <HAL_GetUIDw2>
	strcpy(conf->sensor_type, "AVS 1003LF");
 8026c80:	4aa9      	ldr	r2, [pc, #676]	@ (8026f28 <Memory_Init+0x32c>)
	memcpy((conf->MAC)+8,&idC,4);
 8026c82:	f8cd 000f 	str.w	r0, [sp, #15]
	strcpy(conf->sensor_type, "AVS 1003LF");
 8026c86:	ca03      	ldmia	r2!, {r0, r1}
	conf->X_Calibration_A = 0x3f800000;				// 1
 8026c88:	233f      	movs	r3, #63	@ 0x3f
	memcpy(conf->MAC,&idA,4);
 8026c8a:	f8cd 7007 	str.w	r7, [sp, #7]
	memcpy((conf->MAC)+4,&idB,4);
 8026c8e:	f8cd 600b 	str.w	r6, [sp, #11]
	conf->X_Calibration_A = 0x3f800000;				// 1
 8026c92:	f06f 077f 	mvn.w	r7, #127	@ 0x7f
	conf->X_Calibration_Sensitivity = 0x3fc00000;	// 1.5
 8026c96:	f06f 063f 	mvn.w	r6, #63	@ 0x3f
	strcpy(conf->sensor_type, "AVS 1003LF");
 8026c9a:	f8cd 1019 	str.w	r1, [sp, #25]
 8026c9e:	8811      	ldrh	r1, [r2, #0]
 8026ca0:	7892      	ldrb	r2, [r2, #2]
 8026ca2:	f88d 201f 	strb.w	r2, [sp, #31]
	conf->X_Calibration_A = 0x3f800000;				// 1
 8026ca6:	f88d 4021 	strb.w	r4, [sp, #33]	@ 0x21
 8026caa:	f88d 4022 	strb.w	r4, [sp, #34]	@ 0x22
	conf->X_Calibration_B = 0;
 8026cae:	f88d 4025 	strb.w	r4, [sp, #37]	@ 0x25
 8026cb2:	f88d 4026 	strb.w	r4, [sp, #38]	@ 0x26
 8026cb6:	f88d 4027 	strb.w	r4, [sp, #39]	@ 0x27
 8026cba:	f88d 4028 	strb.w	r4, [sp, #40]	@ 0x28
	conf->X_Calibration_Sensitivity = 0x3fc00000;	// 1.5
 8026cbe:	f88d 4029 	strb.w	r4, [sp, #41]	@ 0x29
 8026cc2:	f88d 402a 	strb.w	r4, [sp, #42]	@ 0x2a
	conf->Y_Calibration_A = 0x3f800000;				// 1
 8026cc6:	f88d 402d 	strb.w	r4, [sp, #45]	@ 0x2d
 8026cca:	f88d 402e 	strb.w	r4, [sp, #46]	@ 0x2e
	conf->Y_Calibration_B = 0;
 8026cce:	f88d 4031 	strb.w	r4, [sp, #49]	@ 0x31
 8026cd2:	f88d 4032 	strb.w	r4, [sp, #50]	@ 0x32
 8026cd6:	f88d 4033 	strb.w	r4, [sp, #51]	@ 0x33
 8026cda:	f88d 4034 	strb.w	r4, [sp, #52]	@ 0x34
	conf->Y_Calibration_Sensitivity = 0x3fc00000;	// 1.5
 8026cde:	f88d 4035 	strb.w	r4, [sp, #53]	@ 0x35
	conf->X_Calibration_A = 0x3f800000;				// 1
 8026ce2:	f88d 3024 	strb.w	r3, [sp, #36]	@ 0x24
	conf->X_Calibration_Sensitivity = 0x3fc00000;	// 1.5
 8026ce6:	f88d 302c 	strb.w	r3, [sp, #44]	@ 0x2c
	conf->Y_Calibration_A = 0x3f800000;				// 1
 8026cea:	f88d 3030 	strb.w	r3, [sp, #48]	@ 0x30
	conf->X_Calibration_A = 0x3f800000;				// 1
 8026cee:	f88d 7023 	strb.w	r7, [sp, #35]	@ 0x23
	conf->Y_Calibration_A = 0x3f800000;				// 1
 8026cf2:	f88d 702f 	strb.w	r7, [sp, #47]	@ 0x2f
	conf->X_Calibration_Sensitivity = 0x3fc00000;	// 1.5
 8026cf6:	f88d 602b 	strb.w	r6, [sp, #43]	@ 0x2b
	strcpy(conf->sensor_type, "AVS 1003LF");
 8026cfa:	f8cd 0015 	str.w	r0, [sp, #21]
 8026cfe:	f8ad 101d 	strh.w	r1, [sp, #29]
	conf->Y_Calibration_Sensitivity = 0x3fc00000;	// 1.5
 8026d02:	f88d 4036 	strb.w	r4, [sp, #54]	@ 0x36
}

bool Memory_SaveConfig(AdiConf_t* conf)
{
	conf->magicNumber = MAGIC_FLASH_NUMBER;
	if (configsInMemory >= MAX_CONFIGS)
 8026d06:	882a      	ldrh	r2, [r5, #0]
	conf->Z_Calibration_A = 0x3f800000;				// 1
 8026d08:	f88d 703b 	strb.w	r7, [sp, #59]	@ 0x3b
	if (configsInMemory >= MAX_CONFIGS)
 8026d0c:	2a63      	cmp	r2, #99	@ 0x63
	conf->magicNumber = MAGIC_FLASH_NUMBER;
 8026d0e:	f8cd 8000 	str.w	r8, [sp]
	conf->Y_Calibration_Sensitivity = 0x3fc00000;	// 1.5
 8026d12:	f88d 6037 	strb.w	r6, [sp, #55]	@ 0x37
	conf->Z_Calibration_Sensitivity = 0x3fc00000;	// 1.5
 8026d16:	f88d 6043 	strb.w	r6, [sp, #67]	@ 0x43
	conf->Y_Calibration_Sensitivity = 0x3fc00000;	// 1.5
 8026d1a:	f88d 3038 	strb.w	r3, [sp, #56]	@ 0x38
	conf->Z_Calibration_A = 0x3f800000;				// 1
 8026d1e:	f88d 4039 	strb.w	r4, [sp, #57]	@ 0x39
 8026d22:	f88d 403a 	strb.w	r4, [sp, #58]	@ 0x3a
 8026d26:	f88d 303c 	strb.w	r3, [sp, #60]	@ 0x3c
	conf->Z_Calibration_B = 0;
 8026d2a:	f88d 403d 	strb.w	r4, [sp, #61]	@ 0x3d
 8026d2e:	f88d 403e 	strb.w	r4, [sp, #62]	@ 0x3e
 8026d32:	f88d 403f 	strb.w	r4, [sp, #63]	@ 0x3f
 8026d36:	f88d 4040 	strb.w	r4, [sp, #64]	@ 0x40
	conf->Z_Calibration_Sensitivity = 0x3fc00000;	// 1.5
 8026d3a:	f88d 4041 	strb.w	r4, [sp, #65]	@ 0x41
 8026d3e:	f88d 4042 	strb.w	r4, [sp, #66]	@ 0x42
 8026d42:	f88d 3044 	strb.w	r3, [sp, #68]	@ 0x44
	if (configsInMemory >= MAX_CONFIGS)
 8026d46:	d82e      	bhi.n	8026da6 <Memory_Init+0x1aa>
	{
		Memory_LL_Clear();
		configsInMemory = 0;
	}
	PRINTF_MEM("Saving config\n");
 8026d48:	4978      	ldr	r1, [pc, #480]	@ (8026f2c <Memory_Init+0x330>)
 8026d4a:	2004      	movs	r0, #4
 8026d4c:	f001 f96c 	bl	8028028 <LOG_fprintf>
	conf->conf_id = configsInMemory;
 8026d50:	882b      	ldrh	r3, [r5, #0]
 8026d52:	f8ad 3004 	strh.w	r3, [sp, #4]
	bool response;
	response = Memory_LL_Save(MEMORY_FIRST_CONFIG_ADDRESS+configsInMemory*sizeof(AdiConf_t),(uint8_t*)conf,sizeof(AdiConf_t));
 8026d56:	eb03 1103 	add.w	r1, r3, r3, lsl #4
 8026d5a:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 8026d5e:	1d18      	adds	r0, r3, #4
 8026d60:	2245      	movs	r2, #69	@ 0x45
 8026d62:	4669      	mov	r1, sp
 8026d64:	f7ff fe26 	bl	80269b4 <Memory_LL_Save>
	memcpy(&currentConfig,conf,sizeof(AdiConf_t));
	configsInMemory++;
 8026d68:	882b      	ldrh	r3, [r5, #0]
 8026d6a:	3301      	adds	r3, #1
 8026d6c:	802b      	strh	r3, [r5, #0]
	return response;
 8026d6e:	e012      	b.n	8026d96 <Memory_Init+0x19a>
		Memory_LL_Read(MEMORY_FIRST_CONFIG_ADDRESS+(configsInMemory-1)*sizeof(AdiConf_t),(uint8_t*)&readedConf,sizeof(AdiConf_t));
 8026d70:	3b01      	subs	r3, #1
 8026d72:	eb03 1203 	add.w	r2, r3, r3, lsl #4
 8026d76:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 8026d7a:	1d18      	adds	r0, r3, #4
 8026d7c:	2245      	movs	r2, #69	@ 0x45
 8026d7e:	4669      	mov	r1, sp
 8026d80:	f7ff fe84 	bl	8026a8c <Memory_LL_Read>
		PRINTF_MEM("So far %d configs has been saved to memory\n",configsInMemory);
 8026d84:	496a      	ldr	r1, [pc, #424]	@ (8026f30 <Memory_Init+0x334>)
 8026d86:	882a      	ldrh	r2, [r5, #0]
 8026d88:	2004      	movs	r0, #4
 8026d8a:	f001 f94d 	bl	8028028 <LOG_fprintf>
	if (configsInMemory == 0)
 8026d8e:	882b      	ldrh	r3, [r5, #0]
 8026d90:	2b00      	cmp	r3, #0
 8026d92:	f43f af5b 	beq.w	8026c4c <Memory_Init+0x50>
	memcpy(&currentConfig,&readedConf,sizeof(AdiConf_t));
 8026d96:	2245      	movs	r2, #69	@ 0x45
 8026d98:	4669      	mov	r1, sp
 8026d9a:	4866      	ldr	r0, [pc, #408]	@ (8026f34 <Memory_Init+0x338>)
 8026d9c:	f002 ff41 	bl	8029c22 <memcpy>
}
 8026da0:	b024      	add	sp, #144	@ 0x90
 8026da2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		Memory_LL_Clear();
 8026da6:	f7ff fdad 	bl	8026904 <Memory_LL_Clear>
		configsInMemory = 0;
 8026daa:	802c      	strh	r4, [r5, #0]
 8026dac:	e7cc      	b.n	8026d48 <Memory_Init+0x14c>
			Memory_LL_Clear();
 8026dae:	f7ff fda9 	bl	8026904 <Memory_LL_Clear>
 8026db2:	f44f 7448 	mov.w	r4, #800	@ 0x320
	Flash_Init();
 8026db6:	f242 7310 	movw	r3, #10000	@ 0x2710
					__asm("nop");
 8026dba:	bf00      	nop
				for(int ii = 0; ii < 10000; ii++)
 8026dbc:	3b01      	subs	r3, #1
 8026dbe:	d1fc      	bne.n	8026dba <Memory_Init+0x1be>
			for(int i = 0; i < 800; i++)
 8026dc0:	3c01      	subs	r4, #1
 8026dc2:	d1f8      	bne.n	8026db6 <Memory_Init+0x1ba>
	conf->sensor_ID = 1;
 8026dc4:	2201      	movs	r2, #1
	conf->RS485_speed = speed_9600;
 8026dc6:	f44f 7398 	mov.w	r3, #304	@ 0x130
	conf->magicNumber = MAGIC_FLASH_NUMBER;
 8026dca:	f8df 8154 	ldr.w	r8, [pc, #340]	@ 8026f20 <Memory_Init+0x324>
	conf->sensor_ID = 1;
 8026dce:	f88d 204e 	strb.w	r2, [sp, #78]	@ 0x4e
	conf->RS485_speed = speed_9600;
 8026dd2:	f8ad 305b 	strh.w	r3, [sp, #91]	@ 0x5b
	conf->magicNumber = MAGIC_FLASH_NUMBER;
 8026dd6:	f8cd 8048 	str.w	r8, [sp, #72]	@ 0x48
	conf->conf_id = 0;
 8026dda:	f8ad 404c 	strh.w	r4, [sp, #76]	@ 0x4c
	uint32_t idA = HAL_GetUIDw0();
 8026dde:	f7fa f993 	bl	8021108 <HAL_GetUIDw0>
 8026de2:	4607      	mov	r7, r0
	uint32_t idB = HAL_GetUIDw1();
 8026de4:	f7fa f996 	bl	8021114 <HAL_GetUIDw1>
 8026de8:	4606      	mov	r6, r0
	uint32_t idC = HAL_GetUIDw2();
 8026dea:	f7fa f999 	bl	8021120 <HAL_GetUIDw2>
	strcpy(conf->sensor_type, "AVS 1003LF");
 8026dee:	4a4e      	ldr	r2, [pc, #312]	@ (8026f28 <Memory_Init+0x32c>)
	memcpy((conf->MAC)+8,&idC,4);
 8026df0:	f8cd 0057 	str.w	r0, [sp, #87]	@ 0x57
	strcpy(conf->sensor_type, "AVS 1003LF");
 8026df4:	ca03      	ldmia	r2!, {r0, r1}
	conf->X_Calibration_A = 0x3f800000;				// 1
 8026df6:	233f      	movs	r3, #63	@ 0x3f
	memcpy(conf->MAC,&idA,4);
 8026df8:	f8cd 704f 	str.w	r7, [sp, #79]	@ 0x4f
	memcpy((conf->MAC)+4,&idB,4);
 8026dfc:	f8cd 6053 	str.w	r6, [sp, #83]	@ 0x53
	conf->X_Calibration_A = 0x3f800000;				// 1
 8026e00:	f06f 077f 	mvn.w	r7, #127	@ 0x7f
	conf->X_Calibration_Sensitivity = 0x3fc00000;	// 1.5
 8026e04:	f06f 063f 	mvn.w	r6, #63	@ 0x3f
	strcpy(conf->sensor_type, "AVS 1003LF");
 8026e08:	f8cd 1061 	str.w	r1, [sp, #97]	@ 0x61
 8026e0c:	8811      	ldrh	r1, [r2, #0]
 8026e0e:	7892      	ldrb	r2, [r2, #2]
 8026e10:	f88d 2067 	strb.w	r2, [sp, #103]	@ 0x67
	conf->X_Calibration_A = 0x3f800000;				// 1
 8026e14:	f88d 4069 	strb.w	r4, [sp, #105]	@ 0x69
 8026e18:	f88d 406a 	strb.w	r4, [sp, #106]	@ 0x6a
	conf->X_Calibration_B = 0;
 8026e1c:	f88d 406d 	strb.w	r4, [sp, #109]	@ 0x6d
 8026e20:	f88d 406e 	strb.w	r4, [sp, #110]	@ 0x6e
 8026e24:	f88d 406f 	strb.w	r4, [sp, #111]	@ 0x6f
 8026e28:	f88d 4070 	strb.w	r4, [sp, #112]	@ 0x70
	conf->X_Calibration_Sensitivity = 0x3fc00000;	// 1.5
 8026e2c:	f88d 4071 	strb.w	r4, [sp, #113]	@ 0x71
 8026e30:	f88d 4072 	strb.w	r4, [sp, #114]	@ 0x72
	conf->Y_Calibration_A = 0x3f800000;				// 1
 8026e34:	f88d 4075 	strb.w	r4, [sp, #117]	@ 0x75
 8026e38:	f88d 4076 	strb.w	r4, [sp, #118]	@ 0x76
	conf->Y_Calibration_B = 0;
 8026e3c:	f88d 4079 	strb.w	r4, [sp, #121]	@ 0x79
 8026e40:	f88d 407a 	strb.w	r4, [sp, #122]	@ 0x7a
 8026e44:	f88d 407b 	strb.w	r4, [sp, #123]	@ 0x7b
 8026e48:	f88d 407c 	strb.w	r4, [sp, #124]	@ 0x7c
	conf->Y_Calibration_Sensitivity = 0x3fc00000;	// 1.5
 8026e4c:	f88d 407d 	strb.w	r4, [sp, #125]	@ 0x7d
	conf->X_Calibration_A = 0x3f800000;				// 1
 8026e50:	f88d 306c 	strb.w	r3, [sp, #108]	@ 0x6c
	conf->X_Calibration_Sensitivity = 0x3fc00000;	// 1.5
 8026e54:	f88d 3074 	strb.w	r3, [sp, #116]	@ 0x74
	conf->Y_Calibration_A = 0x3f800000;				// 1
 8026e58:	f88d 3078 	strb.w	r3, [sp, #120]	@ 0x78
	conf->X_Calibration_A = 0x3f800000;				// 1
 8026e5c:	f88d 706b 	strb.w	r7, [sp, #107]	@ 0x6b
	conf->Y_Calibration_A = 0x3f800000;				// 1
 8026e60:	f88d 7077 	strb.w	r7, [sp, #119]	@ 0x77
	conf->X_Calibration_Sensitivity = 0x3fc00000;	// 1.5
 8026e64:	f88d 6073 	strb.w	r6, [sp, #115]	@ 0x73
	strcpy(conf->sensor_type, "AVS 1003LF");
 8026e68:	f8cd 005d 	str.w	r0, [sp, #93]	@ 0x5d
 8026e6c:	f8ad 1065 	strh.w	r1, [sp, #101]	@ 0x65
	conf->Y_Calibration_Sensitivity = 0x3fc00000;	// 1.5
 8026e70:	f88d 407e 	strb.w	r4, [sp, #126]	@ 0x7e
	if (configsInMemory >= MAX_CONFIGS)
 8026e74:	882a      	ldrh	r2, [r5, #0]
	conf->Z_Calibration_A = 0x3f800000;				// 1
 8026e76:	f88d 7083 	strb.w	r7, [sp, #131]	@ 0x83
	if (configsInMemory >= MAX_CONFIGS)
 8026e7a:	2a63      	cmp	r2, #99	@ 0x63
	conf->Y_Calibration_Sensitivity = 0x3fc00000;	// 1.5
 8026e7c:	f88d 607f 	strb.w	r6, [sp, #127]	@ 0x7f
 8026e80:	f88d 3080 	strb.w	r3, [sp, #128]	@ 0x80
	conf->Z_Calibration_A = 0x3f800000;				// 1
 8026e84:	f88d 4081 	strb.w	r4, [sp, #129]	@ 0x81
 8026e88:	f88d 4082 	strb.w	r4, [sp, #130]	@ 0x82
 8026e8c:	f88d 3084 	strb.w	r3, [sp, #132]	@ 0x84
	conf->Z_Calibration_B = 0;
 8026e90:	f88d 4085 	strb.w	r4, [sp, #133]	@ 0x85
 8026e94:	f88d 4086 	strb.w	r4, [sp, #134]	@ 0x86
 8026e98:	f88d 4087 	strb.w	r4, [sp, #135]	@ 0x87
 8026e9c:	f88d 4088 	strb.w	r4, [sp, #136]	@ 0x88
	conf->Z_Calibration_Sensitivity = 0x3fc00000;	// 1.5
 8026ea0:	f88d 4089 	strb.w	r4, [sp, #137]	@ 0x89
 8026ea4:	f88d 408a 	strb.w	r4, [sp, #138]	@ 0x8a
 8026ea8:	f88d 608b 	strb.w	r6, [sp, #139]	@ 0x8b
 8026eac:	f88d 308c 	strb.w	r3, [sp, #140]	@ 0x8c
	conf->magicNumber = MAGIC_FLASH_NUMBER;
 8026eb0:	f8cd 8048 	str.w	r8, [sp, #72]	@ 0x48
	if (configsInMemory >= MAX_CONFIGS)
 8026eb4:	d82d      	bhi.n	8026f12 <Memory_Init+0x316>
	PRINTF_MEM("Saving config\n");
 8026eb6:	491d      	ldr	r1, [pc, #116]	@ (8026f2c <Memory_Init+0x330>)
 8026eb8:	2004      	movs	r0, #4
 8026eba:	f001 f8b5 	bl	8028028 <LOG_fprintf>
	conf->conf_id = configsInMemory;
 8026ebe:	882b      	ldrh	r3, [r5, #0]
 8026ec0:	f8ad 304c 	strh.w	r3, [sp, #76]	@ 0x4c
	response = Memory_LL_Save(MEMORY_FIRST_CONFIG_ADDRESS+configsInMemory*sizeof(AdiConf_t),(uint8_t*)conf,sizeof(AdiConf_t));
 8026ec4:	eb03 1003 	add.w	r0, r3, r3, lsl #4
 8026ec8:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 8026ecc:	2245      	movs	r2, #69	@ 0x45
 8026ece:	a912      	add	r1, sp, #72	@ 0x48
 8026ed0:	3004      	adds	r0, #4
 8026ed2:	f7ff fd6f 	bl	80269b4 <Memory_LL_Save>
	memcpy(&currentConfig,conf,sizeof(AdiConf_t));
 8026ed6:	2245      	movs	r2, #69	@ 0x45
 8026ed8:	4816      	ldr	r0, [pc, #88]	@ (8026f34 <Memory_Init+0x338>)
 8026eda:	a912      	add	r1, sp, #72	@ 0x48
 8026edc:	f002 fea1 	bl	8029c22 <memcpy>
	configsInMemory++;
 8026ee0:	882b      	ldrh	r3, [r5, #0]
 8026ee2:	3301      	adds	r3, #1
 8026ee4:	f44f 7248 	mov.w	r2, #800	@ 0x320
 8026ee8:	802b      	strh	r3, [r5, #0]
			Memory_LL_Clear();
 8026eea:	f242 7310 	movw	r3, #10000	@ 0x2710
					__asm("nop");
 8026eee:	bf00      	nop
				for(int ii = 0; ii < 10000; ii++)
 8026ef0:	3b01      	subs	r3, #1
 8026ef2:	d1fc      	bne.n	8026eee <Memory_Init+0x2f2>
			for(int i = 0; i < 800; i++)
 8026ef4:	3a01      	subs	r2, #1
 8026ef6:	d1f8      	bne.n	8026eea <Memory_Init+0x2ee>
 8026ef8:	f3bf 8f4f 	dsb	sy
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8026efc:	490e      	ldr	r1, [pc, #56]	@ (8026f38 <Memory_Init+0x33c>)
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8026efe:	4b0f      	ldr	r3, [pc, #60]	@ (8026f3c <Memory_Init+0x340>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8026f00:	68ca      	ldr	r2, [r1, #12]
 8026f02:	f402 62e0 	and.w	r2, r2, #1792	@ 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8026f06:	4313      	orrs	r3, r2
 8026f08:	60cb      	str	r3, [r1, #12]
 8026f0a:	f3bf 8f4f 	dsb	sy
    __NOP();
 8026f0e:	bf00      	nop
  for(;;)                                                           /* wait until reset */
 8026f10:	e7fd      	b.n	8026f0e <Memory_Init+0x312>
		Memory_LL_Clear();
 8026f12:	f7ff fcf7 	bl	8026904 <Memory_LL_Clear>
		configsInMemory = 0;
 8026f16:	802c      	strh	r4, [r5, #0]
 8026f18:	e7cd      	b.n	8026eb6 <Memory_Init+0x2ba>
 8026f1a:	bf00      	nop
 8026f1c:	20022520 	.word	0x20022520
 8026f20:	daeddaed 	.word	0xdaeddaed
 8026f24:	0802ea4c 	.word	0x0802ea4c
 8026f28:	0802ea30 	.word	0x0802ea30
 8026f2c:	0802ea3c 	.word	0x0802ea3c
 8026f30:	0802ea7c 	.word	0x0802ea7c
 8026f34:	20022524 	.word	0x20022524
 8026f38:	e000ed00 	.word	0xe000ed00
 8026f3c:	05fa0004 	.word	0x05fa0004

08026f40 <Memory_SaveConfig>:
{
 8026f40:	b570      	push	{r4, r5, r6, lr}
	if (configsInMemory >= MAX_CONFIGS)
 8026f42:	4d16      	ldr	r5, [pc, #88]	@ (8026f9c <Memory_SaveConfig+0x5c>)
 8026f44:	8829      	ldrh	r1, [r5, #0]
	conf->magicNumber = MAGIC_FLASH_NUMBER;
 8026f46:	f06f 0212 	mvn.w	r2, #18
 8026f4a:	f06f 0325 	mvn.w	r3, #37	@ 0x25
	if (configsInMemory >= MAX_CONFIGS)
 8026f4e:	2963      	cmp	r1, #99	@ 0x63
{
 8026f50:	4604      	mov	r4, r0
	conf->magicNumber = MAGIC_FLASH_NUMBER;
 8026f52:	7002      	strb	r2, [r0, #0]
 8026f54:	7043      	strb	r3, [r0, #1]
 8026f56:	7082      	strb	r2, [r0, #2]
 8026f58:	70c3      	strb	r3, [r0, #3]
	if (configsInMemory >= MAX_CONFIGS)
 8026f5a:	d81a      	bhi.n	8026f92 <Memory_SaveConfig+0x52>
	PRINTF_MEM("Saving config\n");
 8026f5c:	4910      	ldr	r1, [pc, #64]	@ (8026fa0 <Memory_SaveConfig+0x60>)
 8026f5e:	2004      	movs	r0, #4
 8026f60:	f001 f862 	bl	8028028 <LOG_fprintf>
	conf->conf_id = configsInMemory;
 8026f64:	8828      	ldrh	r0, [r5, #0]
 8026f66:	80a0      	strh	r0, [r4, #4]
	response = Memory_LL_Save(MEMORY_FIRST_CONFIG_ADDRESS+configsInMemory*sizeof(AdiConf_t),(uint8_t*)conf,sizeof(AdiConf_t));
 8026f68:	eb00 1300 	add.w	r3, r0, r0, lsl #4
 8026f6c:	eb00 0083 	add.w	r0, r0, r3, lsl #2
 8026f70:	4621      	mov	r1, r4
 8026f72:	2245      	movs	r2, #69	@ 0x45
 8026f74:	3004      	adds	r0, #4
 8026f76:	f7ff fd1d 	bl	80269b4 <Memory_LL_Save>
	memcpy(&currentConfig,conf,sizeof(AdiConf_t));
 8026f7a:	4621      	mov	r1, r4
	response = Memory_LL_Save(MEMORY_FIRST_CONFIG_ADDRESS+configsInMemory*sizeof(AdiConf_t),(uint8_t*)conf,sizeof(AdiConf_t));
 8026f7c:	4603      	mov	r3, r0
	memcpy(&currentConfig,conf,sizeof(AdiConf_t));
 8026f7e:	2245      	movs	r2, #69	@ 0x45
 8026f80:	4808      	ldr	r0, [pc, #32]	@ (8026fa4 <Memory_SaveConfig+0x64>)
	response = Memory_LL_Save(MEMORY_FIRST_CONFIG_ADDRESS+configsInMemory*sizeof(AdiConf_t),(uint8_t*)conf,sizeof(AdiConf_t));
 8026f82:	461c      	mov	r4, r3
	memcpy(&currentConfig,conf,sizeof(AdiConf_t));
 8026f84:	f002 fe4d 	bl	8029c22 <memcpy>
	configsInMemory++;
 8026f88:	882b      	ldrh	r3, [r5, #0]
 8026f8a:	3301      	adds	r3, #1
}
 8026f8c:	4620      	mov	r0, r4
	configsInMemory++;
 8026f8e:	802b      	strh	r3, [r5, #0]
}
 8026f90:	bd70      	pop	{r4, r5, r6, pc}
 8026f92:	2600      	movs	r6, #0
		Memory_LL_Clear();
 8026f94:	f7ff fcb6 	bl	8026904 <Memory_LL_Clear>
		configsInMemory = 0;
 8026f98:	802e      	strh	r6, [r5, #0]
 8026f9a:	e7df      	b.n	8026f5c <Memory_SaveConfig+0x1c>
 8026f9c:	20022520 	.word	0x20022520
 8026fa0:	0802ea3c 	.word	0x0802ea3c
 8026fa4:	20022524 	.word	0x20022524

08026fa8 <Memory_TakeConfig>:

void Memory_TakeConfig(AdiConf_t* conf)
{
 8026fa8:	b508      	push	{r3, lr}
	memcpy(conf,&currentConfig,sizeof(AdiConf_t));
 8026faa:	4905      	ldr	r1, [pc, #20]	@ (8026fc0 <Memory_TakeConfig+0x18>)
 8026fac:	2245      	movs	r2, #69	@ 0x45
 8026fae:	f002 fe38 	bl	8029c22 <memcpy>
	PRINTF_MEM("Config taken\n");
}
 8026fb2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	PRINTF_MEM("Config taken\n");
 8026fb6:	4903      	ldr	r1, [pc, #12]	@ (8026fc4 <Memory_TakeConfig+0x1c>)
 8026fb8:	2004      	movs	r0, #4
 8026fba:	f001 b835 	b.w	8028028 <LOG_fprintf>
 8026fbe:	bf00      	nop
 8026fc0:	20022524 	.word	0x20022524
 8026fc4:	0802eaa8 	.word	0x0802eaa8

08026fc8 <Memory_ShowConfig>:

void Memory_ShowConfig(AdiConf_t* conf)
{
 8026fc8:	b510      	push	{r4, lr}
 8026fca:	4604      	mov	r4, r0
 8026fcc:	b090      	sub	sp, #64	@ 0x40
	PRINTF_MEM("Sensor config:\n");
 8026fce:	4969      	ldr	r1, [pc, #420]	@ (8027174 <Memory_ShowConfig+0x1ac>)
 8026fd0:	2004      	movs	r0, #4
 8026fd2:	f001 f829 	bl	8028028 <LOG_fprintf>
	PRINTF_MEM("Config id: 0x%02X\n",conf->conf_id);
 8026fd6:	4968      	ldr	r1, [pc, #416]	@ (8027178 <Memory_ShowConfig+0x1b0>)
 8026fd8:	88a2      	ldrh	r2, [r4, #4]
 8026fda:	2004      	movs	r0, #4
 8026fdc:	f001 f824 	bl	8028028 <LOG_fprintf>
	PRINTF_MEM("Sensor ID: 0x%02X\n",conf->sensor_ID);
 8026fe0:	4966      	ldr	r1, [pc, #408]	@ (802717c <Memory_ShowConfig+0x1b4>)
 8026fe2:	79a2      	ldrb	r2, [r4, #6]
 8026fe4:	2004      	movs	r0, #4
 8026fe6:	f001 f81f 	bl	8028028 <LOG_fprintf>
	PRINTF_MEM("Sensor MAC: %02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X\n",conf->MAC[0],conf->MAC[1],conf->MAC[2],conf->MAC[3],conf->MAC[4],conf->MAC[5],conf->MAC[6],conf->MAC[7],conf->MAC[8],conf->MAC[9],conf->MAC[10],conf->MAC[11]);
 8026fea:	7ca2      	ldrb	r2, [r4, #18]
 8026fec:	7c63      	ldrb	r3, [r4, #17]
 8026fee:	4964      	ldr	r1, [pc, #400]	@ (8027180 <Memory_ShowConfig+0x1b8>)
 8026ff0:	e9cd 3208 	strd	r3, r2, [sp, #32]
 8026ff4:	7c22      	ldrb	r2, [r4, #16]
 8026ff6:	7be3      	ldrb	r3, [r4, #15]
 8026ff8:	e9cd 3206 	strd	r3, r2, [sp, #24]
 8026ffc:	7ba2      	ldrb	r2, [r4, #14]
 8026ffe:	7b63      	ldrb	r3, [r4, #13]
 8027000:	e9cd 3204 	strd	r3, r2, [sp, #16]
 8027004:	7b22      	ldrb	r2, [r4, #12]
 8027006:	7ae3      	ldrb	r3, [r4, #11]
 8027008:	e9cd 3202 	strd	r3, r2, [sp, #8]
 802700c:	7aa2      	ldrb	r2, [r4, #10]
 802700e:	7a63      	ldrb	r3, [r4, #9]
 8027010:	e9cd 3200 	strd	r3, r2, [sp]
 8027014:	2004      	movs	r0, #4
 8027016:	7a23      	ldrb	r3, [r4, #8]
 8027018:	79e2      	ldrb	r2, [r4, #7]
 802701a:	f001 f805 	bl	8028028 <LOG_fprintf>
	PRINTF_MEM("Sensor Type: %c %c %c %c %c %c %c %c",conf->sensor_type[0],conf->sensor_type[1],conf->sensor_type[2],conf->sensor_type[3],conf->sensor_type[4],conf->sensor_type[5],conf->sensor_type[6],conf->sensor_type[7]);
 802701e:	7f22      	ldrb	r2, [r4, #28]
 8027020:	7ee3      	ldrb	r3, [r4, #27]
 8027022:	4958      	ldr	r1, [pc, #352]	@ (8027184 <Memory_ShowConfig+0x1bc>)
 8027024:	e9cd 3204 	strd	r3, r2, [sp, #16]
 8027028:	7ea2      	ldrb	r2, [r4, #26]
 802702a:	7e63      	ldrb	r3, [r4, #25]
 802702c:	e9cd 3202 	strd	r3, r2, [sp, #8]
 8027030:	7e22      	ldrb	r2, [r4, #24]
 8027032:	7de3      	ldrb	r3, [r4, #23]
 8027034:	e9cd 3200 	strd	r3, r2, [sp]
 8027038:	2004      	movs	r0, #4
 802703a:	7da3      	ldrb	r3, [r4, #22]
 802703c:	7d62      	ldrb	r2, [r4, #21]
 802703e:	f000 fff3 	bl	8028028 <LOG_fprintf>
	PRINTF_MEM("\n");
 8027042:	4951      	ldr	r1, [pc, #324]	@ (8027188 <Memory_ShowConfig+0x1c0>)
 8027044:	2004      	movs	r0, #4
 8027046:	f000 ffef 	bl	8028028 <LOG_fprintf>
	PRINTF_MEM("Os X: %08X, %08X, %08X \n", conf->X_Calibration_A, conf->X_Calibration_B, conf->X_Calibration_Sensitivity);
 802704a:	f8d4 2029 	ldr.w	r2, [r4, #41]	@ 0x29
 802704e:	f8d4 3025 	ldr.w	r3, [r4, #37]	@ 0x25
 8027052:	9200      	str	r2, [sp, #0]
 8027054:	494d      	ldr	r1, [pc, #308]	@ (802718c <Memory_ShowConfig+0x1c4>)
 8027056:	f8d4 2021 	ldr.w	r2, [r4, #33]	@ 0x21
 802705a:	2004      	movs	r0, #4
 802705c:	f000 ffe4 	bl	8028028 <LOG_fprintf>
	PRINTF_MEM("Os Y: %08X, %08X, %08X \n", conf->Y_Calibration_A, conf->Y_Calibration_B, conf->Y_Calibration_Sensitivity);
 8027060:	f8d4 2035 	ldr.w	r2, [r4, #53]	@ 0x35
 8027064:	f8d4 3031 	ldr.w	r3, [r4, #49]	@ 0x31
 8027068:	9200      	str	r2, [sp, #0]
 802706a:	4949      	ldr	r1, [pc, #292]	@ (8027190 <Memory_ShowConfig+0x1c8>)
 802706c:	f8d4 202d 	ldr.w	r2, [r4, #45]	@ 0x2d
 8027070:	2004      	movs	r0, #4
 8027072:	f000 ffd9 	bl	8028028 <LOG_fprintf>
	PRINTF_MEM("Os Z: %08X, %08X, %08X \n", conf->Z_Calibration_A, conf->Z_Calibration_B, conf->Z_Calibration_Sensitivity);
 8027076:	f8d4 2041 	ldr.w	r2, [r4, #65]	@ 0x41
 802707a:	f8d4 303d 	ldr.w	r3, [r4, #61]	@ 0x3d
 802707e:	9200      	str	r2, [sp, #0]
 8027080:	4944      	ldr	r1, [pc, #272]	@ (8027194 <Memory_ShowConfig+0x1cc>)
 8027082:	f8d4 2039 	ldr.w	r2, [r4, #57]	@ 0x39
 8027086:	2004      	movs	r0, #4
 8027088:	f000 ffce 	bl	8028028 <LOG_fprintf>
	char name[20];
	memset(name,0,20);
	switch (conf->RS485_speed)
 802708c:	7ce2      	ldrb	r2, [r4, #19]
	memset(name,0,20);
 802708e:	ab0b      	add	r3, sp, #44	@ 0x2c
 8027090:	2100      	movs	r1, #0
	switch (conf->RS485_speed)
 8027092:	2a70      	cmp	r2, #112	@ 0x70
	memset(name,0,20);
 8027094:	e9c3 1102 	strd	r1, r1, [r3, #8]
 8027098:	6119      	str	r1, [r3, #16]
	switch (conf->RS485_speed)
 802709a:	d051      	beq.n	8027140 <Memory_ShowConfig+0x178>
 802709c:	d90d      	bls.n	80270ba <Memory_ShowConfig+0xf2>
 802709e:	2ab0      	cmp	r2, #176	@ 0xb0
 80270a0:	d045      	beq.n	802712e <Memory_ShowConfig+0x166>
 80270a2:	d832      	bhi.n	802710a <Memory_ShowConfig+0x142>
 80270a4:	2a90      	cmp	r2, #144	@ 0x90
 80270a6:	d029      	beq.n	80270fc <Memory_ShowConfig+0x134>
 80270a8:	2aa0      	cmp	r2, #160	@ 0xa0
 80270aa:	d047      	beq.n	802713c <Memory_ShowConfig+0x174>
 80270ac:	2a80      	cmp	r2, #128	@ 0x80
 80270ae:	d14c      	bne.n	802714a <Memory_ShowConfig+0x182>
		break;
	case speed_33600:
		sprintf(name,"speed_33600");
		break;
	case speed_38400:
		sprintf(name,"speed_38400");
 80270b0:	4a39      	ldr	r2, [pc, #228]	@ (8027198 <Memory_ShowConfig+0x1d0>)
 80270b2:	ca07      	ldmia	r2, {r0, r1, r2}
 80270b4:	e883 0007 	stmia.w	r3, {r0, r1, r2}
		break;
 80270b8:	e011      	b.n	80270de <Memory_ShowConfig+0x116>
	switch (conf->RS485_speed)
 80270ba:	2a40      	cmp	r2, #64	@ 0x40
 80270bc:	d04f      	beq.n	802715e <Memory_ShowConfig+0x196>
 80270be:	d82d      	bhi.n	802711c <Memory_ShowConfig+0x154>
 80270c0:	2a20      	cmp	r2, #32
 80270c2:	d020      	beq.n	8027106 <Memory_ShowConfig+0x13e>
 80270c4:	2a30      	cmp	r2, #48	@ 0x30
 80270c6:	d048      	beq.n	802715a <Memory_ShowConfig+0x192>
 80270c8:	2a10      	cmp	r2, #16
 80270ca:	d13e      	bne.n	802714a <Memory_ShowConfig+0x182>
		sprintf(name,"speed_4800");
 80270cc:	4a33      	ldr	r2, [pc, #204]	@ (802719c <Memory_ShowConfig+0x1d4>)
		sprintf(name,"speed_7200");
 80270ce:	ca07      	ldmia	r2, {r0, r1, r2}
 80270d0:	469c      	mov	ip, r3
 80270d2:	e8ac 0003 	stmia.w	ip!, {r0, r1}
 80270d6:	0c11      	lsrs	r1, r2, #16
 80270d8:	f8ac 2000 	strh.w	r2, [ip]
 80270dc:	7299      	strb	r1, [r3, #10]
		break;
	default:
		sprintf(name,"bad speed");
		break;
	}
	PRINTF_MEM("Sensor speed: %s\n", name);
 80270de:	461a      	mov	r2, r3
 80270e0:	492f      	ldr	r1, [pc, #188]	@ (80271a0 <Memory_ShowConfig+0x1d8>)
 80270e2:	2004      	movs	r0, #4
 80270e4:	f000 ffa0 	bl	8028028 <LOG_fprintf>
	PRINTF_MEM("Sensor protocol: %s\n", enum2str(conf->protocol));
 80270e8:	7d20      	ldrb	r0, [r4, #20]
 80270ea:	f000 ff8d 	bl	8028008 <enum2str>
 80270ee:	492d      	ldr	r1, [pc, #180]	@ (80271a4 <Memory_ShowConfig+0x1dc>)
 80270f0:	4602      	mov	r2, r0
 80270f2:	2004      	movs	r0, #4
 80270f4:	f000 ff98 	bl	8028028 <LOG_fprintf>
}
 80270f8:	b010      	add	sp, #64	@ 0x40
 80270fa:	bd10      	pop	{r4, pc}
		sprintf(name,"speed_57600");
 80270fc:	4a2a      	ldr	r2, [pc, #168]	@ (80271a8 <Memory_ShowConfig+0x1e0>)
 80270fe:	ca07      	ldmia	r2, {r0, r1, r2}
 8027100:	e883 0007 	stmia.w	r3, {r0, r1, r2}
		break;
 8027104:	e7eb      	b.n	80270de <Memory_ShowConfig+0x116>
		sprintf(name,"speed_7200");
 8027106:	4a29      	ldr	r2, [pc, #164]	@ (80271ac <Memory_ShowConfig+0x1e4>)
 8027108:	e7e1      	b.n	80270ce <Memory_ShowConfig+0x106>
	switch (conf->RS485_speed)
 802710a:	2ac0      	cmp	r2, #192	@ 0xc0
 802710c:	d02c      	beq.n	8027168 <Memory_ShowConfig+0x1a0>
 802710e:	2ad0      	cmp	r2, #208	@ 0xd0
 8027110:	d11b      	bne.n	802714a <Memory_ShowConfig+0x182>
		sprintf(name,"speed_1500k");
 8027112:	4a27      	ldr	r2, [pc, #156]	@ (80271b0 <Memory_ShowConfig+0x1e8>)
 8027114:	ca07      	ldmia	r2, {r0, r1, r2}
 8027116:	e883 0007 	stmia.w	r3, {r0, r1, r2}
		break;
 802711a:	e7e0      	b.n	80270de <Memory_ShowConfig+0x116>
	switch (conf->RS485_speed)
 802711c:	2a50      	cmp	r2, #80	@ 0x50
 802711e:	d008      	beq.n	8027132 <Memory_ShowConfig+0x16a>
 8027120:	2a60      	cmp	r2, #96	@ 0x60
 8027122:	d112      	bne.n	802714a <Memory_ShowConfig+0x182>
		sprintf(name,"speed_28800");
 8027124:	4a23      	ldr	r2, [pc, #140]	@ (80271b4 <Memory_ShowConfig+0x1ec>)
 8027126:	ca07      	ldmia	r2, {r0, r1, r2}
 8027128:	e883 0007 	stmia.w	r3, {r0, r1, r2}
		break;
 802712c:	e7d7      	b.n	80270de <Memory_ShowConfig+0x116>
		sprintf(name,"speed_500k");
 802712e:	4a22      	ldr	r2, [pc, #136]	@ (80271b8 <Memory_ShowConfig+0x1f0>)
 8027130:	e7cd      	b.n	80270ce <Memory_ShowConfig+0x106>
		sprintf(name,"speed_19200");
 8027132:	4a22      	ldr	r2, [pc, #136]	@ (80271bc <Memory_ShowConfig+0x1f4>)
 8027134:	ca07      	ldmia	r2, {r0, r1, r2}
 8027136:	e883 0007 	stmia.w	r3, {r0, r1, r2}
		break;
 802713a:	e7d0      	b.n	80270de <Memory_ShowConfig+0x116>
		sprintf(name,"speed_115k");
 802713c:	4a20      	ldr	r2, [pc, #128]	@ (80271c0 <Memory_ShowConfig+0x1f8>)
 802713e:	e7c6      	b.n	80270ce <Memory_ShowConfig+0x106>
		sprintf(name,"speed_33600");
 8027140:	4a20      	ldr	r2, [pc, #128]	@ (80271c4 <Memory_ShowConfig+0x1fc>)
 8027142:	ca07      	ldmia	r2, {r0, r1, r2}
 8027144:	e883 0007 	stmia.w	r3, {r0, r1, r2}
		break;
 8027148:	e7c9      	b.n	80270de <Memory_ShowConfig+0x116>
		sprintf(name,"bad speed");
 802714a:	4a1f      	ldr	r2, [pc, #124]	@ (80271c8 <Memory_ShowConfig+0x200>)
 802714c:	ca07      	ldmia	r2, {r0, r1, r2}
 802714e:	469c      	mov	ip, r3
 8027150:	e8ac 0003 	stmia.w	ip!, {r0, r1}
 8027154:	f8ac 2000 	strh.w	r2, [ip]
		break;
 8027158:	e7c1      	b.n	80270de <Memory_ShowConfig+0x116>
		sprintf(name,"speed_9600");
 802715a:	4a1c      	ldr	r2, [pc, #112]	@ (80271cc <Memory_ShowConfig+0x204>)
 802715c:	e7b7      	b.n	80270ce <Memory_ShowConfig+0x106>
		sprintf(name,"speed_14400");
 802715e:	4a1c      	ldr	r2, [pc, #112]	@ (80271d0 <Memory_ShowConfig+0x208>)
 8027160:	ca07      	ldmia	r2, {r0, r1, r2}
 8027162:	e883 0007 	stmia.w	r3, {r0, r1, r2}
		break;
 8027166:	e7ba      	b.n	80270de <Memory_ShowConfig+0x116>
		sprintf(name,"speed_1000k");
 8027168:	4a1a      	ldr	r2, [pc, #104]	@ (80271d4 <Memory_ShowConfig+0x20c>)
 802716a:	ca07      	ldmia	r2, {r0, r1, r2}
 802716c:	e883 0007 	stmia.w	r3, {r0, r1, r2}
		break;
 8027170:	e7b5      	b.n	80270de <Memory_ShowConfig+0x116>
 8027172:	bf00      	nop
 8027174:	0802eab8 	.word	0x0802eab8
 8027178:	0802eac8 	.word	0x0802eac8
 802717c:	0802eadc 	.word	0x0802eadc
 8027180:	0802eaf0 	.word	0x0802eaf0
 8027184:	0802eb3c 	.word	0x0802eb3c
 8027188:	0802eb64 	.word	0x0802eb64
 802718c:	0802eb68 	.word	0x0802eb68
 8027190:	0802eb84 	.word	0x0802eb84
 8027194:	0802eba0 	.word	0x0802eba0
 8027198:	0802e6ec 	.word	0x0802e6ec
 802719c:	0802e6a4 	.word	0x0802e6a4
 80271a0:	0802ebbc 	.word	0x0802ebbc
 80271a4:	0802ebd0 	.word	0x0802ebd0
 80271a8:	0802e6f8 	.word	0x0802e6f8
 80271ac:	0802e6b0 	.word	0x0802e6b0
 80271b0:	0802e728 	.word	0x0802e728
 80271b4:	0802e6d4 	.word	0x0802e6d4
 80271b8:	0802e710 	.word	0x0802e710
 80271bc:	0802e758 	.word	0x0802e758
 80271c0:	0802e704 	.word	0x0802e704
 80271c4:	0802e6e0 	.word	0x0802e6e0
 80271c8:	0802e734 	.word	0x0802e734
 80271cc:	0802e6bc 	.word	0x0802e6bc
 80271d0:	0802e6c8 	.word	0x0802e6c8
 80271d4:	0802e71c 	.word	0x0802e71c

080271d8 <modbusRTU_loop>:
}

///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
void modbusRTU_loop(void)
{
 80271d8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	mess.data = (uint8_t *)message_data;
 80271dc:	4cc0      	ldr	r4, [pc, #768]	@ (80274e0 <modbusRTU_loop+0x308>)

static uint8_t modbusRTURingBuffer_GetChar(ring_buffer_t *ring_buffer, char *c)
{
	if ((ring_buffer) && (c))
	{
		if (ring_buffer->count > 0)
 80271de:	f8d4 311c 	ldr.w	r3, [r4, #284]	@ 0x11c
 80271e2:	f104 020c 	add.w	r2, r4, #12
 80271e6:	2b00      	cmp	r3, #0
{
 80271e8:	b082      	sub	sp, #8
	mess.data = (uint8_t *)message_data;
 80271ea:	6062      	str	r2, [r4, #4]
 80271ec:	dc0e      	bgt.n	802720c <modbusRTU_loop+0x34>
	if (!frameInProgress)
 80271ee:	f894 2129 	ldrb.w	r2, [r4, #297]	@ 0x129
	if (state == STATE_MESSAGE_RECEIVED)
 80271f2:	f8d4 312c 	ldr.w	r3, [r4, #300]	@ 0x12c
 80271f6:	2b02      	cmp	r3, #2
		state = STATE_IDLE;
 80271f8:	bf04      	itt	eq
 80271fa:	2300      	moveq	r3, #0
 80271fc:	f8c4 312c 	streq.w	r3, [r4, #300]	@ 0x12c
	if (!frameInProgress)
 8027200:	2a00      	cmp	r2, #0
 8027202:	f000 8100 	beq.w	8027406 <modbusRTU_loop+0x22e>
	_modbusRTU_processMessage();
}
 8027206:	b002      	add	sp, #8
 8027208:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802720c:	4db5      	ldr	r5, [pc, #724]	@ (80274e4 <modbusRTU_loop+0x30c>)
	uint8_t message_completed = 0;
 802720e:	2700      	movs	r7, #0
		{
			*c = ring_buffer->data[ring_buffer->tail++];
 8027210:	f8d4 0110 	ldr.w	r0, [r4, #272]	@ 0x110
 8027214:	f8d4 2118 	ldr.w	r2, [r4, #280]	@ 0x118
		switch (message_index_rtu)
 8027218:	f8d4 6124 	ldr.w	r6, [r4, #292]	@ 0x124
 802721c:	1c51      	adds	r1, r2, #1
 802721e:	f8c4 1118 	str.w	r1, [r4, #280]	@ 0x118
			ring_buffer->count--;
 8027222:	3b01      	subs	r3, #1
			*c = ring_buffer->data[ring_buffer->tail++];
 8027224:	5c82      	ldrb	r2, [r0, r2]
			ring_buffer->count--;
 8027226:	f8c4 311c 	str.w	r3, [r4, #284]	@ 0x11c
			if (ring_buffer->tail >= ring_buffer->size)
 802722a:	f8d4 c120 	ldr.w	ip, [r4, #288]	@ 0x120
				ring_buffer->tail = 0;
 802722e:	4561      	cmp	r1, ip
 8027230:	bfa8      	it	ge
 8027232:	2100      	movge	r1, #0
 8027234:	f8c4 1118 	str.w	r1, [r4, #280]	@ 0x118
 8027238:	2e00      	cmp	r6, #0
 802723a:	d076      	beq.n	802732a <modbusRTU_loop+0x152>
 802723c:	2e01      	cmp	r6, #1
 802723e:	d04a      	beq.n	80272d6 <modbusRTU_loop+0xfe>
			if (message_index_rtu == 6 && mess.function == 0x10)
 8027240:	2e06      	cmp	r6, #6
 8027242:	7861      	ldrb	r1, [r4, #1]
 8027244:	f000 80a8 	beq.w	8027398 <modbusRTU_loop+0x1c0>
		if (desc[i].function_code == code)
 8027248:	68a8      	ldr	r0, [r5, #8]
 802724a:	4288      	cmp	r0, r1
 802724c:	f000 8126 	beq.w	802749c <modbusRTU_loop+0x2c4>
 8027250:	6968      	ldr	r0, [r5, #20]
 8027252:	4281      	cmp	r1, r0
 8027254:	f000 8165 	beq.w	8027522 <modbusRTU_loop+0x34a>
 8027258:	6a28      	ldr	r0, [r5, #32]
 802725a:	4281      	cmp	r1, r0
 802725c:	f000 8164 	beq.w	8027528 <modbusRTU_loop+0x350>
 8027260:	6ae8      	ldr	r0, [r5, #44]	@ 0x2c
 8027262:	4281      	cmp	r1, r0
 8027264:	f000 8165 	beq.w	8027532 <modbusRTU_loop+0x35a>
						frameInProgress = false;
 8027268:	2200      	movs	r2, #0
 802726a:	f884 2129 	strb.w	r2, [r4, #297]	@ 0x129
		if (ring_buffer->count > 0)
 802726e:	2b00      	cmp	r3, #0
 8027270:	dcce      	bgt.n	8027210 <modbusRTU_loop+0x38>
	if (message_completed)
 8027272:	2f00      	cmp	r7, #0
 8027274:	d0bd      	beq.n	80271f2 <modbusRTU_loop+0x1a>
		if (wCRCWord != mess.error_check)
 8027276:	8960      	ldrh	r0, [r4, #10]
 8027278:	8869      	ldrh	r1, [r5, #2]
 802727a:	4288      	cmp	r0, r1
 802727c:	f000 809d 	beq.w	80273ba <modbusRTU_loop+0x1e2>
			modbusRTURingBuffer_GoBack((ring_buffer_t *)&data_ring_buffer, ringBufferTail + 2); //skip bad address and function code
 8027280:	686a      	ldr	r2, [r5, #4]
			frameInProgress = false;
 8027282:	2100      	movs	r1, #0
	return 1;
}

static void modbusRTURingBuffer_GoBack(ring_buffer_t *ring_buffer, int whereToGo)
{
	if (ring_buffer && whereToGo >= 0)
 8027284:	3202      	adds	r2, #2
 8027286:	f884 1129 	strb.w	r1, [r4, #297]	@ 0x129
 802728a:	d412      	bmi.n	80272b2 <modbusRTU_loop+0xda>
	{
		int wentBackHowMany = (ring_buffer->tail - whereToGo + ring_buffer->size) % ring_buffer->size;
 802728c:	f8d4 0120 	ldr.w	r0, [r4, #288]	@ 0x120
 8027290:	f8d4 1118 	ldr.w	r1, [r4, #280]	@ 0x118
 8027294:	1a89      	subs	r1, r1, r2
 8027296:	4401      	add	r1, r0
 8027298:	fb91 f6f0 	sdiv	r6, r1, r0
 802729c:	fb00 1116 	mls	r1, r0, r6, r1
		ring_buffer->tail = whereToGo % ring_buffer->size;
		ring_buffer->count += wentBackHowMany;
 80272a0:	4419      	add	r1, r3
		ring_buffer->tail = whereToGo % ring_buffer->size;
 80272a2:	fb92 f3f0 	sdiv	r3, r2, r0
 80272a6:	fb00 2213 	mls	r2, r0, r3, r2
 80272aa:	f8c4 2118 	str.w	r2, [r4, #280]	@ 0x118
		ring_buffer->count += wentBackHowMany;
 80272ae:	f8c4 111c 	str.w	r1, [r4, #284]	@ 0x11c
	if (state == STATE_MESSAGE_RECEIVED)
 80272b2:	f8d4 312c 	ldr.w	r3, [r4, #300]	@ 0x12c
 80272b6:	2b02      	cmp	r3, #2
 80272b8:	d102      	bne.n	80272c0 <modbusRTU_loop+0xe8>
		state = STATE_IDLE;
 80272ba:	2300      	movs	r3, #0
 80272bc:	f8c4 312c 	str.w	r3, [r4, #300]	@ 0x12c
		broadcast_id_mode = 0;
 80272c0:	2300      	movs	r3, #0
		wCRCWord = 0xFFFF;
 80272c2:	f64f 72ff 	movw	r2, #65535	@ 0xffff
		broadcast_id_mode = 0;
 80272c6:	f884 312a 	strb.w	r3, [r4, #298]	@ 0x12a
		message_index_rtu = 0;
 80272ca:	f8c4 3124 	str.w	r3, [r4, #292]	@ 0x124
		wCRCWord = 0xFFFF;
 80272ce:	806a      	strh	r2, [r5, #2]
}
 80272d0:	b002      	add	sp, #8
 80272d2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (desc[i].function_code == code)
 80272d6:	68a8      	ldr	r0, [r5, #8]
			mess.function = c;
 80272d8:	7062      	strb	r2, [r4, #1]
		if (desc[i].function_code == code)
 80272da:	4290      	cmp	r0, r2
 80272dc:	f000 811f 	beq.w	802751e <modbusRTU_loop+0x346>
 80272e0:	6968      	ldr	r0, [r5, #20]
 80272e2:	4282      	cmp	r2, r0
 80272e4:	d03f      	beq.n	8027366 <modbusRTU_loop+0x18e>
 80272e6:	6a28      	ldr	r0, [r5, #32]
 80272e8:	4282      	cmp	r2, r0
 80272ea:	f000 8120 	beq.w	802752e <modbusRTU_loop+0x356>
 80272ee:	6ae8      	ldr	r0, [r5, #44]	@ 0x2c
 80272f0:	4282      	cmp	r2, r0
 80272f2:	d037      	beq.n	8027364 <modbusRTU_loop+0x18c>
				modbusRTURingBuffer_GoBack((ring_buffer_t *)&data_ring_buffer, ringBufferTail + 1);  //Maybe the address is good
 80272f4:	6868      	ldr	r0, [r5, #4]
	if (ring_buffer && whereToGo >= 0)
 80272f6:	3001      	adds	r0, #1
 80272f8:	d40e      	bmi.n	8027318 <modbusRTU_loop+0x140>
		int wentBackHowMany = (ring_buffer->tail - whereToGo + ring_buffer->size) % ring_buffer->size;
 80272fa:	1a09      	subs	r1, r1, r0
 80272fc:	4461      	add	r1, ip
 80272fe:	fb91 f5fc 	sdiv	r5, r1, ip
 8027302:	fb0c 1115 	mls	r1, ip, r5, r1
		ring_buffer->count += wentBackHowMany;
 8027306:	440b      	add	r3, r1
		ring_buffer->tail = whereToGo % ring_buffer->size;
 8027308:	fb90 f1fc 	sdiv	r1, r0, ip
 802730c:	fb0c 0011 	mls	r0, ip, r1, r0
 8027310:	f8c4 0118 	str.w	r0, [r4, #280]	@ 0x118
		ring_buffer->count += wentBackHowMany;
 8027314:	f8c4 311c 	str.w	r3, [r4, #284]	@ 0x11c
				mess.data[0] = 1;
 8027318:	6863      	ldr	r3, [r4, #4]
				mess.function += 0x80;
 802731a:	3a80      	subs	r2, #128	@ 0x80
				mess.data[0] = 1;
 802731c:	2101      	movs	r1, #1
				frameInProgress = false;
 802731e:	2000      	movs	r0, #0
				mess.function += 0x80;
 8027320:	7062      	strb	r2, [r4, #1]
				frameInProgress = false;
 8027322:	f884 0129 	strb.w	r0, [r4, #297]	@ 0x129
				mess.data[0] = 1;
 8027326:	7019      	strb	r1, [r3, #0]
				return MODBUS_STATUS_ERROR;
 8027328:	e76d      	b.n	8027206 <modbusRTU_loop+0x2e>
			if (c == modbus_address)
 802732a:	782b      	ldrb	r3, [r5, #0]
 802732c:	4293      	cmp	r3, r2
 802732e:	f000 809d 	beq.w	802746c <modbusRTU_loop+0x294>
			else if (c == 0xFF)
 8027332:	2aff      	cmp	r2, #255	@ 0xff
 8027334:	f040 8108 	bne.w	8027548 <modbusRTU_loop+0x370>
				wCRCWord = 0xFFFF;
 8027338:	f64f 73ff 	movw	r3, #65535	@ 0xffff
				message_index_rtu++;
 802733c:	2601      	movs	r6, #1
				ModbusRTUCRC(&nTemp, &wCRCWord, c);
 802733e:	496a      	ldr	r1, [pc, #424]	@ (80274e8 <modbusRTU_loop+0x310>)
 8027340:	486a      	ldr	r0, [pc, #424]	@ (80274ec <modbusRTU_loop+0x314>)
				wCRCWord = 0xFFFF;
 8027342:	806b      	strh	r3, [r5, #2]
				mess.address = c;
 8027344:	7023      	strb	r3, [r4, #0]
				message_index_rtu++;
 8027346:	f8c4 6124 	str.w	r6, [r4, #292]	@ 0x124
				ModbusRTUCRC(&nTemp, &wCRCWord, c);
 802734a:	f000 fc91 	bl	8027c70 <ModbusRTUCRC>
				ringBufferTail = data_ring_buffer.tail;
 802734e:	f8d4 3118 	ldr.w	r3, [r4, #280]	@ 0x118
 8027352:	606b      	str	r3, [r5, #4]
				broadcast_id_mode = 1;
 8027354:	f884 612a 	strb.w	r6, [r4, #298]	@ 0x12a
		if (ring_buffer->count > 0)
 8027358:	f8d4 311c 	ldr.w	r3, [r4, #284]	@ 0x11c
				frameInProgress = true;
 802735c:	f884 6129 	strb.w	r6, [r4, #297]	@ 0x129
				ringBufferTail = data_ring_buffer.tail;
 8027360:	4632      	mov	r2, r6
 8027362:	e784      	b.n	802726e <modbusRTU_loop+0x96>
		if (desc[i].function_code == code)
 8027364:	2603      	movs	r6, #3
						ModbusRTUCRC(&nTemp, &wCRCWord, c);
 8027366:	4960      	ldr	r1, [pc, #384]	@ (80274e8 <modbusRTU_loop+0x310>)
 8027368:	4860      	ldr	r0, [pc, #384]	@ (80274ec <modbusRTU_loop+0x314>)
			*index = i;
 802736a:	f884 6131 	strb.w	r6, [r4, #305]	@ 0x131
						ModbusRTUCRC(&nTemp, &wCRCWord, c);
 802736e:	f000 fc7f 	bl	8027c70 <ModbusRTUCRC>
						mess.data_length = desc[index].data_length;
 8027372:	f894 3131 	ldrb.w	r3, [r4, #305]	@ 0x131
 8027376:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 802737a:	eb05 0383 	add.w	r3, r5, r3, lsl #2
						frameInProgress = true;
 802737e:	2201      	movs	r2, #1
						mess.data_length = desc[index].data_length;
 8027380:	68db      	ldr	r3, [r3, #12]
 8027382:	7223      	strb	r3, [r4, #8]
						message_index_rtu++;
 8027384:	f8d4 3124 	ldr.w	r3, [r4, #292]	@ 0x124
						frameInProgress = true;
 8027388:	f884 2129 	strb.w	r2, [r4, #297]	@ 0x129
						message_index_rtu++;
 802738c:	4413      	add	r3, r2
 802738e:	f8c4 3124 	str.w	r3, [r4, #292]	@ 0x124
 8027392:	f8d4 311c 	ldr.w	r3, [r4, #284]	@ 0x11c
 8027396:	e76a      	b.n	802726e <modbusRTU_loop+0x96>
			if (message_index_rtu == 6 && mess.function == 0x10)
 8027398:	2910      	cmp	r1, #16
 802739a:	f47f af55 	bne.w	8027248 <modbusRTU_loop+0x70>
				desc[index].data_length = c + 5;
 802739e:	f894 0131 	ldrb.w	r0, [r4, #305]	@ 0x131
 80273a2:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 80273a6:	eb05 0080 	add.w	r0, r5, r0, lsl #2
 80273aa:	f102 0c05 	add.w	ip, r2, #5
 80273ae:	f8c0 c00c 	str.w	ip, [r0, #12]
				frameInProgress = true;
 80273b2:	2001      	movs	r0, #1
 80273b4:	f884 0129 	strb.w	r0, [r4, #297]	@ 0x129
 80273b8:	e746      	b.n	8027248 <modbusRTU_loop+0x70>
		else if (broadcast_id_mode == 1)
 80273ba:	f894 312a 	ldrb.w	r3, [r4, #298]	@ 0x12a
 80273be:	2b01      	cmp	r3, #1
 80273c0:	d023      	beq.n	802740a <modbusRTU_loop+0x232>
		if (desc[i].function_code == code)
 80273c2:	7863      	ldrb	r3, [r4, #1]
 80273c4:	68a9      	ldr	r1, [r5, #8]
 80273c6:	4299      	cmp	r1, r3
 80273c8:	f000 80cf 	beq.w	802756a <modbusRTU_loop+0x392>
 80273cc:	6969      	ldr	r1, [r5, #20]
 80273ce:	4299      	cmp	r1, r3
 80273d0:	f000 80cd 	beq.w	802756e <modbusRTU_loop+0x396>
 80273d4:	6a29      	ldr	r1, [r5, #32]
 80273d6:	4299      	cmp	r1, r3
 80273d8:	f000 80cb 	beq.w	8027572 <modbusRTU_loop+0x39a>
 80273dc:	6ae9      	ldr	r1, [r5, #44]	@ 0x2c
 80273de:	4299      	cmp	r1, r3
 80273e0:	f47f af07 	bne.w	80271f2 <modbusRTU_loop+0x1a>
 80273e4:	2303      	movs	r3, #3
				desc[index].callback(&mess);
 80273e6:	eb03 0243 	add.w	r2, r3, r3, lsl #1
 80273ea:	eb05 0282 	add.w	r2, r5, r2, lsl #2
				ringBufferTail = -1;
 80273ee:	f04f 31ff 	mov.w	r1, #4294967295
				desc[index].callback(&mess);
 80273f2:	6912      	ldr	r2, [r2, #16]
 80273f4:	483a      	ldr	r0, [pc, #232]	@ (80274e0 <modbusRTU_loop+0x308>)
			*index = i;
 80273f6:	f884 3131 	strb.w	r3, [r4, #305]	@ 0x131
				ringBufferTail = -1;
 80273fa:	6069      	str	r1, [r5, #4]
				desc[index].callback(&mess);
 80273fc:	4790      	blx	r2
				frameInProgress = false;
 80273fe:	2300      	movs	r3, #0
 8027400:	f884 3129 	strb.w	r3, [r4, #297]	@ 0x129
 8027404:	e755      	b.n	80272b2 <modbusRTU_loop+0xda>
 8027406:	4d37      	ldr	r5, [pc, #220]	@ (80274e4 <modbusRTU_loop+0x30c>)
 8027408:	e75a      	b.n	80272c0 <modbusRTU_loop+0xe8>
			if (mess.address == 0xFF && reg_add == 0 && reg_nmb == 2)
 802740a:	7820      	ldrb	r0, [r4, #0]
			uint16_t reg_add = ((mess.data[0] << 8) + mess.data[1]) * 2;
 802740c:	6863      	ldr	r3, [r4, #4]
			broadcast_id_mode = 0;
 802740e:	2100      	movs	r1, #0
			if (mess.address == 0xFF && reg_add == 0 && reg_nmb == 2)
 8027410:	28ff      	cmp	r0, #255	@ 0xff
			broadcast_id_mode = 0;
 8027412:	f884 112a 	strb.w	r1, [r4, #298]	@ 0x12a
			uint16_t reg_add = ((mess.data[0] << 8) + mess.data[1]) * 2;
 8027416:	8819      	ldrh	r1, [r3, #0]
			uint16_t reg_nmb = ((mess.data[2] << 8) + mess.data[3]) * 2;
 8027418:	885b      	ldrh	r3, [r3, #2]
			if (mess.address == 0xFF && reg_add == 0 && reg_nmb == 2)
 802741a:	f47f aeea 	bne.w	80271f2 <modbusRTU_loop+0x1a>
			uint16_t reg_add = ((mess.data[0] << 8) + mess.data[1]) * 2;
 802741e:	ba4e      	rev16	r6, r1
 8027420:	0076      	lsls	r6, r6, #1
			if (mess.address == 0xFF && reg_add == 0 && reg_nmb == 2)
 8027422:	b2b6      	uxth	r6, r6
 8027424:	2e00      	cmp	r6, #0
 8027426:	f47f aee4 	bne.w	80271f2 <modbusRTU_loop+0x1a>
			uint16_t reg_nmb = ((mess.data[2] << 8) + mess.data[3]) * 2;
 802742a:	ba5b      	rev16	r3, r3
 802742c:	005b      	lsls	r3, r3, #1
			if (mess.address == 0xFF && reg_add == 0 && reg_nmb == 2)
 802742e:	b29b      	uxth	r3, r3
 8027430:	2b02      	cmp	r3, #2
 8027432:	f47f aede 	bne.w	80271f2 <modbusRTU_loop+0x1a>
				uint32_t delay = rand() % 1000;
 8027436:	f002 f9b3 	bl	80297a0 <rand>
 802743a:	4a2d      	ldr	r2, [pc, #180]	@ (80274f0 <modbusRTU_loop+0x318>)
 802743c:	fb82 2100 	smull	r2, r1, r2, r0
 8027440:	17c2      	asrs	r2, r0, #31
 8027442:	4603      	mov	r3, r0
 8027444:	ebc2 12a1 	rsb	r2, r2, r1, asr #6
 8027448:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
				HAL_Delay(delay);
 802744c:	fb00 3012 	mls	r0, r0, r2, r3
 8027450:	f7f9 fe48 	bl	80210e4 <HAL_Delay>
				desc[index].callback(&mess);
 8027454:	f894 3131 	ldrb.w	r3, [r4, #305]	@ 0x131
 8027458:	4821      	ldr	r0, [pc, #132]	@ (80274e0 <modbusRTU_loop+0x308>)
 802745a:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 802745e:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 8027462:	691b      	ldr	r3, [r3, #16]
 8027464:	4798      	blx	r3
				frameInProgress = false;
 8027466:	f884 6129 	strb.w	r6, [r4, #297]	@ 0x129
 802746a:	e722      	b.n	80272b2 <modbusRTU_loop+0xda>
				ModbusRTUCRC(&nTemp, &wCRCWord, c);
 802746c:	461a      	mov	r2, r3
				message_index_rtu++;
 802746e:	f04f 0801 	mov.w	r8, #1
				mess.address = c;
 8027472:	7023      	strb	r3, [r4, #0]
				ModbusRTUCRC(&nTemp, &wCRCWord, c);
 8027474:	491c      	ldr	r1, [pc, #112]	@ (80274e8 <modbusRTU_loop+0x310>)
 8027476:	481d      	ldr	r0, [pc, #116]	@ (80274ec <modbusRTU_loop+0x314>)
				message_index_rtu++;
 8027478:	f8c4 8124 	str.w	r8, [r4, #292]	@ 0x124
				wCRCWord = 0xFFFF;
 802747c:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 8027480:	806b      	strh	r3, [r5, #2]
				ModbusRTUCRC(&nTemp, &wCRCWord, c);
 8027482:	f000 fbf5 	bl	8027c70 <ModbusRTUCRC>
				ringBufferTail = data_ring_buffer.tail;
 8027486:	f8d4 3118 	ldr.w	r3, [r4, #280]	@ 0x118
 802748a:	606b      	str	r3, [r5, #4]
				frameInProgress = true;
 802748c:	f884 8129 	strb.w	r8, [r4, #297]	@ 0x129
 8027490:	f8d4 311c 	ldr.w	r3, [r4, #284]	@ 0x11c
				broadcast_id_mode = 0;
 8027494:	f884 612a 	strb.w	r6, [r4, #298]	@ 0x12a
				ringBufferTail = data_ring_buffer.tail;
 8027498:	4642      	mov	r2, r8
 802749a:	e6e8      	b.n	802726e <modbusRTU_loop+0x96>
		if (desc[i].function_code == code)
 802749c:	2100      	movs	r1, #0
 802749e:	4608      	mov	r0, r1
				if (message_index_rtu - 2 < desc[index].data_length)
 80274a0:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 80274a4:	eb05 0181 	add.w	r1, r5, r1, lsl #2
			*index = i;
 80274a8:	f884 0131 	strb.w	r0, [r4, #305]	@ 0x131
				if (message_index_rtu - 2 < desc[index].data_length)
 80274ac:	68c9      	ldr	r1, [r1, #12]
 80274ae:	1e70      	subs	r0, r6, #1
 80274b0:	4288      	cmp	r0, r1
 80274b2:	dd1f      	ble.n	80274f4 <modbusRTU_loop+0x31c>
					if (message_index_rtu == 2 + desc[index].data_length)
 80274b4:	1c88      	adds	r0, r1, #2
 80274b6:	4286      	cmp	r6, r0
 80274b8:	d03e      	beq.n	8027538 <modbusRTU_loop+0x360>
					else if (message_index_rtu == 3 + desc[index].data_length)
 80274ba:	1cc8      	adds	r0, r1, #3
 80274bc:	4286      	cmp	r6, r0
 80274be:	f47f aed3 	bne.w	8027268 <modbusRTU_loop+0x90>
						message_index_rtu++;
 80274c2:	3104      	adds	r1, #4
 80274c4:	f8c4 1124 	str.w	r1, [r4, #292]	@ 0x124
						desc[2].data_length = 6;
 80274c8:	2106      	movs	r1, #6
 80274ca:	6269      	str	r1, [r5, #36]	@ 0x24
						mess.error_check += (c << 8);
 80274cc:	8961      	ldrh	r1, [r4, #10]
						frameInProgress = true;
 80274ce:	2701      	movs	r7, #1
						mess.error_check += (c << 8);
 80274d0:	eb01 2102 	add.w	r1, r1, r2, lsl #8
						frameInProgress = true;
 80274d4:	f884 7129 	strb.w	r7, [r4, #297]	@ 0x129
						mess.error_check += (c << 8);
 80274d8:	8161      	strh	r1, [r4, #10]
						message_completed = 1;
 80274da:	463a      	mov	r2, r7
 80274dc:	e6c7      	b.n	802726e <modbusRTU_loop+0x96>
 80274de:	bf00      	nop
 80274e0:	20022570 	.word	0x20022570
 80274e4:	200000c8 	.word	0x200000c8
 80274e8:	200000ca 	.word	0x200000ca
 80274ec:	20022698 	.word	0x20022698
 80274f0:	10624dd3 	.word	0x10624dd3
					ModbusRTUCRC(&nTemp, &wCRCWord, c);
 80274f4:	4920      	ldr	r1, [pc, #128]	@ (8027578 <modbusRTU_loop+0x3a0>)
 80274f6:	4821      	ldr	r0, [pc, #132]	@ (802757c <modbusRTU_loop+0x3a4>)
 80274f8:	9201      	str	r2, [sp, #4]
 80274fa:	f000 fbb9 	bl	8027c70 <ModbusRTUCRC>
					mess.data[message_index_rtu - 2] = c;
 80274fe:	f8d4 3124 	ldr.w	r3, [r4, #292]	@ 0x124
 8027502:	6861      	ldr	r1, [r4, #4]
 8027504:	9a01      	ldr	r2, [sp, #4]
 8027506:	4419      	add	r1, r3
 8027508:	f801 2c02 	strb.w	r2, [r1, #-2]
					frameInProgress = true;
 802750c:	2201      	movs	r2, #1
					message_index_rtu++;
 802750e:	4413      	add	r3, r2
 8027510:	f8c4 3124 	str.w	r3, [r4, #292]	@ 0x124
					frameInProgress = true;
 8027514:	f884 2129 	strb.w	r2, [r4, #297]	@ 0x129
 8027518:	f8d4 311c 	ldr.w	r3, [r4, #284]	@ 0x11c
 802751c:	e6a7      	b.n	802726e <modbusRTU_loop+0x96>
		if (desc[i].function_code == code)
 802751e:	2600      	movs	r6, #0
 8027520:	e721      	b.n	8027366 <modbusRTU_loop+0x18e>
		if (desc[i].function_code == code)
 8027522:	2101      	movs	r1, #1
 8027524:	4608      	mov	r0, r1
 8027526:	e7bb      	b.n	80274a0 <modbusRTU_loop+0x2c8>
 8027528:	2102      	movs	r1, #2
 802752a:	4608      	mov	r0, r1
 802752c:	e7b8      	b.n	80274a0 <modbusRTU_loop+0x2c8>
		if (desc[i].function_code == code)
 802752e:	2602      	movs	r6, #2
 8027530:	e719      	b.n	8027366 <modbusRTU_loop+0x18e>
		if (desc[i].function_code == code)
 8027532:	2103      	movs	r1, #3
 8027534:	4608      	mov	r0, r1
 8027536:	e7b3      	b.n	80274a0 <modbusRTU_loop+0x2c8>
						mess.error_check = c;
 8027538:	8162      	strh	r2, [r4, #10]
						message_index_rtu++;
 802753a:	3103      	adds	r1, #3
						frameInProgress = true;
 802753c:	2201      	movs	r2, #1
						message_index_rtu++;
 802753e:	f8c4 1124 	str.w	r1, [r4, #292]	@ 0x124
						frameInProgress = true;
 8027542:	f884 2129 	strb.w	r2, [r4, #297]	@ 0x129
 8027546:	e692      	b.n	802726e <modbusRTU_loop+0x96>
		ring_buffer->head = 0;
 8027548:	f8c4 6114 	str.w	r6, [r4, #276]	@ 0x114
				broadcast_id_mode = 0;
 802754c:	f884 612a 	strb.w	r6, [r4, #298]	@ 0x12a
 8027550:	f8c4 6118 	str.w	r6, [r4, #280]	@ 0x118
		ring_buffer->count = 0;
 8027554:	f8c4 611c 	str.w	r6, [r4, #284]	@ 0x11c
				RS485_Clear();
 8027558:	f7fe f8f0 	bl	802573c <RS485_Clear>
				state = STATE_IDLE;
 802755c:	f8c4 612c 	str.w	r6, [r4, #300]	@ 0x12c
				frameInProgress = false;
 8027560:	f884 6129 	strb.w	r6, [r4, #297]	@ 0x129
				timer = 0;
 8027564:	f884 6130 	strb.w	r6, [r4, #304]	@ 0x130
				return MODBUS_STATUS_ERROR;
 8027568:	e64d      	b.n	8027206 <modbusRTU_loop+0x2e>
	for (uint32_t i = 0; i < sizeof(desc) / sizeof(modbus_func_descriptor); i++)
 802756a:	2300      	movs	r3, #0
 802756c:	e73b      	b.n	80273e6 <modbusRTU_loop+0x20e>
 802756e:	2301      	movs	r3, #1
 8027570:	e739      	b.n	80273e6 <modbusRTU_loop+0x20e>
 8027572:	2302      	movs	r3, #2
 8027574:	e737      	b.n	80273e6 <modbusRTU_loop+0x20e>
 8027576:	bf00      	nop
 8027578:	200000ca 	.word	0x200000ca
 802757c:	20022698 	.word	0x20022698

08027580 <modbusRTU_init>:

void modbusRTU_init(uint8_t address)
{
 8027580:	b410      	push	{r4}
	data_ring_buffer.data = (uint8_t *)data_buffer;
 8027582:	4b0b      	ldr	r3, [pc, #44]	@ (80275b0 <modbusRTU_init+0x30>)
	data_ring_buffer.count = 0;
	data_ring_buffer.size = 256;

	// log_fprintf(UART_STREAM, "Init modbus with address: %d\n\r", address);

	modbus_address = address;
 8027584:	4c0b      	ldr	r4, [pc, #44]	@ (80275b4 <modbusRTU_init+0x34>)
	data_ring_buffer.data = (uint8_t *)data_buffer;
 8027586:	f503 719a 	add.w	r1, r3, #308	@ 0x134
	modbus_address = address;
 802758a:	7020      	strb	r0, [r4, #0]
	data_ring_buffer.data = (uint8_t *)data_buffer;
 802758c:	f8c3 1110 	str.w	r1, [r3, #272]	@ 0x110
	data_ring_buffer.head = 0;
 8027590:	2200      	movs	r2, #0
	data_ring_buffer.size = 256;
 8027592:	f44f 7180 	mov.w	r1, #256	@ 0x100
	_modbusRTU_portSetRx();
}
 8027596:	f85d 4b04 	ldr.w	r4, [sp], #4
	data_ring_buffer.head = 0;
 802759a:	f8c3 2114 	str.w	r2, [r3, #276]	@ 0x114
	data_ring_buffer.tail = 0;
 802759e:	f8c3 2118 	str.w	r2, [r3, #280]	@ 0x118
	data_ring_buffer.count = 0;
 80275a2:	f8c3 211c 	str.w	r2, [r3, #284]	@ 0x11c
	data_ring_buffer.size = 256;
 80275a6:	f8c3 1120 	str.w	r1, [r3, #288]	@ 0x120
	RS485_TransmitOff();
 80275aa:	f7fe b89b 	b.w	80256e4 <RS485_TransmitOff>
 80275ae:	bf00      	nop
 80275b0:	20022570 	.word	0x20022570
 80275b4:	200000c8 	.word	0x200000c8

080275b8 <modbusRTU_sendMessage>:

uint8_t modbusRTU_sendMessage(modbus_message_t *message)
{
 80275b8:	b570      	push	{r4, r5, r6, lr}
	uint8_t nTemp;
	uint16_t wCRCWord = 0xFFFF;

	memset((void *)data_out, 0x00, sizeof(data_out));
 80275ba:	4c4c      	ldr	r4, [pc, #304]	@ (80276ec <modbusRTU_sendMessage+0x134>)
{
 80275bc:	b082      	sub	sp, #8
 80275be:	4606      	mov	r6, r0
	uint16_t wCRCWord = 0xFFFF;
 80275c0:	f64f 73ff 	movw	r3, #65535	@ 0xffff
	memset((void *)data_out, 0x00, sizeof(data_out));
 80275c4:	f44f 7280 	mov.w	r2, #256	@ 0x100
 80275c8:	2100      	movs	r1, #0
	send_index = 0;
 80275ca:	2500      	movs	r5, #0
	memset((void *)data_out, 0x00, sizeof(data_out));
 80275cc:	f504 700d 	add.w	r0, r4, #564	@ 0x234
	uint16_t wCRCWord = 0xFFFF;
 80275d0:	f8ad 3006 	strh.w	r3, [sp, #6]
	memset((void *)data_out, 0x00, sizeof(data_out));
 80275d4:	f002 faaa 	bl	8029b2c <memset>
	send_index = 0;
 80275d8:	f884 5334 	strb.w	r5, [r4, #820]	@ 0x334

	data_out[send_index] = message->address;
 80275dc:	f894 3334 	ldrb.w	r3, [r4, #820]	@ 0x334
 80275e0:	7832      	ldrb	r2, [r6, #0]
 80275e2:	4423      	add	r3, r4
	send_index++;
	ModbusRTUCRC(&nTemp, &wCRCWord, message->address);
 80275e4:	f10d 0106 	add.w	r1, sp, #6
	data_out[send_index] = message->address;
 80275e8:	f883 2234 	strb.w	r2, [r3, #564]	@ 0x234
	send_index++;
 80275ec:	f894 3334 	ldrb.w	r3, [r4, #820]	@ 0x334
 80275f0:	3301      	adds	r3, #1
 80275f2:	b2db      	uxtb	r3, r3
 80275f4:	f884 3334 	strb.w	r3, [r4, #820]	@ 0x334
	ModbusRTUCRC(&nTemp, &wCRCWord, message->address);
 80275f8:	7832      	ldrb	r2, [r6, #0]
 80275fa:	f10d 0005 	add.w	r0, sp, #5
 80275fe:	f000 fb37 	bl	8027c70 <ModbusRTUCRC>

	data_out[send_index] = message->function;
 8027602:	f894 3334 	ldrb.w	r3, [r4, #820]	@ 0x334
 8027606:	7872      	ldrb	r2, [r6, #1]
 8027608:	4423      	add	r3, r4
	send_index++;
	ModbusRTUCRC(&nTemp, &wCRCWord, message->function);
 802760a:	f10d 0106 	add.w	r1, sp, #6
	data_out[send_index] = message->function;
 802760e:	f883 2234 	strb.w	r2, [r3, #564]	@ 0x234
	send_index++;
 8027612:	f894 3334 	ldrb.w	r3, [r4, #820]	@ 0x334
 8027616:	3301      	adds	r3, #1
 8027618:	b2db      	uxtb	r3, r3
	ModbusRTUCRC(&nTemp, &wCRCWord, message->function);
 802761a:	f10d 0005 	add.w	r0, sp, #5
	send_index++;
 802761e:	f884 3334 	strb.w	r3, [r4, #820]	@ 0x334
	ModbusRTUCRC(&nTemp, &wCRCWord, message->function);
 8027622:	f000 fb25 	bl	8027c70 <ModbusRTUCRC>

	PRINTF_MODBUS("Sending the frame. Data length: %d\n", message->data_length);

	if (message->function & 0x80) // error occurs
 8027626:	f996 3001 	ldrsb.w	r3, [r6, #1]
 802762a:	42ab      	cmp	r3, r5
 802762c:	db48      	blt.n	80276c0 <modbusRTU_sendMessage+0x108>
		send_index++;
		ModbusRTUCRC(&nTemp, &wCRCWord, message->data[0]);
	}
	else
	{
		for (int i = 0; i < message->data_length; i++)
 802762e:	7a33      	ldrb	r3, [r6, #8]
 8027630:	b1c3      	cbz	r3, 8027664 <modbusRTU_sendMessage+0xac>
		{
			data_out[send_index] = message->data[i];
 8027632:	f894 3334 	ldrb.w	r3, [r4, #820]	@ 0x334
 8027636:	6872      	ldr	r2, [r6, #4]
 8027638:	4423      	add	r3, r4
 802763a:	5d52      	ldrb	r2, [r2, r5]
 802763c:	f883 2234 	strb.w	r2, [r3, #564]	@ 0x234
			send_index++;
 8027640:	f894 3334 	ldrb.w	r3, [r4, #820]	@ 0x334
			ModbusRTUCRC(&nTemp, &wCRCWord, message->data[i]);
 8027644:	6872      	ldr	r2, [r6, #4]
			send_index++;
 8027646:	3301      	adds	r3, #1
 8027648:	b2db      	uxtb	r3, r3
 802764a:	f884 3334 	strb.w	r3, [r4, #820]	@ 0x334
			ModbusRTUCRC(&nTemp, &wCRCWord, message->data[i]);
 802764e:	5d52      	ldrb	r2, [r2, r5]
 8027650:	f10d 0106 	add.w	r1, sp, #6
 8027654:	f10d 0005 	add.w	r0, sp, #5
 8027658:	f000 fb0a 	bl	8027c70 <ModbusRTUCRC>
		for (int i = 0; i < message->data_length; i++)
 802765c:	7a33      	ldrb	r3, [r6, #8]
 802765e:	3501      	adds	r5, #1
 8027660:	42ab      	cmp	r3, r5
 8027662:	dce6      	bgt.n	8027632 <modbusRTU_sendMessage+0x7a>
		}
	}
	data_out[send_index] = (uint8_t)wCRCWord;
 8027664:	f894 3334 	ldrb.w	r3, [r4, #820]	@ 0x334
 8027668:	f8bd 2006 	ldrh.w	r2, [sp, #6]
 802766c:	4423      	add	r3, r4
 802766e:	b2d1      	uxtb	r1, r2
 8027670:	f883 1234 	strb.w	r1, [r3, #564]	@ 0x234
	send_index++;
 8027674:	f894 3334 	ldrb.w	r3, [r4, #820]	@ 0x334
 8027678:	3301      	adds	r3, #1
 802767a:	b2db      	uxtb	r3, r3
 802767c:	f884 3334 	strb.w	r3, [r4, #820]	@ 0x334
	data_out[send_index] = (uint8_t)(wCRCWord >> 8);
 8027680:	f894 3334 	ldrb.w	r3, [r4, #820]	@ 0x334
 8027684:	4423      	add	r3, r4
 8027686:	0a12      	lsrs	r2, r2, #8
 8027688:	f883 2234 	strb.w	r2, [r3, #564]	@ 0x234
	send_index++;
 802768c:	f894 3334 	ldrb.w	r3, [r4, #820]	@ 0x334
 8027690:	3301      	adds	r3, #1
 8027692:	b2db      	uxtb	r3, r3
 8027694:	f884 3334 	strb.w	r3, [r4, #820]	@ 0x334
	RS485_TransmitOn();
 8027698:	f7fe f800 	bl	802569c <RS485_TransmitOn>

	_modbusRTU_portSetTx();
	HAL_Delay(5);
 802769c:	2005      	movs	r0, #5
 802769e:	f7f9 fd21 	bl	80210e4 <HAL_Delay>
	RS485_Send((void *)data_out, send_index);
 80276a2:	f894 1334 	ldrb.w	r1, [r4, #820]	@ 0x334
 80276a6:	4812      	ldr	r0, [pc, #72]	@ (80276f0 <modbusRTU_sendMessage+0x138>)
 80276a8:	f7fd ffd6 	bl	8025658 <RS485_Send>
	HAL_Delay(5);
 80276ac:	2005      	movs	r0, #5
 80276ae:	f7f9 fd19 	bl	80210e4 <HAL_Delay>
	RS485_TransmitOff();
 80276b2:	f7fe f817 	bl	80256e4 <RS485_TransmitOff>
	_modbusRTU_portSetRx();

	send_index = 0;
 80276b6:	2000      	movs	r0, #0
 80276b8:	f884 0334 	strb.w	r0, [r4, #820]	@ 0x334
	return MODBUS_STATUS_OK;
}
 80276bc:	b002      	add	sp, #8
 80276be:	bd70      	pop	{r4, r5, r6, pc}
		data_out[send_index] = message->data[0];
 80276c0:	f894 3334 	ldrb.w	r3, [r4, #820]	@ 0x334
 80276c4:	6872      	ldr	r2, [r6, #4]
 80276c6:	4423      	add	r3, r4
 80276c8:	7812      	ldrb	r2, [r2, #0]
 80276ca:	f883 2234 	strb.w	r2, [r3, #564]	@ 0x234
		send_index++;
 80276ce:	f894 3334 	ldrb.w	r3, [r4, #820]	@ 0x334
		ModbusRTUCRC(&nTemp, &wCRCWord, message->data[0]);
 80276d2:	6872      	ldr	r2, [r6, #4]
		send_index++;
 80276d4:	3301      	adds	r3, #1
 80276d6:	b2db      	uxtb	r3, r3
 80276d8:	f884 3334 	strb.w	r3, [r4, #820]	@ 0x334
		ModbusRTUCRC(&nTemp, &wCRCWord, message->data[0]);
 80276dc:	7812      	ldrb	r2, [r2, #0]
 80276de:	f10d 0106 	add.w	r1, sp, #6
 80276e2:	f10d 0005 	add.w	r0, sp, #5
 80276e6:	f000 fac3 	bl	8027c70 <ModbusRTUCRC>
 80276ea:	e7bb      	b.n	8027664 <modbusRTU_sendMessage+0xac>
 80276ec:	20022570 	.word	0x20022570
 80276f0:	200227a4 	.word	0x200227a4

080276f4 <modbusRTU_getChar>:

void modbusRTU_getChar(char c)
{
	// PRINTF_MODBUS("MODBUS char %02X",c);
	switch (state)
 80276f4:	4b35      	ldr	r3, [pc, #212]	@ (80277cc <modbusRTU_getChar+0xd8>)
 80276f6:	f8d3 212c 	ldr.w	r2, [r3, #300]	@ 0x12c
{
 80276fa:	b430      	push	{r4, r5}
	switch (state)
 80276fc:	b342      	cbz	r2, 8027750 <modbusRTU_getChar+0x5c>
 80276fe:	2a01      	cmp	r2, #1
 8027700:	d001      	beq.n	8027706 <modbusRTU_getChar+0x12>

	case STATE_MESSAGE_RECEIVED:

		break;
	}
}
 8027702:	bc30      	pop	{r4, r5}
 8027704:	4770      	bx	lr
		if (timer > 0)
 8027706:	f893 2130 	ldrb.w	r2, [r3, #304]	@ 0x130
 802770a:	2a00      	cmp	r2, #0
 802770c:	d052      	beq.n	80277b4 <modbusRTU_getChar+0xc0>
		if (ring_buffer->count < ring_buffer->size)
 802770e:	f8d3 111c 	ldr.w	r1, [r3, #284]	@ 0x11c
 8027712:	f8d3 2120 	ldr.w	r2, [r3, #288]	@ 0x120
 8027716:	4291      	cmp	r1, r2
 8027718:	da15      	bge.n	8027746 <modbusRTU_getChar+0x52>
			ring_buffer->data[ring_buffer->head++] = c;
 802771a:	f8d3 1110 	ldr.w	r1, [r3, #272]	@ 0x110
 802771e:	f8d3 2114 	ldr.w	r2, [r3, #276]	@ 0x114
 8027722:	1c54      	adds	r4, r2, #1
 8027724:	f8c3 4114 	str.w	r4, [r3, #276]	@ 0x114
 8027728:	5488      	strb	r0, [r1, r2]
			ring_buffer->count++;
 802772a:	f8d3 211c 	ldr.w	r2, [r3, #284]	@ 0x11c
 802772e:	3201      	adds	r2, #1
 8027730:	f8c3 211c 	str.w	r2, [r3, #284]	@ 0x11c
			if (ring_buffer->head >= ring_buffer->size)
 8027734:	f8d3 1114 	ldr.w	r1, [r3, #276]	@ 0x114
 8027738:	f8d3 2120 	ldr.w	r2, [r3, #288]	@ 0x120
 802773c:	4291      	cmp	r1, r2
				ring_buffer->head = 0;
 802773e:	bfa4      	itt	ge
 8027740:	2200      	movge	r2, #0
 8027742:	f8c3 2114 	strge.w	r2, [r3, #276]	@ 0x114
			timer = 7;
 8027746:	2207      	movs	r2, #7
 8027748:	f883 2130 	strb.w	r2, [r3, #304]	@ 0x130
}
 802774c:	bc30      	pop	{r4, r5}
 802774e:	4770      	bx	lr
		if (timer == 0)
 8027750:	f893 1130 	ldrb.w	r1, [r3, #304]	@ 0x130
 8027754:	f001 04ff 	and.w	r4, r1, #255	@ 0xff
 8027758:	bb11      	cbnz	r1, 80277a0 <modbusRTU_getChar+0xac>
		if (ring_buffer->count < ring_buffer->size)
 802775a:	f8d3 111c 	ldr.w	r1, [r3, #284]	@ 0x11c
 802775e:	f8d3 2120 	ldr.w	r2, [r3, #288]	@ 0x120
 8027762:	4291      	cmp	r1, r2
 8027764:	da14      	bge.n	8027790 <modbusRTU_getChar+0x9c>
			ring_buffer->data[ring_buffer->head++] = c;
 8027766:	f8d3 1110 	ldr.w	r1, [r3, #272]	@ 0x110
 802776a:	f8d3 2114 	ldr.w	r2, [r3, #276]	@ 0x114
 802776e:	1c55      	adds	r5, r2, #1
 8027770:	f8c3 5114 	str.w	r5, [r3, #276]	@ 0x114
 8027774:	5488      	strb	r0, [r1, r2]
			ring_buffer->count++;
 8027776:	f8d3 211c 	ldr.w	r2, [r3, #284]	@ 0x11c
 802777a:	3201      	adds	r2, #1
 802777c:	f8c3 211c 	str.w	r2, [r3, #284]	@ 0x11c
			if (ring_buffer->head >= ring_buffer->size)
 8027780:	f8d3 1114 	ldr.w	r1, [r3, #276]	@ 0x114
 8027784:	f8d3 2120 	ldr.w	r2, [r3, #288]	@ 0x120
 8027788:	4291      	cmp	r1, r2
				ring_buffer->head = 0;
 802778a:	bfa8      	it	ge
 802778c:	f8c3 4114 	strge.w	r4, [r3, #276]	@ 0x114
			timer = 7;
 8027790:	2107      	movs	r1, #7
 8027792:	f883 1130 	strb.w	r1, [r3, #304]	@ 0x130
			state = STATE_MESSAGE_RECEIVING;
 8027796:	2201      	movs	r2, #1
}
 8027798:	bc30      	pop	{r4, r5}
			state = STATE_MESSAGE_RECEIVING;
 802779a:	f8c3 212c 	str.w	r2, [r3, #300]	@ 0x12c
}
 802779e:	4770      	bx	lr
		ring_buffer->head = 0;
 80277a0:	f8c3 2114 	str.w	r2, [r3, #276]	@ 0x114
 80277a4:	f8c3 2118 	str.w	r2, [r3, #280]	@ 0x118
		ring_buffer->count = 0;
 80277a8:	f8c3 211c 	str.w	r2, [r3, #284]	@ 0x11c
			timer = 0;
 80277ac:	f883 2130 	strb.w	r2, [r3, #304]	@ 0x130
}
 80277b0:	bc30      	pop	{r4, r5}
 80277b2:	4770      	bx	lr
		else if (timer == 0)
 80277b4:	f893 2130 	ldrb.w	r2, [r3, #304]	@ 0x130
 80277b8:	f002 01ff 	and.w	r1, r2, #255	@ 0xff
 80277bc:	2a00      	cmp	r2, #0
 80277be:	d1a0      	bne.n	8027702 <modbusRTU_getChar+0xe>
			timer = 4;
 80277c0:	2204      	movs	r2, #4
 80277c2:	f883 2130 	strb.w	r2, [r3, #304]	@ 0x130
			state = STATE_IDLE;
 80277c6:	f8c3 112c 	str.w	r1, [r3, #300]	@ 0x12c
}
 80277ca:	e79a      	b.n	8027702 <modbusRTU_getChar+0xe>
 80277cc:	20022570 	.word	0x20022570

080277d0 <modbusRTU_BufferFlush>:

void modbusRTU_BufferFlush()
{
	message_index_rtu = 0;
 80277d0:	4b05      	ldr	r3, [pc, #20]	@ (80277e8 <modbusRTU_BufferFlush+0x18>)
 80277d2:	2200      	movs	r2, #0
		ring_buffer->head = 0;
 80277d4:	f8c3 2114 	str.w	r2, [r3, #276]	@ 0x114
 80277d8:	f8c3 2124 	str.w	r2, [r3, #292]	@ 0x124
 80277dc:	f8c3 2118 	str.w	r2, [r3, #280]	@ 0x118
		ring_buffer->count = 0;
 80277e0:	f8c3 211c 	str.w	r2, [r3, #284]	@ 0x11c
	modbusRTURingBuffer_Clear((ring_buffer_t *)&data_ring_buffer);
}
 80277e4:	4770      	bx	lr
 80277e6:	bf00      	nop
 80277e8:	20022570 	.word	0x20022570

080277ec <_modbusRTUFCallbacks_registersStructureRead>:
extern modbus_coil_table_entry_t modbus_coils_table[];

///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
void _modbusRTUFCallbacks_registersStructureRead()
{
 80277ec:	b530      	push	{r4, r5, lr}
	AdiConf_t confAllTemp;
	Memory_TakeConfig(&confAllTemp);
	modbus_register_holding_struct.sensor_ID = confAllTemp.sensor_ID;
 80277ee:	4c30      	ldr	r4, [pc, #192]	@ (80278b0 <_modbusRTUFCallbacks_registersStructureRead+0xc4>)
{
 80277f0:	b09d      	sub	sp, #116	@ 0x74
	Memory_TakeConfig(&confAllTemp);
 80277f2:	a80a      	add	r0, sp, #40	@ 0x28
 80277f4:	f7ff fbd8 	bl	8026fa8 <Memory_TakeConfig>
	modbus_register_holding_struct.sensor_ID = confAllTemp.sensor_ID;
 80277f8:	4622      	mov	r2, r4
 80277fa:	f89d 302e 	ldrb.w	r3, [sp, #46]	@ 0x2e
 80277fe:	f822 3b02 	strh.w	r3, [r2], #2
	memcpy((char *)&modbus_register_holding_struct.MAC, (const char *)&confAllTemp.MAC, MAC_ADDRESS_NUMBER_OF_BYTES);
 8027802:	f8dd 5033 	ldr.w	r5, [sp, #51]	@ 0x33
 8027806:	f8dd 302f 	ldr.w	r3, [sp, #47]	@ 0x2f
 802780a:	f8dd 1037 	ldr.w	r1, [sp, #55]	@ 0x37
 802780e:	f8c4 3002 	str.w	r3, [r4, #2]
	modbus_register_holding_struct.RS485_speed = confAllTemp.RS485_speed;
	memcpy((char *)&modbus_register_holding_struct.sensor_type, (const char *)&confAllTemp.sensor_type, 12);
 8027812:	f8dd 003d 	ldr.w	r0, [sp, #61]	@ 0x3d
	memcpy((char *)&modbus_register_holding_struct.MAC, (const char *)&confAllTemp.MAC, MAC_ADDRESS_NUMBER_OF_BYTES);
 8027816:	6055      	str	r5, [r2, #4]
 8027818:	6091      	str	r1, [r2, #8]
	memcpy((char *)&modbus_register_holding_struct.sensor_type, (const char *)&confAllTemp.sensor_type, 12);
 802781a:	f8dd 1041 	ldr.w	r1, [sp, #65]	@ 0x41
 802781e:	f8dd 2045 	ldr.w	r2, [sp, #69]	@ 0x45
	modbus_register_holding_struct.RS485_speed = confAllTemp.RS485_speed;
 8027822:	f89d 503b 	ldrb.w	r5, [sp, #59]	@ 0x3b
 8027826:	81e5      	strh	r5, [r4, #14]
	memcpy((char *)&modbus_register_holding_struct.sensor_type, (const char *)&confAllTemp.sensor_type, 12);
 8027828:	f104 0310 	add.w	r3, r4, #16
 802782c:	c307      	stmia	r3!, {r0, r1, r2}
	modbus_register_holding_struct.X_Calibration_A = confAllTemp.X_Calibration_A;
 802782e:	f8dd 304d 	ldr.w	r3, [sp, #77]	@ 0x4d
 8027832:	6223      	str	r3, [r4, #32]
 8027834:	f8dd 3051 	ldr.w	r3, [sp, #81]	@ 0x51
 8027838:	6263      	str	r3, [r4, #36]	@ 0x24
 802783a:	f8dd 3055 	ldr.w	r3, [sp, #85]	@ 0x55
 802783e:	62a3      	str	r3, [r4, #40]	@ 0x28
 8027840:	f8dd 3059 	ldr.w	r3, [sp, #89]	@ 0x59
 8027844:	f8dd 1061 	ldr.w	r1, [sp, #97]	@ 0x61
 8027848:	f8dd 2065 	ldr.w	r2, [sp, #101]	@ 0x65
 802784c:	f8dd 0049 	ldr.w	r0, [sp, #73]	@ 0x49
 8027850:	62e3      	str	r3, [r4, #44]	@ 0x2c
 8027852:	f8dd 305d 	ldr.w	r3, [sp, #93]	@ 0x5d
 8027856:	6323      	str	r3, [r4, #48]	@ 0x30
 8027858:	61e0      	str	r0, [r4, #28]
 802785a:	f8dd 3069 	ldr.w	r3, [sp, #105]	@ 0x69
	modbus_register_holding_struct.Y_Calibration_Sensitivity = confAllTemp.Y_Calibration_Sensitivity;
	modbus_register_holding_struct.Z_Calibration_A = confAllTemp.Z_Calibration_A;
	modbus_register_holding_struct.Z_Calibration_B = confAllTemp.Z_Calibration_B;
	modbus_register_holding_struct.Z_Calibration_Sensitivity = confAllTemp.Z_Calibration_Sensitivity;

	Temp_SampleGet(modbus_register_holding_struct.temperature);
 802785e:	f104 0040 	add.w	r0, r4, #64	@ 0x40
	modbus_register_holding_struct.X_Calibration_A = confAllTemp.X_Calibration_A;
 8027862:	e9c4 120d 	strd	r1, r2, [r4, #52]	@ 0x34
 8027866:	63e3      	str	r3, [r4, #60]	@ 0x3c
	Temp_SampleGet(modbus_register_holding_struct.temperature);
 8027868:	f7fe fac0 	bl	8025dec <Temp_SampleGet>

	calculated_estimates_t estimates = getEstimates();
 802786c:	a801      	add	r0, sp, #4
 802786e:	f7fd fc77 	bl	8025160 <getEstimates>
	modbus_register_holding_struct.unused[2] = 0;
	modbus_register_holding_struct.unused[3] = 0;

	modbus_register_holding_struct.is_HF = 1;
#elif defined SENSOR_TYPE_LF
	memcpy((char*)&modbus_register_holding_struct.PP, (char*)&estimates.x_PP, sizeof(float));
 8027872:	9b02      	ldr	r3, [sp, #8]
 8027874:	64a3      	str	r3, [r4, #72]	@ 0x48
 8027876:	9b03      	ldr	r3, [sp, #12]
 8027878:	64e3      	str	r3, [r4, #76]	@ 0x4c
 802787a:	9b04      	ldr	r3, [sp, #16]
 802787c:	6523      	str	r3, [r4, #80]	@ 0x50
 802787e:	9b05      	ldr	r3, [sp, #20]
 8027880:	6563      	str	r3, [r4, #84]	@ 0x54
 8027882:	e9dd 0207 	ldrd	r0, r2, [sp, #28]
 8027886:	9b06      	ldr	r3, [sp, #24]
 8027888:	65a3      	str	r3, [r4, #88]	@ 0x58
 802788a:	9b01      	ldr	r3, [sp, #4]
 802788c:	9909      	ldr	r1, [sp, #36]	@ 0x24
 802788e:	6463      	str	r3, [r4, #68]	@ 0x44

	memcpy((char*)&modbus_register_holding_struct.z_PP, (char*)&estimates.z_PP, sizeof(float));
	memcpy((char*)&modbus_register_holding_struct.z_RMS, (char*)&estimates.z_RMS, sizeof(float));
	memcpy((char*)&modbus_register_holding_struct.z_VRMS, (char*)&estimates.z_VRMS, sizeof(float));

	modbus_register_holding_struct.is_HF = 0;
 8027890:	4b08      	ldr	r3, [pc, #32]	@ (80278b4 <_modbusRTUFCallbacks_registersStructureRead+0xc8>)
 8027892:	6723      	str	r3, [r4, #112]	@ 0x70
	memcpy((char*)&modbus_register_holding_struct.PP, (char*)&estimates.x_PP, sizeof(float));
 8027894:	e9c4 0217 	strd	r0, r2, [r4, #92]	@ 0x5c
	modbus_register_holding_struct.is_HF = 0;
 8027898:	f44f 3580 	mov.w	r5, #65536	@ 0x10000
	modbus_register_holding_struct.software_version[0] = SOFTWARE_MAJOR;
	modbus_register_holding_struct.software_version[1] = SOFTWARE_MINOR;
	modbus_register_holding_struct.software_version[2] = SOFTWARE_PATCH;
	modbus_register_holding_struct.hardware_version[0] = HARDWARE_MAJOR;
	modbus_register_holding_struct.hardware_version[1] = HARDWARE_MINOR;
	modbus_register_holding_struct.hardware_version[2] = HARDWARE_REVISION;
 802789c:	2300      	movs	r3, #0
	modbus_register_holding_struct.is_HF = 0;
 802789e:	2201      	movs	r2, #1
 80278a0:	66a5      	str	r5, [r4, #104]	@ 0x68
	memcpy((char*)&modbus_register_holding_struct.PP, (char*)&estimates.x_PP, sizeof(float));
 80278a2:	6661      	str	r1, [r4, #100]	@ 0x64
	modbus_register_holding_struct.is_HF = 0;
 80278a4:	66e2      	str	r2, [r4, #108]	@ 0x6c
	modbus_register_holding_struct.hardware_version[2] = HARDWARE_REVISION;
 80278a6:	f8a4 3074 	strh.w	r3, [r4, #116]	@ 0x74
}
 80278aa:	b01d      	add	sp, #116	@ 0x74
 80278ac:	bd30      	pop	{r4, r5, pc}
 80278ae:	bf00      	nop
 80278b0:	200228a8 	.word	0x200228a8
 80278b4:	00020003 	.word	0x00020003

080278b8 <_modbusRTUFCallbacks_registersStructureWrite>:

void _modbusRTUFCallbacks_registersStructureWrite()
{
 80278b8:	b510      	push	{r4, lr}
 80278ba:	b092      	sub	sp, #72	@ 0x48
	AdiConf_t confAllTemp;
	Memory_TakeConfig(&confAllTemp);
 80278bc:	4668      	mov	r0, sp
 80278be:	f7ff fb73 	bl	8026fa8 <Memory_TakeConfig>
	confAllTemp.sensor_ID = modbus_register_holding_struct.sensor_ID;
 80278c2:	4b1e      	ldr	r3, [pc, #120]	@ (802793c <_modbusRTUFCallbacks_registersStructureWrite+0x84>)
 80278c4:	461a      	mov	r2, r3
	memcpy((char *)&confAllTemp.MAC, (const char *)&modbus_register_holding_struct.MAC,
 80278c6:	f8d3 1002 	ldr.w	r1, [r3, #2]
 80278ca:	f8cd 1007 	str.w	r1, [sp, #7]
	confAllTemp.sensor_ID = modbus_register_holding_struct.sensor_ID;
 80278ce:	f832 1b02 	ldrh.w	r1, [r2], #2
 80278d2:	f88d 1006 	strb.w	r1, [sp, #6]
	memcpy((char *)&confAllTemp.MAC, (const char *)&modbus_register_holding_struct.MAC,
 80278d6:	6851      	ldr	r1, [r2, #4]
 80278d8:	f8cd 100b 	str.w	r1, [sp, #11]
		   MAC_ADDRESS_NUMBER_OF_BYTES);
	confAllTemp.RS485_speed = modbus_register_holding_struct.RS485_speed;
	memcpy((char *)&confAllTemp.sensor_type, (const char *)&modbus_register_holding_struct.sensor_type, 12);
 80278dc:	f103 0c10 	add.w	ip, r3, #16
	memcpy((char *)&confAllTemp.MAC, (const char *)&modbus_register_holding_struct.MAC,
 80278e0:	6891      	ldr	r1, [r2, #8]
	confAllTemp.RS485_speed = modbus_register_holding_struct.RS485_speed;
 80278e2:	89da      	ldrh	r2, [r3, #14]
	memcpy((char *)&confAllTemp.MAC, (const char *)&modbus_register_holding_struct.MAC,
 80278e4:	f8cd 100f 	str.w	r1, [sp, #15]
	confAllTemp.RS485_speed = modbus_register_holding_struct.RS485_speed;
 80278e8:	f88d 2013 	strb.w	r2, [sp, #19]
	memcpy((char *)&confAllTemp.sensor_type, (const char *)&modbus_register_holding_struct.sensor_type, 12);
 80278ec:	e8bc 0007 	ldmia.w	ip!, {r0, r1, r2}
 80278f0:	f8cd 1019 	str.w	r1, [sp, #25]
	confAllTemp.X_Calibration_A = modbus_register_holding_struct.X_Calibration_A;
 80278f4:	6a59      	ldr	r1, [r3, #36]	@ 0x24
 80278f6:	f8cd 1029 	str.w	r1, [sp, #41]	@ 0x29
 80278fa:	6a99      	ldr	r1, [r3, #40]	@ 0x28
 80278fc:	f8cd 102d 	str.w	r1, [sp, #45]	@ 0x2d
 8027900:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
 8027902:	f8cd 1031 	str.w	r1, [sp, #49]	@ 0x31
 8027906:	6b19      	ldr	r1, [r3, #48]	@ 0x30
 8027908:	f8cd 1035 	str.w	r1, [sp, #53]	@ 0x35
 802790c:	6b59      	ldr	r1, [r3, #52]	@ 0x34
 802790e:	f8cd 1039 	str.w	r1, [sp, #57]	@ 0x39
 8027912:	e9d3 410e 	ldrd	r4, r1, [r3, #56]	@ 0x38
	memcpy((char *)&confAllTemp.sensor_type, (const char *)&modbus_register_holding_struct.sensor_type, 12);
 8027916:	f8cd 0015 	str.w	r0, [sp, #21]
	confAllTemp.X_Calibration_A = modbus_register_holding_struct.X_Calibration_A;
 802791a:	6a18      	ldr	r0, [r3, #32]
 802791c:	f8cd 0025 	str.w	r0, [sp, #37]	@ 0x25
 8027920:	69db      	ldr	r3, [r3, #28]
 8027922:	f8cd 3021 	str.w	r3, [sp, #33]	@ 0x21
	confAllTemp.Y_Calibration_Sensitivity = modbus_register_holding_struct.Y_Calibration_Sensitivity;
	confAllTemp.Z_Calibration_A = modbus_register_holding_struct.Z_Calibration_A;
	confAllTemp.Z_Calibration_B = modbus_register_holding_struct.Z_Calibration_B;
	confAllTemp.Z_Calibration_Sensitivity = modbus_register_holding_struct.Z_Calibration_Sensitivity;

	Memory_SaveConfig(&confAllTemp);
 8027926:	4668      	mov	r0, sp
	memcpy((char *)&confAllTemp.sensor_type, (const char *)&modbus_register_holding_struct.sensor_type, 12);
 8027928:	f8cd 201d 	str.w	r2, [sp, #29]
	confAllTemp.X_Calibration_A = modbus_register_holding_struct.X_Calibration_A;
 802792c:	f8cd 403d 	str.w	r4, [sp, #61]	@ 0x3d
 8027930:	f8cd 1041 	str.w	r1, [sp, #65]	@ 0x41
	Memory_SaveConfig(&confAllTemp);
 8027934:	f7ff fb04 	bl	8026f40 <Memory_SaveConfig>
}
 8027938:	b012      	add	sp, #72	@ 0x48
 802793a:	bd10      	pop	{r4, pc}
 802793c:	200228a8 	.word	0x200228a8

08027940 <modbusRTUFCallbacks_readCoils>:
///////////////////////////////////////////////////////////////////////////////////

/////////////////////// COILS   ///////////////////////////////////////////////////

void modbusRTUFCallbacks_readCoils(modbus_message_t *mess)
{
 8027940:	b510      	push	{r4, lr}
 8027942:	b08e      	sub	sp, #56	@ 0x38
	PRINTF_MODBUS("MODBUS read coils callback\n");
	modbus_message_t response;
	uint8_t response_data[30];
	response.address = mess->address;
 8027944:	8803      	ldrh	r3, [r0, #0]
	response.data = response_data;
	response.data_length = 0;
	response.function = mess->function;
	uint16_t coil_add = (mess->data[0] << 8) + mess->data[1];
 8027946:	6842      	ldr	r2, [r0, #4]
	response.address = mess->address;
 8027948:	f8ad 300c 	strh.w	r3, [sp, #12]
	response.data = response_data;
 802794c:	ac06      	add	r4, sp, #24
	response.data_length = 0;
 802794e:	2100      	movs	r1, #0
	response.data = response_data;
 8027950:	9404      	str	r4, [sp, #16]
	response.data_length = 0;
 8027952:	f88d 1014 	strb.w	r1, [sp, #20]
	uint16_t coil_add = (mess->data[0] << 8) + mess->data[1];
 8027956:	8813      	ldrh	r3, [r2, #0]
 8027958:	ba5b      	rev16	r3, r3
 802795a:	b29b      	uxth	r3, r3
	uint16_t coil_nmb = (mess->data[2] << 8) + mess->data[3];

	bool coil_avbl = 0;

	if (coil_add <= 8)
 802795c:	2b08      	cmp	r3, #8
 802795e:	d807      	bhi.n	8027970 <modbusRTUFCallbacks_readCoils+0x30>
 8027960:	8850      	ldrh	r0, [r2, #2]
		coil_avbl = true;
	}

	if (coil_avbl)
	{
		if (coil_nmb <= 8)
 8027962:	ba42      	rev16	r2, r0
 8027964:	b292      	uxth	r2, r2
 8027966:	2a08      	cmp	r2, #8
 8027968:	d904      	bls.n	8027974 <modbusRTUFCallbacks_readCoils+0x34>
			response_data[0] = ((coil_nmb - 1) / 8) + 1;
			response_data[1] = _modbusRTUFCallbacks_getCoilByte(coil_add, coil_nmb);
			response.data_length = 2;
			PRINTF_MODBUS("MODBUS read coils start:%d, amount:%d value:%d/n", coil_add, coil_nmb, response_data[1]);
		}
		modbusRTU_sendMessage(&response);
 802796a:	a803      	add	r0, sp, #12
 802796c:	f7ff fe24 	bl	80275b8 <modbusRTU_sendMessage>
	}
}
 8027970:	b00e      	add	sp, #56	@ 0x38
 8027972:	bd10      	pop	{r4, pc}
			response_data[0] = ((coil_nmb - 1) / 8) + 1;
 8027974:	2201      	movs	r2, #1
	bool ret_dataTable[8] =
 8027976:	e9cd 1101 	strd	r1, r1, [sp, #4]
			response_data[0] = ((coil_nmb - 1) / 8) + 1;
 802797a:	f88d 2018 	strb.w	r2, [sp, #24]
	for (uint8_t i = 0; i < byte_amount; i++)
 802797e:	2800      	cmp	r0, #0
 8027980:	d03d      	beq.n	80279fe <modbusRTUFCallbacks_readCoils+0xbe>
		ret_dataTable[i] = modbus_coils_table[i + byte_address].coil_state;
 8027982:	4a31      	ldr	r2, [pc, #196]	@ (8027a48 <modbusRTUFCallbacks_readCoils+0x108>)
 8027984:	eb02 0183 	add.w	r1, r2, r3, lsl #2
	for (uint8_t i = 0; i < byte_amount; i++)
 8027988:	f5b0 7f80 	cmp.w	r0, #256	@ 0x100
		ret_dataTable[i] = modbus_coils_table[i + byte_address].coil_state;
 802798c:	7889      	ldrb	r1, [r1, #2]
 802798e:	f88d 1004 	strb.w	r1, [sp, #4]
	for (uint8_t i = 0; i < byte_amount; i++)
 8027992:	d034      	beq.n	80279fe <modbusRTUFCallbacks_readCoils+0xbe>
		ret_dataTable[i] = modbus_coils_table[i + byte_address].coil_state;
 8027994:	eb02 0183 	add.w	r1, r2, r3, lsl #2
	for (uint8_t i = 0; i < byte_amount; i++)
 8027998:	f5b0 7f00 	cmp.w	r0, #512	@ 0x200
		ret_dataTable[i] = modbus_coils_table[i + byte_address].coil_state;
 802799c:	7989      	ldrb	r1, [r1, #6]
 802799e:	f88d 1005 	strb.w	r1, [sp, #5]
	for (uint8_t i = 0; i < byte_amount; i++)
 80279a2:	d02c      	beq.n	80279fe <modbusRTUFCallbacks_readCoils+0xbe>
		ret_dataTable[i] = modbus_coils_table[i + byte_address].coil_state;
 80279a4:	eb02 0183 	add.w	r1, r2, r3, lsl #2
	for (uint8_t i = 0; i < byte_amount; i++)
 80279a8:	f5b0 7f40 	cmp.w	r0, #768	@ 0x300
		ret_dataTable[i] = modbus_coils_table[i + byte_address].coil_state;
 80279ac:	7a89      	ldrb	r1, [r1, #10]
 80279ae:	f88d 1006 	strb.w	r1, [sp, #6]
	for (uint8_t i = 0; i < byte_amount; i++)
 80279b2:	d024      	beq.n	80279fe <modbusRTUFCallbacks_readCoils+0xbe>
		ret_dataTable[i] = modbus_coils_table[i + byte_address].coil_state;
 80279b4:	eb02 0183 	add.w	r1, r2, r3, lsl #2
	for (uint8_t i = 0; i < byte_amount; i++)
 80279b8:	f5b0 6f80 	cmp.w	r0, #1024	@ 0x400
		ret_dataTable[i] = modbus_coils_table[i + byte_address].coil_state;
 80279bc:	7b89      	ldrb	r1, [r1, #14]
 80279be:	f88d 1007 	strb.w	r1, [sp, #7]
	for (uint8_t i = 0; i < byte_amount; i++)
 80279c2:	d01c      	beq.n	80279fe <modbusRTUFCallbacks_readCoils+0xbe>
		ret_dataTable[i] = modbus_coils_table[i + byte_address].coil_state;
 80279c4:	eb02 0183 	add.w	r1, r2, r3, lsl #2
	for (uint8_t i = 0; i < byte_amount; i++)
 80279c8:	f5b0 6fa0 	cmp.w	r0, #1280	@ 0x500
		ret_dataTable[i] = modbus_coils_table[i + byte_address].coil_state;
 80279cc:	7c89      	ldrb	r1, [r1, #18]
 80279ce:	f88d 1008 	strb.w	r1, [sp, #8]
	for (uint8_t i = 0; i < byte_amount; i++)
 80279d2:	d014      	beq.n	80279fe <modbusRTUFCallbacks_readCoils+0xbe>
		ret_dataTable[i] = modbus_coils_table[i + byte_address].coil_state;
 80279d4:	eb02 0183 	add.w	r1, r2, r3, lsl #2
	for (uint8_t i = 0; i < byte_amount; i++)
 80279d8:	f5b0 6fc0 	cmp.w	r0, #1536	@ 0x600
		ret_dataTable[i] = modbus_coils_table[i + byte_address].coil_state;
 80279dc:	7d89      	ldrb	r1, [r1, #22]
 80279de:	f88d 1009 	strb.w	r1, [sp, #9]
	for (uint8_t i = 0; i < byte_amount; i++)
 80279e2:	d00c      	beq.n	80279fe <modbusRTUFCallbacks_readCoils+0xbe>
		ret_dataTable[i] = modbus_coils_table[i + byte_address].coil_state;
 80279e4:	eb02 0183 	add.w	r1, r2, r3, lsl #2
	for (uint8_t i = 0; i < byte_amount; i++)
 80279e8:	f5b0 6f00 	cmp.w	r0, #2048	@ 0x800
		ret_dataTable[i] = modbus_coils_table[i + byte_address].coil_state;
 80279ec:	7e89      	ldrb	r1, [r1, #26]
 80279ee:	f88d 100a 	strb.w	r1, [sp, #10]
	for (uint8_t i = 0; i < byte_amount; i++)
 80279f2:	d104      	bne.n	80279fe <modbusRTUFCallbacks_readCoils+0xbe>
		ret_dataTable[i] = modbus_coils_table[i + byte_address].coil_state;
 80279f4:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 80279f8:	7f93      	ldrb	r3, [r2, #30]
 80279fa:	f88d 300b 	strb.w	r3, [sp, #11]
		tmp = TempArr1[i];
 80279fe:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8027a02:	f89d 200a 	ldrb.w	r2, [sp, #10]
 8027a06:	f89d 0004 	ldrb.w	r0, [sp, #4]
 8027a0a:	f89d 1009 	ldrb.w	r1, [sp, #9]
		ret |= tmp << (count - i - 1);
 8027a0e:	01db      	lsls	r3, r3, #7
 8027a10:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
 8027a14:	4303      	orrs	r3, r0
		tmp = TempArr1[i];
 8027a16:	f89d 2008 	ldrb.w	r2, [sp, #8]
 8027a1a:	f89d 0007 	ldrb.w	r0, [sp, #7]
		ret |= tmp << (count - i - 1);
 8027a1e:	ea43 1341 	orr.w	r3, r3, r1, lsl #5
 8027a22:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
		tmp = TempArr1[i];
 8027a26:	f89d 1006 	ldrb.w	r1, [sp, #6]
 8027a2a:	f89d 2005 	ldrb.w	r2, [sp, #5]
		ret |= tmp << (count - i - 1);
 8027a2e:	ea43 03c0 	orr.w	r3, r3, r0, lsl #3
 8027a32:	ea43 0381 	orr.w	r3, r3, r1, lsl #2
 8027a36:	ea43 0342 	orr.w	r3, r3, r2, lsl #1
			response.data_length = 2;
 8027a3a:	2202      	movs	r2, #2
	ret_data = _modbusRTUFCallbacks_bitArrayToInt(ret_dataTable, 8);
 8027a3c:	f88d 3019 	strb.w	r3, [sp, #25]
			response.data_length = 2;
 8027a40:	f88d 2014 	strb.w	r2, [sp, #20]
 8027a44:	e791      	b.n	802796a <modbusRTUFCallbacks_readCoils+0x2a>
 8027a46:	bf00      	nop
 8027a48:	20000100 	.word	0x20000100

08027a4c <modbusRTUFCallbacks_writeCoil>:

void modbusRTUFCallbacks_writeCoil(modbus_message_t *mess)
{
 8027a4c:	b530      	push	{r4, r5, lr}
	PRINTF_MODBUS("MODBUS write single coil callback\n");
	if (mess->data_length == 4)
 8027a4e:	7a03      	ldrb	r3, [r0, #8]
 8027a50:	2b04      	cmp	r3, #4
{
 8027a52:	b093      	sub	sp, #76	@ 0x4c
 8027a54:	4604      	mov	r4, r0
	if (mess->data_length == 4)
 8027a56:	d116      	bne.n	8027a86 <modbusRTUFCallbacks_writeCoil+0x3a>
	{
		uint16_t coil = (mess->data[0] << 8) + mess->data[1];
 8027a58:	6842      	ldr	r2, [r0, #4]
 8027a5a:	8813      	ldrh	r3, [r2, #0]
 8027a5c:	8852      	ldrh	r2, [r2, #2]
 8027a5e:	ba5b      	rev16	r3, r3
 8027a60:	b29b      	uxth	r3, r3
		uint16_t data = (mess->data[2] << 8) + mess->data[3];
		bool dataBoll;
		if (data == MODBUS_COIL_VALUE_FALSE)
 8027a62:	b9b2      	cbnz	r2, 8027a92 <modbusRTUFCallbacks_writeCoil+0x46>
		{
			PRINTF_MODBUS("ERROR: wrong coil value...");
			return;
		}

		switch (coil)
 8027a64:	2b09      	cmp	r3, #9
 8027a66:	d82f      	bhi.n	8027ac8 <modbusRTUFCallbacks_writeCoil+0x7c>
 8027a68:	e8df f003 	tbb	[pc, r3]
 8027a6c:	0d0d0d37 	.word	0x0d0d0d37
 8027a70:	2e2e2e2e 	.word	0x2e2e2e2e
 8027a74:	302e      	.short	0x302e

		case modbusACQMaxMin:
			if (dataBoll == true)
			{
				PRINTF_MODBUS("Modbus coil ACQMaxMin true");
				modbus_coils_table[coil].coil_state = true;
 8027a76:	4b32      	ldr	r3, [pc, #200]	@ (8027b40 <modbusRTUFCallbacks_writeCoil+0xf4>)
 8027a78:	2201      	movs	r2, #1
 8027a7a:	f883 2026 	strb.w	r2, [r3, #38]	@ 0x26
				ModbusMath_MaxMin_Start();
 8027a7e:	f7fb fe6d 	bl	802375c <ModbusMath_MaxMin_Start>
				Comm_ModbusMath();
 8027a82:	f7fd f9cb 	bl	8024e1c <Comm_ModbusMath>
			PRINTF_MODBUS("Command not found. A wrong modbus coil has been chosen...");
			return;
		}
	}

	modbusRTU_sendMessage(mess);
 8027a86:	4620      	mov	r0, r4
}
 8027a88:	b013      	add	sp, #76	@ 0x4c
 8027a8a:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	modbusRTU_sendMessage(mess);
 8027a8e:	f7ff bd93 	b.w	80275b8 <modbusRTU_sendMessage>
		else if (data == MODBUS_COIL_VALUE_TRUE)
 8027a92:	2aff      	cmp	r2, #255	@ 0xff
 8027a94:	d118      	bne.n	8027ac8 <modbusRTUFCallbacks_writeCoil+0x7c>
		switch (coil)
 8027a96:	2b09      	cmp	r3, #9
 8027a98:	d816      	bhi.n	8027ac8 <modbusRTUFCallbacks_writeCoil+0x7c>
 8027a9a:	a201      	add	r2, pc, #4	@ (adr r2, 8027aa0 <modbusRTUFCallbacks_writeCoil+0x54>)
 8027a9c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8027aa0:	08027aeb 	.word	0x08027aeb
 8027aa4:	08027b2d 	.word	0x08027b2d
 8027aa8:	08027b15 	.word	0x08027b15
 8027aac:	08027afb 	.word	0x08027afb
 8027ab0:	08027ac9 	.word	0x08027ac9
 8027ab4:	08027ac9 	.word	0x08027ac9
 8027ab8:	08027ac9 	.word	0x08027ac9
 8027abc:	08027ac9 	.word	0x08027ac9
 8027ac0:	08027ac9 	.word	0x08027ac9
 8027ac4:	08027a77 	.word	0x08027a77
}
 8027ac8:	b013      	add	sp, #76	@ 0x4c
 8027aca:	bd30      	pop	{r4, r5, pc}
				modbus_coils_table[coil].coil_state = false;
 8027acc:	4b1c      	ldr	r3, [pc, #112]	@ (8027b40 <modbusRTUFCallbacks_writeCoil+0xf4>)
 8027ace:	2200      	movs	r2, #0
 8027ad0:	f883 2026 	strb.w	r2, [r3, #38]	@ 0x26
				ModbusMath_MaxMin_Stop();
 8027ad4:	f7fb fe4c 	bl	8023770 <ModbusMath_MaxMin_Stop>
 8027ad8:	e7d5      	b.n	8027a86 <modbusRTUFCallbacks_writeCoil+0x3a>
				modbus_coils_table[coil].coil_state = false;
 8027ada:	4b19      	ldr	r3, [pc, #100]	@ (8027b40 <modbusRTUFCallbacks_writeCoil+0xf4>)
 8027adc:	2000      	movs	r0, #0
 8027ade:	7098      	strb	r0, [r3, #2]
				ModbusMath_ACQStart_Write(false);
 8027ae0:	f7fb fe30 	bl	8023744 <ModbusMath_ACQStart_Write>
				ACQ_Stop();
 8027ae4:	f7fb fec8 	bl	8023878 <ACQ_Stop>
 8027ae8:	e7cd      	b.n	8027a86 <modbusRTUFCallbacks_writeCoil+0x3a>
				modbus_coils_table[coil].coil_state = true;
 8027aea:	4b15      	ldr	r3, [pc, #84]	@ (8027b40 <modbusRTUFCallbacks_writeCoil+0xf4>)
 8027aec:	2001      	movs	r0, #1
 8027aee:	7098      	strb	r0, [r3, #2]
				ModbusMath_ACQStart_Write(true);
 8027af0:	f7fb fe28 	bl	8023744 <ModbusMath_ACQStart_Write>
				ACQ_Start();
 8027af4:	f7fb fea4 	bl	8023840 <ACQ_Start>
 8027af8:	e7c5      	b.n	8027a86 <modbusRTUFCallbacks_writeCoil+0x3a>
				modbus_coils_table[coil].coil_state = true;
 8027afa:	4b11      	ldr	r3, [pc, #68]	@ (8027b40 <modbusRTUFCallbacks_writeCoil+0xf4>)
 8027afc:	2201      	movs	r2, #1
				Memory_TakeConfig(&confAllTemp);
 8027afe:	4668      	mov	r0, sp
				modbus_coils_table[coil].coil_state = true;
 8027b00:	739a      	strb	r2, [r3, #14]
				Memory_TakeConfig(&confAllTemp);
 8027b02:	f7ff fa51 	bl	8026fa8 <Memory_TakeConfig>
				Memory_MakeDefaultConfig(&confAllTemp);
 8027b06:	4668      	mov	r0, sp
 8027b08:	f7fe fffc 	bl	8026b04 <Memory_MakeDefaultConfig>
				Memory_SaveConfig(&confAllTemp);
 8027b0c:	4668      	mov	r0, sp
 8027b0e:	f7ff fa17 	bl	8026f40 <Memory_SaveConfig>
 8027b12:	e7b8      	b.n	8027a86 <modbusRTUFCallbacks_writeCoil+0x3a>
				modbus_coils_table[coil].coil_state = true;
 8027b14:	4b0a      	ldr	r3, [pc, #40]	@ (8027b40 <modbusRTUFCallbacks_writeCoil+0xf4>)
 8027b16:	2201      	movs	r2, #1
 8027b18:	729a      	strb	r2, [r3, #10]
				modbusRTU_sendMessage(mess);
 8027b1a:	4620      	mov	r0, r4
 8027b1c:	f7ff fd4c 	bl	80275b8 <modbusRTU_sendMessage>
				HAL_Delay(200);
 8027b20:	20c8      	movs	r0, #200	@ 0xc8
 8027b22:	f7f9 fadf 	bl	80210e4 <HAL_Delay>
				HAL_NVIC_SystemReset();
 8027b26:	f7f9 fddf 	bl	80216e8 <HAL_NVIC_SystemReset>
 8027b2a:	e7ac      	b.n	8027a86 <modbusRTUFCallbacks_writeCoil+0x3a>
				modbus_coils_table[coil].coil_state = true;
 8027b2c:	4b04      	ldr	r3, [pc, #16]	@ (8027b40 <modbusRTUFCallbacks_writeCoil+0xf4>)
 8027b2e:	2501      	movs	r5, #1
				modbusRTU_sendMessage(mess);
 8027b30:	4620      	mov	r0, r4
				modbus_coils_table[coil].coil_state = true;
 8027b32:	719d      	strb	r5, [r3, #6]
				modbusRTU_sendMessage(mess);
 8027b34:	f7ff fd40 	bl	80275b8 <modbusRTU_sendMessage>
				swap_t(coil);
 8027b38:	4628      	mov	r0, r5
 8027b3a:	f7fc fc9f 	bl	802447c <swap_t>
 8027b3e:	e7a2      	b.n	8027a86 <modbusRTUFCallbacks_writeCoil+0x3a>
 8027b40:	20000100 	.word	0x20000100

08027b44 <modbusRTUFCallbacks_readRegisters>:
///////////////////////////////////////////////////////////////////////////////////

/////////////////////// REGISTERS  ////////////////////////////////////////////////

void modbusRTUFCallbacks_readRegisters(modbus_message_t *mess)
{
 8027b44:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8027b48:	f5ad 7d02 	sub.w	sp, sp, #520	@ 0x208
	uint8_t response_data[252];
	response.address = mess->address;
	response.data = response_data;
	response.function = mess->function;
	response.data_length = 0;
	uint16_t reg_add = ((mess->data[0] << 8) + mess->data[1]) * 2;
 8027b4c:	6843      	ldr	r3, [r0, #4]
	response.address = mess->address;
 8027b4e:	8802      	ldrh	r2, [r0, #0]
 8027b50:	f8ad 2004 	strh.w	r2, [sp, #4]
	response.data_length = 0;
 8027b54:	2100      	movs	r1, #0
	response.data = response_data;
 8027b56:	f10d 0810 	add.w	r8, sp, #16
	response.data_length = 0;
 8027b5a:	f88d 100c 	strb.w	r1, [sp, #12]
	response.data = response_data;
 8027b5e:	f8cd 8008 	str.w	r8, [sp, #8]
	uint16_t reg_nmb = ((mess->data[2] << 8) + mess->data[3]) * 2;
 8027b62:	885c      	ldrh	r4, [r3, #2]
	uint16_t reg_add = ((mess->data[0] << 8) + mess->data[1]) * 2;
 8027b64:	881f      	ldrh	r7, [r3, #0]
	uint16_t reg_nmb = ((mess->data[2] << 8) + mess->data[3]) * 2;
 8027b66:	ba64      	rev16	r4, r4
 8027b68:	0064      	lsls	r4, r4, #1
 8027b6a:	b2a4      	uxth	r4, r4

	uint8_t response_dataBuffTemp[252] = {0};
 8027b6c:	ad43      	add	r5, sp, #268	@ 0x10c
 8027b6e:	22fc      	movs	r2, #252	@ 0xfc
	uint16_t reg_add = ((mess->data[0] << 8) + mess->data[1]) * 2;
 8027b70:	ba7f      	rev16	r7, r7
	uint8_t response_dataBuffTemp[252] = {0};
 8027b72:	4628      	mov	r0, r5
	uint16_t response_dataTemp = 0;

	PRINTF_MODBUS("modbusRTUFCallbacks_readRegisters regAdd:%d  regNmb:%d\n", reg_add, reg_nmb);

	response.data[0] = reg_nmb;
 8027b74:	b2e6      	uxtb	r6, r4
	uint8_t response_dataBuffTemp[252] = {0};
 8027b76:	f001 ffd9 	bl	8029b2c <memset>
	uint16_t reg_add = ((mess->data[0] << 8) + mess->data[1]) * 2;
 8027b7a:	007f      	lsls	r7, r7, #1
	response.data[0] = reg_nmb;
 8027b7c:	f88d 6010 	strb.w	r6, [sp, #16]

	_modbusRTUFCallbacks_registersStructureRead();
 8027b80:	f7ff fe34 	bl	80277ec <_modbusRTUFCallbacks_registersStructureRead>

	// Bez odwracania bajtow (LOW first)
	// memcpy((char *)&response.data[1], (const char *)&modbus_register_holding_struct + reg_add, reg_nmb);

	// Odwrocenie bajtow (HIGH first)
	memcpy((char *)&response_dataBuffTemp[0], (const char *)&modbus_register_holding_struct + reg_add, reg_nmb);
 8027b84:	4912      	ldr	r1, [pc, #72]	@ (8027bd0 <modbusRTUFCallbacks_readRegisters+0x8c>)
	uint16_t reg_add = ((mess->data[0] << 8) + mess->data[1]) * 2;
 8027b86:	b2bf      	uxth	r7, r7
	memcpy((char *)&response_dataBuffTemp[0], (const char *)&modbus_register_holding_struct + reg_add, reg_nmb);
 8027b88:	4439      	add	r1, r7
 8027b8a:	4622      	mov	r2, r4
 8027b8c:	4628      	mov	r0, r5
 8027b8e:	f002 f848 	bl	8029c22 <memcpy>
	for (int i = 0; i < reg_nmb; i += 2)
 8027b92:	b17c      	cbz	r4, 8027bb4 <modbusRTUFCallbacks_readRegisters+0x70>
 8027b94:	f504 7302 	add.w	r3, r4, #520	@ 0x208
 8027b98:	eb0d 0003 	add.w	r0, sp, r3
 8027b9c:	38fc      	subs	r0, #252	@ 0xfc
 8027b9e:	462b      	mov	r3, r5
	{
		memcpy((char *)&response_dataTemp, (const char *)&response_dataBuffTemp[i], 2);
 8027ba0:	f833 1b02 	ldrh.w	r1, [r3], #2
		response_dataTemp = __builtin_bswap16(response_dataTemp);
		memcpy((char *)&response.data[1 + i], (const char *)&response_dataTemp, 2);
 8027ba4:	9a02      	ldr	r2, [sp, #8]
 8027ba6:	1b5c      	subs	r4, r3, r5
 8027ba8:	4422      	add	r2, r4
		response_dataTemp = __builtin_bswap16(response_dataTemp);
 8027baa:	ba49      	rev16	r1, r1
	for (int i = 0; i < reg_nmb; i += 2)
 8027bac:	4283      	cmp	r3, r0
		memcpy((char *)&response.data[1 + i], (const char *)&response_dataTemp, 2);
 8027bae:	f822 1c01 	strh.w	r1, [r2, #-1]
	for (int i = 0; i < reg_nmb; i += 2)
 8027bb2:	d1f5      	bne.n	8027ba0 <modbusRTUFCallbacks_readRegisters+0x5c>

	response.data_length = (reg_nmb + 1);

	PRINTF_MODBUS("modbusRTUFCallbacks_readRegisters\n");

	response.error_check = 0;
 8027bb4:	2300      	movs	r3, #0
	response.data_length = (reg_nmb + 1);
 8027bb6:	3601      	adds	r6, #1
	PRINTF_MODBUS("Holding registers request OK\n");

	modbusRTU_sendMessage(&response);
 8027bb8:	a801      	add	r0, sp, #4
	response.data_length = (reg_nmb + 1);
 8027bba:	f88d 600c 	strb.w	r6, [sp, #12]
	response.error_check = 0;
 8027bbe:	f8ad 300e 	strh.w	r3, [sp, #14]
	modbusRTU_sendMessage(&response);
 8027bc2:	f7ff fcf9 	bl	80275b8 <modbusRTU_sendMessage>
}
 8027bc6:	f50d 7d02 	add.w	sp, sp, #520	@ 0x208
 8027bca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8027bce:	bf00      	nop
 8027bd0:	200228a8 	.word	0x200228a8

08027bd4 <modbusRTUFCallbacks_writeRegisters>:

void modbusRTUFCallbacks_writeRegisters(modbus_message_t *mess)
{
 8027bd4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8027bd8:	4604      	mov	r4, r0
 8027bda:	f5ad 7d41 	sub.w	sp, sp, #772	@ 0x304
	PRINTF_MODBUS("MODBUS write MULTIPLE register callback\n");
	uint8_t recive_data[252];
	modbus_message_t response;
	uint8_t response_data[252];
	uint8_t response_dataBuffTemp[252] = {0};
 8027bde:	22fc      	movs	r2, #252	@ 0xfc
 8027be0:	2100      	movs	r1, #0
 8027be2:	a881      	add	r0, sp, #516	@ 0x204
 8027be4:	f001 ffa2 	bl	8029b2c <memset>
	response.address = mess->address;
	response.data = response_data;
	response.function = mess->function;
	response.data_length = 0;

	memcpy((char *)recive_data, (const char *)mess->data, sizeof(recive_data));
 8027be8:	6866      	ldr	r6, [r4, #4]
	response.address = mess->address;
 8027bea:	8823      	ldrh	r3, [r4, #0]
 8027bec:	f8ad 3000 	strh.w	r3, [sp]
	response.data = response_data;
 8027bf0:	aa42      	add	r2, sp, #264	@ 0x108
	memcpy((char *)recive_data, (const char *)mess->data, sizeof(recive_data));
 8027bf2:	4631      	mov	r1, r6
	response.data = response_data;
 8027bf4:	9201      	str	r2, [sp, #4]
	response.data_length = 0;
 8027bf6:	2400      	movs	r4, #0
	memcpy((char *)recive_data, (const char *)mess->data, sizeof(recive_data));
 8027bf8:	22fc      	movs	r2, #252	@ 0xfc
 8027bfa:	a803      	add	r0, sp, #12
	response.data_length = 0;
 8027bfc:	f88d 4008 	strb.w	r4, [sp, #8]
	memcpy((char *)recive_data, (const char *)mess->data, sizeof(recive_data));
 8027c00:	f002 f80f 	bl	8029c22 <memcpy>

	uint16_t startAddress = (mess->data[0] << 8) + mess->data[1];
 8027c04:	f8b6 9002 	ldrh.w	r9, [r6, #2]
 8027c08:	8835      	ldrh	r5, [r6, #0]
 8027c0a:	fa99 f699 	rev16.w	r6, r9
	uint16_t quantityOfRegisters = ((mess->data[2] << 8) + mess->data[3]);
 8027c0e:	b2b7      	uxth	r7, r6

	// Bez odwracania bajtow (LOW first)
	// memcpy((char *)&modbus_register_holding_struct + startAddress, (const char *)&recive_data[5], quantityOfRegisters*2);

	// Odwrocenie bajtow (HIGH first)
	memcpy((char *)&response_dataBuffTemp[0], (const char *)&recive_data[5], quantityOfRegisters * 2);
 8027c10:	007f      	lsls	r7, r7, #1
	_modbusRTUFCallbacks_registersStructureRead();
 8027c12:	f7ff fdeb 	bl	80277ec <_modbusRTUFCallbacks_registersStructureRead>
	memcpy((char *)&response_dataBuffTemp[0], (const char *)&recive_data[5], quantityOfRegisters * 2);
 8027c16:	463a      	mov	r2, r7
 8027c18:	f10d 0111 	add.w	r1, sp, #17
 8027c1c:	a881      	add	r0, sp, #516	@ 0x204
 8027c1e:	ba6d      	rev16	r5, r5
 8027c20:	f001 ffff 	bl	8029c22 <memcpy>
	for (int i = 0; i < quantityOfRegisters * 2; i += 2)
 8027c24:	f1b9 0f00 	cmp.w	r9, #0
 8027c28:	d00e      	beq.n	8027c48 <modbusRTUFCallbacks_writeRegisters+0x74>
 8027c2a:	4621      	mov	r1, r4
 8027c2c:	4c0f      	ldr	r4, [pc, #60]	@ (8027c6c <modbusRTUFCallbacks_writeRegisters+0x98>)
 8027c2e:	fa1f f885 	uxth.w	r8, r5
 8027c32:	a881      	add	r0, sp, #516	@ 0x204
 8027c34:	eb04 0448 	add.w	r4, r4, r8, lsl #1
	{
		memcpy((char *)&response_dataTemp, (const char *)&response_dataBuffTemp[i], 2);
 8027c38:	f830 3b02 	ldrh.w	r3, [r0], #2
	for (int i = 0; i < quantityOfRegisters * 2; i += 2)
 8027c3c:	3102      	adds	r1, #2
		response_dataTemp = __builtin_bswap16(response_dataTemp);
 8027c3e:	ba5b      	rev16	r3, r3
	for (int i = 0; i < quantityOfRegisters * 2; i += 2)
 8027c40:	428f      	cmp	r7, r1
		memcpy((char *)&modbus_register_holding_struct + i + startAddress * 2, (const char *)&response_dataTemp, 2);
 8027c42:	f824 3b02 	strh.w	r3, [r4], #2
	for (int i = 0; i < quantityOfRegisters * 2; i += 2)
 8027c46:	dcf7      	bgt.n	8027c38 <modbusRTUFCallbacks_writeRegisters+0x64>
	}

	_modbusRTUFCallbacks_registersStructureWrite();
 8027c48:	f7ff fe36 	bl	80278b8 <_modbusRTUFCallbacks_registersStructureWrite>

	uint16_t startAddressBE = __builtin_bswap16(startAddress);
	memcpy((char *)&response.data[0], (const char *)&startAddressBE, 2);
 8027c4c:	9a01      	ldr	r2, [sp, #4]
	uint16_t startAddressBE = __builtin_bswap16(startAddress);
 8027c4e:	ba6d      	rev16	r5, r5
	memcpy((char *)&response.data[0], (const char *)&startAddressBE, 2);
 8027c50:	8015      	strh	r5, [r2, #0]
	uint16_t quantityOfRegistersBE = __builtin_bswap16(quantityOfRegisters);
	memcpy((char *)&response.data[2], (const char *)&quantityOfRegistersBE, 2);
 8027c52:	9a01      	ldr	r2, [sp, #4]
	uint16_t quantityOfRegistersBE = __builtin_bswap16(quantityOfRegisters);
 8027c54:	ba76      	rev16	r6, r6

	response.data_length = 4;
 8027c56:	2304      	movs	r3, #4
	memcpy((char *)&response.data[2], (const char *)&quantityOfRegistersBE, 2);
 8027c58:	8056      	strh	r6, [r2, #2]
	modbusRTU_sendMessage(&response);
 8027c5a:	4668      	mov	r0, sp
	response.data_length = 4;
 8027c5c:	f88d 3008 	strb.w	r3, [sp, #8]
	modbusRTU_sendMessage(&response);
 8027c60:	f7ff fcaa 	bl	80275b8 <modbusRTU_sendMessage>

	return;
}
 8027c64:	f50d 7d41 	add.w	sp, sp, #772	@ 0x304
 8027c68:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8027c6c:	200228a8 	.word	0x200228a8

08027c70 <ModbusRTUCRC>:
	0X4400, 0X84C1, 0X8581, 0X4540, 0X8701, 0X47C0, 0X4680, 0X8641,
	0X8201, 0X42C0, 0X4380, 0X8341, 0X4100, 0X81C1, 0X8081, 0X4040};

void ModbusRTUCRC(uint8_t *nTemp, uint16_t *wCRCWord, uint8_t nData) /* The function returns the CRC as a unsigned short type */
{
	*nTemp = nData ^ (*wCRCWord);
 8027c70:	880b      	ldrh	r3, [r1, #0]
 8027c72:	405a      	eors	r2, r3
 8027c74:	7002      	strb	r2, [r0, #0]
	*wCRCWord >>= 8;
 8027c76:	880b      	ldrh	r3, [r1, #0]
	*wCRCWord ^= wCRCTable[*nTemp];
 8027c78:	4a04      	ldr	r2, [pc, #16]	@ (8027c8c <ModbusRTUCRC+0x1c>)
	*wCRCWord >>= 8;
 8027c7a:	0a1b      	lsrs	r3, r3, #8
 8027c7c:	800b      	strh	r3, [r1, #0]
	*wCRCWord ^= wCRCTable[*nTemp];
 8027c7e:	7800      	ldrb	r0, [r0, #0]
 8027c80:	f832 2010 	ldrh.w	r2, [r2, r0, lsl #1]
 8027c84:	4053      	eors	r3, r2
 8027c86:	800b      	strh	r3, [r1, #0]
}
 8027c88:	4770      	bx	lr
 8027c8a:	bf00      	nop
 8027c8c:	0802dfd4 	.word	0x0802dfd4

08027c90 <__NVIC_SystemReset>:
 8027c90:	f3bf 8f4f 	dsb	sy
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8027c94:	4905      	ldr	r1, [pc, #20]	@ (8027cac <__NVIC_SystemReset+0x1c>)
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8027c96:	4b06      	ldr	r3, [pc, #24]	@ (8027cb0 <__NVIC_SystemReset+0x20>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8027c98:	68ca      	ldr	r2, [r1, #12]
 8027c9a:	f402 62e0 	and.w	r2, r2, #1792	@ 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8027c9e:	4313      	orrs	r3, r2
 8027ca0:	60cb      	str	r3, [r1, #12]
 8027ca2:	f3bf 8f4f 	dsb	sy
    __NOP();
 8027ca6:	bf00      	nop
  for(;;)                                                           /* wait until reset */
 8027ca8:	e7fd      	b.n	8027ca6 <__NVIC_SystemReset+0x16>
 8027caa:	bf00      	nop
 8027cac:	e000ed00 	.word	0xe000ed00
 8027cb0:	05fa0004 	.word	0x05fa0004

08027cb4 <OTC_Body>:
	}
	NVIC_SystemReset();
}

void OTC_Body(uint8_t* data, uint16_t length)
{
 8027cb4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	OTC_Subcommand_t sub_com = data[0];
 8027cb8:	7803      	ldrb	r3, [r0, #0]
	switch(sub_com)
 8027cba:	2b04      	cmp	r3, #4
{
 8027cbc:	b084      	sub	sp, #16
	switch(sub_com)
 8027cbe:	d861      	bhi.n	8027d84 <OTC_Body+0xd0>
 8027cc0:	b373      	cbz	r3, 8027d20 <OTC_Body+0x6c>
 8027cc2:	3b02      	subs	r3, #2
 8027cc4:	4606      	mov	r6, r0
 8027cc6:	460f      	mov	r7, r1
 8027cc8:	2b02      	cmp	r3, #2
 8027cca:	f200 8084 	bhi.w	8027dd6 <OTC_Body+0x122>
 8027cce:	e8df f003 	tbb	[pc, r3]
 8027cd2:	2a4b      	.short	0x2a4b
 8027cd4:	02          	.byte	0x02
 8027cd5:	00          	.byte	0x00
	uint32_t addressForRead = 0x1000*startPage+startOffset;
 8027cd6:	7843      	ldrb	r3, [r0, #1]
 8027cd8:	8845      	ldrh	r5, [r0, #2]
	uint16_t lenToVerify = length  - 6;
 8027cda:	1f8c      	subs	r4, r1, #6
	uint32_t addressForRead = 0x1000*startPage+startOffset;
 8027cdc:	eb05 3503 	add.w	r5, r5, r3, lsl #12
	uint16_t lenToVerify = length  - 6;
 8027ce0:	b2a4      	uxth	r4, r4
	PRINTF_HW("Address to read to: 0x%05X\n",addressForRead);
 8027ce2:	4946      	ldr	r1, [pc, #280]	@ (8027dfc <OTC_Body+0x148>)
 8027ce4:	462a      	mov	r2, r5
 8027ce6:	2001      	movs	r0, #1
 8027ce8:	f000 f99e 	bl	8028028 <LOG_fprintf>
	OTC_Read(addressForRead, tempBuffer, lenToVerify);
 8027cec:	4622      	mov	r2, r4
 8027cee:	4944      	ldr	r1, [pc, #272]	@ (8027e00 <OTC_Body+0x14c>)
 8027cf0:	4628      	mov	r0, r5
 8027cf2:	f000 f8f9 	bl	8027ee8 <OTC_Read>
	responseData[0] = OTC_VerifyData;
 8027cf6:	2304      	movs	r3, #4
	if (memcmp(tempBuffer,data+6,lenToVerify) == 0)
 8027cf8:	4622      	mov	r2, r4
 8027cfa:	4841      	ldr	r0, [pc, #260]	@ (8027e00 <OTC_Body+0x14c>)
	responseData[0] = OTC_VerifyData;
 8027cfc:	f88d 3008 	strb.w	r3, [sp, #8]
	if (memcmp(tempBuffer,data+6,lenToVerify) == 0)
 8027d00:	1db1      	adds	r1, r6, #6
 8027d02:	f001 ff03 	bl	8029b0c <memcmp>
	if (send_response != null)
 8027d06:	4b3f      	ldr	r3, [pc, #252]	@ (8027e04 <OTC_Body+0x150>)
 8027d08:	681c      	ldr	r4, [r3, #0]
	if (memcmp(tempBuffer,data+6,lenToVerify) == 0)
 8027d0a:	2800      	cmp	r0, #0
 8027d0c:	d140      	bne.n	8027d90 <OTC_Body+0xdc>
	if (send_response != null)
 8027d0e:	b13c      	cbz	r4, 8027d20 <OTC_Body+0x6c>
		send_response(Sensor.configuration.sensor_ID,0x31,flags,data,dataLen);
 8027d10:	4b3d      	ldr	r3, [pc, #244]	@ (8027e08 <OTC_Body+0x154>)
 8027d12:	2201      	movs	r2, #1
 8027d14:	f893 006e 	ldrb.w	r0, [r3, #110]	@ 0x6e
 8027d18:	9200      	str	r2, [sp, #0]
 8027d1a:	ab02      	add	r3, sp, #8
 8027d1c:	2131      	movs	r1, #49	@ 0x31
 8027d1e:	47a0      	blx	r4
		break;
	case OTC_Reboot:
		NVIC_SystemReset();
		break;
	}
}
 8027d20:	b004      	add	sp, #16
 8027d22:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	uint32_t addressForWriting = 0x1000*startPage+startOffset;
 8027d26:	8842      	ldrh	r2, [r0, #2]
 8027d28:	7843      	ldrb	r3, [r0, #1]
	PRINTF_HW("Write start addr: 0x%05X  curPage: %d curPart %d\n",addressForWriting,startPage,startOffset);
 8027d2a:	4938      	ldr	r1, [pc, #224]	@ (8027e0c <OTC_Body+0x158>)
 8027d2c:	9200      	str	r2, [sp, #0]
	uint32_t addressForWriting = 0x1000*startPage+startOffset;
 8027d2e:	eb02 3803 	add.w	r8, r2, r3, lsl #12
	PRINTF_HW("Write start addr: 0x%05X  curPage: %d curPart %d\n",addressForWriting,startPage,startOffset);
 8027d32:	4642      	mov	r2, r8
 8027d34:	2001      	movs	r0, #1
 8027d36:	f000 f977 	bl	8028028 <LOG_fprintf>
	for(int i = 0; i < length-6; i++)
 8027d3a:	2f06      	cmp	r7, #6
 8027d3c:	d90c      	bls.n	8027d58 <OTC_Body+0xa4>
 8027d3e:	f06f 0505 	mvn.w	r5, #5
 8027d42:	1bad      	subs	r5, r5, r6
 8027d44:	1db4      	adds	r4, r6, #6
		OTC_Write(addressForWriting+i, data[i+6]);
 8027d46:	4445      	add	r5, r8
 8027d48:	443e      	add	r6, r7
 8027d4a:	1928      	adds	r0, r5, r4
 8027d4c:	f814 1b01 	ldrb.w	r1, [r4], #1
 8027d50:	f000 f904 	bl	8027f5c <OTC_Write>
	for(int i = 0; i < length-6; i++)
 8027d54:	42a6      	cmp	r6, r4
 8027d56:	d1f8      	bne.n	8027d4a <OTC_Body+0x96>
	if (send_response != null)
 8027d58:	4a2a      	ldr	r2, [pc, #168]	@ (8027e04 <OTC_Body+0x150>)
 8027d5a:	6814      	ldr	r4, [r2, #0]
	responseData[0] = OTC_WriteData;
 8027d5c:	2303      	movs	r3, #3
 8027d5e:	f88d 3008 	strb.w	r3, [sp, #8]
	if (send_response != null)
 8027d62:	2c00      	cmp	r4, #0
 8027d64:	d1d4      	bne.n	8027d10 <OTC_Body+0x5c>
 8027d66:	e7db      	b.n	8027d20 <OTC_Body+0x6c>
	OTC_Erese_Internal();
 8027d68:	f000 f870 	bl	8027e4c <OTC_Erese_Internal>
	PRINTF_HW("Flash prepared for OTC\n");
 8027d6c:	4928      	ldr	r1, [pc, #160]	@ (8027e10 <OTC_Body+0x15c>)
 8027d6e:	2001      	movs	r0, #1
 8027d70:	f000 f95a 	bl	8028028 <LOG_fprintf>
	if (send_response != null)
 8027d74:	4a23      	ldr	r2, [pc, #140]	@ (8027e04 <OTC_Body+0x150>)
 8027d76:	6814      	ldr	r4, [r2, #0]
	responseData[0] = OTC_Preparation;
 8027d78:	2302      	movs	r3, #2
 8027d7a:	f88d 3008 	strb.w	r3, [sp, #8]
	if (send_response != null)
 8027d7e:	2c00      	cmp	r4, #0
 8027d80:	d1c6      	bne.n	8027d10 <OTC_Body+0x5c>
 8027d82:	e7cd      	b.n	8027d20 <OTC_Body+0x6c>
	switch(sub_com)
 8027d84:	2bdc      	cmp	r3, #220	@ 0xdc
 8027d86:	d00f      	beq.n	8027da8 <OTC_Body+0xf4>
 8027d88:	2bf0      	cmp	r3, #240	@ 0xf0
 8027d8a:	d1c9      	bne.n	8027d20 <OTC_Body+0x6c>
		NVIC_SystemReset();
 8027d8c:	f7ff ff80 	bl	8027c90 <__NVIC_SystemReset>
	if (send_response != null)
 8027d90:	2c00      	cmp	r4, #0
 8027d92:	d0c5      	beq.n	8027d20 <OTC_Body+0x6c>
		send_response(Sensor.configuration.sensor_ID,0x31,flags,data,dataLen);
 8027d94:	4a1c      	ldr	r2, [pc, #112]	@ (8027e08 <OTC_Body+0x154>)
 8027d96:	2301      	movs	r3, #1
 8027d98:	f892 006e 	ldrb.w	r0, [r2, #110]	@ 0x6e
 8027d9c:	9300      	str	r3, [sp, #0]
 8027d9e:	2200      	movs	r2, #0
 8027da0:	ab02      	add	r3, sp, #8
 8027da2:	2131      	movs	r1, #49	@ 0x31
 8027da4:	47a0      	blx	r4
}
 8027da6:	e7bb      	b.n	8027d20 <OTC_Body+0x6c>
	if (send_response != null)
 8027da8:	4a16      	ldr	r2, [pc, #88]	@ (8027e04 <OTC_Body+0x150>)
	responseData[0] = OTC_Done;
 8027daa:	f88d 3008 	strb.w	r3, [sp, #8]
	if (send_response != null)
 8027dae:	6814      	ldr	r4, [r2, #0]
 8027db0:	b13c      	cbz	r4, 8027dc2 <OTC_Body+0x10e>
		send_response(Sensor.configuration.sensor_ID,0x31,flags,data,dataLen);
 8027db2:	4b15      	ldr	r3, [pc, #84]	@ (8027e08 <OTC_Body+0x154>)
 8027db4:	2201      	movs	r2, #1
 8027db6:	f893 006e 	ldrb.w	r0, [r3, #110]	@ 0x6e
 8027dba:	9200      	str	r2, [sp, #0]
 8027dbc:	ab02      	add	r3, sp, #8
 8027dbe:	2131      	movs	r1, #49	@ 0x31
 8027dc0:	47a0      	blx	r4
{
 8027dc2:	f241 3288 	movw	r2, #5000	@ 0x1388
 8027dc6:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
			__asm("nop");
 8027dca:	bf00      	nop
		for(int j = 0; j < 1000; j++)
 8027dcc:	3b01      	subs	r3, #1
 8027dce:	d1fc      	bne.n	8027dca <OTC_Body+0x116>
	for(int i = 0; i < 5000; i++)
 8027dd0:	3a01      	subs	r2, #1
 8027dd2:	d1f8      	bne.n	8027dc6 <OTC_Body+0x112>
 8027dd4:	e7da      	b.n	8027d8c <OTC_Body+0xd8>
	if (send_response != null)
 8027dd6:	4b0b      	ldr	r3, [pc, #44]	@ (8027e04 <OTC_Body+0x150>)
	responseBuffer[0] = OTC_GetVersion;
 8027dd8:	4a0e      	ldr	r2, [pc, #56]	@ (8027e14 <OTC_Body+0x160>)
	if (send_response != null)
 8027dda:	681c      	ldr	r4, [r3, #0]
	responseBuffer[0] = OTC_GetVersion;
 8027ddc:	4b0e      	ldr	r3, [pc, #56]	@ (8027e18 <OTC_Body+0x164>)
 8027dde:	e9cd 2302 	strd	r2, r3, [sp, #8]
	if (send_response != null)
 8027de2:	2c00      	cmp	r4, #0
 8027de4:	d09c      	beq.n	8027d20 <OTC_Body+0x6c>
		send_response(Sensor.configuration.sensor_ID,0x31,flags,data,dataLen);
 8027de6:	4a08      	ldr	r2, [pc, #32]	@ (8027e08 <OTC_Body+0x154>)
 8027de8:	2308      	movs	r3, #8
 8027dea:	f892 006e 	ldrb.w	r0, [r2, #110]	@ 0x6e
 8027dee:	9300      	str	r3, [sp, #0]
 8027df0:	2201      	movs	r2, #1
 8027df2:	446b      	add	r3, sp
 8027df4:	2131      	movs	r1, #49	@ 0x31
 8027df6:	47a0      	blx	r4
}
 8027df8:	e792      	b.n	8027d20 <OTC_Body+0x6c>
 8027dfa:	bf00      	nop
 8027dfc:	0802ec34 	.word	0x0802ec34
 8027e00:	20022924 	.word	0x20022924
 8027e04:	20022920 	.word	0x20022920
 8027e08:	20000008 	.word	0x20000008
 8027e0c:	0802ec00 	.word	0x0802ec00
 8027e10:	0802ebe8 	.word	0x0802ebe8
 8027e14:	00010101 	.word	0x00010101
 8027e18:	1f000203 	.word	0x1f000203

08027e1c <OTC_RegisterResponseHandler>:

void OTC_RegisterResponseHandler(send_resp_func handler)
{
	send_response = handler;
 8027e1c:	4b01      	ldr	r3, [pc, #4]	@ (8027e24 <OTC_RegisterResponseHandler+0x8>)
 8027e1e:	6018      	str	r0, [r3, #0]
}
 8027e20:	4770      	bx	lr
 8027e22:	bf00      	nop
 8027e24:	20022920 	.word	0x20022920

08027e28 <OTC_Flash_Error>:
 8027e28:	f3bf 8f4f 	dsb	sy
}

static void OTC_Flash_Error(void)
{
  __DSB();
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)|(SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk)|SCB_AIRCR_SYSRESETREQ_Msk);
 8027e2c:	4905      	ldr	r1, [pc, #20]	@ (8027e44 <OTC_Flash_Error+0x1c>)
 8027e2e:	4b06      	ldr	r3, [pc, #24]	@ (8027e48 <OTC_Flash_Error+0x20>)
 8027e30:	68ca      	ldr	r2, [r1, #12]
 8027e32:	f402 62e0 	and.w	r2, r2, #1792	@ 0x700
 8027e36:	4313      	orrs	r3, r2
 8027e38:	60cb      	str	r3, [r1, #12]
 8027e3a:	f3bf 8f4f 	dsb	sy
  __DSB();
  for(;;)
  {
    __NOP();
 8027e3e:	bf00      	nop
  for(;;)
 8027e40:	e7fd      	b.n	8027e3e <OTC_Flash_Error+0x16>
 8027e42:	bf00      	nop
 8027e44:	e000ed00 	.word	0xe000ed00
 8027e48:	05fa0004 	.word	0x05fa0004

08027e4c <OTC_Erese_Internal>:
  }
}

void OTC_Erese_Internal(void)
{
 8027e4c:	b538      	push	{r3, r4, r5, lr}
	while(_flashState == BUSY)
 8027e4e:	4d1e      	ldr	r5, [pc, #120]	@ (8027ec8 <OTC_Erese_Internal+0x7c>)
 8027e50:	782b      	ldrb	r3, [r5, #0]
 8027e52:	b903      	cbnz	r3, 8027e56 <OTC_Erese_Internal+0xa>
 8027e54:	e7fe      	b.n	8027e54 <OTC_Erese_Internal+0x8>
	{;}
	_flashState = BUSY;
 8027e56:	2200      	movs	r2, #0
	  if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
 8027e58:	4b1c      	ldr	r3, [pc, #112]	@ (8027ecc <OTC_Erese_Internal+0x80>)
	_flashState = BUSY;
 8027e5a:	702a      	strb	r2, [r5, #0]
	  if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
 8027e5c:	691a      	ldr	r2, [r3, #16]
 8027e5e:	2a00      	cmp	r2, #0
 8027e60:	db1c      	blt.n	8027e9c <OTC_Erese_Internal+0x50>
	if (!OTC_Flash_Unlock())
	{
	     PRINTF_MEM("Flash access error: %s\n", __FUNCTION__);
	     return;
	}
     __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | FLASH_FLAG_PGSERR );
 8027e62:	4c1a      	ldr	r4, [pc, #104]	@ (8027ecc <OTC_Erese_Internal+0x80>)
 8027e64:	23b3      	movs	r3, #179	@ 0xb3
 8027e66:	60e3      	str	r3, [r4, #12]
     FLASH_Erase_Sector(FLASH_SECTOR_8, VOLTAGE_RANGE_3);
 8027e68:	2102      	movs	r1, #2
 8027e6a:	2008      	movs	r0, #8
 8027e6c:	f7f9 ff0c 	bl	8021c88 <FLASH_Erase_Sector>
     FLASH_Erase_Sector(FLASH_SECTOR_9, VOLTAGE_RANGE_3);
 8027e70:	2102      	movs	r1, #2
 8027e72:	2009      	movs	r0, #9
 8027e74:	f7f9 ff08 	bl	8021c88 <FLASH_Erase_Sector>
     FLASH_Erase_Sector(FLASH_SECTOR_10, VOLTAGE_RANGE_3);
 8027e78:	2102      	movs	r1, #2
 8027e7a:	200a      	movs	r0, #10
 8027e7c:	f7f9 ff04 	bl	8021c88 <FLASH_Erase_Sector>
	FLASH->CR |= FLASH_CR_LOCK;
 8027e80:	6923      	ldr	r3, [r4, #16]
 8027e82:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 8027e86:	6123      	str	r3, [r4, #16]
    if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
 8027e88:	6923      	ldr	r3, [r4, #16]
 8027e8a:	2b00      	cmp	r3, #0
 8027e8c:	db14      	blt.n	8027eb8 <OTC_Erese_Internal+0x6c>
     if (!OTC_Flash_Lock())
     {
         PRINTF_MEM("Flash could not been secured, system reset: %s\n", __FUNCTION__);
 8027e8e:	4a10      	ldr	r2, [pc, #64]	@ (8027ed0 <OTC_Erese_Internal+0x84>)
 8027e90:	4910      	ldr	r1, [pc, #64]	@ (8027ed4 <OTC_Erese_Internal+0x88>)
 8027e92:	2004      	movs	r0, #4
 8027e94:	f000 f8c8 	bl	8028028 <LOG_fprintf>
         OTC_Flash_Error();
 8027e98:	f7ff ffc6 	bl	8027e28 <OTC_Flash_Error>
	    WRITE_REG(FLASH->KEYR, FLASH_KEY1);
 8027e9c:	490e      	ldr	r1, [pc, #56]	@ (8027ed8 <OTC_Erese_Internal+0x8c>)
	    WRITE_REG(FLASH->KEYR, FLASH_KEY2);
 8027e9e:	4a0f      	ldr	r2, [pc, #60]	@ (8027edc <OTC_Erese_Internal+0x90>)
	    WRITE_REG(FLASH->KEYR, FLASH_KEY1);
 8027ea0:	6059      	str	r1, [r3, #4]
	    WRITE_REG(FLASH->KEYR, FLASH_KEY2);
 8027ea2:	605a      	str	r2, [r3, #4]
	    if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
 8027ea4:	691b      	ldr	r3, [r3, #16]
 8027ea6:	2b00      	cmp	r3, #0
 8027ea8:	dadb      	bge.n	8027e62 <OTC_Erese_Internal+0x16>
     }
     PRINTF_MEM("Bootloader data has been erased\n");

 	_flashState = OK;
}
 8027eaa:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	     PRINTF_MEM("Flash access error: %s\n", __FUNCTION__);
 8027eae:	4a08      	ldr	r2, [pc, #32]	@ (8027ed0 <OTC_Erese_Internal+0x84>)
 8027eb0:	490b      	ldr	r1, [pc, #44]	@ (8027ee0 <OTC_Erese_Internal+0x94>)
 8027eb2:	2004      	movs	r0, #4
 8027eb4:	f000 b8b8 	b.w	8028028 <LOG_fprintf>
     PRINTF_MEM("Bootloader data has been erased\n");
 8027eb8:	490a      	ldr	r1, [pc, #40]	@ (8027ee4 <OTC_Erese_Internal+0x98>)
 8027eba:	2004      	movs	r0, #4
 8027ebc:	f000 f8b4 	bl	8028028 <LOG_fprintf>
 	_flashState = OK;
 8027ec0:	2301      	movs	r3, #1
 8027ec2:	702b      	strb	r3, [r5, #0]
}
 8027ec4:	bd38      	pop	{r3, r4, r5, pc}
 8027ec6:	bf00      	nop
 8027ec8:	2000012c 	.word	0x2000012c
 8027ecc:	40023c00 	.word	0x40023c00
 8027ed0:	0802e1d4 	.word	0x0802e1d4
 8027ed4:	0802e92c 	.word	0x0802e92c
 8027ed8:	45670123 	.word	0x45670123
 8027edc:	cdef89ab 	.word	0xcdef89ab
 8027ee0:	0802e914 	.word	0x0802e914
 8027ee4:	0802ec50 	.word	0x0802ec50

08027ee8 <OTC_Read>:
    *data = *(__IO uint8_t*)address;
    //PRINTF_MEM("Readed byte: 0x%02X from address: 0x%08X\n",*data,address);
}

bool OTC_Read(uint32_t address, uint8_t* data, uint16_t length)
{
 8027ee8:	b510      	push	{r4, lr}
	while(_flashState == BUSY)
 8027eea:	4c17      	ldr	r4, [pc, #92]	@ (8027f48 <OTC_Read+0x60>)
 8027eec:	7823      	ldrb	r3, [r4, #0]
 8027eee:	b903      	cbnz	r3, 8027ef2 <OTC_Read+0xa>
 8027ef0:	e7fe      	b.n	8027ef0 <OTC_Read+0x8>
	{;}
	_flashState = BUSY;
 8027ef2:	2300      	movs	r3, #0

	if (address >= MAX_BOOT_DATA_SIZE)
 8027ef4:	f5b0 2fc0 	cmp.w	r0, #393216	@ 0x60000
	_flashState = BUSY;
 8027ef8:	7023      	strb	r3, [r4, #0]
	if (address >= MAX_BOOT_DATA_SIZE)
 8027efa:	d213      	bcs.n	8027f24 <OTC_Read+0x3c>
	{
		PRINTF_MEM("Address: 0x%08X\n",address);
		PRINTF_MEM("Read address overflows user flash size: %s\n", __FUNCTION__);
		return false;
	}
	if (length + address >= MAX_BOOT_DATA_SIZE)
 8027efc:	1813      	adds	r3, r2, r0
 8027efe:	f5b3 2fc0 	cmp.w	r3, #393216	@ 0x60000
 8027f02:	d21b      	bcs.n	8027f3c <OTC_Read+0x54>
	{
		PRINTF_MEM("Data overflows bootloader data size: %s\n", __FUNCTION__);
		return false;
	}
	for(int i = 0; i < length; i++)
 8027f04:	b15a      	cbz	r2, 8027f1e <OTC_Read+0x36>
 8027f06:	1a40      	subs	r0, r0, r1
    *data = *(__IO uint8_t*)address;
 8027f08:	f100 6000 	add.w	r0, r0, #134217728	@ 0x8000000
	for(int i = 0; i < length; i++)
 8027f0c:	460b      	mov	r3, r1
    *data = *(__IO uint8_t*)address;
 8027f0e:	f500 2000 	add.w	r0, r0, #524288	@ 0x80000
 8027f12:	4411      	add	r1, r2
 8027f14:	5cc2      	ldrb	r2, [r0, r3]
 8027f16:	f803 2b01 	strb.w	r2, [r3], #1
	for(int i = 0; i < length; i++)
 8027f1a:	428b      	cmp	r3, r1
 8027f1c:	d1fa      	bne.n	8027f14 <OTC_Read+0x2c>
	{
		OTC_ReadByte(address+i,data+i);
	}

 	_flashState = OK;
 8027f1e:	2001      	movs	r0, #1
 8027f20:	7020      	strb	r0, [r4, #0]
 	return true;
}
 8027f22:	bd10      	pop	{r4, pc}
		PRINTF_MEM("Address: 0x%08X\n",address);
 8027f24:	4602      	mov	r2, r0
 8027f26:	4909      	ldr	r1, [pc, #36]	@ (8027f4c <OTC_Read+0x64>)
 8027f28:	2004      	movs	r0, #4
 8027f2a:	f000 f87d 	bl	8028028 <LOG_fprintf>
		PRINTF_MEM("Read address overflows user flash size: %s\n", __FUNCTION__);
 8027f2e:	4a08      	ldr	r2, [pc, #32]	@ (8027f50 <OTC_Read+0x68>)
 8027f30:	4908      	ldr	r1, [pc, #32]	@ (8027f54 <OTC_Read+0x6c>)
 8027f32:	2004      	movs	r0, #4
 8027f34:	f000 f878 	bl	8028028 <LOG_fprintf>
		return false;
 8027f38:	2000      	movs	r0, #0
}
 8027f3a:	bd10      	pop	{r4, pc}
		PRINTF_MEM("Data overflows bootloader data size: %s\n", __FUNCTION__);
 8027f3c:	4a04      	ldr	r2, [pc, #16]	@ (8027f50 <OTC_Read+0x68>)
 8027f3e:	4906      	ldr	r1, [pc, #24]	@ (8027f58 <OTC_Read+0x70>)
 8027f40:	2004      	movs	r0, #4
 8027f42:	f000 f871 	bl	8028028 <LOG_fprintf>
		return false;
 8027f46:	e7f7      	b.n	8027f38 <OTC_Read+0x50>
 8027f48:	2000012c 	.word	0x2000012c
 8027f4c:	0802e8d0 	.word	0x0802e8d0
 8027f50:	0802e1e8 	.word	0x0802e1e8
 8027f54:	0802e9e0 	.word	0x0802e9e0
 8027f58:	0802ec74 	.word	0x0802ec74

08027f5c <OTC_Write>:

bool OTC_Write(uint32_t address, uint8_t data)
{
 8027f5c:	b538      	push	{r3, r4, r5, lr}
	while(_flashState == BUSY)
 8027f5e:	4d22      	ldr	r5, [pc, #136]	@ (8027fe8 <OTC_Write+0x8c>)
 8027f60:	782b      	ldrb	r3, [r5, #0]
 8027f62:	b903      	cbnz	r3, 8027f66 <OTC_Write+0xa>
 8027f64:	e7fe      	b.n	8027f64 <OTC_Write+0x8>
	{;}
	_flashState = BUSY;
 8027f66:	2300      	movs	r3, #0

	if (address >= MAX_BOOT_DATA_SIZE)
 8027f68:	f5b0 2fc0 	cmp.w	r0, #393216	@ 0x60000
	_flashState = BUSY;
 8027f6c:	702b      	strb	r3, [r5, #0]
	if (address >= MAX_BOOT_DATA_SIZE)
 8027f6e:	d22b      	bcs.n	8027fc8 <OTC_Write+0x6c>
	  if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
 8027f70:	4b1e      	ldr	r3, [pc, #120]	@ (8027fec <OTC_Write+0x90>)
 8027f72:	460a      	mov	r2, r1
 8027f74:	6919      	ldr	r1, [r3, #16]
 8027f76:	2900      	cmp	r1, #0
 8027f78:	db18      	blt.n	8027fac <OTC_Write+0x50>
	{
	     PRINTF_MEM("Flash access error: %s\n", __FUNCTION__);
	     return false;
	}

    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | FLASH_FLAG_PGSERR );
 8027f7a:	4c1c      	ldr	r4, [pc, #112]	@ (8027fec <OTC_Write+0x90>)
 8027f7c:	23b3      	movs	r3, #179	@ 0xb3
    HAL_FLASH_Program(TYPEPROGRAM_FASTBYTE, 0x08080000 + address, data);
 8027f7e:	f100 6100 	add.w	r1, r0, #134217728	@ 0x8000000
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | FLASH_FLAG_PGSERR );
 8027f82:	60e3      	str	r3, [r4, #12]
    HAL_FLASH_Program(TYPEPROGRAM_FASTBYTE, 0x08080000 + address, data);
 8027f84:	2300      	movs	r3, #0
 8027f86:	4618      	mov	r0, r3
 8027f88:	f501 2100 	add.w	r1, r1, #524288	@ 0x80000
 8027f8c:	f7f9 fddc 	bl	8021b48 <HAL_FLASH_Program>
	FLASH->CR |= FLASH_CR_LOCK;
 8027f90:	6923      	ldr	r3, [r4, #16]
 8027f92:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 8027f96:	6123      	str	r3, [r4, #16]
    if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
 8027f98:	6923      	ldr	r3, [r4, #16]
 8027f9a:	2b00      	cmp	r3, #0
 8027f9c:	db20      	blt.n	8027fe0 <OTC_Write+0x84>

    //PRINTF_MEM("Saved byte 0x%02X to address: 0x%08X\n",data,0x080E0000 + address);

    if (!OTC_Flash_Lock())
    {
        PRINTF_MEM("Flash could not been secured, system reset: %s\n", __FUNCTION__);
 8027f9e:	4a14      	ldr	r2, [pc, #80]	@ (8027ff0 <OTC_Write+0x94>)
 8027fa0:	4914      	ldr	r1, [pc, #80]	@ (8027ff4 <OTC_Write+0x98>)
 8027fa2:	2004      	movs	r0, #4
 8027fa4:	f000 f840 	bl	8028028 <LOG_fprintf>
        OTC_Flash_Error();
 8027fa8:	f7ff ff3e 	bl	8027e28 <OTC_Flash_Error>
	    WRITE_REG(FLASH->KEYR, FLASH_KEY1);
 8027fac:	4912      	ldr	r1, [pc, #72]	@ (8027ff8 <OTC_Write+0x9c>)
 8027fae:	6059      	str	r1, [r3, #4]
	    WRITE_REG(FLASH->KEYR, FLASH_KEY2);
 8027fb0:	f101 3188 	add.w	r1, r1, #2290649224	@ 0x88888888
 8027fb4:	6059      	str	r1, [r3, #4]
	    if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
 8027fb6:	691b      	ldr	r3, [r3, #16]
 8027fb8:	2b00      	cmp	r3, #0
 8027fba:	dade      	bge.n	8027f7a <OTC_Write+0x1e>
	     PRINTF_MEM("Flash access error: %s\n", __FUNCTION__);
 8027fbc:	4a0c      	ldr	r2, [pc, #48]	@ (8027ff0 <OTC_Write+0x94>)
 8027fbe:	490f      	ldr	r1, [pc, #60]	@ (8027ffc <OTC_Write+0xa0>)
 8027fc0:	2004      	movs	r0, #4
 8027fc2:	f000 f831 	bl	8028028 <LOG_fprintf>
	     return false;
 8027fc6:	e009      	b.n	8027fdc <OTC_Write+0x80>
		PRINTF_MEM("Address: 0x%08X\n",address);
 8027fc8:	4602      	mov	r2, r0
 8027fca:	490d      	ldr	r1, [pc, #52]	@ (8028000 <OTC_Write+0xa4>)
 8027fcc:	2004      	movs	r0, #4
 8027fce:	f000 f82b 	bl	8028028 <LOG_fprintf>
		PRINTF_MEM("Write address overflows user flash size: %s\n", __FUNCTION__);
 8027fd2:	4a07      	ldr	r2, [pc, #28]	@ (8027ff0 <OTC_Write+0x94>)
 8027fd4:	490b      	ldr	r1, [pc, #44]	@ (8028004 <OTC_Write+0xa8>)
 8027fd6:	2004      	movs	r0, #4
 8027fd8:	f000 f826 	bl	8028028 <LOG_fprintf>
		return false;
 8027fdc:	2000      	movs	r0, #0
    }

 	_flashState = OK;
 	return true;
}
 8027fde:	bd38      	pop	{r3, r4, r5, pc}
 	_flashState = OK;
 8027fe0:	2001      	movs	r0, #1
 8027fe2:	7028      	strb	r0, [r5, #0]
}
 8027fe4:	bd38      	pop	{r3, r4, r5, pc}
 8027fe6:	bf00      	nop
 8027fe8:	2000012c 	.word	0x2000012c
 8027fec:	40023c00 	.word	0x40023c00
 8027ff0:	0802e1f4 	.word	0x0802e1f4
 8027ff4:	0802e92c 	.word	0x0802e92c
 8027ff8:	45670123 	.word	0x45670123
 8027ffc:	0802e914 	.word	0x0802e914
 8028000:	0802e8d0 	.word	0x0802e8d0
 8028004:	0802e8e4 	.word	0x0802e8e4

08028008 <enum2str>:
		"MODBUS",
		"COMM"};

char *enum2str(CurrentProtocol t)
{
	switch (t)
 8028008:	4603      	mov	r3, r0
 802800a:	b128      	cbz	r0, 8028018 <enum2str+0x10>
	case SLS:
		return "SLS";
	case MODBUS:
		return "MODBUS";
	default:
		return "ERROR";
 802800c:	4a03      	ldr	r2, [pc, #12]	@ (802801c <enum2str+0x14>)
 802800e:	4804      	ldr	r0, [pc, #16]	@ (8028020 <enum2str+0x18>)
 8028010:	2b01      	cmp	r3, #1
 8028012:	bf18      	it	ne
 8028014:	4610      	movne	r0, r2
 8028016:	4770      	bx	lr
		return "SLS";
 8028018:	4802      	ldr	r0, [pc, #8]	@ (8028024 <enum2str+0x1c>)
	}
	return NULL;

}
 802801a:	4770      	bx	lr
 802801c:	0802e4d4 	.word	0x0802e4d4
 8028020:	0802eca4 	.word	0x0802eca4
 8028024:	0802eca0 	.word	0x0802eca0

08028028 <LOG_fprintf>:
    HAL_UART_Transmit_DMA(&huart7, (uint8_t*)logQueue[logTail].data, logQueue[logTail].length);

}

void LOG_fprintf(uint8_t flags, const char *str, ...)
{
 8028028:	b40e      	push	{r1, r2, r3}
 802802a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    uint8_t nextHead = (logHead + 1) % LOG_QUEUE_SIZE;
 802802e:	4c4d      	ldr	r4, [pc, #308]	@ (8028164 <LOG_fprintf+0x13c>)
 8028030:	7825      	ldrb	r5, [r4, #0]

    if (nextHead == logTail) {
 8028032:	7863      	ldrb	r3, [r4, #1]
    uint8_t nextHead = (logHead + 1) % LOG_QUEUE_SIZE;
 8028034:	3501      	adds	r5, #1
 8028036:	f005 0507 	and.w	r5, r5, #7
    if (nextHead == logTail) {
 802803a:	42ab      	cmp	r3, r5
{
 802803c:	b083      	sub	sp, #12
    if (nextHead == logTail) {
 802803e:	d051      	beq.n	80280e4 <LOG_fprintf+0xbc>
        return;
    }

    va_list args;
    va_start(args, str);
    memset(logQueue[logHead].data, 0, LOG_MSG_MAX_LEN);
 8028040:	4627      	mov	r7, r4
 8028042:	4606      	mov	r6, r0
 8028044:	f817 0b04 	ldrb.w	r0, [r7], #4
 8028048:	eb00 1080 	add.w	r0, r0, r0, lsl #6
    va_start(args, str);
 802804c:	ab0a      	add	r3, sp, #40	@ 0x28
    memset(logQueue[logHead].data, 0, LOG_MSG_MAX_LEN);
 802804e:	eb07 0040 	add.w	r0, r7, r0, lsl #1
 8028052:	2280      	movs	r2, #128	@ 0x80
 8028054:	2100      	movs	r1, #0
    va_start(args, str);
 8028056:	9301      	str	r3, [sp, #4]
    memset(logQueue[logHead].data, 0, LOG_MSG_MAX_LEN);
 8028058:	f001 fd68 	bl	8029b2c <memset>

    switch (flags)
 802805c:	2e08      	cmp	r6, #8
 802805e:	d810      	bhi.n	8028082 <LOG_fprintf+0x5a>
 8028060:	e8df f006 	tbb	[pc, r6]
 8028064:	69666360 	.word	0x69666360
 8028068:	75726f6c 	.word	0x75726f6c
 802806c:	05          	.byte	0x05
 802806d:	00          	.byte	0x00
    case LOG_ERROR:  snprintf(logQueue[logHead].data, LOG_MSG_MAX_LEN, "%s: ", log_sources[3]); break;
    case LOG_MEMORY: snprintf(logQueue[logHead].data, LOG_MSG_MAX_LEN, "%s: ", log_sources[4]); break;
    case LOG_TEST:   snprintf(logQueue[logHead].data, LOG_MSG_MAX_LEN, "%s: ", log_sources[5]); break;
    case LOG_0:      snprintf(logQueue[logHead].data, LOG_MSG_MAX_LEN, "%s: ", log_sources[6]); break;
    case LOG_MODBUS: snprintf(logQueue[logHead].data, LOG_MSG_MAX_LEN, "%s: ", log_sources[7]); break;
    case LOG_COMM:   snprintf(logQueue[logHead].data, LOG_MSG_MAX_LEN, "%s: ", log_sources[8]); break;
 802806e:	7820      	ldrb	r0, [r4, #0]
 8028070:	4b3d      	ldr	r3, [pc, #244]	@ (8028168 <LOG_fprintf+0x140>)
 8028072:	4a3e      	ldr	r2, [pc, #248]	@ (802816c <LOG_fprintf+0x144>)
 8028074:	eb00 1080 	add.w	r0, r0, r0, lsl #6
 8028078:	eb07 0040 	add.w	r0, r7, r0, lsl #1
 802807c:	2180      	movs	r1, #128	@ 0x80
 802807e:	f001 fc8f 	bl	80299a0 <sniprintf>
    }

    vsnprintf(logQueue[logHead].data + strlen(logQueue[logHead].data),LOG_MSG_MAX_LEN - strlen(logQueue[logHead].data),str, args);
 8028082:	f894 8000 	ldrb.w	r8, [r4]
 8028086:	7820      	ldrb	r0, [r4, #0]
 8028088:	eb00 1080 	add.w	r0, r0, r0, lsl #6
 802808c:	eb07 0040 	add.w	r0, r7, r0, lsl #1
 8028090:	f7f8 f926 	bl	80202e0 <strlen>
 8028094:	7823      	ldrb	r3, [r4, #0]
 8028096:	eb03 1383 	add.w	r3, r3, r3, lsl #6
 802809a:	4606      	mov	r6, r0
 802809c:	eb07 0043 	add.w	r0, r7, r3, lsl #1
 80280a0:	f7f8 f91e 	bl	80202e0 <strlen>
 80280a4:	fa5f f888 	uxtb.w	r8, r8
 80280a8:	2382      	movs	r3, #130	@ 0x82
 80280aa:	f1c0 0180 	rsb	r1, r0, #128	@ 0x80
 80280ae:	fb13 6008 	smlabb	r0, r3, r8, r6
 80280b2:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 80280b4:	9b01      	ldr	r3, [sp, #4]
 80280b6:	4438      	add	r0, r7
 80280b8:	f001 fd1a 	bl	8029af0 <vsniprintf>
    va_end(args);

    logQueue[logHead].length = strlen(logQueue[logHead].data);
 80280bc:	7820      	ldrb	r0, [r4, #0]
 80280be:	eb00 1080 	add.w	r0, r0, r0, lsl #6
 80280c2:	eb07 0040 	add.w	r0, r7, r0, lsl #1
 80280c6:	f7f8 f90b 	bl	80202e0 <strlen>
 80280ca:	7823      	ldrb	r3, [r4, #0]
    logHead = nextHead;
 80280cc:	7025      	strb	r5, [r4, #0]
    logQueue[logHead].length = strlen(logQueue[logHead].data);
 80280ce:	eb03 1383 	add.w	r3, r3, r3, lsl #6
 80280d2:	eb04 0343 	add.w	r3, r4, r3, lsl #1


    if (!logTransmitting) {
 80280d6:	f894 2414 	ldrb.w	r2, [r4, #1044]	@ 0x414
    logQueue[logHead].length = strlen(logQueue[logHead].data);
 80280da:	f8a3 0084 	strh.w	r0, [r3, #132]	@ 0x84
    if (!logTransmitting) {
 80280de:	f002 03ff 	and.w	r3, r2, #255	@ 0xff
 80280e2:	b122      	cbz	r2, 80280ee <LOG_fprintf+0xc6>
        UART7_StartNextLog();
    }
}
 80280e4:	b003      	add	sp, #12
 80280e6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 80280ea:	b003      	add	sp, #12
 80280ec:	4770      	bx	lr
    if (logHead == logTail) {
 80280ee:	7821      	ldrb	r1, [r4, #0]
 80280f0:	7862      	ldrb	r2, [r4, #1]
 80280f2:	4291      	cmp	r1, r2
 80280f4:	d02e      	beq.n	8028154 <LOG_fprintf+0x12c>
    logTransmitting = true;
 80280f6:	2301      	movs	r3, #1
 80280f8:	f884 3414 	strb.w	r3, [r4, #1044]	@ 0x414
    HAL_UART_Transmit_DMA(&huart7, (uint8_t*)logQueue[logTail].data, logQueue[logTail].length);
 80280fc:	7861      	ldrb	r1, [r4, #1]
 80280fe:	7863      	ldrb	r3, [r4, #1]
 8028100:	481b      	ldr	r0, [pc, #108]	@ (8028170 <LOG_fprintf+0x148>)
 8028102:	eb03 1383 	add.w	r3, r3, r3, lsl #6
 8028106:	eb04 0443 	add.w	r4, r4, r3, lsl #1
 802810a:	eb01 1181 	add.w	r1, r1, r1, lsl #6
 802810e:	f8b4 2084 	ldrh.w	r2, [r4, #132]	@ 0x84
 8028112:	eb07 0141 	add.w	r1, r7, r1, lsl #1
 8028116:	f7fb f971 	bl	80233fc <HAL_UART_Transmit_DMA>
}
 802811a:	b003      	add	sp, #12
 802811c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8028120:	b003      	add	sp, #12
 8028122:	4770      	bx	lr
    case LOG_APP:    snprintf(logQueue[logHead].data, LOG_MSG_MAX_LEN, "%s: ", log_sources[0]); break;
 8028124:	7820      	ldrb	r0, [r4, #0]
 8028126:	4b13      	ldr	r3, [pc, #76]	@ (8028174 <LOG_fprintf+0x14c>)
 8028128:	e7a3      	b.n	8028072 <LOG_fprintf+0x4a>
    case LOG_HW:     snprintf(logQueue[logHead].data, LOG_MSG_MAX_LEN, "%s: ", log_sources[1]); break;
 802812a:	7820      	ldrb	r0, [r4, #0]
 802812c:	4b12      	ldr	r3, [pc, #72]	@ (8028178 <LOG_fprintf+0x150>)
 802812e:	e7a0      	b.n	8028072 <LOG_fprintf+0x4a>
    case LOG_FU:     snprintf(logQueue[logHead].data, LOG_MSG_MAX_LEN, "%s: ", log_sources[2]); break;
 8028130:	7820      	ldrb	r0, [r4, #0]
 8028132:	4b12      	ldr	r3, [pc, #72]	@ (802817c <LOG_fprintf+0x154>)
 8028134:	e79d      	b.n	8028072 <LOG_fprintf+0x4a>
    case LOG_ERROR:  snprintf(logQueue[logHead].data, LOG_MSG_MAX_LEN, "%s: ", log_sources[3]); break;
 8028136:	7820      	ldrb	r0, [r4, #0]
 8028138:	4b11      	ldr	r3, [pc, #68]	@ (8028180 <LOG_fprintf+0x158>)
 802813a:	e79a      	b.n	8028072 <LOG_fprintf+0x4a>
    case LOG_MEMORY: snprintf(logQueue[logHead].data, LOG_MSG_MAX_LEN, "%s: ", log_sources[4]); break;
 802813c:	7820      	ldrb	r0, [r4, #0]
 802813e:	4b11      	ldr	r3, [pc, #68]	@ (8028184 <LOG_fprintf+0x15c>)
 8028140:	e797      	b.n	8028072 <LOG_fprintf+0x4a>
    case LOG_TEST:   snprintf(logQueue[logHead].data, LOG_MSG_MAX_LEN, "%s: ", log_sources[5]); break;
 8028142:	7820      	ldrb	r0, [r4, #0]
 8028144:	4b10      	ldr	r3, [pc, #64]	@ (8028188 <LOG_fprintf+0x160>)
 8028146:	e794      	b.n	8028072 <LOG_fprintf+0x4a>
    case LOG_0:      snprintf(logQueue[logHead].data, LOG_MSG_MAX_LEN, "%s: ", log_sources[6]); break;
 8028148:	7820      	ldrb	r0, [r4, #0]
 802814a:	4b10      	ldr	r3, [pc, #64]	@ (802818c <LOG_fprintf+0x164>)
 802814c:	e791      	b.n	8028072 <LOG_fprintf+0x4a>
    case LOG_MODBUS: snprintf(logQueue[logHead].data, LOG_MSG_MAX_LEN, "%s: ", log_sources[7]); break;
 802814e:	7820      	ldrb	r0, [r4, #0]
 8028150:	4b0f      	ldr	r3, [pc, #60]	@ (8028190 <LOG_fprintf+0x168>)
 8028152:	e78e      	b.n	8028072 <LOG_fprintf+0x4a>
        logTransmitting = false;
 8028154:	f884 3414 	strb.w	r3, [r4, #1044]	@ 0x414
}
 8028158:	b003      	add	sp, #12
 802815a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 802815e:	b003      	add	sp, #12
 8028160:	4770      	bx	lr
 8028162:	bf00      	nop
 8028164:	20023924 	.word	0x20023924
 8028168:	0802ecd8 	.word	0x0802ecd8
 802816c:	0802ecb0 	.word	0x0802ecb0
 8028170:	20023d3c 	.word	0x20023d3c
 8028174:	0802ecac 	.word	0x0802ecac
 8028178:	0802ecb8 	.word	0x0802ecb8
 802817c:	0802ecbc 	.word	0x0802ecbc
 8028180:	0802e4d4 	.word	0x0802e4d4
 8028184:	0802ecc8 	.word	0x0802ecc8
 8028188:	0802eccc 	.word	0x0802eccc
 802818c:	0802ecd4 	.word	0x0802ecd4
 8028190:	0802eca4 	.word	0x0802eca4

08028194 <UART7_Init>:

void UART7_Init(void)
{
 8028194:	b5f0      	push	{r4, r5, r6, r7, lr}
 8028196:	b083      	sub	sp, #12
    huart7.Instance = UART7;
    huart7.Init.BaudRate = 1500000;
    huart7.Init.WordLength = UART_WORDLENGTH_8B;
 8028198:	2500      	movs	r5, #0
    huart7.Init.Parity = UART_PARITY_NONE;
    huart7.Init.Mode = UART_MODE_TX_RX;
    huart7.Init.HwFlowCtl = UART_HWCONTROL_NONE;
    huart7.Init.OverSampling = UART_OVERSAMPLING_16;

    __HAL_RCC_DMA1_CLK_ENABLE();
 802819a:	4b2c      	ldr	r3, [pc, #176]	@ (802824c <UART7_Init+0xb8>)
 802819c:	9501      	str	r5, [sp, #4]
 802819e:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
    huart7.Instance = UART7;
 80281a0:	4c2b      	ldr	r4, [pc, #172]	@ (8028250 <UART7_Init+0xbc>)

    //DMA_Init
    hdma_uart7_tx.Instance = DMA1_Stream1;
 80281a2:	492c      	ldr	r1, [pc, #176]	@ (8028254 <UART7_Init+0xc0>)
    __HAL_RCC_DMA1_CLK_ENABLE();
 80281a4:	f442 1200 	orr.w	r2, r2, #2097152	@ 0x200000
 80281a8:	631a      	str	r2, [r3, #48]	@ 0x30
 80281aa:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
    huart7.Instance = UART7;
 80281ac:	4a2a      	ldr	r2, [pc, #168]	@ (8028258 <UART7_Init+0xc4>)
 80281ae:	f8c4 2418 	str.w	r2, [r4, #1048]	@ 0x418
    __HAL_RCC_DMA1_CLK_ENABLE();
 80281b2:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
 80281b6:	9301      	str	r3, [sp, #4]
 80281b8:	9b01      	ldr	r3, [sp, #4]
    huart7.Init.BaudRate = 1500000;
 80281ba:	4a28      	ldr	r2, [pc, #160]	@ (802825c <UART7_Init+0xc8>)
    hdma_uart7_tx.Instance = DMA1_Stream1;
 80281bc:	f8c4 1458 	str.w	r1, [r4, #1112]	@ 0x458
    hdma_uart7_tx.Init.Channel = DMA_CHANNEL_5;
 80281c0:	f04f 6320 	mov.w	r3, #167772160	@ 0xa000000
    hdma_uart7_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_uart7_tx.Init.Mode = DMA_NORMAL;
    hdma_uart7_tx.Init.Priority = DMA_PRIORITY_LOW;
    hdma_uart7_tx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;

    HAL_DMA_Init(&hdma_uart7_tx);
 80281c4:	f504 678b 	add.w	r7, r4, #1112	@ 0x458
    hdma_uart7_tx.Init.Channel = DMA_CHANNEL_5;
 80281c8:	f8c4 345c 	str.w	r3, [r4, #1116]	@ 0x45c
    hdma_uart7_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 80281cc:	2340      	movs	r3, #64	@ 0x40
    huart7.Init.Mode = UART_MODE_TX_RX;
 80281ce:	260c      	movs	r6, #12
    hdma_uart7_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 80281d0:	f8c4 3460 	str.w	r3, [r4, #1120]	@ 0x460
    HAL_DMA_Init(&hdma_uart7_tx);
 80281d4:	4638      	mov	r0, r7
    hdma_uart7_tx.Init.MemInc = DMA_MINC_ENABLE;
 80281d6:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 80281da:	f8c4 3468 	str.w	r3, [r4, #1128]	@ 0x468
    huart7.Init.BaudRate = 1500000;
 80281de:	f8c4 241c 	str.w	r2, [r4, #1052]	@ 0x41c
    huart7.Init.WordLength = UART_WORDLENGTH_8B;
 80281e2:	f8c4 5420 	str.w	r5, [r4, #1056]	@ 0x420
    huart7.Init.StopBits = UART_STOPBITS_1;
 80281e6:	f8c4 5424 	str.w	r5, [r4, #1060]	@ 0x424
    huart7.Init.Parity = UART_PARITY_NONE;
 80281ea:	f8c4 5428 	str.w	r5, [r4, #1064]	@ 0x428
    huart7.Init.OverSampling = UART_OVERSAMPLING_16;
 80281ee:	f8c4 5434 	str.w	r5, [r4, #1076]	@ 0x434
    hdma_uart7_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 80281f2:	f8c4 5464 	str.w	r5, [r4, #1124]	@ 0x464
    hdma_uart7_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 80281f6:	f8c4 546c 	str.w	r5, [r4, #1132]	@ 0x46c
    hdma_uart7_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 80281fa:	f8c4 5470 	str.w	r5, [r4, #1136]	@ 0x470
    hdma_uart7_tx.Init.Mode = DMA_NORMAL;
 80281fe:	f8c4 5474 	str.w	r5, [r4, #1140]	@ 0x474
    hdma_uart7_tx.Init.Priority = DMA_PRIORITY_LOW;
 8028202:	f8c4 5478 	str.w	r5, [r4, #1144]	@ 0x478
    hdma_uart7_tx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 8028206:	f8c4 547c 	str.w	r5, [r4, #1148]	@ 0x47c
    huart7.Init.Mode = UART_MODE_TX_RX;
 802820a:	f8c4 642c 	str.w	r6, [r4, #1068]	@ 0x42c
 802820e:	f8c4 5430 	str.w	r5, [r4, #1072]	@ 0x430
    HAL_DMA_Init(&hdma_uart7_tx);
 8028212:	f7f9 fa95 	bl	8021740 <HAL_DMA_Init>

    __HAL_LINKDMA(&huart7, hdmatx, hdma_uart7_tx);
 8028216:	f504 6083 	add.w	r0, r4, #1048	@ 0x418
 802821a:	f8c4 7448 	str.w	r7, [r4, #1096]	@ 0x448
 802821e:	f8c4 0490 	str.w	r0, [r4, #1168]	@ 0x490

    HAL_UART_Init(&huart7);
 8028222:	f7fb f8bb 	bl	802339c <HAL_UART_Init>

    HAL_NVIC_SetPriority(UART7_IRQn, 0, 0);
 8028226:	462a      	mov	r2, r5
 8028228:	4629      	mov	r1, r5
 802822a:	2052      	movs	r0, #82	@ 0x52
 802822c:	f7f9 fa00 	bl	8021630 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(UART7_IRQn);
 8028230:	2052      	movs	r0, #82	@ 0x52
 8028232:	f7f9 fa39 	bl	80216a8 <HAL_NVIC_EnableIRQ>

    HAL_NVIC_SetPriority(DMA1_Stream1_IRQn, 0, 0);
 8028236:	4630      	mov	r0, r6
 8028238:	462a      	mov	r2, r5
 802823a:	4629      	mov	r1, r5
 802823c:	f7f9 f9f8 	bl	8021630 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(DMA1_Stream1_IRQn);
 8028240:	4630      	mov	r0, r6
}
 8028242:	b003      	add	sp, #12
 8028244:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    HAL_NVIC_EnableIRQ(DMA1_Stream1_IRQn);
 8028248:	f7f9 ba2e 	b.w	80216a8 <HAL_NVIC_EnableIRQ>
 802824c:	40023800 	.word	0x40023800
 8028250:	20023924 	.word	0x20023924
 8028254:	40026028 	.word	0x40026028
 8028258:	40007800 	.word	0x40007800
 802825c:	0016e360 	.word	0x0016e360

08028260 <HAL_UART_TxCpltCallback>:


void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
{
    if (huart->Instance == UART7)
 8028260:	4b13      	ldr	r3, [pc, #76]	@ (80282b0 <HAL_UART_TxCpltCallback+0x50>)
 8028262:	6802      	ldr	r2, [r0, #0]
 8028264:	429a      	cmp	r2, r3
 8028266:	d000      	beq.n	802826a <HAL_UART_TxCpltCallback+0xa>
#endif

        logTail = (logTail + 1) % LOG_QUEUE_SIZE;
        UART7_StartNextLog();
    }
}
 8028268:	4770      	bx	lr
        logTail = (logTail + 1) % LOG_QUEUE_SIZE;
 802826a:	4812      	ldr	r0, [pc, #72]	@ (80282b4 <HAL_UART_TxCpltCallback+0x54>)
 802826c:	7843      	ldrb	r3, [r0, #1]
 802826e:	3301      	adds	r3, #1
 8028270:	f003 0307 	and.w	r3, r3, #7
 8028274:	7043      	strb	r3, [r0, #1]
    if (logHead == logTail) {
 8028276:	7802      	ldrb	r2, [r0, #0]
 8028278:	7843      	ldrb	r3, [r0, #1]
 802827a:	429a      	cmp	r2, r3
 802827c:	d014      	beq.n	80282a8 <HAL_UART_TxCpltCallback+0x48>
    logTransmitting = true;
 802827e:	2301      	movs	r3, #1
 8028280:	f880 3414 	strb.w	r3, [r0, #1044]	@ 0x414
    HAL_UART_Transmit_DMA(&huart7, (uint8_t*)logQueue[logTail].data, logQueue[logTail].length);
 8028284:	7842      	ldrb	r2, [r0, #1]
 8028286:	7843      	ldrb	r3, [r0, #1]
 8028288:	eb03 1383 	add.w	r3, r3, r3, lsl #6
 802828c:	eb00 0343 	add.w	r3, r0, r3, lsl #1
 8028290:	f100 0c04 	add.w	ip, r0, #4
 8028294:	eb02 1182 	add.w	r1, r2, r2, lsl #6
 8028298:	eb0c 0141 	add.w	r1, ip, r1, lsl #1
 802829c:	f8b3 2084 	ldrh.w	r2, [r3, #132]	@ 0x84
 80282a0:	f500 6083 	add.w	r0, r0, #1048	@ 0x418
 80282a4:	f7fb b8aa 	b.w	80233fc <HAL_UART_Transmit_DMA>
        logTransmitting = false;
 80282a8:	2300      	movs	r3, #0
 80282aa:	f880 3414 	strb.w	r3, [r0, #1044]	@ 0x414
        return;
 80282ae:	4770      	bx	lr
 80282b0:	40007800 	.word	0x40007800
 80282b4:	20023924 	.word	0x20023924

080282b8 <UART7_IRQHandler>:

void UART7_IRQHandler(void)
{
	HAL_UART_IRQHandler(&huart7);
 80282b8:	4801      	ldr	r0, [pc, #4]	@ (80282c0 <UART7_IRQHandler+0x8>)
 80282ba:	f7fb b967 	b.w	802358c <HAL_UART_IRQHandler>
 80282be:	bf00      	nop
 80282c0:	20023d3c 	.word	0x20023d3c

080282c4 <DMA1_Stream1_IRQHandler>:
}

void DMA1_Stream1_IRQHandler(void)
{

	HAL_DMA_IRQHandler(&hdma_uart7_tx);
 80282c4:	4801      	ldr	r0, [pc, #4]	@ (80282cc <DMA1_Stream1_IRQHandler+0x8>)
 80282c6:	f7f9 bb21 	b.w	802190c <HAL_DMA_IRQHandler>
 80282ca:	bf00      	nop
 80282cc:	20023d7c 	.word	0x20023d7c

080282d0 <main>:

float* collectedData = NULL;
char calculationsInterrupt = 0;

int main(void)
{
 80282d0:	b500      	push	{lr}
    SCB->VTOR = 0x8020000;
 80282d2:	4b48      	ldr	r3, [pc, #288]	@ (80283f4 <main+0x124>)
 80282d4:	4a48      	ldr	r2, [pc, #288]	@ (80283f8 <main+0x128>)
    AdiConf_t fromMemoryConfig;

    Memory_TakeConfig(&fromMemoryConfig);
    Memory_ShowConfig(&fromMemoryConfig);

    Sensor.configuration.sensor_ID = fromMemoryConfig.sensor_ID;
 80282d6:	4e49      	ldr	r6, [pc, #292]	@ (80283fc <main+0x12c>)
    memcpy(Sensor.configuration.MAC, fromMemoryConfig.MAC, 12);
    Sensor.configuration.RS485_speed = fromMemoryConfig.RS485_speed;
    Protocol = fromMemoryConfig.protocol;
 80282d8:	4c49      	ldr	r4, [pc, #292]	@ (8028400 <main+0x130>)
{
 80282da:	b095      	sub	sp, #84	@ 0x54
    SCB->VTOR = 0x8020000;
 80282dc:	609a      	str	r2, [r3, #8]
    HAL_Init();
 80282de:	f7f8 fed5 	bl	802108c <HAL_Init>
    SystemClock_Config();
 80282e2:	f7fd f8cd 	bl	8025480 <SystemClock_Config>
    GPIO_Init();
 80282e6:	f7fd f92f 	bl	8025548 <GPIO_Init>
    LOG_Init();
 80282ea:	f7ff ff53 	bl	8028194 <UART7_Init>
    ADC_Temp_Init();
 80282ee:	f7fd fd33 	bl	8025d58 <ADC_Temp_Init>
    TIMER_Sleep_Init();
 80282f2:	f7fd fdf7 	bl	8025ee4 <TIMER_Sleep_Init>
    TIMER_AcqSample_Init();
 80282f6:	f7fd fdd5 	bl	8025ea4 <TIMER_AcqSample_Init>
    TIMER_TempSample_Init();
 80282fa:	f7fd fdd5 	bl	8025ea8 <TIMER_TempSample_Init>
    PRINTF_HW("\n\n");
 80282fe:	4941      	ldr	r1, [pc, #260]	@ (8028404 <main+0x134>)
 8028300:	2001      	movs	r0, #1
 8028302:	f7ff fe91 	bl	8028028 <LOG_fprintf>
    PRINTF_HW("Software version: %02d:%02d:%02d\n", SOFTWARE_MAJOR, SOFTWARE_MINOR, SOFTWARE_PATCH);
 8028306:	2500      	movs	r5, #0
 8028308:	2301      	movs	r3, #1
 802830a:	461a      	mov	r2, r3
 802830c:	4618      	mov	r0, r3
 802830e:	493e      	ldr	r1, [pc, #248]	@ (8028408 <main+0x138>)
 8028310:	9500      	str	r5, [sp, #0]
 8028312:	f7ff fe89 	bl	8028028 <LOG_fprintf>
    PRINTF_HW("Hardware version: %02d:%02d:%02d\n", HARDWARE_MAJOR, HARDWARE_MINOR, HARDWARE_REVISION);
 8028316:	2302      	movs	r3, #2
 8028318:	2203      	movs	r2, #3
 802831a:	493c      	ldr	r1, [pc, #240]	@ (802840c <main+0x13c>)
 802831c:	9500      	str	r5, [sp, #0]
 802831e:	2001      	movs	r0, #1
 8028320:	f7ff fe82 	bl	8028028 <LOG_fprintf>
    PRINTF_HW("Sensor type: LF\n\n\n");
 8028324:	493a      	ldr	r1, [pc, #232]	@ (8028410 <main+0x140>)
 8028326:	2001      	movs	r0, #1
 8028328:	f7ff fe7e 	bl	8028028 <LOG_fprintf>
    SPI1_Init();
 802832c:	f7fd fc7e 	bl	8025c2c <SPI1_Init>
    Memory_Init();
 8028330:	f7fe fc64 	bl	8026bfc <Memory_Init>
    adxl_Init();
 8028334:	f7fc ffe0 	bl	80252f8 <adxl_Init>
    Memory_TakeConfig(&fromMemoryConfig);
 8028338:	a802      	add	r0, sp, #8
 802833a:	f7fe fe35 	bl	8026fa8 <Memory_TakeConfig>
    Memory_ShowConfig(&fromMemoryConfig);
 802833e:	a802      	add	r0, sp, #8
 8028340:	f7fe fe42 	bl	8026fc8 <Memory_ShowConfig>
    memcpy(Sensor.configuration.MAC, fromMemoryConfig.MAC, 12);
 8028344:	f8dd 300f 	ldr.w	r3, [sp, #15]
 8028348:	f8c6 306f 	str.w	r3, [r6, #111]	@ 0x6f
    Sensor.configuration.RS485_speed = fromMemoryConfig.RS485_speed;
 802834c:	f89d 301b 	ldrb.w	r3, [sp, #27]
 8028350:	f886 307b 	strb.w	r3, [r6, #123]	@ 0x7b
    Protocol = fromMemoryConfig.protocol;
 8028354:	f89d 301c 	ldrb.w	r3, [sp, #28]
 8028358:	7023      	strb	r3, [r4, #0]
    memcpy(Sensor.configuration.MAC, fromMemoryConfig.MAC, 12);
 802835a:	f8dd 3013 	ldr.w	r3, [sp, #19]
    Sensor.configuration.sensor_ID = fromMemoryConfig.sensor_ID;
 802835e:	f89d 200e 	ldrb.w	r2, [sp, #14]
    memcpy(Sensor.configuration.MAC, fromMemoryConfig.MAC, 12);
 8028362:	f8c6 3073 	str.w	r3, [r6, #115]	@ 0x73
 8028366:	f8dd 3017 	ldr.w	r3, [sp, #23]
    Sensor.configuration.sensor_ID = fromMemoryConfig.sensor_ID;
 802836a:	f886 206e 	strb.w	r2, [r6, #110]	@ 0x6e
    memcpy(Sensor.configuration.MAC, fromMemoryConfig.MAC, 12);
 802836e:	f8c6 3077 	str.w	r3, [r6, #119]	@ 0x77

    ACQ_Init();
 8028372:	f7fb fa0b 	bl	802378c <ACQ_Init>

    PRINTF_APP("Odczytano id po zapisie\r\n");
 8028376:	4927      	ldr	r1, [pc, #156]	@ (8028414 <main+0x144>)
 8028378:	4628      	mov	r0, r5
 802837a:	f7ff fe55 	bl	8028028 <LOG_fprintf>
    Memory_ShowConfig(&fromMemoryConfig);
 802837e:	a802      	add	r0, sp, #8
 8028380:	f7fe fe22 	bl	8026fc8 <Memory_ShowConfig>

    RS485_Init(Sensor.configuration.RS485_speed);
 8028384:	f896 007b 	ldrb.w	r0, [r6, #123]	@ 0x7b
 8028388:	f7fd fa72 	bl	8025870 <RS485_Init>
    FAST_UART_RX_Start();
 802838c:	f7fd f9fc 	bl	8025788 <FAST_UART_RX_Start>
    CommLink_Init();
 8028390:	f7fc fde4 	bl	8024f5c <CommLink_Init>
    PRINTF_HW("Init ok\n");
 8028394:	4920      	ldr	r1, [pc, #128]	@ (8028418 <main+0x148>)
 8028396:	2001      	movs	r0, #1
 8028398:	f7ff fe46 	bl	8028028 <LOG_fprintf>

    TimerTemperature_Start();
 802839c:	f7fd fd7c 	bl	8025e98 <TimerTemperature_Start>

    modbusRTU_init(fromMemoryConfig.sensor_ID);
 80283a0:	f89d 000e 	ldrb.w	r0, [sp, #14]
 80283a4:	f7ff f8ec 	bl	8027580 <modbusRTU_init>
    PRINTF_HW("Init ok\n");
 80283a8:	491b      	ldr	r1, [pc, #108]	@ (8028418 <main+0x148>)
 80283aa:	2001      	movs	r0, #1
 80283ac:	f7ff fe3c 	bl	8028028 <LOG_fprintf>
    PRINTF_APP("Protocol : %s \n", enum2str(Protocol));
 80283b0:	7820      	ldrb	r0, [r4, #0]
 80283b2:	f7ff fe29 	bl	8028008 <enum2str>
 80283b6:	4919      	ldr	r1, [pc, #100]	@ (802841c <main+0x14c>)
 80283b8:	4602      	mov	r2, r0
 80283ba:	4628      	mov	r0, r5
 80283bc:	f7ff fe34 	bl	8028028 <LOG_fprintf>

    ACQ_Start();
 80283c0:	f7fb fa3e 	bl	8023840 <ACQ_Start>

    while (1)
    {
        LED_red_Toggle();
 80283c4:	f7fd f8b8 	bl	8025538 <LED_red_Toggle>
        switch (Protocol)
 80283c8:	7823      	ldrb	r3, [r4, #0]
 80283ca:	b17b      	cbz	r3, 80283ec <main+0x11c>
 80283cc:	2b01      	cmp	r3, #1
 80283ce:	d1f9      	bne.n	80283c4 <main+0xf4>
        case SLS:
            Comm_Process();
            break;

        case MODBUS:
            modbusRTU_loop();
 80283d0:	f7fe ff02 	bl	80271d8 <modbusRTU_loop>
            if (calculationsInterrupt == 1)
 80283d4:	7863      	ldrb	r3, [r4, #1]
 80283d6:	2b01      	cmp	r3, #1
 80283d8:	d1f4      	bne.n	80283c4 <main+0xf4>
            {
                calculateEstimates(collectedData);
 80283da:	6860      	ldr	r0, [r4, #4]
 80283dc:	f7fc fed2 	bl	8025184 <calculateEstimates>
                calculationsInterrupt = 0;
 80283e0:	7065      	strb	r5, [r4, #1]
        LED_red_Toggle();
 80283e2:	f7fd f8a9 	bl	8025538 <LED_red_Toggle>
        switch (Protocol)
 80283e6:	7823      	ldrb	r3, [r4, #0]
 80283e8:	2b00      	cmp	r3, #0
 80283ea:	d1ef      	bne.n	80283cc <main+0xfc>
            Comm_Process();
 80283ec:	f7fc fc00 	bl	8024bf0 <Comm_Process>
            break;
 80283f0:	e7e8      	b.n	80283c4 <main+0xf4>
 80283f2:	bf00      	nop
 80283f4:	e000ed00 	.word	0xe000ed00
 80283f8:	08020000 	.word	0x08020000
 80283fc:	20000008 	.word	0x20000008
 8028400:	20023e5c 	.word	0x20023e5c
 8028404:	0802ed38 	.word	0x0802ed38
 8028408:	0802ece0 	.word	0x0802ece0
 802840c:	0802ed04 	.word	0x0802ed04
 8028410:	0802ed28 	.word	0x0802ed28
 8028414:	0802ed3c 	.word	0x0802ed3c
 8028418:	0802ed58 	.word	0x0802ed58
 802841c:	0802ed64 	.word	0x0802ed64

08028420 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 8028420:	b082      	sub	sp, #8
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8028422:	4b0c      	ldr	r3, [pc, #48]	@ (8028454 <HAL_MspInit+0x34>)
 8028424:	2100      	movs	r1, #0
 8028426:	9100      	str	r1, [sp, #0]
 8028428:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 802842a:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
 802842e:	645a      	str	r2, [r3, #68]	@ 0x44
 8028430:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 8028432:	f402 4280 	and.w	r2, r2, #16384	@ 0x4000
 8028436:	9200      	str	r2, [sp, #0]
 8028438:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_PWR_CLK_ENABLE();
 802843a:	9101      	str	r1, [sp, #4]
 802843c:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
 802843e:	f042 5280 	orr.w	r2, r2, #268435456	@ 0x10000000
 8028442:	641a      	str	r2, [r3, #64]	@ 0x40
 8028444:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8028446:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 802844a:	9301      	str	r3, [sp, #4]
 802844c:	9b01      	ldr	r3, [sp, #4]
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 802844e:	b002      	add	sp, #8
 8028450:	4770      	bx	lr
 8028452:	bf00      	nop
 8028454:	40023800 	.word	0x40023800

08028458 <HAL_UART_MspInit>:
* This function configures the hardware resources used in this example
* @param huart: UART handle pointer
* @retval None
*/
void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
 8028458:	b510      	push	{r4, lr}
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(huart->Instance==UART7)
 802845a:	6803      	ldr	r3, [r0, #0]
 802845c:	4a36      	ldr	r2, [pc, #216]	@ (8028538 <HAL_UART_MspInit+0xe0>)
{
 802845e:	b08a      	sub	sp, #40	@ 0x28
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8028460:	2400      	movs	r4, #0
  if(huart->Instance==UART7)
 8028462:	4293      	cmp	r3, r2
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8028464:	e9cd 4404 	strd	r4, r4, [sp, #16]
 8028468:	e9cd 4406 	strd	r4, r4, [sp, #24]
 802846c:	9408      	str	r4, [sp, #32]
  if(huart->Instance==UART7)
 802846e:	d004      	beq.n	802847a <HAL_UART_MspInit+0x22>
    //HAL_NVIC_EnableIRQ(UART7_IRQn);
  /* USER CODE BEGIN UART7_MspInit 1 */

  /* USER CODE END UART7_MspInit 1 */
  }
  else if(huart->Instance==USART1)
 8028470:	4a32      	ldr	r2, [pc, #200]	@ (802853c <HAL_UART_MspInit+0xe4>)
 8028472:	4293      	cmp	r3, r2
 8028474:	d026      	beq.n	80284c4 <HAL_UART_MspInit+0x6c>
  /* USER CODE BEGIN USART1_MspInit 1 */

  /* USER CODE END USART1_MspInit 1 */
  }

}
 8028476:	b00a      	add	sp, #40	@ 0x28
 8028478:	bd10      	pop	{r4, pc}
    __HAL_RCC_UART7_CLK_ENABLE();
 802847a:	4b31      	ldr	r3, [pc, #196]	@ (8028540 <HAL_UART_MspInit+0xe8>)
 802847c:	9400      	str	r4, [sp, #0]
 802847e:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8028480:	4830      	ldr	r0, [pc, #192]	@ (8028544 <HAL_UART_MspInit+0xec>)
    __HAL_RCC_UART7_CLK_ENABLE();
 8028482:	f042 4280 	orr.w	r2, r2, #1073741824	@ 0x40000000
 8028486:	641a      	str	r2, [r3, #64]	@ 0x40
 8028488:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
 802848a:	f002 4280 	and.w	r2, r2, #1073741824	@ 0x40000000
 802848e:	9200      	str	r2, [sp, #0]
 8028490:	9a00      	ldr	r2, [sp, #0]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8028492:	9401      	str	r4, [sp, #4]
 8028494:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
    GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_4;
 8028496:	ed9f 7b22 	vldr	d7, [pc, #136]	@ 8028520 <HAL_UART_MspInit+0xc8>
    __HAL_RCC_GPIOB_CLK_ENABLE();
 802849a:	f042 0202 	orr.w	r2, r2, #2
 802849e:	631a      	str	r2, [r3, #48]	@ 0x30
 80284a0:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
    GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_4;
 80284a2:	ed8d 7b04 	vstr	d7, [sp, #16]
 80284a6:	ed9f 7b20 	vldr	d7, [pc, #128]	@ 8028528 <HAL_UART_MspInit+0xd0>
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80284aa:	f003 0302 	and.w	r3, r3, #2
 80284ae:	9301      	str	r3, [sp, #4]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80284b0:	a904      	add	r1, sp, #16
    GPIO_InitStruct.Alternate = GPIO_AF8_UART7;
 80284b2:	2308      	movs	r3, #8
    GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_4;
 80284b4:	ed8d 7b06 	vstr	d7, [sp, #24]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80284b8:	9a01      	ldr	r2, [sp, #4]
    GPIO_InitStruct.Alternate = GPIO_AF8_UART7;
 80284ba:	9308      	str	r3, [sp, #32]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80284bc:	f7f9 fc02 	bl	8021cc4 <HAL_GPIO_Init>
}
 80284c0:	b00a      	add	sp, #40	@ 0x28
 80284c2:	bd10      	pop	{r4, pc}
    __HAL_RCC_USART1_CLK_ENABLE();
 80284c4:	4b1e      	ldr	r3, [pc, #120]	@ (8028540 <HAL_UART_MspInit+0xe8>)
 80284c6:	9402      	str	r4, [sp, #8]
 80284c8:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80284ca:	481f      	ldr	r0, [pc, #124]	@ (8028548 <HAL_UART_MspInit+0xf0>)
    __HAL_RCC_USART1_CLK_ENABLE();
 80284cc:	f042 0210 	orr.w	r2, r2, #16
 80284d0:	645a      	str	r2, [r3, #68]	@ 0x44
 80284d2:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 80284d4:	f002 0210 	and.w	r2, r2, #16
 80284d8:	9202      	str	r2, [sp, #8]
 80284da:	9a02      	ldr	r2, [sp, #8]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80284dc:	9403      	str	r4, [sp, #12]
 80284de:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
    GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10;
 80284e0:	ed9f 7b13 	vldr	d7, [pc, #76]	@ 8028530 <HAL_UART_MspInit+0xd8>
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80284e4:	f042 0201 	orr.w	r2, r2, #1
 80284e8:	631a      	str	r2, [r3, #48]	@ 0x30
 80284ea:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
    GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10;
 80284ec:	ed8d 7b04 	vstr	d7, [sp, #16]
 80284f0:	ed9f 7b0d 	vldr	d7, [pc, #52]	@ 8028528 <HAL_UART_MspInit+0xd0>
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80284f4:	f003 0301 	and.w	r3, r3, #1
 80284f8:	9303      	str	r3, [sp, #12]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80284fa:	a904      	add	r1, sp, #16
    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
 80284fc:	2307      	movs	r3, #7
    GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10;
 80284fe:	ed8d 7b06 	vstr	d7, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
 8028502:	9308      	str	r3, [sp, #32]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8028504:	9a03      	ldr	r2, [sp, #12]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8028506:	f7f9 fbdd 	bl	8021cc4 <HAL_GPIO_Init>
    HAL_NVIC_SetPriority(USART1_IRQn, 0, 0);
 802850a:	4622      	mov	r2, r4
 802850c:	4621      	mov	r1, r4
 802850e:	2025      	movs	r0, #37	@ 0x25
 8028510:	f7f9 f88e 	bl	8021630 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART1_IRQn);
 8028514:	2025      	movs	r0, #37	@ 0x25
 8028516:	f7f9 f8c7 	bl	80216a8 <HAL_NVIC_EnableIRQ>
}
 802851a:	b00a      	add	sp, #40	@ 0x28
 802851c:	bd10      	pop	{r4, pc}
 802851e:	bf00      	nop
 8028520:	00000018 	.word	0x00000018
 8028524:	00000002 	.word	0x00000002
 8028528:	00000001 	.word	0x00000001
 802852c:	00000003 	.word	0x00000003
 8028530:	00000600 	.word	0x00000600
 8028534:	00000002 	.word	0x00000002
 8028538:	40007800 	.word	0x40007800
 802853c:	40011000 	.word	0x40011000
 8028540:	40023800 	.word	0x40023800
 8028544:	40020400 	.word	0x40020400
 8028548:	40020000 	.word	0x40020000

0802854c <NMI_Handler>:

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */

  /* USER CODE END NonMaskableInt_IRQn 1 */
}
 802854c:	4770      	bx	lr
 802854e:	bf00      	nop

08028550 <HardFault_Handler>:
void HardFault_Handler(void)
{
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 8028550:	e7fe      	b.n	8028550 <HardFault_Handler>
 8028552:	bf00      	nop

08028554 <MemManage_Handler>:
void MemManage_Handler(void)
{
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 8028554:	e7fe      	b.n	8028554 <MemManage_Handler>
 8028556:	bf00      	nop

08028558 <BusFault_Handler>:
void BusFault_Handler(void)
{
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 8028558:	e7fe      	b.n	8028558 <BusFault_Handler>
 802855a:	bf00      	nop

0802855c <UsageFault_Handler>:
void UsageFault_Handler(void)
{
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 802855c:	e7fe      	b.n	802855c <UsageFault_Handler>
 802855e:	bf00      	nop

08028560 <SVC_Handler>:
}

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
 8028560:	4770      	bx	lr
 8028562:	bf00      	nop

08028564 <DebugMon_Handler>:
}

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
 8028564:	4770      	bx	lr
 8028566:	bf00      	nop

08028568 <PendSV_Handler>:
}

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
 8028568:	4770      	bx	lr
 802856a:	bf00      	nop

0802856c <SysTick_Handler>:
void SysTick_Handler(void)
{
  /* USER CODE BEGIN SysTick_IRQn 0 */
  // exeCounter++;
  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 802856c:	f7f8 bda8 	b.w	80210c0 <HAL_IncTick>

08028570 <_getpid>:
}

int _getpid(void)
{
	return 1;
}
 8028570:	2001      	movs	r0, #1
 8028572:	4770      	bx	lr

08028574 <_kill>:

int _kill(int pid, int sig)
{
 8028574:	b508      	push	{r3, lr}
	errno = EINVAL;
 8028576:	f001 fb27 	bl	8029bc8 <__errno>
 802857a:	2316      	movs	r3, #22
 802857c:	6003      	str	r3, [r0, #0]
	return -1;
}
 802857e:	f04f 30ff 	mov.w	r0, #4294967295
 8028582:	bd08      	pop	{r3, pc}

08028584 <_exit>:

void _exit (int status)
{
 8028584:	b508      	push	{r3, lr}
	errno = EINVAL;
 8028586:	f001 fb1f 	bl	8029bc8 <__errno>
 802858a:	2316      	movs	r3, #22
 802858c:	6003      	str	r3, [r0, #0]
	_kill(status, -1);
	while (1) {}		/* Make sure we hang here */
 802858e:	e7fe      	b.n	802858e <_exit+0xa>

08028590 <_read>:
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
 8028590:	b570      	push	{r4, r5, r6, lr}
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 8028592:	1e16      	subs	r6, r2, #0
 8028594:	dd07      	ble.n	80285a6 <_read+0x16>
 8028596:	460c      	mov	r4, r1
 8028598:	198d      	adds	r5, r1, r6
	{
		*ptr++ = __io_getchar();
 802859a:	f3af 8000 	nop.w
 802859e:	f804 0b01 	strb.w	r0, [r4], #1
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 80285a2:	42a5      	cmp	r5, r4
 80285a4:	d1f9      	bne.n	802859a <_read+0xa>
	}

return len;
}
 80285a6:	4630      	mov	r0, r6
 80285a8:	bd70      	pop	{r4, r5, r6, pc}
 80285aa:	bf00      	nop

080285ac <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
 80285ac:	b570      	push	{r4, r5, r6, lr}
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 80285ae:	1e16      	subs	r6, r2, #0
 80285b0:	dd07      	ble.n	80285c2 <_write+0x16>
 80285b2:	460c      	mov	r4, r1
 80285b4:	198d      	adds	r5, r1, r6
	{
		__io_putchar(*ptr++);
 80285b6:	f814 0b01 	ldrb.w	r0, [r4], #1
 80285ba:	f3af 8000 	nop.w
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 80285be:	42a5      	cmp	r5, r4
 80285c0:	d1f9      	bne.n	80285b6 <_write+0xa>
	}
	return len;
}
 80285c2:	4630      	mov	r0, r6
 80285c4:	bd70      	pop	{r4, r5, r6, pc}
 80285c6:	bf00      	nop

080285c8 <_sbrk>:
{
	extern char end asm("end");
	static char *heap_end;
	char *prev_heap_end;

	if (heap_end == 0)
 80285c8:	4a0b      	ldr	r2, [pc, #44]	@ (80285f8 <_sbrk+0x30>)
{
 80285ca:	b508      	push	{r3, lr}
 80285cc:	4603      	mov	r3, r0
	if (heap_end == 0)
 80285ce:	6810      	ldr	r0, [r2, #0]
 80285d0:	b128      	cbz	r0, 80285de <_sbrk+0x16>
		heap_end = &end;

	prev_heap_end = heap_end;
	if (heap_end + incr > stack_ptr)
 80285d2:	4403      	add	r3, r0
 80285d4:	4669      	mov	r1, sp
 80285d6:	428b      	cmp	r3, r1
 80285d8:	d807      	bhi.n	80285ea <_sbrk+0x22>
//		abort();
		errno = ENOMEM;
		return (caddr_t) -1;
	}

	heap_end += incr;
 80285da:	6013      	str	r3, [r2, #0]

	return (caddr_t) prev_heap_end;
}
 80285dc:	bd08      	pop	{r3, pc}
		heap_end = &end;
 80285de:	4807      	ldr	r0, [pc, #28]	@ (80285fc <_sbrk+0x34>)
 80285e0:	6010      	str	r0, [r2, #0]
	if (heap_end + incr > stack_ptr)
 80285e2:	4403      	add	r3, r0
 80285e4:	4669      	mov	r1, sp
 80285e6:	428b      	cmp	r3, r1
 80285e8:	d9f7      	bls.n	80285da <_sbrk+0x12>
		errno = ENOMEM;
 80285ea:	f001 faed 	bl	8029bc8 <__errno>
 80285ee:	230c      	movs	r3, #12
 80285f0:	6003      	str	r3, [r0, #0]
		return (caddr_t) -1;
 80285f2:	f04f 30ff 	mov.w	r0, #4294967295
}
 80285f6:	bd08      	pop	{r3, pc}
 80285f8:	20023e64 	.word	0x20023e64
 80285fc:	20023fb8 	.word	0x20023fb8

08028600 <_close>:

int _close(int file)
{
	return -1;
}
 8028600:	f04f 30ff 	mov.w	r0, #4294967295
 8028604:	4770      	bx	lr
 8028606:	bf00      	nop

08028608 <_fstat>:


int _fstat(int file, struct stat *st)
{
	st->st_mode = S_IFCHR;
 8028608:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
 802860c:	604b      	str	r3, [r1, #4]
	return 0;
}
 802860e:	2000      	movs	r0, #0
 8028610:	4770      	bx	lr
 8028612:	bf00      	nop

08028614 <_isatty>:

int _isatty(int file)
{
	return 1;
}
 8028614:	2001      	movs	r0, #1
 8028616:	4770      	bx	lr

08028618 <_lseek>:

int _lseek(int file, int ptr, int dir)
{
	return 0;
}
 8028618:	2000      	movs	r0, #0
 802861a:	4770      	bx	lr

0802861c <SystemInit>:
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 802861c:	4911      	ldr	r1, [pc, #68]	@ (8028664 <SystemInit+0x48>)
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 802861e:	4b12      	ldr	r3, [pc, #72]	@ (8028668 <SystemInit+0x4c>)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8028620:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
 8028624:	f442 0270 	orr.w	r2, r2, #15728640	@ 0xf00000
{
 8028628:	b430      	push	{r4, r5}
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 802862a:	f8c1 2088 	str.w	r2, [r1, #136]	@ 0x88
  RCC->CR |= (uint32_t)0x00000001;
 802862e:	681a      	ldr	r2, [r3, #0]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 8028630:	4c0e      	ldr	r4, [pc, #56]	@ (802866c <SystemInit+0x50>)
  RCC->CFGR = 0x00000000;
 8028632:	2000      	movs	r0, #0
  RCC->CR |= (uint32_t)0x00000001;
 8028634:	f042 0201 	orr.w	r2, r2, #1
 8028638:	601a      	str	r2, [r3, #0]
  RCC->CFGR = 0x00000000;
 802863a:	6098      	str	r0, [r3, #8]
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 802863c:	681a      	ldr	r2, [r3, #0]
 802863e:	f022 7284 	bic.w	r2, r2, #17301504	@ 0x1080000
 8028642:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
 8028646:	601a      	str	r2, [r3, #0]
  RCC->PLLCFGR = 0x24003010;
 8028648:	605c      	str	r4, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 802864a:	681a      	ldr	r2, [r3, #0]
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
#endif
  SCB->VTOR = 0x08020000UL | VECT_TAB_OFFSET;
 802864c:	4c08      	ldr	r4, [pc, #32]	@ (8028670 <SystemInit+0x54>)
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 802864e:	f04f 6500 	mov.w	r5, #134217728	@ 0x8000000
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8028652:	f422 2280 	bic.w	r2, r2, #262144	@ 0x40000
 8028656:	601a      	str	r2, [r3, #0]
  RCC->CIR = 0x00000000;
 8028658:	60d8      	str	r0, [r3, #12]
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 802865a:	608d      	str	r5, [r1, #8]
  SCB->VTOR = 0x08020000UL | VECT_TAB_OFFSET;
 802865c:	608c      	str	r4, [r1, #8]
}
 802865e:	bc30      	pop	{r4, r5}
 8028660:	4770      	bx	lr
 8028662:	bf00      	nop
 8028664:	e000ed00 	.word	0xe000ed00
 8028668:	40023800 	.word	0x40023800
 802866c:	24003010 	.word	0x24003010
 8028670:	08020000 	.word	0x08020000

08028674 <Reset_Handler>:
 8028674:	f8df d034 	ldr.w	sp, [pc, #52]	@ 80286ac <LoopFillZerobss+0x14>
 8028678:	2100      	movs	r1, #0
 802867a:	e003      	b.n	8028684 <LoopCopyDataInit>

0802867c <CopyDataInit>:
 802867c:	4b0c      	ldr	r3, [pc, #48]	@ (80286b0 <LoopFillZerobss+0x18>)
 802867e:	585b      	ldr	r3, [r3, r1]
 8028680:	5043      	str	r3, [r0, r1]
 8028682:	3104      	adds	r1, #4

08028684 <LoopCopyDataInit>:
 8028684:	480b      	ldr	r0, [pc, #44]	@ (80286b4 <LoopFillZerobss+0x1c>)
 8028686:	4b0c      	ldr	r3, [pc, #48]	@ (80286b8 <LoopFillZerobss+0x20>)
 8028688:	1842      	adds	r2, r0, r1
 802868a:	429a      	cmp	r2, r3
 802868c:	d3f6      	bcc.n	802867c <CopyDataInit>
 802868e:	4a0b      	ldr	r2, [pc, #44]	@ (80286bc <LoopFillZerobss+0x24>)
 8028690:	e002      	b.n	8028698 <LoopFillZerobss>

08028692 <FillZerobss>:
 8028692:	2300      	movs	r3, #0
 8028694:	f842 3b04 	str.w	r3, [r2], #4

08028698 <LoopFillZerobss>:
 8028698:	4b09      	ldr	r3, [pc, #36]	@ (80286c0 <LoopFillZerobss+0x28>)
 802869a:	429a      	cmp	r2, r3
 802869c:	d3f9      	bcc.n	8028692 <FillZerobss>
 802869e:	f7ff ffbd 	bl	802861c <SystemInit>
 80286a2:	f001 fa97 	bl	8029bd4 <__libc_init_array>
 80286a6:	f7ff fe13 	bl	80282d0 <main>
 80286aa:	4770      	bx	lr
 80286ac:	20050000 	.word	0x20050000
 80286b0:	080422bc 	.word	0x080422bc
 80286b4:	20000000 	.word	0x20000000
 80286b8:	20000190 	.word	0x20000190
 80286bc:	20000190 	.word	0x20000190
 80286c0:	20023fb8 	.word	0x20023fb8

080286c4 <CAN1_RX0_IRQHandler>:
 80286c4:	e7fe      	b.n	80286c4 <CAN1_RX0_IRQHandler>
	...

080286c8 <arm_rfft_fast_init_f32>:
 80286c8:	084b      	lsrs	r3, r1, #1
 80286ca:	2b80      	cmp	r3, #128	@ 0x80
 80286cc:	b410      	push	{r4}
 80286ce:	8201      	strh	r1, [r0, #16]
 80286d0:	8003      	strh	r3, [r0, #0]
 80286d2:	d046      	beq.n	8028762 <arm_rfft_fast_init_f32+0x9a>
 80286d4:	d916      	bls.n	8028704 <arm_rfft_fast_init_f32+0x3c>
 80286d6:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 80286da:	d03c      	beq.n	8028756 <arm_rfft_fast_init_f32+0x8e>
 80286dc:	d928      	bls.n	8028730 <arm_rfft_fast_init_f32+0x68>
 80286de:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 80286e2:	d01f      	beq.n	8028724 <arm_rfft_fast_init_f32+0x5c>
 80286e4:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 80286e8:	d112      	bne.n	8028710 <arm_rfft_fast_init_f32+0x48>
 80286ea:	4920      	ldr	r1, [pc, #128]	@ (802876c <arm_rfft_fast_init_f32+0xa4>)
 80286ec:	4a20      	ldr	r2, [pc, #128]	@ (8028770 <arm_rfft_fast_init_f32+0xa8>)
 80286ee:	4b21      	ldr	r3, [pc, #132]	@ (8028774 <arm_rfft_fast_init_f32+0xac>)
 80286f0:	f44f 646e 	mov.w	r4, #3808	@ 0xee0
 80286f4:	8184      	strh	r4, [r0, #12]
 80286f6:	6081      	str	r1, [r0, #8]
 80286f8:	6042      	str	r2, [r0, #4]
 80286fa:	6143      	str	r3, [r0, #20]
 80286fc:	f85d 4b04 	ldr.w	r4, [sp], #4
 8028700:	2000      	movs	r0, #0
 8028702:	4770      	bx	lr
 8028704:	2b20      	cmp	r3, #32
 8028706:	d01c      	beq.n	8028742 <arm_rfft_fast_init_f32+0x7a>
 8028708:	2b40      	cmp	r3, #64	@ 0x40
 802870a:	d006      	beq.n	802871a <arm_rfft_fast_init_f32+0x52>
 802870c:	2b10      	cmp	r3, #16
 802870e:	d01d      	beq.n	802874c <arm_rfft_fast_init_f32+0x84>
 8028710:	f04f 30ff 	mov.w	r0, #4294967295
 8028714:	f85d 4b04 	ldr.w	r4, [sp], #4
 8028718:	4770      	bx	lr
 802871a:	2438      	movs	r4, #56	@ 0x38
 802871c:	4916      	ldr	r1, [pc, #88]	@ (8028778 <arm_rfft_fast_init_f32+0xb0>)
 802871e:	4a17      	ldr	r2, [pc, #92]	@ (802877c <arm_rfft_fast_init_f32+0xb4>)
 8028720:	4b17      	ldr	r3, [pc, #92]	@ (8028780 <arm_rfft_fast_init_f32+0xb8>)
 8028722:	e7e7      	b.n	80286f4 <arm_rfft_fast_init_f32+0x2c>
 8028724:	f44f 64e1 	mov.w	r4, #1800	@ 0x708
 8028728:	4916      	ldr	r1, [pc, #88]	@ (8028784 <arm_rfft_fast_init_f32+0xbc>)
 802872a:	4a17      	ldr	r2, [pc, #92]	@ (8028788 <arm_rfft_fast_init_f32+0xc0>)
 802872c:	4b17      	ldr	r3, [pc, #92]	@ (802878c <arm_rfft_fast_init_f32+0xc4>)
 802872e:	e7e1      	b.n	80286f4 <arm_rfft_fast_init_f32+0x2c>
 8028730:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8028734:	d1ec      	bne.n	8028710 <arm_rfft_fast_init_f32+0x48>
 8028736:	f44f 74dc 	mov.w	r4, #440	@ 0x1b8
 802873a:	4915      	ldr	r1, [pc, #84]	@ (8028790 <arm_rfft_fast_init_f32+0xc8>)
 802873c:	4a15      	ldr	r2, [pc, #84]	@ (8028794 <arm_rfft_fast_init_f32+0xcc>)
 802873e:	4b16      	ldr	r3, [pc, #88]	@ (8028798 <arm_rfft_fast_init_f32+0xd0>)
 8028740:	e7d8      	b.n	80286f4 <arm_rfft_fast_init_f32+0x2c>
 8028742:	2430      	movs	r4, #48	@ 0x30
 8028744:	4915      	ldr	r1, [pc, #84]	@ (802879c <arm_rfft_fast_init_f32+0xd4>)
 8028746:	4a16      	ldr	r2, [pc, #88]	@ (80287a0 <arm_rfft_fast_init_f32+0xd8>)
 8028748:	4b16      	ldr	r3, [pc, #88]	@ (80287a4 <arm_rfft_fast_init_f32+0xdc>)
 802874a:	e7d3      	b.n	80286f4 <arm_rfft_fast_init_f32+0x2c>
 802874c:	2414      	movs	r4, #20
 802874e:	4916      	ldr	r1, [pc, #88]	@ (80287a8 <arm_rfft_fast_init_f32+0xe0>)
 8028750:	4a16      	ldr	r2, [pc, #88]	@ (80287ac <arm_rfft_fast_init_f32+0xe4>)
 8028752:	4b17      	ldr	r3, [pc, #92]	@ (80287b0 <arm_rfft_fast_init_f32+0xe8>)
 8028754:	e7ce      	b.n	80286f4 <arm_rfft_fast_init_f32+0x2c>
 8028756:	f44f 74e0 	mov.w	r4, #448	@ 0x1c0
 802875a:	4916      	ldr	r1, [pc, #88]	@ (80287b4 <arm_rfft_fast_init_f32+0xec>)
 802875c:	4a16      	ldr	r2, [pc, #88]	@ (80287b8 <arm_rfft_fast_init_f32+0xf0>)
 802875e:	4b17      	ldr	r3, [pc, #92]	@ (80287bc <arm_rfft_fast_init_f32+0xf4>)
 8028760:	e7c8      	b.n	80286f4 <arm_rfft_fast_init_f32+0x2c>
 8028762:	24d0      	movs	r4, #208	@ 0xd0
 8028764:	4916      	ldr	r1, [pc, #88]	@ (80287c0 <arm_rfft_fast_init_f32+0xf8>)
 8028766:	4a17      	ldr	r2, [pc, #92]	@ (80287c4 <arm_rfft_fast_init_f32+0xfc>)
 8028768:	4b17      	ldr	r3, [pc, #92]	@ (80287c8 <arm_rfft_fast_init_f32+0x100>)
 802876a:	e7c3      	b.n	80286f4 <arm_rfft_fast_init_f32+0x2c>
 802876c:	0803db7c 	.word	0x0803db7c
 8028770:	0802ed74 	.word	0x0802ed74
 8028774:	08034ee4 	.word	0x08034ee4
 8028778:	08032e74 	.word	0x08032e74
 802877c:	0803f93c 	.word	0x0803f93c
 8028780:	08041e2c 	.word	0x08041e2c
 8028784:	0803b864 	.word	0x0803b864
 8028788:	08039764 	.word	0x08039764
 802878c:	08032ee4 	.word	0x08032ee4
 8028790:	08041abc 	.word	0x08041abc
 8028794:	08038ee4 	.word	0x08038ee4
 8028798:	0803fb3c 	.word	0x0803fb3c
 802879c:	0803c71c 	.word	0x0803c71c
 80287a0:	0803b764 	.word	0x0803b764
 80287a4:	08032d74 	.word	0x08032d74
 80287a8:	0803c674 	.word	0x0803c674
 80287ac:	080396e4 	.word	0x080396e4
 80287b0:	0803c69c 	.word	0x0803c69c
 80287b4:	0804033c 	.word	0x0804033c
 80287b8:	0803cb7c 	.word	0x0803cb7c
 80287bc:	080406bc 	.word	0x080406bc
 80287c0:	0804202c 	.word	0x0804202c
 80287c4:	0803c77c 	.word	0x0803c77c
 80287c8:	080416bc 	.word	0x080416bc

080287cc <arm_rfft_fast_f32>:
 80287cc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80287d0:	8a06      	ldrh	r6, [r0, #16]
 80287d2:	0876      	lsrs	r6, r6, #1
 80287d4:	4607      	mov	r7, r0
 80287d6:	4615      	mov	r5, r2
 80287d8:	8006      	strh	r6, [r0, #0]
 80287da:	460c      	mov	r4, r1
 80287dc:	2b00      	cmp	r3, #0
 80287de:	d15c      	bne.n	802889a <arm_rfft_fast_f32+0xce>
 80287e0:	461a      	mov	r2, r3
 80287e2:	2301      	movs	r3, #1
 80287e4:	f000 fbe4 	bl	8028fb0 <arm_cfft_f32>
 80287e8:	edd4 7a00 	vldr	s15, [r4]
 80287ec:	ed94 7a01 	vldr	s14, [r4, #4]
 80287f0:	883e      	ldrh	r6, [r7, #0]
 80287f2:	6978      	ldr	r0, [r7, #20]
 80287f4:	ee37 7a07 	vadd.f32	s14, s14, s14
 80287f8:	ee77 7aa7 	vadd.f32	s15, s15, s15
 80287fc:	eeb6 3a00 	vmov.f32	s6, #96	@ 0x3f000000  0.5
 8028800:	ee77 6a87 	vadd.f32	s13, s15, s14
 8028804:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8028808:	3e01      	subs	r6, #1
 802880a:	ee26 7a83 	vmul.f32	s14, s13, s6
 802880e:	ee67 7a83 	vmul.f32	s15, s15, s6
 8028812:	eb04 03c6 	add.w	r3, r4, r6, lsl #3
 8028816:	ed85 7a00 	vstr	s14, [r5]
 802881a:	edc5 7a01 	vstr	s15, [r5, #4]
 802881e:	3010      	adds	r0, #16
 8028820:	f105 0210 	add.w	r2, r5, #16
 8028824:	3b08      	subs	r3, #8
 8028826:	f104 0110 	add.w	r1, r4, #16
 802882a:	ed93 7a02 	vldr	s14, [r3, #8]
 802882e:	ed51 6a02 	vldr	s13, [r1, #-8]
 8028832:	ed10 6a02 	vldr	s12, [r0, #-8]
 8028836:	edd3 3a03 	vldr	s7, [r3, #12]
 802883a:	ed11 5a01 	vldr	s10, [r1, #-4]
 802883e:	ed50 5a01 	vldr	s11, [r0, #-4]
 8028842:	ee77 7a66 	vsub.f32	s15, s14, s13
 8028846:	ee77 4a26 	vadd.f32	s9, s14, s13
 802884a:	ee33 4a85 	vadd.f32	s8, s7, s10
 802884e:	ee66 6a27 	vmul.f32	s13, s12, s15
 8028852:	ee25 7aa7 	vmul.f32	s14, s11, s15
 8028856:	ee35 5a63 	vsub.f32	s10, s10, s7
 802885a:	ee76 6aa4 	vadd.f32	s13, s13, s9
 802885e:	ee77 7a05 	vadd.f32	s15, s14, s10
 8028862:	ee26 6a04 	vmul.f32	s12, s12, s8
 8028866:	ee65 5a84 	vmul.f32	s11, s11, s8
 802886a:	ee77 7ac6 	vsub.f32	s15, s15, s12
 802886e:	ee36 7aa5 	vadd.f32	s14, s13, s11
 8028872:	ee67 7a83 	vmul.f32	s15, s15, s6
 8028876:	ee27 7a03 	vmul.f32	s14, s14, s6
 802887a:	3e01      	subs	r6, #1
 802887c:	ed02 7a02 	vstr	s14, [r2, #-8]
 8028880:	ed42 7a01 	vstr	s15, [r2, #-4]
 8028884:	f1a3 0308 	sub.w	r3, r3, #8
 8028888:	f101 0108 	add.w	r1, r1, #8
 802888c:	f100 0008 	add.w	r0, r0, #8
 8028890:	f102 0208 	add.w	r2, r2, #8
 8028894:	d1c9      	bne.n	802882a <arm_rfft_fast_f32+0x5e>
 8028896:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802889a:	edd1 7a00 	vldr	s15, [r1]
 802889e:	edd1 6a01 	vldr	s13, [r1, #4]
 80288a2:	6941      	ldr	r1, [r0, #20]
 80288a4:	ee37 7aa6 	vadd.f32	s14, s15, s13
 80288a8:	ee77 7ae6 	vsub.f32	s15, s15, s13
 80288ac:	eef6 3a00 	vmov.f32	s7, #96	@ 0x3f000000  0.5
 80288b0:	ee27 7a23 	vmul.f32	s14, s14, s7
 80288b4:	ee67 7aa3 	vmul.f32	s15, s15, s7
 80288b8:	3e01      	subs	r6, #1
 80288ba:	ed82 7a00 	vstr	s14, [r2]
 80288be:	edc2 7a01 	vstr	s15, [r2, #4]
 80288c2:	00f0      	lsls	r0, r6, #3
 80288c4:	b3ee      	cbz	r6, 8028942 <arm_rfft_fast_f32+0x176>
 80288c6:	3808      	subs	r0, #8
 80288c8:	f101 0e10 	add.w	lr, r1, #16
 80288cc:	4420      	add	r0, r4
 80288ce:	f104 0110 	add.w	r1, r4, #16
 80288d2:	f102 0c10 	add.w	ip, r2, #16
 80288d6:	ed90 7a02 	vldr	s14, [r0, #8]
 80288da:	ed51 6a02 	vldr	s13, [r1, #-8]
 80288de:	ed1e 6a02 	vldr	s12, [lr, #-8]
 80288e2:	ed90 4a03 	vldr	s8, [r0, #12]
 80288e6:	ed11 5a01 	vldr	s10, [r1, #-4]
 80288ea:	ed5e 5a01 	vldr	s11, [lr, #-4]
 80288ee:	ee76 7ac7 	vsub.f32	s15, s13, s14
 80288f2:	ee74 4a05 	vadd.f32	s9, s8, s10
 80288f6:	ee26 3a27 	vmul.f32	s6, s12, s15
 80288fa:	ee77 6a26 	vadd.f32	s13, s14, s13
 80288fe:	ee35 5a44 	vsub.f32	s10, s10, s8
 8028902:	ee25 7aa7 	vmul.f32	s14, s11, s15
 8028906:	ee76 6ac3 	vsub.f32	s13, s13, s6
 802890a:	ee77 7a05 	vadd.f32	s15, s14, s10
 802890e:	ee26 6a24 	vmul.f32	s12, s12, s9
 8028912:	ee65 5aa4 	vmul.f32	s11, s11, s9
 8028916:	ee77 7ac6 	vsub.f32	s15, s15, s12
 802891a:	ee36 7ae5 	vsub.f32	s14, s13, s11
 802891e:	ee67 7aa3 	vmul.f32	s15, s15, s7
 8028922:	ee27 7a23 	vmul.f32	s14, s14, s7
 8028926:	3e01      	subs	r6, #1
 8028928:	ed0c 7a02 	vstr	s14, [ip, #-8]
 802892c:	ed4c 7a01 	vstr	s15, [ip, #-4]
 8028930:	f1a0 0008 	sub.w	r0, r0, #8
 8028934:	f101 0108 	add.w	r1, r1, #8
 8028938:	f10e 0e08 	add.w	lr, lr, #8
 802893c:	f10c 0c08 	add.w	ip, ip, #8
 8028940:	d1c9      	bne.n	80288d6 <arm_rfft_fast_f32+0x10a>
 8028942:	461a      	mov	r2, r3
 8028944:	4629      	mov	r1, r5
 8028946:	4638      	mov	r0, r7
 8028948:	2301      	movs	r3, #1
 802894a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 802894e:	f000 bb2f 	b.w	8028fb0 <arm_cfft_f32>
 8028952:	bf00      	nop

08028954 <arm_cfft_radix8by2_f32>:
 8028954:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8028958:	ed2d 8b08 	vpush	{d8-d11}
 802895c:	4607      	mov	r7, r0
 802895e:	4608      	mov	r0, r1
 8028960:	f8b7 e000 	ldrh.w	lr, [r7]
 8028964:	687a      	ldr	r2, [r7, #4]
 8028966:	ea4f 015e 	mov.w	r1, lr, lsr #1
 802896a:	eb00 088e 	add.w	r8, r0, lr, lsl #2
 802896e:	ea5f 0ede 	movs.w	lr, lr, lsr #3
 8028972:	f000 80b0 	beq.w	8028ad6 <arm_cfft_radix8by2_f32+0x182>
 8028976:	008b      	lsls	r3, r1, #2
 8028978:	3310      	adds	r3, #16
 802897a:	18c6      	adds	r6, r0, r3
 802897c:	3210      	adds	r2, #16
 802897e:	4443      	add	r3, r8
 8028980:	f100 0510 	add.w	r5, r0, #16
 8028984:	f108 0410 	add.w	r4, r8, #16
 8028988:	ed54 1a04 	vldr	s3, [r4, #-16]
 802898c:	ed54 6a03 	vldr	s13, [r4, #-12]
 8028990:	ed13 4a04 	vldr	s8, [r3, #-16]
 8028994:	ed53 3a03 	vldr	s7, [r3, #-12]
 8028998:	ed53 5a02 	vldr	s11, [r3, #-8]
 802899c:	ed13 5a01 	vldr	s10, [r3, #-4]
 80289a0:	ed14 0a02 	vldr	s0, [r4, #-8]
 80289a4:	ed54 7a01 	vldr	s15, [r4, #-4]
 80289a8:	ed16 2a04 	vldr	s4, [r6, #-16]
 80289ac:	ed56 2a03 	vldr	s5, [r6, #-12]
 80289b0:	ed15 6a03 	vldr	s12, [r5, #-12]
 80289b4:	ed15 7a01 	vldr	s14, [r5, #-4]
 80289b8:	ed15 3a04 	vldr	s6, [r5, #-16]
 80289bc:	ed56 0a02 	vldr	s1, [r6, #-8]
 80289c0:	ed16 1a01 	vldr	s2, [r6, #-4]
 80289c4:	ed55 4a02 	vldr	s9, [r5, #-8]
 80289c8:	ee73 ba21 	vadd.f32	s23, s6, s3
 80289cc:	ee36 ba26 	vadd.f32	s22, s12, s13
 80289d0:	ee37 aa27 	vadd.f32	s20, s14, s15
 80289d4:	ee72 9a04 	vadd.f32	s19, s4, s8
 80289d8:	ee32 9aa3 	vadd.f32	s18, s5, s7
 80289dc:	ee31 8a05 	vadd.f32	s16, s2, s10
 80289e0:	ee74 aa80 	vadd.f32	s21, s9, s0
 80289e4:	ee70 8aa5 	vadd.f32	s17, s1, s11
 80289e8:	ed45 ba04 	vstr	s23, [r5, #-16]
 80289ec:	ed05 ba03 	vstr	s22, [r5, #-12]
 80289f0:	ed45 aa02 	vstr	s21, [r5, #-8]
 80289f4:	ed05 aa01 	vstr	s20, [r5, #-4]
 80289f8:	ed06 8a01 	vstr	s16, [r6, #-4]
 80289fc:	ed46 9a04 	vstr	s19, [r6, #-16]
 8028a00:	ed06 9a03 	vstr	s18, [r6, #-12]
 8028a04:	ed46 8a02 	vstr	s17, [r6, #-8]
 8028a08:	ee76 6a66 	vsub.f32	s13, s12, s13
 8028a0c:	ee73 3ae2 	vsub.f32	s7, s7, s5
 8028a10:	ed12 6a03 	vldr	s12, [r2, #-12]
 8028a14:	ed52 2a04 	vldr	s5, [r2, #-16]
 8028a18:	ee33 3a61 	vsub.f32	s6, s6, s3
 8028a1c:	ee34 4a42 	vsub.f32	s8, s8, s4
 8028a20:	ee26 8a86 	vmul.f32	s16, s13, s12
 8028a24:	ee24 2a06 	vmul.f32	s4, s8, s12
 8028a28:	ee63 1a22 	vmul.f32	s3, s6, s5
 8028a2c:	ee24 4a22 	vmul.f32	s8, s8, s5
 8028a30:	ee23 3a06 	vmul.f32	s6, s6, s12
 8028a34:	ee66 6aa2 	vmul.f32	s13, s13, s5
 8028a38:	ee23 6a86 	vmul.f32	s12, s7, s12
 8028a3c:	ee63 3aa2 	vmul.f32	s7, s7, s5
 8028a40:	ee36 6a04 	vadd.f32	s12, s12, s8
 8028a44:	ee76 6ac3 	vsub.f32	s13, s13, s6
 8028a48:	ee72 3a63 	vsub.f32	s7, s4, s7
 8028a4c:	ee71 2a88 	vadd.f32	s5, s3, s16
 8028a50:	ed44 6a03 	vstr	s13, [r4, #-12]
 8028a54:	ed44 2a04 	vstr	s5, [r4, #-16]
 8028a58:	ed43 3a04 	vstr	s7, [r3, #-16]
 8028a5c:	ed03 6a03 	vstr	s12, [r3, #-12]
 8028a60:	ee77 7a67 	vsub.f32	s15, s14, s15
 8028a64:	ee75 6ae0 	vsub.f32	s13, s11, s1
 8028a68:	ed12 7a01 	vldr	s14, [r2, #-4]
 8028a6c:	ed52 5a02 	vldr	s11, [r2, #-8]
 8028a70:	ee35 6a41 	vsub.f32	s12, s10, s2
 8028a74:	ee74 4ac0 	vsub.f32	s9, s9, s0
 8028a78:	ee67 3a87 	vmul.f32	s7, s15, s14
 8028a7c:	ee26 5a87 	vmul.f32	s10, s13, s14
 8028a80:	ee24 4aa5 	vmul.f32	s8, s9, s11
 8028a84:	ee67 7aa5 	vmul.f32	s15, s15, s11
 8028a88:	ee64 4a87 	vmul.f32	s9, s9, s14
 8028a8c:	ee66 6aa5 	vmul.f32	s13, s13, s11
 8028a90:	ee26 7a07 	vmul.f32	s14, s12, s14
 8028a94:	ee26 6a25 	vmul.f32	s12, s12, s11
 8028a98:	ee77 7ae4 	vsub.f32	s15, s15, s9
 8028a9c:	ee74 5a23 	vadd.f32	s11, s8, s7
 8028aa0:	ee35 6a46 	vsub.f32	s12, s10, s12
 8028aa4:	ee37 7a26 	vadd.f32	s14, s14, s13
 8028aa8:	f1be 0e01 	subs.w	lr, lr, #1
 8028aac:	ed44 5a02 	vstr	s11, [r4, #-8]
 8028ab0:	f105 0510 	add.w	r5, r5, #16
 8028ab4:	ed44 7a01 	vstr	s15, [r4, #-4]
 8028ab8:	f106 0610 	add.w	r6, r6, #16
 8028abc:	ed03 6a02 	vstr	s12, [r3, #-8]
 8028ac0:	ed03 7a01 	vstr	s14, [r3, #-4]
 8028ac4:	f102 0210 	add.w	r2, r2, #16
 8028ac8:	f104 0410 	add.w	r4, r4, #16
 8028acc:	f103 0310 	add.w	r3, r3, #16
 8028ad0:	f47f af5a 	bne.w	8028988 <arm_cfft_radix8by2_f32+0x34>
 8028ad4:	687a      	ldr	r2, [r7, #4]
 8028ad6:	b28c      	uxth	r4, r1
 8028ad8:	4621      	mov	r1, r4
 8028ada:	2302      	movs	r3, #2
 8028adc:	f000 fb6e 	bl	80291bc <arm_radix8_butterfly_f32>
 8028ae0:	ecbd 8b08 	vpop	{d8-d11}
 8028ae4:	4621      	mov	r1, r4
 8028ae6:	687a      	ldr	r2, [r7, #4]
 8028ae8:	4640      	mov	r0, r8
 8028aea:	2302      	movs	r3, #2
 8028aec:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8028af0:	f000 bb64 	b.w	80291bc <arm_radix8_butterfly_f32>

08028af4 <arm_cfft_radix8by4_f32>:
 8028af4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8028af8:	ed2d 8b0a 	vpush	{d8-d12}
 8028afc:	8802      	ldrh	r2, [r0, #0]
 8028afe:	ed91 6a00 	vldr	s12, [r1]
 8028b02:	b08f      	sub	sp, #60	@ 0x3c
 8028b04:	460f      	mov	r7, r1
 8028b06:	0852      	lsrs	r2, r2, #1
 8028b08:	6841      	ldr	r1, [r0, #4]
 8028b0a:	900c      	str	r0, [sp, #48]	@ 0x30
 8028b0c:	0093      	lsls	r3, r2, #2
 8028b0e:	4638      	mov	r0, r7
 8028b10:	4418      	add	r0, r3
 8028b12:	4606      	mov	r6, r0
 8028b14:	9009      	str	r0, [sp, #36]	@ 0x24
 8028b16:	4418      	add	r0, r3
 8028b18:	edd0 6a00 	vldr	s13, [r0]
 8028b1c:	ed96 4a00 	vldr	s8, [r6]
 8028b20:	edd6 2a01 	vldr	s5, [r6, #4]
 8028b24:	edd0 7a01 	vldr	s15, [r0, #4]
 8028b28:	900a      	str	r0, [sp, #40]	@ 0x28
 8028b2a:	ee76 5a26 	vadd.f32	s11, s12, s13
 8028b2e:	4604      	mov	r4, r0
 8028b30:	4625      	mov	r5, r4
 8028b32:	441c      	add	r4, r3
 8028b34:	edd4 4a00 	vldr	s9, [r4]
 8028b38:	ed97 7a01 	vldr	s14, [r7, #4]
 8028b3c:	ed94 3a01 	vldr	s6, [r4, #4]
 8028b40:	9401      	str	r4, [sp, #4]
 8028b42:	ee35 5a84 	vadd.f32	s10, s11, s8
 8028b46:	4630      	mov	r0, r6
 8028b48:	ee35 5a24 	vadd.f32	s10, s10, s9
 8028b4c:	463e      	mov	r6, r7
 8028b4e:	ee15 ea10 	vmov	lr, s10
 8028b52:	ee76 6a66 	vsub.f32	s13, s12, s13
 8028b56:	f846 eb08 	str.w	lr, [r6], #8
 8028b5a:	ee37 6a27 	vadd.f32	s12, s14, s15
 8028b5e:	ed90 5a01 	vldr	s10, [r0, #4]
 8028b62:	9605      	str	r6, [sp, #20]
 8028b64:	ee77 7a67 	vsub.f32	s15, s14, s15
 8028b68:	9e01      	ldr	r6, [sp, #4]
 8028b6a:	9707      	str	r7, [sp, #28]
 8028b6c:	ee76 3aa2 	vadd.f32	s7, s13, s5
 8028b70:	ed96 2a01 	vldr	s4, [r6, #4]
 8028b74:	ee36 7a05 	vadd.f32	s14, s12, s10
 8028b78:	ee75 5ac4 	vsub.f32	s11, s11, s8
 8028b7c:	ee37 5ac4 	vsub.f32	s10, s15, s8
 8028b80:	ee77 7a84 	vadd.f32	s15, s15, s8
 8028b84:	ee33 4ac3 	vsub.f32	s8, s7, s6
 8028b88:	4604      	mov	r4, r0
 8028b8a:	46a3      	mov	fp, r4
 8028b8c:	ee37 7a02 	vadd.f32	s14, s14, s4
 8028b90:	ee35 5a24 	vadd.f32	s10, s10, s9
 8028b94:	ee14 8a10 	vmov	r8, s8
 8028b98:	46a4      	mov	ip, r4
 8028b9a:	ee75 5ae4 	vsub.f32	s11, s11, s9
 8028b9e:	ed87 7a01 	vstr	s14, [r7, #4]
 8028ba2:	f84b 8b08 	str.w	r8, [fp], #8
 8028ba6:	f1ac 0704 	sub.w	r7, ip, #4
 8028baa:	ed8c 5a01 	vstr	s10, [ip, #4]
 8028bae:	f101 0c08 	add.w	ip, r1, #8
 8028bb2:	462c      	mov	r4, r5
 8028bb4:	f8cd c010 	str.w	ip, [sp, #16]
 8028bb8:	ee15 ca90 	vmov	ip, s11
 8028bbc:	ee36 6a62 	vsub.f32	s12, s12, s5
 8028bc0:	f844 cb08 	str.w	ip, [r4], #8
 8028bc4:	ee76 6ae2 	vsub.f32	s13, s13, s5
 8028bc8:	ee36 6a43 	vsub.f32	s12, s12, s6
 8028bcc:	9406      	str	r4, [sp, #24]
 8028bce:	ee76 6a83 	vadd.f32	s13, s13, s6
 8028bd2:	f101 0410 	add.w	r4, r1, #16
 8028bd6:	0852      	lsrs	r2, r2, #1
 8028bd8:	9402      	str	r4, [sp, #8]
 8028bda:	ed85 6a01 	vstr	s12, [r5, #4]
 8028bde:	462c      	mov	r4, r5
 8028be0:	f101 0518 	add.w	r5, r1, #24
 8028be4:	920b      	str	r2, [sp, #44]	@ 0x2c
 8028be6:	46b2      	mov	sl, r6
 8028be8:	9503      	str	r5, [sp, #12]
 8028bea:	ee77 7ae4 	vsub.f32	s15, s15, s9
 8028bee:	3a02      	subs	r2, #2
 8028bf0:	ee16 5a90 	vmov	r5, s13
 8028bf4:	46b6      	mov	lr, r6
 8028bf6:	4630      	mov	r0, r6
 8028bf8:	0852      	lsrs	r2, r2, #1
 8028bfa:	f84a 5b08 	str.w	r5, [sl], #8
 8028bfe:	f1a0 0604 	sub.w	r6, r0, #4
 8028c02:	edce 7a01 	vstr	s15, [lr, #4]
 8028c06:	9208      	str	r2, [sp, #32]
 8028c08:	f000 8130 	beq.w	8028e6c <arm_cfft_radix8by4_f32+0x378>
 8028c0c:	4691      	mov	r9, r2
 8028c0e:	9a07      	ldr	r2, [sp, #28]
 8028c10:	f8dd 8008 	ldr.w	r8, [sp, #8]
 8028c14:	f8cd a034 	str.w	sl, [sp, #52]	@ 0x34
 8028c18:	3b08      	subs	r3, #8
 8028c1a:	f102 0510 	add.w	r5, r2, #16
 8028c1e:	f101 0c20 	add.w	ip, r1, #32
 8028c22:	f1a4 020c 	sub.w	r2, r4, #12
 8028c26:	f101 0e30 	add.w	lr, r1, #48	@ 0x30
 8028c2a:	4433      	add	r3, r6
 8028c2c:	3410      	adds	r4, #16
 8028c2e:	4650      	mov	r0, sl
 8028c30:	4659      	mov	r1, fp
 8028c32:	ed55 3a02 	vldr	s7, [r5, #-8]
 8028c36:	ed14 5a02 	vldr	s10, [r4, #-8]
 8028c3a:	ed91 7a00 	vldr	s14, [r1]
 8028c3e:	edd0 7a00 	vldr	s15, [r0]
 8028c42:	ed54 5a01 	vldr	s11, [r4, #-4]
 8028c46:	ed15 4a01 	vldr	s8, [r5, #-4]
 8028c4a:	edd0 6a01 	vldr	s13, [r0, #4]
 8028c4e:	ed91 6a01 	vldr	s12, [r1, #4]
 8028c52:	ee33 8a85 	vadd.f32	s16, s7, s10
 8028c56:	ee34 0a25 	vadd.f32	s0, s8, s11
 8028c5a:	ee78 4a07 	vadd.f32	s9, s16, s14
 8028c5e:	ee74 5a65 	vsub.f32	s11, s8, s11
 8028c62:	ee74 4aa7 	vadd.f32	s9, s9, s15
 8028c66:	ee33 5ac5 	vsub.f32	s10, s7, s10
 8028c6a:	ed45 4a02 	vstr	s9, [r5, #-8]
 8028c6e:	edd1 4a01 	vldr	s9, [r1, #4]
 8028c72:	ed90 4a01 	vldr	s8, [r0, #4]
 8028c76:	ee70 4a24 	vadd.f32	s9, s0, s9
 8028c7a:	ee75 aa06 	vadd.f32	s21, s10, s12
 8028c7e:	ee74 4a84 	vadd.f32	s9, s9, s8
 8028c82:	ee35 aac7 	vsub.f32	s20, s11, s14
 8028c86:	ed45 4a01 	vstr	s9, [r5, #-4]
 8028c8a:	edd6 1a00 	vldr	s3, [r6]
 8028c8e:	edd7 0a00 	vldr	s1, [r7]
 8028c92:	ed92 4a02 	vldr	s8, [r2, #8]
 8028c96:	edd3 3a02 	vldr	s7, [r3, #8]
 8028c9a:	ed93 2a01 	vldr	s4, [r3, #4]
 8028c9e:	ed16 1a01 	vldr	s2, [r6, #-4]
 8028ca2:	edd2 2a01 	vldr	s5, [r2, #4]
 8028ca6:	ed57 9a01 	vldr	s19, [r7, #-4]
 8028caa:	ee70 4aa1 	vadd.f32	s9, s1, s3
 8028cae:	ee39 3a81 	vadd.f32	s6, s19, s2
 8028cb2:	ee74 8a84 	vadd.f32	s17, s9, s8
 8028cb6:	ee70 1ae1 	vsub.f32	s3, s1, s3
 8028cba:	ee78 8aa3 	vadd.f32	s17, s17, s7
 8028cbe:	ee7a aae6 	vsub.f32	s21, s21, s13
 8028cc2:	ee18 aa90 	vmov	sl, s17
 8028cc6:	f847 a908 	str.w	sl, [r7], #-8
 8028cca:	edd2 8a01 	vldr	s17, [r2, #4]
 8028cce:	ed93 9a01 	vldr	s18, [r3, #4]
 8028cd2:	ee73 8a28 	vadd.f32	s17, s6, s17
 8028cd6:	ee3a aa27 	vadd.f32	s20, s20, s15
 8028cda:	ee78 8a89 	vadd.f32	s17, s17, s18
 8028cde:	ee74 0a63 	vsub.f32	s1, s8, s7
 8028ce2:	edc7 8a01 	vstr	s17, [r7, #4]
 8028ce6:	ed18 ba02 	vldr	s22, [r8, #-8]
 8028cea:	ed58 8a01 	vldr	s17, [r8, #-4]
 8028cee:	ee39 1ac1 	vsub.f32	s2, s19, s2
 8028cf2:	ee6a ba28 	vmul.f32	s23, s20, s17
 8028cf6:	ee2a ca8b 	vmul.f32	s24, s21, s22
 8028cfa:	ee71 9ae2 	vsub.f32	s19, s3, s5
 8028cfe:	ee31 9a20 	vadd.f32	s18, s2, s1
 8028d02:	ee79 9a82 	vadd.f32	s19, s19, s4
 8028d06:	ee3c ca2b 	vadd.f32	s24, s24, s23
 8028d0a:	ee6a aaa8 	vmul.f32	s21, s21, s17
 8028d0e:	ee69 baa8 	vmul.f32	s23, s19, s17
 8028d12:	ee2a aa0b 	vmul.f32	s20, s20, s22
 8028d16:	ee69 9a8b 	vmul.f32	s19, s19, s22
 8028d1a:	ee69 8a28 	vmul.f32	s17, s18, s17
 8028d1e:	ee29 ba0b 	vmul.f32	s22, s18, s22
 8028d22:	ee1c aa10 	vmov	sl, s24
 8028d26:	ee78 8aa9 	vadd.f32	s17, s17, s19
 8028d2a:	f841 ab08 	str.w	sl, [r1], #8
 8028d2e:	ee3a aa6a 	vsub.f32	s20, s20, s21
 8028d32:	ee3b bacb 	vsub.f32	s22, s23, s22
 8028d36:	ee34 4ac4 	vsub.f32	s8, s9, s8
 8028d3a:	ee33 3a62 	vsub.f32	s6, s6, s5
 8028d3e:	ed01 aa01 	vstr	s20, [r1, #-4]
 8028d42:	edc2 8a01 	vstr	s17, [r2, #4]
 8028d46:	ed82 ba02 	vstr	s22, [r2, #8]
 8028d4a:	ed5c 4a04 	vldr	s9, [ip, #-16]
 8028d4e:	ee74 3a63 	vsub.f32	s7, s8, s7
 8028d52:	ee38 8a47 	vsub.f32	s16, s16, s14
 8028d56:	ed1c 4a03 	vldr	s8, [ip, #-12]
 8028d5a:	ee30 0a46 	vsub.f32	s0, s0, s12
 8028d5e:	ee33 3a42 	vsub.f32	s6, s6, s4
 8028d62:	ee38 8a67 	vsub.f32	s16, s16, s15
 8028d66:	ee30 0a66 	vsub.f32	s0, s0, s13
 8028d6a:	ee23 9ae4 	vnmul.f32	s18, s7, s9
 8028d6e:	ee63 8a04 	vmul.f32	s17, s6, s8
 8028d72:	ee28 aa24 	vmul.f32	s20, s16, s9
 8028d76:	ee60 9a04 	vmul.f32	s19, s0, s8
 8028d7a:	ee28 8a04 	vmul.f32	s16, s16, s8
 8028d7e:	ee20 0a24 	vmul.f32	s0, s0, s9
 8028d82:	ee63 3a84 	vmul.f32	s7, s7, s8
 8028d86:	ee39 4a68 	vsub.f32	s8, s18, s17
 8028d8a:	ee7a 9a29 	vadd.f32	s19, s20, s19
 8028d8e:	ee14 aa10 	vmov	sl, s8
 8028d92:	ee30 0a48 	vsub.f32	s0, s0, s16
 8028d96:	ee63 4a24 	vmul.f32	s9, s6, s9
 8028d9a:	ed44 9a02 	vstr	s19, [r4, #-8]
 8028d9e:	ee73 3ae4 	vsub.f32	s7, s7, s9
 8028da2:	ed04 0a01 	vstr	s0, [r4, #-4]
 8028da6:	f846 a908 	str.w	sl, [r6], #-8
 8028daa:	ee35 6a46 	vsub.f32	s12, s10, s12
 8028dae:	ee35 7a87 	vadd.f32	s14, s11, s14
 8028db2:	edc6 3a01 	vstr	s7, [r6, #4]
 8028db6:	ee76 6a26 	vadd.f32	s13, s12, s13
 8028dba:	ee77 7a67 	vsub.f32	s15, s14, s15
 8028dbe:	ed1e 6a05 	vldr	s12, [lr, #-20]	@ 0xffffffec
 8028dc2:	ed1e 7a06 	vldr	s14, [lr, #-24]	@ 0xffffffe8
 8028dc6:	ee67 5a86 	vmul.f32	s11, s15, s12
 8028dca:	ee26 5a87 	vmul.f32	s10, s13, s14
 8028dce:	ee72 2a62 	vsub.f32	s5, s4, s5
 8028dd2:	ee30 1ac1 	vsub.f32	s2, s1, s2
 8028dd6:	ee72 2ae1 	vsub.f32	s5, s5, s3
 8028dda:	ee75 5a25 	vadd.f32	s11, s10, s11
 8028dde:	ee62 0a86 	vmul.f32	s1, s5, s12
 8028de2:	ee66 6a86 	vmul.f32	s13, s13, s12
 8028de6:	ee67 7a87 	vmul.f32	s15, s15, s14
 8028dea:	ee21 6a06 	vmul.f32	s12, s2, s12
 8028dee:	ee62 2a87 	vmul.f32	s5, s5, s14
 8028df2:	ee21 1a07 	vmul.f32	s2, s2, s14
 8028df6:	ee15 aa90 	vmov	sl, s11
 8028dfa:	ee77 7ae6 	vsub.f32	s15, s15, s13
 8028dfe:	f840 ab08 	str.w	sl, [r0], #8
 8028e02:	ee30 1ac1 	vsub.f32	s2, s1, s2
 8028e06:	ee76 2a22 	vadd.f32	s5, s12, s5
 8028e0a:	f1b9 0901 	subs.w	r9, r9, #1
 8028e0e:	ed40 7a01 	vstr	s15, [r0, #-4]
 8028e12:	f105 0508 	add.w	r5, r5, #8
 8028e16:	ed83 1a02 	vstr	s2, [r3, #8]
 8028e1a:	edc3 2a01 	vstr	s5, [r3, #4]
 8028e1e:	f108 0808 	add.w	r8, r8, #8
 8028e22:	f1a2 0208 	sub.w	r2, r2, #8
 8028e26:	f10c 0c10 	add.w	ip, ip, #16
 8028e2a:	f104 0408 	add.w	r4, r4, #8
 8028e2e:	f10e 0e18 	add.w	lr, lr, #24
 8028e32:	f1a3 0308 	sub.w	r3, r3, #8
 8028e36:	f47f aefc 	bne.w	8028c32 <arm_cfft_radix8by4_f32+0x13e>
 8028e3a:	9908      	ldr	r1, [sp, #32]
 8028e3c:	9802      	ldr	r0, [sp, #8]
 8028e3e:	f8dd a034 	ldr.w	sl, [sp, #52]	@ 0x34
 8028e42:	00cb      	lsls	r3, r1, #3
 8028e44:	eb01 0241 	add.w	r2, r1, r1, lsl #1
 8028e48:	eb00 1101 	add.w	r1, r0, r1, lsl #4
 8028e4c:	9102      	str	r1, [sp, #8]
 8028e4e:	9905      	ldr	r1, [sp, #20]
 8028e50:	4419      	add	r1, r3
 8028e52:	9105      	str	r1, [sp, #20]
 8028e54:	9904      	ldr	r1, [sp, #16]
 8028e56:	4419      	add	r1, r3
 8028e58:	9104      	str	r1, [sp, #16]
 8028e5a:	9906      	ldr	r1, [sp, #24]
 8028e5c:	449b      	add	fp, r3
 8028e5e:	4419      	add	r1, r3
 8028e60:	449a      	add	sl, r3
 8028e62:	9b03      	ldr	r3, [sp, #12]
 8028e64:	9106      	str	r1, [sp, #24]
 8028e66:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8028e6a:	9303      	str	r3, [sp, #12]
 8028e6c:	9a05      	ldr	r2, [sp, #20]
 8028e6e:	9806      	ldr	r0, [sp, #24]
 8028e70:	ed92 4a00 	vldr	s8, [r2]
 8028e74:	ed90 7a00 	vldr	s14, [r0]
 8028e78:	ed9b 3a00 	vldr	s6, [fp]
 8028e7c:	edda 3a00 	vldr	s7, [sl]
 8028e80:	edd2 4a01 	vldr	s9, [r2, #4]
 8028e84:	edd0 6a01 	vldr	s13, [r0, #4]
 8028e88:	ed9a 2a01 	vldr	s4, [sl, #4]
 8028e8c:	eddb 7a01 	vldr	s15, [fp, #4]
 8028e90:	f8bd 402c 	ldrh.w	r4, [sp, #44]	@ 0x2c
 8028e94:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
 8028e96:	ee34 6a07 	vadd.f32	s12, s8, s14
 8028e9a:	ee74 5aa6 	vadd.f32	s11, s9, s13
 8028e9e:	ee36 5a03 	vadd.f32	s10, s12, s6
 8028ea2:	ee74 6ae6 	vsub.f32	s13, s9, s13
 8028ea6:	ee35 5a23 	vadd.f32	s10, s10, s7
 8028eaa:	ee34 7a47 	vsub.f32	s14, s8, s14
 8028eae:	ed82 5a00 	vstr	s10, [r2]
 8028eb2:	ed9b 5a01 	vldr	s10, [fp, #4]
 8028eb6:	edda 4a01 	vldr	s9, [sl, #4]
 8028eba:	ee35 5a85 	vadd.f32	s10, s11, s10
 8028ebe:	ee37 4a27 	vadd.f32	s8, s14, s15
 8028ec2:	ee35 5a24 	vadd.f32	s10, s10, s9
 8028ec6:	ee76 4ac3 	vsub.f32	s9, s13, s6
 8028eca:	ed82 5a01 	vstr	s10, [r2, #4]
 8028ece:	9a04      	ldr	r2, [sp, #16]
 8028ed0:	ee34 5aa3 	vadd.f32	s10, s9, s7
 8028ed4:	edd2 1a00 	vldr	s3, [r2]
 8028ed8:	edd2 2a01 	vldr	s5, [r2, #4]
 8028edc:	9a02      	ldr	r2, [sp, #8]
 8028ede:	ee34 4a42 	vsub.f32	s8, s8, s4
 8028ee2:	ee36 6a43 	vsub.f32	s12, s12, s6
 8028ee6:	ee64 4a21 	vmul.f32	s9, s8, s3
 8028eea:	ee24 4a22 	vmul.f32	s8, s8, s5
 8028eee:	ee65 2a22 	vmul.f32	s5, s10, s5
 8028ef2:	ee25 5a21 	vmul.f32	s10, s10, s3
 8028ef6:	ee74 2aa2 	vadd.f32	s5, s9, s5
 8028efa:	ee35 5a44 	vsub.f32	s10, s10, s8
 8028efe:	ee75 5ae7 	vsub.f32	s11, s11, s15
 8028f02:	edcb 2a00 	vstr	s5, [fp]
 8028f06:	ed8b 5a01 	vstr	s10, [fp, #4]
 8028f0a:	ed92 4a01 	vldr	s8, [r2, #4]
 8028f0e:	ed92 5a00 	vldr	s10, [r2]
 8028f12:	9a03      	ldr	r2, [sp, #12]
 8028f14:	ee36 6a63 	vsub.f32	s12, s12, s7
 8028f18:	ee75 5ac2 	vsub.f32	s11, s11, s4
 8028f1c:	ee66 4a05 	vmul.f32	s9, s12, s10
 8028f20:	ee25 5a85 	vmul.f32	s10, s11, s10
 8028f24:	ee26 6a04 	vmul.f32	s12, s12, s8
 8028f28:	ee65 5a84 	vmul.f32	s11, s11, s8
 8028f2c:	ee35 6a46 	vsub.f32	s12, s10, s12
 8028f30:	ee74 5aa5 	vadd.f32	s11, s9, s11
 8028f34:	ee76 6a83 	vadd.f32	s13, s13, s6
 8028f38:	ee37 7a67 	vsub.f32	s14, s14, s15
 8028f3c:	ed80 6a01 	vstr	s12, [r0, #4]
 8028f40:	edc0 5a00 	vstr	s11, [r0]
 8028f44:	edd2 5a01 	vldr	s11, [r2, #4]
 8028f48:	9807      	ldr	r0, [sp, #28]
 8028f4a:	ee77 7a02 	vadd.f32	s15, s14, s4
 8028f4e:	ee36 7ae3 	vsub.f32	s14, s13, s7
 8028f52:	edd2 6a00 	vldr	s13, [r2]
 8028f56:	ee27 6aa6 	vmul.f32	s12, s15, s13
 8028f5a:	ee67 6a26 	vmul.f32	s13, s14, s13
 8028f5e:	ee67 7aa5 	vmul.f32	s15, s15, s11
 8028f62:	ee27 7a25 	vmul.f32	s14, s14, s11
 8028f66:	ee76 7ae7 	vsub.f32	s15, s13, s15
 8028f6a:	ee36 7a07 	vadd.f32	s14, s12, s14
 8028f6e:	edca 7a01 	vstr	s15, [sl, #4]
 8028f72:	ed8a 7a00 	vstr	s14, [sl]
 8028f76:	6872      	ldr	r2, [r6, #4]
 8028f78:	4621      	mov	r1, r4
 8028f7a:	2304      	movs	r3, #4
 8028f7c:	f000 f91e 	bl	80291bc <arm_radix8_butterfly_f32>
 8028f80:	9809      	ldr	r0, [sp, #36]	@ 0x24
 8028f82:	6872      	ldr	r2, [r6, #4]
 8028f84:	4621      	mov	r1, r4
 8028f86:	2304      	movs	r3, #4
 8028f88:	f000 f918 	bl	80291bc <arm_radix8_butterfly_f32>
 8028f8c:	980a      	ldr	r0, [sp, #40]	@ 0x28
 8028f8e:	6872      	ldr	r2, [r6, #4]
 8028f90:	4621      	mov	r1, r4
 8028f92:	2304      	movs	r3, #4
 8028f94:	f000 f912 	bl	80291bc <arm_radix8_butterfly_f32>
 8028f98:	6872      	ldr	r2, [r6, #4]
 8028f9a:	9801      	ldr	r0, [sp, #4]
 8028f9c:	4621      	mov	r1, r4
 8028f9e:	2304      	movs	r3, #4
 8028fa0:	b00f      	add	sp, #60	@ 0x3c
 8028fa2:	ecbd 8b0a 	vpop	{d8-d12}
 8028fa6:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8028faa:	f000 b907 	b.w	80291bc <arm_radix8_butterfly_f32>
 8028fae:	bf00      	nop

08028fb0 <arm_cfft_f32>:
 8028fb0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8028fb4:	2a01      	cmp	r2, #1
 8028fb6:	4606      	mov	r6, r0
 8028fb8:	4617      	mov	r7, r2
 8028fba:	460c      	mov	r4, r1
 8028fbc:	4698      	mov	r8, r3
 8028fbe:	8805      	ldrh	r5, [r0, #0]
 8028fc0:	d054      	beq.n	802906c <arm_cfft_f32+0xbc>
 8028fc2:	f5b5 7f80 	cmp.w	r5, #256	@ 0x100
 8028fc6:	d04c      	beq.n	8029062 <arm_cfft_f32+0xb2>
 8028fc8:	d916      	bls.n	8028ff8 <arm_cfft_f32+0x48>
 8028fca:	f5b5 6f80 	cmp.w	r5, #1024	@ 0x400
 8028fce:	d01a      	beq.n	8029006 <arm_cfft_f32+0x56>
 8028fd0:	d95c      	bls.n	802908c <arm_cfft_f32+0xdc>
 8028fd2:	f5b5 6f00 	cmp.w	r5, #2048	@ 0x800
 8028fd6:	d044      	beq.n	8029062 <arm_cfft_f32+0xb2>
 8028fd8:	f5b5 5f80 	cmp.w	r5, #4096	@ 0x1000
 8028fdc:	d105      	bne.n	8028fea <arm_cfft_f32+0x3a>
 8028fde:	2301      	movs	r3, #1
 8028fe0:	6872      	ldr	r2, [r6, #4]
 8028fe2:	4629      	mov	r1, r5
 8028fe4:	4620      	mov	r0, r4
 8028fe6:	f000 f8e9 	bl	80291bc <arm_radix8_butterfly_f32>
 8028fea:	f1b8 0f00 	cmp.w	r8, #0
 8028fee:	d111      	bne.n	8029014 <arm_cfft_f32+0x64>
 8028ff0:	2f01      	cmp	r7, #1
 8028ff2:	d016      	beq.n	8029022 <arm_cfft_f32+0x72>
 8028ff4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8028ff8:	2d20      	cmp	r5, #32
 8028ffa:	d032      	beq.n	8029062 <arm_cfft_f32+0xb2>
 8028ffc:	d94a      	bls.n	8029094 <arm_cfft_f32+0xe4>
 8028ffe:	2d40      	cmp	r5, #64	@ 0x40
 8029000:	d0ed      	beq.n	8028fde <arm_cfft_f32+0x2e>
 8029002:	2d80      	cmp	r5, #128	@ 0x80
 8029004:	d1f1      	bne.n	8028fea <arm_cfft_f32+0x3a>
 8029006:	4621      	mov	r1, r4
 8029008:	4630      	mov	r0, r6
 802900a:	f7ff fca3 	bl	8028954 <arm_cfft_radix8by2_f32>
 802900e:	f1b8 0f00 	cmp.w	r8, #0
 8029012:	d0ed      	beq.n	8028ff0 <arm_cfft_f32+0x40>
 8029014:	68b2      	ldr	r2, [r6, #8]
 8029016:	89b1      	ldrh	r1, [r6, #12]
 8029018:	4620      	mov	r0, r4
 802901a:	f7f7 f901 	bl	8020220 <arm_bitreversal_32>
 802901e:	2f01      	cmp	r7, #1
 8029020:	d1e8      	bne.n	8028ff4 <arm_cfft_f32+0x44>
 8029022:	ee07 5a90 	vmov	s15, r5
 8029026:	eef8 7a67 	vcvt.f32.u32	s15, s15
 802902a:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 802902e:	eec7 6a27 	vdiv.f32	s13, s14, s15
 8029032:	2d00      	cmp	r5, #0
 8029034:	d0de      	beq.n	8028ff4 <arm_cfft_f32+0x44>
 8029036:	f104 0108 	add.w	r1, r4, #8
 802903a:	2300      	movs	r3, #0
 802903c:	3301      	adds	r3, #1
 802903e:	429d      	cmp	r5, r3
 8029040:	f101 0108 	add.w	r1, r1, #8
 8029044:	ed11 7a04 	vldr	s14, [r1, #-16]
 8029048:	ed51 7a03 	vldr	s15, [r1, #-12]
 802904c:	ee27 7a26 	vmul.f32	s14, s14, s13
 8029050:	ee67 7ae6 	vnmul.f32	s15, s15, s13
 8029054:	ed01 7a04 	vstr	s14, [r1, #-16]
 8029058:	ed41 7a03 	vstr	s15, [r1, #-12]
 802905c:	d1ee      	bne.n	802903c <arm_cfft_f32+0x8c>
 802905e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8029062:	4621      	mov	r1, r4
 8029064:	4630      	mov	r0, r6
 8029066:	f7ff fd45 	bl	8028af4 <arm_cfft_radix8by4_f32>
 802906a:	e7be      	b.n	8028fea <arm_cfft_f32+0x3a>
 802906c:	b1ad      	cbz	r5, 802909a <arm_cfft_f32+0xea>
 802906e:	f101 030c 	add.w	r3, r1, #12
 8029072:	2200      	movs	r2, #0
 8029074:	ed53 7a02 	vldr	s15, [r3, #-8]
 8029078:	3201      	adds	r2, #1
 802907a:	eef1 7a67 	vneg.f32	s15, s15
 802907e:	4295      	cmp	r5, r2
 8029080:	ed43 7a02 	vstr	s15, [r3, #-8]
 8029084:	f103 0308 	add.w	r3, r3, #8
 8029088:	d1f4      	bne.n	8029074 <arm_cfft_f32+0xc4>
 802908a:	e79a      	b.n	8028fc2 <arm_cfft_f32+0x12>
 802908c:	f5b5 7f00 	cmp.w	r5, #512	@ 0x200
 8029090:	d0a5      	beq.n	8028fde <arm_cfft_f32+0x2e>
 8029092:	e7aa      	b.n	8028fea <arm_cfft_f32+0x3a>
 8029094:	2d10      	cmp	r5, #16
 8029096:	d0b6      	beq.n	8029006 <arm_cfft_f32+0x56>
 8029098:	e7a7      	b.n	8028fea <arm_cfft_f32+0x3a>
 802909a:	f5b5 7f80 	cmp.w	r5, #256	@ 0x100
 802909e:	d894      	bhi.n	8028fca <arm_cfft_f32+0x1a>
 80290a0:	e7aa      	b.n	8028ff8 <arm_cfft_f32+0x48>
 80290a2:	bf00      	nop

080290a4 <arm_sub_f32>:
 80290a4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80290a6:	ea5f 0e93 	movs.w	lr, r3, lsr #2
 80290aa:	d033      	beq.n	8029114 <arm_sub_f32+0x70>
 80290ac:	f100 0610 	add.w	r6, r0, #16
 80290b0:	f101 0510 	add.w	r5, r1, #16
 80290b4:	f102 0410 	add.w	r4, r2, #16
 80290b8:	4677      	mov	r7, lr
 80290ba:	ed16 6a03 	vldr	s12, [r6, #-12]
 80290be:	ed15 4a03 	vldr	s8, [r5, #-12]
 80290c2:	ed56 6a02 	vldr	s13, [r6, #-8]
 80290c6:	ed55 4a02 	vldr	s9, [r5, #-8]
 80290ca:	ed16 7a01 	vldr	s14, [r6, #-4]
 80290ce:	ed15 5a01 	vldr	s10, [r5, #-4]
 80290d2:	ed56 7a04 	vldr	s15, [r6, #-16]
 80290d6:	ed55 5a04 	vldr	s11, [r5, #-16]
 80290da:	ee36 6a44 	vsub.f32	s12, s12, s8
 80290de:	ee76 6ae4 	vsub.f32	s13, s13, s9
 80290e2:	ee37 7a45 	vsub.f32	s14, s14, s10
 80290e6:	ee77 7ae5 	vsub.f32	s15, s15, s11
 80290ea:	3f01      	subs	r7, #1
 80290ec:	ed04 6a03 	vstr	s12, [r4, #-12]
 80290f0:	ed44 6a02 	vstr	s13, [r4, #-8]
 80290f4:	ed04 7a01 	vstr	s14, [r4, #-4]
 80290f8:	ed44 7a04 	vstr	s15, [r4, #-16]
 80290fc:	f106 0610 	add.w	r6, r6, #16
 8029100:	f105 0510 	add.w	r5, r5, #16
 8029104:	f104 0410 	add.w	r4, r4, #16
 8029108:	d1d7      	bne.n	80290ba <arm_sub_f32+0x16>
 802910a:	ea4f 140e 	mov.w	r4, lr, lsl #4
 802910e:	4420      	add	r0, r4
 8029110:	4421      	add	r1, r4
 8029112:	4422      	add	r2, r4
 8029114:	f013 0303 	ands.w	r3, r3, #3
 8029118:	d009      	beq.n	802912e <arm_sub_f32+0x8a>
 802911a:	ecf0 7a01 	vldmia	r0!, {s15}
 802911e:	ecb1 7a01 	vldmia	r1!, {s14}
 8029122:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8029126:	3b01      	subs	r3, #1
 8029128:	ece2 7a01 	vstmia	r2!, {s15}
 802912c:	d1f5      	bne.n	802911a <arm_sub_f32+0x76>
 802912e:	bdf0      	pop	{r4, r5, r6, r7, pc}

08029130 <arm_mult_f32>:
 8029130:	b5f0      	push	{r4, r5, r6, r7, lr}
 8029132:	ea5f 0e93 	movs.w	lr, r3, lsr #2
 8029136:	d033      	beq.n	80291a0 <arm_mult_f32+0x70>
 8029138:	f100 0610 	add.w	r6, r0, #16
 802913c:	f101 0510 	add.w	r5, r1, #16
 8029140:	f102 0410 	add.w	r4, r2, #16
 8029144:	4677      	mov	r7, lr
 8029146:	ed16 6a04 	vldr	s12, [r6, #-16]
 802914a:	ed55 4a04 	vldr	s9, [r5, #-16]
 802914e:	ed56 6a02 	vldr	s13, [r6, #-8]
 8029152:	ed15 5a02 	vldr	s10, [r5, #-8]
 8029156:	ed16 7a03 	vldr	s14, [r6, #-12]
 802915a:	ed55 5a03 	vldr	s11, [r5, #-12]
 802915e:	ed56 7a01 	vldr	s15, [r6, #-4]
 8029162:	ee26 6a24 	vmul.f32	s12, s12, s9
 8029166:	ee66 6a85 	vmul.f32	s13, s13, s10
 802916a:	ed04 6a04 	vstr	s12, [r4, #-16]
 802916e:	ed15 6a01 	vldr	s12, [r5, #-4]
 8029172:	ed44 6a02 	vstr	s13, [r4, #-8]
 8029176:	ee27 7a25 	vmul.f32	s14, s14, s11
 802917a:	ee67 7a86 	vmul.f32	s15, s15, s12
 802917e:	3f01      	subs	r7, #1
 8029180:	ed04 7a03 	vstr	s14, [r4, #-12]
 8029184:	ed44 7a01 	vstr	s15, [r4, #-4]
 8029188:	f106 0610 	add.w	r6, r6, #16
 802918c:	f105 0510 	add.w	r5, r5, #16
 8029190:	f104 0410 	add.w	r4, r4, #16
 8029194:	d1d7      	bne.n	8029146 <arm_mult_f32+0x16>
 8029196:	ea4f 140e 	mov.w	r4, lr, lsl #4
 802919a:	4420      	add	r0, r4
 802919c:	4421      	add	r1, r4
 802919e:	4422      	add	r2, r4
 80291a0:	f013 0303 	ands.w	r3, r3, #3
 80291a4:	d009      	beq.n	80291ba <arm_mult_f32+0x8a>
 80291a6:	ecf0 7a01 	vldmia	r0!, {s15}
 80291aa:	ecb1 7a01 	vldmia	r1!, {s14}
 80291ae:	ee67 7a87 	vmul.f32	s15, s15, s14
 80291b2:	3b01      	subs	r3, #1
 80291b4:	ece2 7a01 	vstmia	r2!, {s15}
 80291b8:	d1f5      	bne.n	80291a6 <arm_mult_f32+0x76>
 80291ba:	bdf0      	pop	{r4, r5, r6, r7, pc}

080291bc <arm_radix8_butterfly_f32>:
 80291bc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80291c0:	ed2d 8b10 	vpush	{d8-d15}
 80291c4:	461c      	mov	r4, r3
 80291c6:	b09d      	sub	sp, #116	@ 0x74
 80291c8:	4603      	mov	r3, r0
 80291ca:	3304      	adds	r3, #4
 80291cc:	ed9f bac4 	vldr	s22, [pc, #784]	@ 80294e0 <arm_radix8_butterfly_f32+0x324>
 80291d0:	9019      	str	r0, [sp, #100]	@ 0x64
 80291d2:	921a      	str	r2, [sp, #104]	@ 0x68
 80291d4:	468b      	mov	fp, r1
 80291d6:	931b      	str	r3, [sp, #108]	@ 0x6c
 80291d8:	468a      	mov	sl, r1
 80291da:	46a1      	mov	r9, r4
 80291dc:	4607      	mov	r7, r0
 80291de:	ea4f 03db 	mov.w	r3, fp, lsr #3
 80291e2:	ea4f 0843 	mov.w	r8, r3, lsl #1
 80291e6:	eb03 0508 	add.w	r5, r3, r8
 80291ea:	195c      	adds	r4, r3, r5
 80291ec:	00de      	lsls	r6, r3, #3
 80291ee:	191a      	adds	r2, r3, r4
 80291f0:	9600      	str	r6, [sp, #0]
 80291f2:	1898      	adds	r0, r3, r2
 80291f4:	4619      	mov	r1, r3
 80291f6:	9e00      	ldr	r6, [sp, #0]
 80291f8:	9311      	str	r3, [sp, #68]	@ 0x44
 80291fa:	4401      	add	r1, r0
 80291fc:	eb07 02c2 	add.w	r2, r7, r2, lsl #3
 8029200:	eb07 01c1 	add.w	r1, r7, r1, lsl #3
 8029204:	19be      	adds	r6, r7, r6
 8029206:	eb07 05c5 	add.w	r5, r7, r5, lsl #3
 802920a:	eb07 04c4 	add.w	r4, r7, r4, lsl #3
 802920e:	eb07 00c0 	add.w	r0, r7, r0, lsl #3
 8029212:	9f00      	ldr	r7, [sp, #0]
 8029214:	011b      	lsls	r3, r3, #4
 8029216:	eb06 0e07 	add.w	lr, r6, r7
 802921a:	9f1b      	ldr	r7, [sp, #108]	@ 0x6c
 802921c:	9302      	str	r3, [sp, #8]
 802921e:	3204      	adds	r2, #4
 8029220:	3104      	adds	r1, #4
 8029222:	ea4f 03cb 	mov.w	r3, fp, lsl #3
 8029226:	f04f 0c00 	mov.w	ip, #0
 802922a:	edde 7a00 	vldr	s15, [lr]
 802922e:	edd6 6a00 	vldr	s13, [r6]
 8029232:	ed95 2a00 	vldr	s4, [r5]
 8029236:	ed17 aa01 	vldr	s20, [r7, #-4]
 802923a:	edd4 4a00 	vldr	s9, [r4]
 802923e:	ed90 5a00 	vldr	s10, [r0]
 8029242:	ed12 7a01 	vldr	s14, [r2, #-4]
 8029246:	ed51 0a01 	vldr	s1, [r1, #-4]
 802924a:	ee77 8a85 	vadd.f32	s17, s15, s10
 802924e:	ee76 3a87 	vadd.f32	s7, s13, s14
 8029252:	ee32 4a20 	vadd.f32	s8, s4, s1
 8029256:	ee3a 3a24 	vadd.f32	s6, s20, s9
 802925a:	ee33 6a84 	vadd.f32	s12, s7, s8
 802925e:	ee73 5a28 	vadd.f32	s11, s6, s17
 8029262:	ee36 7ac7 	vsub.f32	s14, s13, s14
 8029266:	ee75 6a86 	vadd.f32	s13, s11, s12
 802926a:	ee75 5ac6 	vsub.f32	s11, s11, s12
 802926e:	ed47 6a01 	vstr	s13, [r7, #-4]
 8029272:	edc4 5a00 	vstr	s11, [r4]
 8029276:	ed92 9a00 	vldr	s18, [r2]
 802927a:	ed95 1a01 	vldr	s2, [r5, #4]
 802927e:	edd6 5a01 	vldr	s11, [r6, #4]
 8029282:	ed91 6a00 	vldr	s12, [r1]
 8029286:	edd7 2a00 	vldr	s5, [r7]
 802928a:	edd4 1a01 	vldr	s3, [r4, #4]
 802928e:	edde 6a01 	vldr	s13, [lr, #4]
 8029292:	edd0 9a01 	vldr	s19, [r0, #4]
 8029296:	ee72 0a60 	vsub.f32	s1, s4, s1
 802929a:	ee71 aa46 	vsub.f32	s21, s2, s12
 802929e:	ee35 2ac9 	vsub.f32	s4, s11, s18
 80292a2:	ee37 0a60 	vsub.f32	s0, s14, s1
 80292a6:	ee32 8a2a 	vadd.f32	s16, s4, s21
 80292aa:	ee37 7a20 	vadd.f32	s14, s14, s1
 80292ae:	ee32 2a6a 	vsub.f32	s4, s4, s21
 80292b2:	ee37 5ac5 	vsub.f32	s10, s15, s10
 80292b6:	ee75 5a89 	vadd.f32	s11, s11, s18
 80292ba:	ee60 0a0b 	vmul.f32	s1, s0, s22
 80292be:	ee7a 4a64 	vsub.f32	s9, s20, s9
 80292c2:	ee31 6a06 	vadd.f32	s12, s2, s12
 80292c6:	ee36 9aa9 	vadd.f32	s18, s13, s19
 80292ca:	ee32 1aa1 	vadd.f32	s2, s5, s3
 80292ce:	ee76 6ae9 	vsub.f32	s13, s13, s19
 80292d2:	ee72 1ae1 	vsub.f32	s3, s5, s3
 80292d6:	ee28 8a0b 	vmul.f32	s16, s16, s22
 80292da:	ee62 2a0b 	vmul.f32	s5, s4, s22
 80292de:	ee67 7a0b 	vmul.f32	s15, s14, s22
 80292e2:	ee33 3a68 	vsub.f32	s6, s6, s17
 80292e6:	ee36 0a88 	vadd.f32	s0, s13, s16
 80292ea:	ee75 8a86 	vadd.f32	s17, s11, s12
 80292ee:	ee36 7ac8 	vsub.f32	s14, s13, s16
 80292f2:	ee33 4ac4 	vsub.f32	s8, s7, s8
 80292f6:	ee74 6ae0 	vsub.f32	s13, s9, s1
 80292fa:	ee74 3aa0 	vadd.f32	s7, s9, s1
 80292fe:	ee35 6ac6 	vsub.f32	s12, s11, s12
 8029302:	ee75 4a27 	vadd.f32	s9, s10, s15
 8029306:	ee71 5a49 	vsub.f32	s11, s2, s18
 802930a:	ee31 2a09 	vadd.f32	s4, s2, s18
 802930e:	ee75 7a67 	vsub.f32	s15, s10, s15
 8029312:	ee31 1aa2 	vadd.f32	s2, s3, s5
 8029316:	ee71 2ae2 	vsub.f32	s5, s3, s5
 802931a:	ee73 0a06 	vadd.f32	s1, s6, s12
 802931e:	ee75 1ac4 	vsub.f32	s3, s11, s8
 8029322:	ee36 5a87 	vadd.f32	s10, s13, s14
 8029326:	ee32 8a28 	vadd.f32	s16, s4, s17
 802932a:	ee33 6a46 	vsub.f32	s12, s6, s12
 802932e:	ee34 4a25 	vadd.f32	s8, s8, s11
 8029332:	ee33 3a80 	vadd.f32	s6, s7, s0
 8029336:	ee36 7ac7 	vsub.f32	s14, s13, s14
 802933a:	ee71 5a64 	vsub.f32	s11, s2, s9
 802933e:	ee72 6ae7 	vsub.f32	s13, s5, s15
 8029342:	ee32 2a68 	vsub.f32	s4, s4, s17
 8029346:	ee73 3ac0 	vsub.f32	s7, s7, s0
 802934a:	ee74 4a81 	vadd.f32	s9, s9, s2
 802934e:	ee77 7aa2 	vadd.f32	s15, s15, s5
 8029352:	44dc      	add	ip, fp
 8029354:	45e2      	cmp	sl, ip
 8029356:	ed87 8a00 	vstr	s16, [r7]
 802935a:	ed84 2a01 	vstr	s4, [r4, #4]
 802935e:	441f      	add	r7, r3
 8029360:	edce 0a00 	vstr	s1, [lr]
 8029364:	441c      	add	r4, r3
 8029366:	ed80 6a00 	vstr	s12, [r0]
 802936a:	edce 1a01 	vstr	s3, [lr, #4]
 802936e:	ed80 4a01 	vstr	s8, [r0, #4]
 8029372:	449e      	add	lr, r3
 8029374:	ed86 3a00 	vstr	s6, [r6]
 8029378:	4418      	add	r0, r3
 802937a:	ed41 3a01 	vstr	s7, [r1, #-4]
 802937e:	ed02 5a01 	vstr	s10, [r2, #-4]
 8029382:	ed85 7a00 	vstr	s14, [r5]
 8029386:	edc6 5a01 	vstr	s11, [r6, #4]
 802938a:	edc1 4a00 	vstr	s9, [r1]
 802938e:	441e      	add	r6, r3
 8029390:	edc2 6a00 	vstr	s13, [r2]
 8029394:	4419      	add	r1, r3
 8029396:	edc5 7a01 	vstr	s15, [r5, #4]
 802939a:	441a      	add	r2, r3
 802939c:	441d      	add	r5, r3
 802939e:	f63f af44 	bhi.w	802922a <arm_radix8_butterfly_f32+0x6e>
 80293a2:	9a11      	ldr	r2, [sp, #68]	@ 0x44
 80293a4:	2a07      	cmp	r2, #7
 80293a6:	f240 81f5 	bls.w	8029794 <arm_radix8_butterfly_f32+0x5d8>
 80293aa:	f108 0101 	add.w	r1, r8, #1
 80293ae:	188f      	adds	r7, r1, r2
 80293b0:	eb09 0849 	add.w	r8, r9, r9, lsl #1
 80293b4:	19d6      	adds	r6, r2, r7
 80293b6:	eb08 0c09 	add.w	ip, r8, r9
 80293ba:	1994      	adds	r4, r2, r6
 80293bc:	eb0c 0e09 	add.w	lr, ip, r9
 80293c0:	4610      	mov	r0, r2
 80293c2:	9701      	str	r7, [sp, #4]
 80293c4:	4420      	add	r0, r4
 80293c6:	eb0e 0709 	add.w	r7, lr, r9
 80293ca:	1815      	adds	r5, r2, r0
 80293cc:	eb07 0209 	add.w	r2, r7, r9
 80293d0:	9203      	str	r2, [sp, #12]
 80293d2:	9a1a      	ldr	r2, [sp, #104]	@ 0x68
 80293d4:	ea4f 01c9 	mov.w	r1, r9, lsl #3
 80293d8:	9117      	str	r1, [sp, #92]	@ 0x5c
 80293da:	440a      	add	r2, r1
 80293dc:	9900      	ldr	r1, [sp, #0]
 80293de:	3108      	adds	r1, #8
 80293e0:	9100      	str	r1, [sp, #0]
 80293e2:	9902      	ldr	r1, [sp, #8]
 80293e4:	3108      	adds	r1, #8
 80293e6:	9102      	str	r1, [sp, #8]
 80293e8:	9919      	ldr	r1, [sp, #100]	@ 0x64
 80293ea:	00ff      	lsls	r7, r7, #3
 80293ec:	9715      	str	r7, [sp, #84]	@ 0x54
 80293ee:	eb01 04c4 	add.w	r4, r1, r4, lsl #3
 80293f2:	eb01 05c5 	add.w	r5, r1, r5, lsl #3
 80293f6:	eb01 00c0 	add.w	r0, r1, r0, lsl #3
 80293fa:	9f17      	ldr	r7, [sp, #92]	@ 0x5c
 80293fc:	9903      	ldr	r1, [sp, #12]
 80293fe:	19d7      	adds	r7, r2, r7
 8029400:	00c9      	lsls	r1, r1, #3
 8029402:	9114      	str	r1, [sp, #80]	@ 0x50
 8029404:	9710      	str	r7, [sp, #64]	@ 0x40
 8029406:	9919      	ldr	r1, [sp, #100]	@ 0x64
 8029408:	9f00      	ldr	r7, [sp, #0]
 802940a:	19cf      	adds	r7, r1, r7
 802940c:	970d      	str	r7, [sp, #52]	@ 0x34
 802940e:	9f02      	ldr	r7, [sp, #8]
 8029410:	19cf      	adds	r7, r1, r7
 8029412:	ea4f 0ece 	mov.w	lr, lr, lsl #3
 8029416:	970c      	str	r7, [sp, #48]	@ 0x30
 8029418:	9f01      	ldr	r7, [sp, #4]
 802941a:	f8cd e058 	str.w	lr, [sp, #88]	@ 0x58
 802941e:	3504      	adds	r5, #4
 8029420:	3004      	adds	r0, #4
 8029422:	eb01 0ec7 	add.w	lr, r1, r7, lsl #3
 8029426:	9508      	str	r5, [sp, #32]
 8029428:	9009      	str	r0, [sp, #36]	@ 0x24
 802942a:	9d16      	ldr	r5, [sp, #88]	@ 0x58
 802942c:	981a      	ldr	r0, [sp, #104]	@ 0x68
 802942e:	f8cd e02c 	str.w	lr, [sp, #44]	@ 0x2c
 8029432:	ea4f 08c8 	mov.w	r8, r8, lsl #3
 8029436:	eb01 0ec6 	add.w	lr, r1, r6, lsl #3
 802943a:	9e14      	ldr	r6, [sp, #80]	@ 0x50
 802943c:	f8cd e038 	str.w	lr, [sp, #56]	@ 0x38
 8029440:	1945      	adds	r5, r0, r5
 8029442:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 8029446:	460f      	mov	r7, r1
 8029448:	3404      	adds	r4, #4
 802944a:	4641      	mov	r1, r8
 802944c:	1841      	adds	r1, r0, r1
 802944e:	f8cd c048 	str.w	ip, [sp, #72]	@ 0x48
 8029452:	940a      	str	r4, [sp, #40]	@ 0x28
 8029454:	eb00 0c06 	add.w	ip, r0, r6
 8029458:	f8cd 804c 	str.w	r8, [sp, #76]	@ 0x4c
 802945c:	9e15      	ldr	r6, [sp, #84]	@ 0x54
 802945e:	9506      	str	r5, [sp, #24]
 8029460:	9c12      	ldr	r4, [sp, #72]	@ 0x48
 8029462:	9105      	str	r1, [sp, #20]
 8029464:	4639      	mov	r1, r7
 8029466:	1905      	adds	r5, r0, r4
 8029468:	3108      	adds	r1, #8
 802946a:	9c10      	ldr	r4, [sp, #64]	@ 0x40
 802946c:	9507      	str	r5, [sp, #28]
 802946e:	910f      	str	r1, [sp, #60]	@ 0x3c
 8029470:	ea4f 1509 	mov.w	r5, r9, lsl #4
 8029474:	2101      	movs	r1, #1
 8029476:	eb00 0e06 	add.w	lr, r0, r6
 802947a:	9518      	str	r5, [sp, #96]	@ 0x60
 802947c:	9404      	str	r4, [sp, #16]
 802947e:	9103      	str	r1, [sp, #12]
 8029480:	4620      	mov	r0, r4
 8029482:	4689      	mov	r9, r1
 8029484:	9e06      	ldr	r6, [sp, #24]
 8029486:	ed90 fa00 	vldr	s30, [r0]
 802948a:	edd6 7a01 	vldr	s15, [r6, #4]
 802948e:	edd0 ba01 	vldr	s23, [r0, #4]
 8029492:	edcd 7a00 	vstr	s15, [sp]
 8029496:	a80d      	add	r0, sp, #52	@ 0x34
 8029498:	edde 7a01 	vldr	s15, [lr, #4]
 802949c:	9c05      	ldr	r4, [sp, #20]
 802949e:	9d07      	ldr	r5, [sp, #28]
 80294a0:	edd2 fa00 	vldr	s31, [r2]
 80294a4:	ed92 ca01 	vldr	s24, [r2, #4]
 80294a8:	edcd 7a01 	vstr	s15, [sp, #4]
 80294ac:	c807      	ldmia	r0, {r0, r1, r2}
 80294ae:	eddc 7a01 	vldr	s15, [ip, #4]
 80294b2:	edd4 ea00 	vldr	s29, [r4]
 80294b6:	ed95 ea00 	vldr	s28, [r5]
 80294ba:	edd6 da00 	vldr	s27, [r6]
 80294be:	edd4 aa01 	vldr	s21, [r4, #4]
 80294c2:	ed95 aa01 	vldr	s20, [r5, #4]
 80294c6:	ed9e da00 	vldr	s26, [lr]
 80294ca:	eddc ca00 	vldr	s25, [ip]
 80294ce:	f8dd 8020 	ldr.w	r8, [sp, #32]
 80294d2:	9f09      	ldr	r7, [sp, #36]	@ 0x24
 80294d4:	9e0a      	ldr	r6, [sp, #40]	@ 0x28
 80294d6:	9d0b      	ldr	r5, [sp, #44]	@ 0x2c
 80294d8:	9c0c      	ldr	r4, [sp, #48]	@ 0x30
 80294da:	edcd 7a02 	vstr	s15, [sp, #8]
 80294de:	e001      	b.n	80294e4 <arm_radix8_butterfly_f32+0x328>
 80294e0:	3f3504f3 	.word	0x3f3504f3
 80294e4:	ed16 6a01 	vldr	s12, [r6, #-4]
 80294e8:	ed91 5a00 	vldr	s10, [r1]
 80294ec:	ed57 9a01 	vldr	s19, [r7, #-4]
 80294f0:	edd5 7a00 	vldr	s15, [r5]
 80294f4:	ed18 7a01 	vldr	s14, [r8, #-4]
 80294f8:	edd2 3a00 	vldr	s7, [r2]
 80294fc:	ed94 3a00 	vldr	s6, [r4]
 8029500:	ed90 2a00 	vldr	s4, [r0]
 8029504:	ed92 0a01 	vldr	s0, [r2, #4]
 8029508:	ee33 8a85 	vadd.f32	s16, s7, s10
 802950c:	ee32 1a06 	vadd.f32	s2, s4, s12
 8029510:	ee33 4a29 	vadd.f32	s8, s6, s19
 8029514:	ee77 4a87 	vadd.f32	s9, s15, s14
 8029518:	ee78 1a04 	vadd.f32	s3, s16, s8
 802951c:	ee71 6a24 	vadd.f32	s13, s2, s9
 8029520:	ee32 2a46 	vsub.f32	s4, s4, s12
 8029524:	ee31 6aa6 	vadd.f32	s12, s3, s13
 8029528:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802952c:	ed82 6a00 	vstr	s12, [r2]
 8029530:	edd5 8a01 	vldr	s17, [r5, #4]
 8029534:	ed90 9a01 	vldr	s18, [r0, #4]
 8029538:	edd6 2a00 	vldr	s5, [r6]
 802953c:	ed98 7a00 	vldr	s14, [r8]
 8029540:	edd4 0a01 	vldr	s1, [r4, #4]
 8029544:	ed91 6a01 	vldr	s12, [r1, #4]
 8029548:	edd7 5a00 	vldr	s11, [r7]
 802954c:	ee73 3ac5 	vsub.f32	s7, s7, s10
 8029550:	ee33 3a69 	vsub.f32	s6, s6, s19
 8029554:	ee39 5a62 	vsub.f32	s10, s18, s5
 8029558:	ee78 9ac7 	vsub.f32	s19, s17, s14
 802955c:	ee38 4a44 	vsub.f32	s8, s16, s8
 8029560:	ee38 7a87 	vadd.f32	s14, s17, s14
 8029564:	ee30 8aa5 	vadd.f32	s16, s1, s11
 8029568:	ee79 2a22 	vadd.f32	s5, s18, s5
 802956c:	ee75 8a69 	vsub.f32	s17, s10, s19
 8029570:	ee32 9a27 	vadd.f32	s18, s4, s15
 8029574:	ee35 5a29 	vadd.f32	s10, s10, s19
 8029578:	ee72 7a67 	vsub.f32	s15, s4, s15
 802957c:	ee30 2a06 	vadd.f32	s4, s0, s12
 8029580:	ee69 9a0b 	vmul.f32	s19, s18, s22
 8029584:	ee70 5ae5 	vsub.f32	s11, s1, s11
 8029588:	ee32 9a08 	vadd.f32	s18, s4, s16
 802958c:	ee68 8a8b 	vmul.f32	s17, s17, s22
 8029590:	ee32 2a48 	vsub.f32	s4, s4, s16
 8029594:	ee71 4a64 	vsub.f32	s9, s2, s9
 8029598:	ee25 5a0b 	vmul.f32	s10, s10, s22
 802959c:	ee32 1a87 	vadd.f32	s2, s5, s14
 80295a0:	ee67 7a8b 	vmul.f32	s15, s15, s22
 80295a4:	ee72 2ac7 	vsub.f32	s5, s5, s14
 80295a8:	ee30 6a46 	vsub.f32	s12, s0, s12
 80295ac:	ee73 0a29 	vadd.f32	s1, s6, s19
 80295b0:	ee36 0a28 	vadd.f32	s0, s12, s17
 80295b4:	ee33 3a69 	vsub.f32	s6, s6, s19
 80295b8:	ee32 7a64 	vsub.f32	s14, s4, s9
 80295bc:	ee73 9aa7 	vadd.f32	s19, s7, s15
 80295c0:	ee36 6a68 	vsub.f32	s12, s12, s17
 80295c4:	ee73 7ae7 	vsub.f32	s15, s7, s15
 80295c8:	ee75 8a85 	vadd.f32	s17, s11, s10
 80295cc:	ee74 3a22 	vadd.f32	s7, s8, s5
 80295d0:	ee35 5ac5 	vsub.f32	s10, s11, s10
 80295d4:	ee71 6ae6 	vsub.f32	s13, s3, s13
 80295d8:	ee79 1a41 	vsub.f32	s3, s18, s2
 80295dc:	ee39 8aa8 	vadd.f32	s16, s19, s17
 80295e0:	ee76 5a43 	vsub.f32	s11, s12, s6
 80295e4:	ee74 2a62 	vsub.f32	s5, s8, s5
 80295e8:	ee74 4a82 	vadd.f32	s9, s9, s4
 80295ec:	ee30 4a60 	vsub.f32	s8, s0, s1
 80295f0:	ee79 8ae8 	vsub.f32	s17, s19, s17
 80295f4:	ee30 0a80 	vadd.f32	s0, s1, s0
 80295f8:	ee77 9a85 	vadd.f32	s19, s15, s10
 80295fc:	ee33 6a06 	vadd.f32	s12, s6, s12
 8029600:	ee77 7ac5 	vsub.f32	s15, s15, s10
 8029604:	ee2e 2a21 	vmul.f32	s4, s28, s3
 8029608:	ee2e 5a26 	vmul.f32	s10, s28, s13
 802960c:	ee6f 0a23 	vmul.f32	s1, s30, s7
 8029610:	ee2a 3a21 	vmul.f32	s6, s20, s3
 8029614:	ee39 1a01 	vadd.f32	s2, s18, s2
 8029618:	ee6a 6a26 	vmul.f32	s13, s20, s13
 802961c:	ee2b 9a87 	vmul.f32	s18, s23, s14
 8029620:	ee6b 3aa3 	vmul.f32	s7, s23, s7
 8029624:	ee2f 7a07 	vmul.f32	s14, s30, s14
 8029628:	ee6f 1a84 	vmul.f32	s3, s31, s8
 802962c:	ee35 3a03 	vadd.f32	s6, s10, s6
 8029630:	ee72 6a66 	vsub.f32	s13, s4, s13
 8029634:	ee2c 5a04 	vmul.f32	s10, s24, s8
 8029638:	ee2f 2a88 	vmul.f32	s4, s31, s16
 802963c:	ed9d 4a02 	vldr	s8, [sp, #8]
 8029640:	ed82 1a01 	vstr	s2, [r2, #4]
 8029644:	ee77 3a63 	vsub.f32	s7, s14, s7
 8029648:	ee2c 8a08 	vmul.f32	s16, s24, s16
 802964c:	ed9d 7a01 	vldr	s14, [sp, #4]
 8029650:	ed81 3a00 	vstr	s6, [r1]
 8029654:	ee30 9a89 	vadd.f32	s18, s1, s18
 8029658:	ee32 2a05 	vadd.f32	s4, s4, s10
 802965c:	ee6d 0a22 	vmul.f32	s1, s26, s5
 8029660:	ee31 8ac8 	vsub.f32	s16, s3, s16
 8029664:	ee67 2a22 	vmul.f32	s5, s14, s5
 8029668:	ee64 1a00 	vmul.f32	s3, s8, s0
 802966c:	ee27 7a24 	vmul.f32	s14, s14, s9
 8029670:	ee2c 5aa8 	vmul.f32	s10, s25, s17
 8029674:	ee6d 4a24 	vmul.f32	s9, s26, s9
 8029678:	ee64 8a28 	vmul.f32	s17, s8, s17
 802967c:	ed9d 4a00 	vldr	s8, [sp]
 8029680:	edc1 6a01 	vstr	s13, [r1, #4]
 8029684:	ee74 2ae2 	vsub.f32	s5, s9, s5
 8029688:	ee6d 4aa9 	vmul.f32	s9, s27, s19
 802968c:	ee64 9a29 	vmul.f32	s19, s8, s19
 8029690:	ee24 4a25 	vmul.f32	s8, s8, s11
 8029694:	ee30 7a87 	vadd.f32	s14, s1, s14
 8029698:	ee74 4a84 	vadd.f32	s9, s9, s8
 802969c:	ee6e 0aa7 	vmul.f32	s1, s29, s15
 80296a0:	ee2a 4a86 	vmul.f32	s8, s21, s12
 80296a4:	ee2c 0a80 	vmul.f32	s0, s25, s0
 80296a8:	ee6d 5aa5 	vmul.f32	s11, s27, s11
 80296ac:	ee6a 7aa7 	vmul.f32	s15, s21, s15
 80296b0:	ee2e 6a86 	vmul.f32	s12, s29, s12
 80296b4:	ee75 1a21 	vadd.f32	s3, s10, s3
 80296b8:	ee30 0a68 	vsub.f32	s0, s0, s17
 80296bc:	ee75 9ae9 	vsub.f32	s19, s11, s19
 80296c0:	ee70 0a84 	vadd.f32	s1, s1, s8
 80296c4:	ee36 6a67 	vsub.f32	s12, s12, s15
 80296c8:	44d9      	add	r9, fp
 80296ca:	45ca      	cmp	sl, r9
 80296cc:	ed84 9a00 	vstr	s18, [r4]
 80296d0:	edc4 3a01 	vstr	s7, [r4, #4]
 80296d4:	441a      	add	r2, r3
 80296d6:	ed07 7a01 	vstr	s14, [r7, #-4]
 80296da:	edc7 2a00 	vstr	s5, [r7]
 80296de:	4419      	add	r1, r3
 80296e0:	ed80 2a00 	vstr	s4, [r0]
 80296e4:	ed80 8a01 	vstr	s16, [r0, #4]
 80296e8:	441c      	add	r4, r3
 80296ea:	ed48 1a01 	vstr	s3, [r8, #-4]
 80296ee:	ed88 0a00 	vstr	s0, [r8]
 80296f2:	441f      	add	r7, r3
 80296f4:	ed46 4a01 	vstr	s9, [r6, #-4]
 80296f8:	4418      	add	r0, r3
 80296fa:	edc6 9a00 	vstr	s19, [r6]
 80296fe:	4498      	add	r8, r3
 8029700:	edc5 0a00 	vstr	s1, [r5]
 8029704:	ed85 6a01 	vstr	s12, [r5, #4]
 8029708:	441e      	add	r6, r3
 802970a:	441d      	add	r5, r3
 802970c:	f63f aeea 	bhi.w	80294e4 <arm_radix8_butterfly_f32+0x328>
 8029710:	9a03      	ldr	r2, [sp, #12]
 8029712:	9818      	ldr	r0, [sp, #96]	@ 0x60
 8029714:	3201      	adds	r2, #1
 8029716:	4611      	mov	r1, r2
 8029718:	9203      	str	r2, [sp, #12]
 802971a:	9a04      	ldr	r2, [sp, #16]
 802971c:	4402      	add	r2, r0
 802971e:	9204      	str	r2, [sp, #16]
 8029720:	9813      	ldr	r0, [sp, #76]	@ 0x4c
 8029722:	9a05      	ldr	r2, [sp, #20]
 8029724:	4402      	add	r2, r0
 8029726:	9205      	str	r2, [sp, #20]
 8029728:	9812      	ldr	r0, [sp, #72]	@ 0x48
 802972a:	9a07      	ldr	r2, [sp, #28]
 802972c:	4402      	add	r2, r0
 802972e:	9207      	str	r2, [sp, #28]
 8029730:	9816      	ldr	r0, [sp, #88]	@ 0x58
 8029732:	9a06      	ldr	r2, [sp, #24]
 8029734:	4402      	add	r2, r0
 8029736:	9206      	str	r2, [sp, #24]
 8029738:	9a15      	ldr	r2, [sp, #84]	@ 0x54
 802973a:	4496      	add	lr, r2
 802973c:	9a14      	ldr	r2, [sp, #80]	@ 0x50
 802973e:	4494      	add	ip, r2
 8029740:	9a0f      	ldr	r2, [sp, #60]	@ 0x3c
 8029742:	3208      	adds	r2, #8
 8029744:	920f      	str	r2, [sp, #60]	@ 0x3c
 8029746:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
 8029748:	3208      	adds	r2, #8
 802974a:	920e      	str	r2, [sp, #56]	@ 0x38
 802974c:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
 802974e:	3208      	adds	r2, #8
 8029750:	920d      	str	r2, [sp, #52]	@ 0x34
 8029752:	9a0c      	ldr	r2, [sp, #48]	@ 0x30
 8029754:	3208      	adds	r2, #8
 8029756:	920c      	str	r2, [sp, #48]	@ 0x30
 8029758:	9a0b      	ldr	r2, [sp, #44]	@ 0x2c
 802975a:	3208      	adds	r2, #8
 802975c:	920b      	str	r2, [sp, #44]	@ 0x2c
 802975e:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 8029760:	3208      	adds	r2, #8
 8029762:	920a      	str	r2, [sp, #40]	@ 0x28
 8029764:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 8029766:	3208      	adds	r2, #8
 8029768:	9209      	str	r2, [sp, #36]	@ 0x24
 802976a:	9a08      	ldr	r2, [sp, #32]
 802976c:	3208      	adds	r2, #8
 802976e:	9208      	str	r2, [sp, #32]
 8029770:	9c10      	ldr	r4, [sp, #64]	@ 0x40
 8029772:	9811      	ldr	r0, [sp, #68]	@ 0x44
 8029774:	4288      	cmp	r0, r1
 8029776:	4622      	mov	r2, r4
 8029778:	d007      	beq.n	802978a <arm_radix8_butterfly_f32+0x5ce>
 802977a:	9817      	ldr	r0, [sp, #92]	@ 0x5c
 802977c:	f8dd 900c 	ldr.w	r9, [sp, #12]
 8029780:	4621      	mov	r1, r4
 8029782:	4401      	add	r1, r0
 8029784:	9110      	str	r1, [sp, #64]	@ 0x40
 8029786:	9804      	ldr	r0, [sp, #16]
 8029788:	e67c      	b.n	8029484 <arm_radix8_butterfly_f32+0x2c8>
 802978a:	4683      	mov	fp, r0
 802978c:	f8bd 905c 	ldrh.w	r9, [sp, #92]	@ 0x5c
 8029790:	9f19      	ldr	r7, [sp, #100]	@ 0x64
 8029792:	e524      	b.n	80291de <arm_radix8_butterfly_f32+0x22>
 8029794:	b01d      	add	sp, #116	@ 0x74
 8029796:	ecbd 8b10 	vpop	{d8-d15}
 802979a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802979e:	bf00      	nop

080297a0 <rand>:
 80297a0:	4b16      	ldr	r3, [pc, #88]	@ (80297fc <rand+0x5c>)
 80297a2:	b510      	push	{r4, lr}
 80297a4:	681c      	ldr	r4, [r3, #0]
 80297a6:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 80297a8:	b9b3      	cbnz	r3, 80297d8 <rand+0x38>
 80297aa:	2018      	movs	r0, #24
 80297ac:	f000 fab0 	bl	8029d10 <malloc>
 80297b0:	4602      	mov	r2, r0
 80297b2:	6320      	str	r0, [r4, #48]	@ 0x30
 80297b4:	b920      	cbnz	r0, 80297c0 <rand+0x20>
 80297b6:	4b12      	ldr	r3, [pc, #72]	@ (8029800 <rand+0x60>)
 80297b8:	4812      	ldr	r0, [pc, #72]	@ (8029804 <rand+0x64>)
 80297ba:	2152      	movs	r1, #82	@ 0x52
 80297bc:	f000 fa40 	bl	8029c40 <__assert_func>
 80297c0:	4911      	ldr	r1, [pc, #68]	@ (8029808 <rand+0x68>)
 80297c2:	4b12      	ldr	r3, [pc, #72]	@ (802980c <rand+0x6c>)
 80297c4:	e9c0 1300 	strd	r1, r3, [r0]
 80297c8:	4b11      	ldr	r3, [pc, #68]	@ (8029810 <rand+0x70>)
 80297ca:	6083      	str	r3, [r0, #8]
 80297cc:	230b      	movs	r3, #11
 80297ce:	8183      	strh	r3, [r0, #12]
 80297d0:	2100      	movs	r1, #0
 80297d2:	2001      	movs	r0, #1
 80297d4:	e9c2 0104 	strd	r0, r1, [r2, #16]
 80297d8:	6b21      	ldr	r1, [r4, #48]	@ 0x30
 80297da:	480e      	ldr	r0, [pc, #56]	@ (8029814 <rand+0x74>)
 80297dc:	690b      	ldr	r3, [r1, #16]
 80297de:	694c      	ldr	r4, [r1, #20]
 80297e0:	4a0d      	ldr	r2, [pc, #52]	@ (8029818 <rand+0x78>)
 80297e2:	4358      	muls	r0, r3
 80297e4:	fb02 0004 	mla	r0, r2, r4, r0
 80297e8:	fba3 3202 	umull	r3, r2, r3, r2
 80297ec:	3301      	adds	r3, #1
 80297ee:	eb40 0002 	adc.w	r0, r0, r2
 80297f2:	e9c1 3004 	strd	r3, r0, [r1, #16]
 80297f6:	f020 4000 	bic.w	r0, r0, #2147483648	@ 0x80000000
 80297fa:	bd10      	pop	{r4, pc}
 80297fc:	20000140 	.word	0x20000140
 8029800:	080421cc 	.word	0x080421cc
 8029804:	080421e3 	.word	0x080421e3
 8029808:	abcd330e 	.word	0xabcd330e
 802980c:	e66d1234 	.word	0xe66d1234
 8029810:	0005deec 	.word	0x0005deec
 8029814:	5851f42d 	.word	0x5851f42d
 8029818:	4c957f2d 	.word	0x4c957f2d

0802981c <std>:
 802981c:	2300      	movs	r3, #0
 802981e:	b510      	push	{r4, lr}
 8029820:	4604      	mov	r4, r0
 8029822:	e9c0 3300 	strd	r3, r3, [r0]
 8029826:	e9c0 3304 	strd	r3, r3, [r0, #16]
 802982a:	6083      	str	r3, [r0, #8]
 802982c:	8181      	strh	r1, [r0, #12]
 802982e:	6643      	str	r3, [r0, #100]	@ 0x64
 8029830:	81c2      	strh	r2, [r0, #14]
 8029832:	6183      	str	r3, [r0, #24]
 8029834:	4619      	mov	r1, r3
 8029836:	2208      	movs	r2, #8
 8029838:	305c      	adds	r0, #92	@ 0x5c
 802983a:	f000 f977 	bl	8029b2c <memset>
 802983e:	4b0d      	ldr	r3, [pc, #52]	@ (8029874 <std+0x58>)
 8029840:	6263      	str	r3, [r4, #36]	@ 0x24
 8029842:	4b0d      	ldr	r3, [pc, #52]	@ (8029878 <std+0x5c>)
 8029844:	62a3      	str	r3, [r4, #40]	@ 0x28
 8029846:	4b0d      	ldr	r3, [pc, #52]	@ (802987c <std+0x60>)
 8029848:	62e3      	str	r3, [r4, #44]	@ 0x2c
 802984a:	4b0d      	ldr	r3, [pc, #52]	@ (8029880 <std+0x64>)
 802984c:	6323      	str	r3, [r4, #48]	@ 0x30
 802984e:	4b0d      	ldr	r3, [pc, #52]	@ (8029884 <std+0x68>)
 8029850:	6224      	str	r4, [r4, #32]
 8029852:	429c      	cmp	r4, r3
 8029854:	d006      	beq.n	8029864 <std+0x48>
 8029856:	f103 0268 	add.w	r2, r3, #104	@ 0x68
 802985a:	4294      	cmp	r4, r2
 802985c:	d002      	beq.n	8029864 <std+0x48>
 802985e:	33d0      	adds	r3, #208	@ 0xd0
 8029860:	429c      	cmp	r4, r3
 8029862:	d105      	bne.n	8029870 <std+0x54>
 8029864:	f104 0058 	add.w	r0, r4, #88	@ 0x58
 8029868:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 802986c:	f000 b9d6 	b.w	8029c1c <__retarget_lock_init_recursive>
 8029870:	bd10      	pop	{r4, pc}
 8029872:	bf00      	nop
 8029874:	08029a0d 	.word	0x08029a0d
 8029878:	08029a2f 	.word	0x08029a2f
 802987c:	08029a67 	.word	0x08029a67
 8029880:	08029a8b 	.word	0x08029a8b
 8029884:	20023e6c 	.word	0x20023e6c

08029888 <stdio_exit_handler>:
 8029888:	4a02      	ldr	r2, [pc, #8]	@ (8029894 <stdio_exit_handler+0xc>)
 802988a:	4903      	ldr	r1, [pc, #12]	@ (8029898 <stdio_exit_handler+0x10>)
 802988c:	4803      	ldr	r0, [pc, #12]	@ (802989c <stdio_exit_handler+0x14>)
 802988e:	f000 b869 	b.w	8029964 <_fwalk_sglue>
 8029892:	bf00      	nop
 8029894:	20000134 	.word	0x20000134
 8029898:	0802a54d 	.word	0x0802a54d
 802989c:	20000144 	.word	0x20000144

080298a0 <cleanup_stdio>:
 80298a0:	6841      	ldr	r1, [r0, #4]
 80298a2:	4b0c      	ldr	r3, [pc, #48]	@ (80298d4 <cleanup_stdio+0x34>)
 80298a4:	4299      	cmp	r1, r3
 80298a6:	b510      	push	{r4, lr}
 80298a8:	4604      	mov	r4, r0
 80298aa:	d001      	beq.n	80298b0 <cleanup_stdio+0x10>
 80298ac:	f000 fe4e 	bl	802a54c <_fflush_r>
 80298b0:	68a1      	ldr	r1, [r4, #8]
 80298b2:	4b09      	ldr	r3, [pc, #36]	@ (80298d8 <cleanup_stdio+0x38>)
 80298b4:	4299      	cmp	r1, r3
 80298b6:	d002      	beq.n	80298be <cleanup_stdio+0x1e>
 80298b8:	4620      	mov	r0, r4
 80298ba:	f000 fe47 	bl	802a54c <_fflush_r>
 80298be:	68e1      	ldr	r1, [r4, #12]
 80298c0:	4b06      	ldr	r3, [pc, #24]	@ (80298dc <cleanup_stdio+0x3c>)
 80298c2:	4299      	cmp	r1, r3
 80298c4:	d004      	beq.n	80298d0 <cleanup_stdio+0x30>
 80298c6:	4620      	mov	r0, r4
 80298c8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80298cc:	f000 be3e 	b.w	802a54c <_fflush_r>
 80298d0:	bd10      	pop	{r4, pc}
 80298d2:	bf00      	nop
 80298d4:	20023e6c 	.word	0x20023e6c
 80298d8:	20023ed4 	.word	0x20023ed4
 80298dc:	20023f3c 	.word	0x20023f3c

080298e0 <global_stdio_init.part.0>:
 80298e0:	b510      	push	{r4, lr}
 80298e2:	4b0b      	ldr	r3, [pc, #44]	@ (8029910 <global_stdio_init.part.0+0x30>)
 80298e4:	4c0b      	ldr	r4, [pc, #44]	@ (8029914 <global_stdio_init.part.0+0x34>)
 80298e6:	4a0c      	ldr	r2, [pc, #48]	@ (8029918 <global_stdio_init.part.0+0x38>)
 80298e8:	601a      	str	r2, [r3, #0]
 80298ea:	4620      	mov	r0, r4
 80298ec:	2200      	movs	r2, #0
 80298ee:	2104      	movs	r1, #4
 80298f0:	f7ff ff94 	bl	802981c <std>
 80298f4:	f104 0068 	add.w	r0, r4, #104	@ 0x68
 80298f8:	2201      	movs	r2, #1
 80298fa:	2109      	movs	r1, #9
 80298fc:	f7ff ff8e 	bl	802981c <std>
 8029900:	f104 00d0 	add.w	r0, r4, #208	@ 0xd0
 8029904:	2202      	movs	r2, #2
 8029906:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 802990a:	2112      	movs	r1, #18
 802990c:	f7ff bf86 	b.w	802981c <std>
 8029910:	20023fa4 	.word	0x20023fa4
 8029914:	20023e6c 	.word	0x20023e6c
 8029918:	08029889 	.word	0x08029889

0802991c <__sfp_lock_acquire>:
 802991c:	4801      	ldr	r0, [pc, #4]	@ (8029924 <__sfp_lock_acquire+0x8>)
 802991e:	f000 b97e 	b.w	8029c1e <__retarget_lock_acquire_recursive>
 8029922:	bf00      	nop
 8029924:	20023fad 	.word	0x20023fad

08029928 <__sfp_lock_release>:
 8029928:	4801      	ldr	r0, [pc, #4]	@ (8029930 <__sfp_lock_release+0x8>)
 802992a:	f000 b979 	b.w	8029c20 <__retarget_lock_release_recursive>
 802992e:	bf00      	nop
 8029930:	20023fad 	.word	0x20023fad

08029934 <__sinit>:
 8029934:	b510      	push	{r4, lr}
 8029936:	4604      	mov	r4, r0
 8029938:	f7ff fff0 	bl	802991c <__sfp_lock_acquire>
 802993c:	6a23      	ldr	r3, [r4, #32]
 802993e:	b11b      	cbz	r3, 8029948 <__sinit+0x14>
 8029940:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8029944:	f7ff bff0 	b.w	8029928 <__sfp_lock_release>
 8029948:	4b04      	ldr	r3, [pc, #16]	@ (802995c <__sinit+0x28>)
 802994a:	6223      	str	r3, [r4, #32]
 802994c:	4b04      	ldr	r3, [pc, #16]	@ (8029960 <__sinit+0x2c>)
 802994e:	681b      	ldr	r3, [r3, #0]
 8029950:	2b00      	cmp	r3, #0
 8029952:	d1f5      	bne.n	8029940 <__sinit+0xc>
 8029954:	f7ff ffc4 	bl	80298e0 <global_stdio_init.part.0>
 8029958:	e7f2      	b.n	8029940 <__sinit+0xc>
 802995a:	bf00      	nop
 802995c:	080298a1 	.word	0x080298a1
 8029960:	20023fa4 	.word	0x20023fa4

08029964 <_fwalk_sglue>:
 8029964:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8029968:	4607      	mov	r7, r0
 802996a:	4688      	mov	r8, r1
 802996c:	4614      	mov	r4, r2
 802996e:	2600      	movs	r6, #0
 8029970:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
 8029974:	f1b9 0901 	subs.w	r9, r9, #1
 8029978:	d505      	bpl.n	8029986 <_fwalk_sglue+0x22>
 802997a:	6824      	ldr	r4, [r4, #0]
 802997c:	2c00      	cmp	r4, #0
 802997e:	d1f7      	bne.n	8029970 <_fwalk_sglue+0xc>
 8029980:	4630      	mov	r0, r6
 8029982:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8029986:	89ab      	ldrh	r3, [r5, #12]
 8029988:	2b01      	cmp	r3, #1
 802998a:	d907      	bls.n	802999c <_fwalk_sglue+0x38>
 802998c:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 8029990:	3301      	adds	r3, #1
 8029992:	d003      	beq.n	802999c <_fwalk_sglue+0x38>
 8029994:	4629      	mov	r1, r5
 8029996:	4638      	mov	r0, r7
 8029998:	47c0      	blx	r8
 802999a:	4306      	orrs	r6, r0
 802999c:	3568      	adds	r5, #104	@ 0x68
 802999e:	e7e9      	b.n	8029974 <_fwalk_sglue+0x10>

080299a0 <sniprintf>:
 80299a0:	b40c      	push	{r2, r3}
 80299a2:	b530      	push	{r4, r5, lr}
 80299a4:	4b18      	ldr	r3, [pc, #96]	@ (8029a08 <sniprintf+0x68>)
 80299a6:	1e0c      	subs	r4, r1, #0
 80299a8:	681d      	ldr	r5, [r3, #0]
 80299aa:	b09d      	sub	sp, #116	@ 0x74
 80299ac:	da08      	bge.n	80299c0 <sniprintf+0x20>
 80299ae:	238b      	movs	r3, #139	@ 0x8b
 80299b0:	602b      	str	r3, [r5, #0]
 80299b2:	f04f 30ff 	mov.w	r0, #4294967295
 80299b6:	b01d      	add	sp, #116	@ 0x74
 80299b8:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 80299bc:	b002      	add	sp, #8
 80299be:	4770      	bx	lr
 80299c0:	f44f 7302 	mov.w	r3, #520	@ 0x208
 80299c4:	f8ad 3014 	strh.w	r3, [sp, #20]
 80299c8:	f04f 0300 	mov.w	r3, #0
 80299cc:	931b      	str	r3, [sp, #108]	@ 0x6c
 80299ce:	bf14      	ite	ne
 80299d0:	f104 33ff 	addne.w	r3, r4, #4294967295
 80299d4:	4623      	moveq	r3, r4
 80299d6:	9304      	str	r3, [sp, #16]
 80299d8:	9307      	str	r3, [sp, #28]
 80299da:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 80299de:	9002      	str	r0, [sp, #8]
 80299e0:	9006      	str	r0, [sp, #24]
 80299e2:	f8ad 3016 	strh.w	r3, [sp, #22]
 80299e6:	9a20      	ldr	r2, [sp, #128]	@ 0x80
 80299e8:	ab21      	add	r3, sp, #132	@ 0x84
 80299ea:	a902      	add	r1, sp, #8
 80299ec:	4628      	mov	r0, r5
 80299ee:	9301      	str	r3, [sp, #4]
 80299f0:	f000 faa0 	bl	8029f34 <_svfiprintf_r>
 80299f4:	1c43      	adds	r3, r0, #1
 80299f6:	bfbc      	itt	lt
 80299f8:	238b      	movlt	r3, #139	@ 0x8b
 80299fa:	602b      	strlt	r3, [r5, #0]
 80299fc:	2c00      	cmp	r4, #0
 80299fe:	d0da      	beq.n	80299b6 <sniprintf+0x16>
 8029a00:	9b02      	ldr	r3, [sp, #8]
 8029a02:	2200      	movs	r2, #0
 8029a04:	701a      	strb	r2, [r3, #0]
 8029a06:	e7d6      	b.n	80299b6 <sniprintf+0x16>
 8029a08:	20000140 	.word	0x20000140

08029a0c <__sread>:
 8029a0c:	b510      	push	{r4, lr}
 8029a0e:	460c      	mov	r4, r1
 8029a10:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8029a14:	f000 f8b4 	bl	8029b80 <_read_r>
 8029a18:	2800      	cmp	r0, #0
 8029a1a:	bfab      	itete	ge
 8029a1c:	6d63      	ldrge	r3, [r4, #84]	@ 0x54
 8029a1e:	89a3      	ldrhlt	r3, [r4, #12]
 8029a20:	181b      	addge	r3, r3, r0
 8029a22:	f423 5380 	biclt.w	r3, r3, #4096	@ 0x1000
 8029a26:	bfac      	ite	ge
 8029a28:	6563      	strge	r3, [r4, #84]	@ 0x54
 8029a2a:	81a3      	strhlt	r3, [r4, #12]
 8029a2c:	bd10      	pop	{r4, pc}

08029a2e <__swrite>:
 8029a2e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8029a32:	461f      	mov	r7, r3
 8029a34:	898b      	ldrh	r3, [r1, #12]
 8029a36:	05db      	lsls	r3, r3, #23
 8029a38:	4605      	mov	r5, r0
 8029a3a:	460c      	mov	r4, r1
 8029a3c:	4616      	mov	r6, r2
 8029a3e:	d505      	bpl.n	8029a4c <__swrite+0x1e>
 8029a40:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8029a44:	2302      	movs	r3, #2
 8029a46:	2200      	movs	r2, #0
 8029a48:	f000 f888 	bl	8029b5c <_lseek_r>
 8029a4c:	89a3      	ldrh	r3, [r4, #12]
 8029a4e:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8029a52:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
 8029a56:	81a3      	strh	r3, [r4, #12]
 8029a58:	4632      	mov	r2, r6
 8029a5a:	463b      	mov	r3, r7
 8029a5c:	4628      	mov	r0, r5
 8029a5e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8029a62:	f000 b89f 	b.w	8029ba4 <_write_r>

08029a66 <__sseek>:
 8029a66:	b510      	push	{r4, lr}
 8029a68:	460c      	mov	r4, r1
 8029a6a:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8029a6e:	f000 f875 	bl	8029b5c <_lseek_r>
 8029a72:	1c43      	adds	r3, r0, #1
 8029a74:	89a3      	ldrh	r3, [r4, #12]
 8029a76:	bf15      	itete	ne
 8029a78:	6560      	strne	r0, [r4, #84]	@ 0x54
 8029a7a:	f423 5380 	biceq.w	r3, r3, #4096	@ 0x1000
 8029a7e:	f443 5380 	orrne.w	r3, r3, #4096	@ 0x1000
 8029a82:	81a3      	strheq	r3, [r4, #12]
 8029a84:	bf18      	it	ne
 8029a86:	81a3      	strhne	r3, [r4, #12]
 8029a88:	bd10      	pop	{r4, pc}

08029a8a <__sclose>:
 8029a8a:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8029a8e:	f000 b855 	b.w	8029b3c <_close_r>

08029a92 <_vsniprintf_r>:
 8029a92:	b530      	push	{r4, r5, lr}
 8029a94:	4614      	mov	r4, r2
 8029a96:	2c00      	cmp	r4, #0
 8029a98:	b09b      	sub	sp, #108	@ 0x6c
 8029a9a:	4605      	mov	r5, r0
 8029a9c:	461a      	mov	r2, r3
 8029a9e:	da05      	bge.n	8029aac <_vsniprintf_r+0x1a>
 8029aa0:	238b      	movs	r3, #139	@ 0x8b
 8029aa2:	6003      	str	r3, [r0, #0]
 8029aa4:	f04f 30ff 	mov.w	r0, #4294967295
 8029aa8:	b01b      	add	sp, #108	@ 0x6c
 8029aaa:	bd30      	pop	{r4, r5, pc}
 8029aac:	f44f 7302 	mov.w	r3, #520	@ 0x208
 8029ab0:	f8ad 300c 	strh.w	r3, [sp, #12]
 8029ab4:	f04f 0300 	mov.w	r3, #0
 8029ab8:	9319      	str	r3, [sp, #100]	@ 0x64
 8029aba:	bf14      	ite	ne
 8029abc:	f104 33ff 	addne.w	r3, r4, #4294967295
 8029ac0:	4623      	moveq	r3, r4
 8029ac2:	9302      	str	r3, [sp, #8]
 8029ac4:	9305      	str	r3, [sp, #20]
 8029ac6:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 8029aca:	9100      	str	r1, [sp, #0]
 8029acc:	9104      	str	r1, [sp, #16]
 8029ace:	f8ad 300e 	strh.w	r3, [sp, #14]
 8029ad2:	4669      	mov	r1, sp
 8029ad4:	9b1e      	ldr	r3, [sp, #120]	@ 0x78
 8029ad6:	f000 fa2d 	bl	8029f34 <_svfiprintf_r>
 8029ada:	1c43      	adds	r3, r0, #1
 8029adc:	bfbc      	itt	lt
 8029ade:	238b      	movlt	r3, #139	@ 0x8b
 8029ae0:	602b      	strlt	r3, [r5, #0]
 8029ae2:	2c00      	cmp	r4, #0
 8029ae4:	d0e0      	beq.n	8029aa8 <_vsniprintf_r+0x16>
 8029ae6:	9b00      	ldr	r3, [sp, #0]
 8029ae8:	2200      	movs	r2, #0
 8029aea:	701a      	strb	r2, [r3, #0]
 8029aec:	e7dc      	b.n	8029aa8 <_vsniprintf_r+0x16>
	...

08029af0 <vsniprintf>:
 8029af0:	b507      	push	{r0, r1, r2, lr}
 8029af2:	9300      	str	r3, [sp, #0]
 8029af4:	4613      	mov	r3, r2
 8029af6:	460a      	mov	r2, r1
 8029af8:	4601      	mov	r1, r0
 8029afa:	4803      	ldr	r0, [pc, #12]	@ (8029b08 <vsniprintf+0x18>)
 8029afc:	6800      	ldr	r0, [r0, #0]
 8029afe:	f7ff ffc8 	bl	8029a92 <_vsniprintf_r>
 8029b02:	b003      	add	sp, #12
 8029b04:	f85d fb04 	ldr.w	pc, [sp], #4
 8029b08:	20000140 	.word	0x20000140

08029b0c <memcmp>:
 8029b0c:	b510      	push	{r4, lr}
 8029b0e:	3901      	subs	r1, #1
 8029b10:	4402      	add	r2, r0
 8029b12:	4290      	cmp	r0, r2
 8029b14:	d101      	bne.n	8029b1a <memcmp+0xe>
 8029b16:	2000      	movs	r0, #0
 8029b18:	e005      	b.n	8029b26 <memcmp+0x1a>
 8029b1a:	7803      	ldrb	r3, [r0, #0]
 8029b1c:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 8029b20:	42a3      	cmp	r3, r4
 8029b22:	d001      	beq.n	8029b28 <memcmp+0x1c>
 8029b24:	1b18      	subs	r0, r3, r4
 8029b26:	bd10      	pop	{r4, pc}
 8029b28:	3001      	adds	r0, #1
 8029b2a:	e7f2      	b.n	8029b12 <memcmp+0x6>

08029b2c <memset>:
 8029b2c:	4402      	add	r2, r0
 8029b2e:	4603      	mov	r3, r0
 8029b30:	4293      	cmp	r3, r2
 8029b32:	d100      	bne.n	8029b36 <memset+0xa>
 8029b34:	4770      	bx	lr
 8029b36:	f803 1b01 	strb.w	r1, [r3], #1
 8029b3a:	e7f9      	b.n	8029b30 <memset+0x4>

08029b3c <_close_r>:
 8029b3c:	b538      	push	{r3, r4, r5, lr}
 8029b3e:	4d06      	ldr	r5, [pc, #24]	@ (8029b58 <_close_r+0x1c>)
 8029b40:	2300      	movs	r3, #0
 8029b42:	4604      	mov	r4, r0
 8029b44:	4608      	mov	r0, r1
 8029b46:	602b      	str	r3, [r5, #0]
 8029b48:	f7fe fd5a 	bl	8028600 <_close>
 8029b4c:	1c43      	adds	r3, r0, #1
 8029b4e:	d102      	bne.n	8029b56 <_close_r+0x1a>
 8029b50:	682b      	ldr	r3, [r5, #0]
 8029b52:	b103      	cbz	r3, 8029b56 <_close_r+0x1a>
 8029b54:	6023      	str	r3, [r4, #0]
 8029b56:	bd38      	pop	{r3, r4, r5, pc}
 8029b58:	20023fa8 	.word	0x20023fa8

08029b5c <_lseek_r>:
 8029b5c:	b538      	push	{r3, r4, r5, lr}
 8029b5e:	4d07      	ldr	r5, [pc, #28]	@ (8029b7c <_lseek_r+0x20>)
 8029b60:	4604      	mov	r4, r0
 8029b62:	4608      	mov	r0, r1
 8029b64:	4611      	mov	r1, r2
 8029b66:	2200      	movs	r2, #0
 8029b68:	602a      	str	r2, [r5, #0]
 8029b6a:	461a      	mov	r2, r3
 8029b6c:	f7fe fd54 	bl	8028618 <_lseek>
 8029b70:	1c43      	adds	r3, r0, #1
 8029b72:	d102      	bne.n	8029b7a <_lseek_r+0x1e>
 8029b74:	682b      	ldr	r3, [r5, #0]
 8029b76:	b103      	cbz	r3, 8029b7a <_lseek_r+0x1e>
 8029b78:	6023      	str	r3, [r4, #0]
 8029b7a:	bd38      	pop	{r3, r4, r5, pc}
 8029b7c:	20023fa8 	.word	0x20023fa8

08029b80 <_read_r>:
 8029b80:	b538      	push	{r3, r4, r5, lr}
 8029b82:	4d07      	ldr	r5, [pc, #28]	@ (8029ba0 <_read_r+0x20>)
 8029b84:	4604      	mov	r4, r0
 8029b86:	4608      	mov	r0, r1
 8029b88:	4611      	mov	r1, r2
 8029b8a:	2200      	movs	r2, #0
 8029b8c:	602a      	str	r2, [r5, #0]
 8029b8e:	461a      	mov	r2, r3
 8029b90:	f7fe fcfe 	bl	8028590 <_read>
 8029b94:	1c43      	adds	r3, r0, #1
 8029b96:	d102      	bne.n	8029b9e <_read_r+0x1e>
 8029b98:	682b      	ldr	r3, [r5, #0]
 8029b9a:	b103      	cbz	r3, 8029b9e <_read_r+0x1e>
 8029b9c:	6023      	str	r3, [r4, #0]
 8029b9e:	bd38      	pop	{r3, r4, r5, pc}
 8029ba0:	20023fa8 	.word	0x20023fa8

08029ba4 <_write_r>:
 8029ba4:	b538      	push	{r3, r4, r5, lr}
 8029ba6:	4d07      	ldr	r5, [pc, #28]	@ (8029bc4 <_write_r+0x20>)
 8029ba8:	4604      	mov	r4, r0
 8029baa:	4608      	mov	r0, r1
 8029bac:	4611      	mov	r1, r2
 8029bae:	2200      	movs	r2, #0
 8029bb0:	602a      	str	r2, [r5, #0]
 8029bb2:	461a      	mov	r2, r3
 8029bb4:	f7fe fcfa 	bl	80285ac <_write>
 8029bb8:	1c43      	adds	r3, r0, #1
 8029bba:	d102      	bne.n	8029bc2 <_write_r+0x1e>
 8029bbc:	682b      	ldr	r3, [r5, #0]
 8029bbe:	b103      	cbz	r3, 8029bc2 <_write_r+0x1e>
 8029bc0:	6023      	str	r3, [r4, #0]
 8029bc2:	bd38      	pop	{r3, r4, r5, pc}
 8029bc4:	20023fa8 	.word	0x20023fa8

08029bc8 <__errno>:
 8029bc8:	4b01      	ldr	r3, [pc, #4]	@ (8029bd0 <__errno+0x8>)
 8029bca:	6818      	ldr	r0, [r3, #0]
 8029bcc:	4770      	bx	lr
 8029bce:	bf00      	nop
 8029bd0:	20000140 	.word	0x20000140

08029bd4 <__libc_init_array>:
 8029bd4:	b570      	push	{r4, r5, r6, lr}
 8029bd6:	4d0d      	ldr	r5, [pc, #52]	@ (8029c0c <__libc_init_array+0x38>)
 8029bd8:	4c0d      	ldr	r4, [pc, #52]	@ (8029c10 <__libc_init_array+0x3c>)
 8029bda:	1b64      	subs	r4, r4, r5
 8029bdc:	10a4      	asrs	r4, r4, #2
 8029bde:	2600      	movs	r6, #0
 8029be0:	42a6      	cmp	r6, r4
 8029be2:	d109      	bne.n	8029bf8 <__libc_init_array+0x24>
 8029be4:	4d0b      	ldr	r5, [pc, #44]	@ (8029c14 <__libc_init_array+0x40>)
 8029be6:	4c0c      	ldr	r4, [pc, #48]	@ (8029c18 <__libc_init_array+0x44>)
 8029be8:	f001 f86a 	bl	802acc0 <_init>
 8029bec:	1b64      	subs	r4, r4, r5
 8029bee:	10a4      	asrs	r4, r4, #2
 8029bf0:	2600      	movs	r6, #0
 8029bf2:	42a6      	cmp	r6, r4
 8029bf4:	d105      	bne.n	8029c02 <__libc_init_array+0x2e>
 8029bf6:	bd70      	pop	{r4, r5, r6, pc}
 8029bf8:	f855 3b04 	ldr.w	r3, [r5], #4
 8029bfc:	4798      	blx	r3
 8029bfe:	3601      	adds	r6, #1
 8029c00:	e7ee      	b.n	8029be0 <__libc_init_array+0xc>
 8029c02:	f855 3b04 	ldr.w	r3, [r5], #4
 8029c06:	4798      	blx	r3
 8029c08:	3601      	adds	r6, #1
 8029c0a:	e7f2      	b.n	8029bf2 <__libc_init_array+0x1e>
 8029c0c:	080422b4 	.word	0x080422b4
 8029c10:	080422b4 	.word	0x080422b4
 8029c14:	080422b4 	.word	0x080422b4
 8029c18:	080422b8 	.word	0x080422b8

08029c1c <__retarget_lock_init_recursive>:
 8029c1c:	4770      	bx	lr

08029c1e <__retarget_lock_acquire_recursive>:
 8029c1e:	4770      	bx	lr

08029c20 <__retarget_lock_release_recursive>:
 8029c20:	4770      	bx	lr

08029c22 <memcpy>:
 8029c22:	440a      	add	r2, r1
 8029c24:	4291      	cmp	r1, r2
 8029c26:	f100 33ff 	add.w	r3, r0, #4294967295
 8029c2a:	d100      	bne.n	8029c2e <memcpy+0xc>
 8029c2c:	4770      	bx	lr
 8029c2e:	b510      	push	{r4, lr}
 8029c30:	f811 4b01 	ldrb.w	r4, [r1], #1
 8029c34:	f803 4f01 	strb.w	r4, [r3, #1]!
 8029c38:	4291      	cmp	r1, r2
 8029c3a:	d1f9      	bne.n	8029c30 <memcpy+0xe>
 8029c3c:	bd10      	pop	{r4, pc}
	...

08029c40 <__assert_func>:
 8029c40:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 8029c42:	4614      	mov	r4, r2
 8029c44:	461a      	mov	r2, r3
 8029c46:	4b09      	ldr	r3, [pc, #36]	@ (8029c6c <__assert_func+0x2c>)
 8029c48:	681b      	ldr	r3, [r3, #0]
 8029c4a:	4605      	mov	r5, r0
 8029c4c:	68d8      	ldr	r0, [r3, #12]
 8029c4e:	b14c      	cbz	r4, 8029c64 <__assert_func+0x24>
 8029c50:	4b07      	ldr	r3, [pc, #28]	@ (8029c70 <__assert_func+0x30>)
 8029c52:	9100      	str	r1, [sp, #0]
 8029c54:	e9cd 3401 	strd	r3, r4, [sp, #4]
 8029c58:	4906      	ldr	r1, [pc, #24]	@ (8029c74 <__assert_func+0x34>)
 8029c5a:	462b      	mov	r3, r5
 8029c5c:	f000 fc9e 	bl	802a59c <fiprintf>
 8029c60:	f000 fcd8 	bl	802a614 <abort>
 8029c64:	4b04      	ldr	r3, [pc, #16]	@ (8029c78 <__assert_func+0x38>)
 8029c66:	461c      	mov	r4, r3
 8029c68:	e7f3      	b.n	8029c52 <__assert_func+0x12>
 8029c6a:	bf00      	nop
 8029c6c:	20000140 	.word	0x20000140
 8029c70:	0804223b 	.word	0x0804223b
 8029c74:	08042248 	.word	0x08042248
 8029c78:	08042276 	.word	0x08042276

08029c7c <_free_r>:
 8029c7c:	b538      	push	{r3, r4, r5, lr}
 8029c7e:	4605      	mov	r5, r0
 8029c80:	2900      	cmp	r1, #0
 8029c82:	d041      	beq.n	8029d08 <_free_r+0x8c>
 8029c84:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8029c88:	1f0c      	subs	r4, r1, #4
 8029c8a:	2b00      	cmp	r3, #0
 8029c8c:	bfb8      	it	lt
 8029c8e:	18e4      	addlt	r4, r4, r3
 8029c90:	f000 f8e8 	bl	8029e64 <__malloc_lock>
 8029c94:	4a1d      	ldr	r2, [pc, #116]	@ (8029d0c <_free_r+0x90>)
 8029c96:	6813      	ldr	r3, [r2, #0]
 8029c98:	b933      	cbnz	r3, 8029ca8 <_free_r+0x2c>
 8029c9a:	6063      	str	r3, [r4, #4]
 8029c9c:	6014      	str	r4, [r2, #0]
 8029c9e:	4628      	mov	r0, r5
 8029ca0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8029ca4:	f000 b8e4 	b.w	8029e70 <__malloc_unlock>
 8029ca8:	42a3      	cmp	r3, r4
 8029caa:	d908      	bls.n	8029cbe <_free_r+0x42>
 8029cac:	6820      	ldr	r0, [r4, #0]
 8029cae:	1821      	adds	r1, r4, r0
 8029cb0:	428b      	cmp	r3, r1
 8029cb2:	bf01      	itttt	eq
 8029cb4:	6819      	ldreq	r1, [r3, #0]
 8029cb6:	685b      	ldreq	r3, [r3, #4]
 8029cb8:	1809      	addeq	r1, r1, r0
 8029cba:	6021      	streq	r1, [r4, #0]
 8029cbc:	e7ed      	b.n	8029c9a <_free_r+0x1e>
 8029cbe:	461a      	mov	r2, r3
 8029cc0:	685b      	ldr	r3, [r3, #4]
 8029cc2:	b10b      	cbz	r3, 8029cc8 <_free_r+0x4c>
 8029cc4:	42a3      	cmp	r3, r4
 8029cc6:	d9fa      	bls.n	8029cbe <_free_r+0x42>
 8029cc8:	6811      	ldr	r1, [r2, #0]
 8029cca:	1850      	adds	r0, r2, r1
 8029ccc:	42a0      	cmp	r0, r4
 8029cce:	d10b      	bne.n	8029ce8 <_free_r+0x6c>
 8029cd0:	6820      	ldr	r0, [r4, #0]
 8029cd2:	4401      	add	r1, r0
 8029cd4:	1850      	adds	r0, r2, r1
 8029cd6:	4283      	cmp	r3, r0
 8029cd8:	6011      	str	r1, [r2, #0]
 8029cda:	d1e0      	bne.n	8029c9e <_free_r+0x22>
 8029cdc:	6818      	ldr	r0, [r3, #0]
 8029cde:	685b      	ldr	r3, [r3, #4]
 8029ce0:	6053      	str	r3, [r2, #4]
 8029ce2:	4408      	add	r0, r1
 8029ce4:	6010      	str	r0, [r2, #0]
 8029ce6:	e7da      	b.n	8029c9e <_free_r+0x22>
 8029ce8:	d902      	bls.n	8029cf0 <_free_r+0x74>
 8029cea:	230c      	movs	r3, #12
 8029cec:	602b      	str	r3, [r5, #0]
 8029cee:	e7d6      	b.n	8029c9e <_free_r+0x22>
 8029cf0:	6820      	ldr	r0, [r4, #0]
 8029cf2:	1821      	adds	r1, r4, r0
 8029cf4:	428b      	cmp	r3, r1
 8029cf6:	bf04      	itt	eq
 8029cf8:	6819      	ldreq	r1, [r3, #0]
 8029cfa:	685b      	ldreq	r3, [r3, #4]
 8029cfc:	6063      	str	r3, [r4, #4]
 8029cfe:	bf04      	itt	eq
 8029d00:	1809      	addeq	r1, r1, r0
 8029d02:	6021      	streq	r1, [r4, #0]
 8029d04:	6054      	str	r4, [r2, #4]
 8029d06:	e7ca      	b.n	8029c9e <_free_r+0x22>
 8029d08:	bd38      	pop	{r3, r4, r5, pc}
 8029d0a:	bf00      	nop
 8029d0c:	20023fb4 	.word	0x20023fb4

08029d10 <malloc>:
 8029d10:	4b02      	ldr	r3, [pc, #8]	@ (8029d1c <malloc+0xc>)
 8029d12:	4601      	mov	r1, r0
 8029d14:	6818      	ldr	r0, [r3, #0]
 8029d16:	f000 b825 	b.w	8029d64 <_malloc_r>
 8029d1a:	bf00      	nop
 8029d1c:	20000140 	.word	0x20000140

08029d20 <sbrk_aligned>:
 8029d20:	b570      	push	{r4, r5, r6, lr}
 8029d22:	4e0f      	ldr	r6, [pc, #60]	@ (8029d60 <sbrk_aligned+0x40>)
 8029d24:	460c      	mov	r4, r1
 8029d26:	6831      	ldr	r1, [r6, #0]
 8029d28:	4605      	mov	r5, r0
 8029d2a:	b911      	cbnz	r1, 8029d32 <sbrk_aligned+0x12>
 8029d2c:	f000 fc62 	bl	802a5f4 <_sbrk_r>
 8029d30:	6030      	str	r0, [r6, #0]
 8029d32:	4621      	mov	r1, r4
 8029d34:	4628      	mov	r0, r5
 8029d36:	f000 fc5d 	bl	802a5f4 <_sbrk_r>
 8029d3a:	1c43      	adds	r3, r0, #1
 8029d3c:	d103      	bne.n	8029d46 <sbrk_aligned+0x26>
 8029d3e:	f04f 34ff 	mov.w	r4, #4294967295
 8029d42:	4620      	mov	r0, r4
 8029d44:	bd70      	pop	{r4, r5, r6, pc}
 8029d46:	1cc4      	adds	r4, r0, #3
 8029d48:	f024 0403 	bic.w	r4, r4, #3
 8029d4c:	42a0      	cmp	r0, r4
 8029d4e:	d0f8      	beq.n	8029d42 <sbrk_aligned+0x22>
 8029d50:	1a21      	subs	r1, r4, r0
 8029d52:	4628      	mov	r0, r5
 8029d54:	f000 fc4e 	bl	802a5f4 <_sbrk_r>
 8029d58:	3001      	adds	r0, #1
 8029d5a:	d1f2      	bne.n	8029d42 <sbrk_aligned+0x22>
 8029d5c:	e7ef      	b.n	8029d3e <sbrk_aligned+0x1e>
 8029d5e:	bf00      	nop
 8029d60:	20023fb0 	.word	0x20023fb0

08029d64 <_malloc_r>:
 8029d64:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8029d68:	1ccd      	adds	r5, r1, #3
 8029d6a:	f025 0503 	bic.w	r5, r5, #3
 8029d6e:	3508      	adds	r5, #8
 8029d70:	2d0c      	cmp	r5, #12
 8029d72:	bf38      	it	cc
 8029d74:	250c      	movcc	r5, #12
 8029d76:	2d00      	cmp	r5, #0
 8029d78:	4606      	mov	r6, r0
 8029d7a:	db01      	blt.n	8029d80 <_malloc_r+0x1c>
 8029d7c:	42a9      	cmp	r1, r5
 8029d7e:	d904      	bls.n	8029d8a <_malloc_r+0x26>
 8029d80:	230c      	movs	r3, #12
 8029d82:	6033      	str	r3, [r6, #0]
 8029d84:	2000      	movs	r0, #0
 8029d86:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8029d8a:	f8df 80d4 	ldr.w	r8, [pc, #212]	@ 8029e60 <_malloc_r+0xfc>
 8029d8e:	f000 f869 	bl	8029e64 <__malloc_lock>
 8029d92:	f8d8 3000 	ldr.w	r3, [r8]
 8029d96:	461c      	mov	r4, r3
 8029d98:	bb44      	cbnz	r4, 8029dec <_malloc_r+0x88>
 8029d9a:	4629      	mov	r1, r5
 8029d9c:	4630      	mov	r0, r6
 8029d9e:	f7ff ffbf 	bl	8029d20 <sbrk_aligned>
 8029da2:	1c43      	adds	r3, r0, #1
 8029da4:	4604      	mov	r4, r0
 8029da6:	d158      	bne.n	8029e5a <_malloc_r+0xf6>
 8029da8:	f8d8 4000 	ldr.w	r4, [r8]
 8029dac:	4627      	mov	r7, r4
 8029dae:	2f00      	cmp	r7, #0
 8029db0:	d143      	bne.n	8029e3a <_malloc_r+0xd6>
 8029db2:	2c00      	cmp	r4, #0
 8029db4:	d04b      	beq.n	8029e4e <_malloc_r+0xea>
 8029db6:	6823      	ldr	r3, [r4, #0]
 8029db8:	4639      	mov	r1, r7
 8029dba:	4630      	mov	r0, r6
 8029dbc:	eb04 0903 	add.w	r9, r4, r3
 8029dc0:	f000 fc18 	bl	802a5f4 <_sbrk_r>
 8029dc4:	4581      	cmp	r9, r0
 8029dc6:	d142      	bne.n	8029e4e <_malloc_r+0xea>
 8029dc8:	6821      	ldr	r1, [r4, #0]
 8029dca:	1a6d      	subs	r5, r5, r1
 8029dcc:	4629      	mov	r1, r5
 8029dce:	4630      	mov	r0, r6
 8029dd0:	f7ff ffa6 	bl	8029d20 <sbrk_aligned>
 8029dd4:	3001      	adds	r0, #1
 8029dd6:	d03a      	beq.n	8029e4e <_malloc_r+0xea>
 8029dd8:	6823      	ldr	r3, [r4, #0]
 8029dda:	442b      	add	r3, r5
 8029ddc:	6023      	str	r3, [r4, #0]
 8029dde:	f8d8 3000 	ldr.w	r3, [r8]
 8029de2:	685a      	ldr	r2, [r3, #4]
 8029de4:	bb62      	cbnz	r2, 8029e40 <_malloc_r+0xdc>
 8029de6:	f8c8 7000 	str.w	r7, [r8]
 8029dea:	e00f      	b.n	8029e0c <_malloc_r+0xa8>
 8029dec:	6822      	ldr	r2, [r4, #0]
 8029dee:	1b52      	subs	r2, r2, r5
 8029df0:	d420      	bmi.n	8029e34 <_malloc_r+0xd0>
 8029df2:	2a0b      	cmp	r2, #11
 8029df4:	d917      	bls.n	8029e26 <_malloc_r+0xc2>
 8029df6:	1961      	adds	r1, r4, r5
 8029df8:	42a3      	cmp	r3, r4
 8029dfa:	6025      	str	r5, [r4, #0]
 8029dfc:	bf18      	it	ne
 8029dfe:	6059      	strne	r1, [r3, #4]
 8029e00:	6863      	ldr	r3, [r4, #4]
 8029e02:	bf08      	it	eq
 8029e04:	f8c8 1000 	streq.w	r1, [r8]
 8029e08:	5162      	str	r2, [r4, r5]
 8029e0a:	604b      	str	r3, [r1, #4]
 8029e0c:	4630      	mov	r0, r6
 8029e0e:	f000 f82f 	bl	8029e70 <__malloc_unlock>
 8029e12:	f104 000b 	add.w	r0, r4, #11
 8029e16:	1d23      	adds	r3, r4, #4
 8029e18:	f020 0007 	bic.w	r0, r0, #7
 8029e1c:	1ac2      	subs	r2, r0, r3
 8029e1e:	bf1c      	itt	ne
 8029e20:	1a1b      	subne	r3, r3, r0
 8029e22:	50a3      	strne	r3, [r4, r2]
 8029e24:	e7af      	b.n	8029d86 <_malloc_r+0x22>
 8029e26:	6862      	ldr	r2, [r4, #4]
 8029e28:	42a3      	cmp	r3, r4
 8029e2a:	bf0c      	ite	eq
 8029e2c:	f8c8 2000 	streq.w	r2, [r8]
 8029e30:	605a      	strne	r2, [r3, #4]
 8029e32:	e7eb      	b.n	8029e0c <_malloc_r+0xa8>
 8029e34:	4623      	mov	r3, r4
 8029e36:	6864      	ldr	r4, [r4, #4]
 8029e38:	e7ae      	b.n	8029d98 <_malloc_r+0x34>
 8029e3a:	463c      	mov	r4, r7
 8029e3c:	687f      	ldr	r7, [r7, #4]
 8029e3e:	e7b6      	b.n	8029dae <_malloc_r+0x4a>
 8029e40:	461a      	mov	r2, r3
 8029e42:	685b      	ldr	r3, [r3, #4]
 8029e44:	42a3      	cmp	r3, r4
 8029e46:	d1fb      	bne.n	8029e40 <_malloc_r+0xdc>
 8029e48:	2300      	movs	r3, #0
 8029e4a:	6053      	str	r3, [r2, #4]
 8029e4c:	e7de      	b.n	8029e0c <_malloc_r+0xa8>
 8029e4e:	230c      	movs	r3, #12
 8029e50:	6033      	str	r3, [r6, #0]
 8029e52:	4630      	mov	r0, r6
 8029e54:	f000 f80c 	bl	8029e70 <__malloc_unlock>
 8029e58:	e794      	b.n	8029d84 <_malloc_r+0x20>
 8029e5a:	6005      	str	r5, [r0, #0]
 8029e5c:	e7d6      	b.n	8029e0c <_malloc_r+0xa8>
 8029e5e:	bf00      	nop
 8029e60:	20023fb4 	.word	0x20023fb4

08029e64 <__malloc_lock>:
 8029e64:	4801      	ldr	r0, [pc, #4]	@ (8029e6c <__malloc_lock+0x8>)
 8029e66:	f7ff beda 	b.w	8029c1e <__retarget_lock_acquire_recursive>
 8029e6a:	bf00      	nop
 8029e6c:	20023fac 	.word	0x20023fac

08029e70 <__malloc_unlock>:
 8029e70:	4801      	ldr	r0, [pc, #4]	@ (8029e78 <__malloc_unlock+0x8>)
 8029e72:	f7ff bed5 	b.w	8029c20 <__retarget_lock_release_recursive>
 8029e76:	bf00      	nop
 8029e78:	20023fac 	.word	0x20023fac

08029e7c <__ssputs_r>:
 8029e7c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8029e80:	688e      	ldr	r6, [r1, #8]
 8029e82:	461f      	mov	r7, r3
 8029e84:	42be      	cmp	r6, r7
 8029e86:	680b      	ldr	r3, [r1, #0]
 8029e88:	4682      	mov	sl, r0
 8029e8a:	460c      	mov	r4, r1
 8029e8c:	4690      	mov	r8, r2
 8029e8e:	d82d      	bhi.n	8029eec <__ssputs_r+0x70>
 8029e90:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
 8029e94:	f412 6f90 	tst.w	r2, #1152	@ 0x480
 8029e98:	d026      	beq.n	8029ee8 <__ssputs_r+0x6c>
 8029e9a:	6965      	ldr	r5, [r4, #20]
 8029e9c:	6909      	ldr	r1, [r1, #16]
 8029e9e:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 8029ea2:	eba3 0901 	sub.w	r9, r3, r1
 8029ea6:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
 8029eaa:	1c7b      	adds	r3, r7, #1
 8029eac:	444b      	add	r3, r9
 8029eae:	106d      	asrs	r5, r5, #1
 8029eb0:	429d      	cmp	r5, r3
 8029eb2:	bf38      	it	cc
 8029eb4:	461d      	movcc	r5, r3
 8029eb6:	0553      	lsls	r3, r2, #21
 8029eb8:	d527      	bpl.n	8029f0a <__ssputs_r+0x8e>
 8029eba:	4629      	mov	r1, r5
 8029ebc:	f7ff ff52 	bl	8029d64 <_malloc_r>
 8029ec0:	4606      	mov	r6, r0
 8029ec2:	b360      	cbz	r0, 8029f1e <__ssputs_r+0xa2>
 8029ec4:	6921      	ldr	r1, [r4, #16]
 8029ec6:	464a      	mov	r2, r9
 8029ec8:	f7ff feab 	bl	8029c22 <memcpy>
 8029ecc:	89a3      	ldrh	r3, [r4, #12]
 8029ece:	f423 6390 	bic.w	r3, r3, #1152	@ 0x480
 8029ed2:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8029ed6:	81a3      	strh	r3, [r4, #12]
 8029ed8:	6126      	str	r6, [r4, #16]
 8029eda:	6165      	str	r5, [r4, #20]
 8029edc:	444e      	add	r6, r9
 8029ede:	eba5 0509 	sub.w	r5, r5, r9
 8029ee2:	6026      	str	r6, [r4, #0]
 8029ee4:	60a5      	str	r5, [r4, #8]
 8029ee6:	463e      	mov	r6, r7
 8029ee8:	42be      	cmp	r6, r7
 8029eea:	d900      	bls.n	8029eee <__ssputs_r+0x72>
 8029eec:	463e      	mov	r6, r7
 8029eee:	6820      	ldr	r0, [r4, #0]
 8029ef0:	4632      	mov	r2, r6
 8029ef2:	4641      	mov	r1, r8
 8029ef4:	f000 fb64 	bl	802a5c0 <memmove>
 8029ef8:	68a3      	ldr	r3, [r4, #8]
 8029efa:	1b9b      	subs	r3, r3, r6
 8029efc:	60a3      	str	r3, [r4, #8]
 8029efe:	6823      	ldr	r3, [r4, #0]
 8029f00:	4433      	add	r3, r6
 8029f02:	6023      	str	r3, [r4, #0]
 8029f04:	2000      	movs	r0, #0
 8029f06:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8029f0a:	462a      	mov	r2, r5
 8029f0c:	f000 fb89 	bl	802a622 <_realloc_r>
 8029f10:	4606      	mov	r6, r0
 8029f12:	2800      	cmp	r0, #0
 8029f14:	d1e0      	bne.n	8029ed8 <__ssputs_r+0x5c>
 8029f16:	6921      	ldr	r1, [r4, #16]
 8029f18:	4650      	mov	r0, sl
 8029f1a:	f7ff feaf 	bl	8029c7c <_free_r>
 8029f1e:	230c      	movs	r3, #12
 8029f20:	f8ca 3000 	str.w	r3, [sl]
 8029f24:	89a3      	ldrh	r3, [r4, #12]
 8029f26:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8029f2a:	81a3      	strh	r3, [r4, #12]
 8029f2c:	f04f 30ff 	mov.w	r0, #4294967295
 8029f30:	e7e9      	b.n	8029f06 <__ssputs_r+0x8a>
	...

08029f34 <_svfiprintf_r>:
 8029f34:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8029f38:	4698      	mov	r8, r3
 8029f3a:	898b      	ldrh	r3, [r1, #12]
 8029f3c:	061b      	lsls	r3, r3, #24
 8029f3e:	b09d      	sub	sp, #116	@ 0x74
 8029f40:	4607      	mov	r7, r0
 8029f42:	460d      	mov	r5, r1
 8029f44:	4614      	mov	r4, r2
 8029f46:	d510      	bpl.n	8029f6a <_svfiprintf_r+0x36>
 8029f48:	690b      	ldr	r3, [r1, #16]
 8029f4a:	b973      	cbnz	r3, 8029f6a <_svfiprintf_r+0x36>
 8029f4c:	2140      	movs	r1, #64	@ 0x40
 8029f4e:	f7ff ff09 	bl	8029d64 <_malloc_r>
 8029f52:	6028      	str	r0, [r5, #0]
 8029f54:	6128      	str	r0, [r5, #16]
 8029f56:	b930      	cbnz	r0, 8029f66 <_svfiprintf_r+0x32>
 8029f58:	230c      	movs	r3, #12
 8029f5a:	603b      	str	r3, [r7, #0]
 8029f5c:	f04f 30ff 	mov.w	r0, #4294967295
 8029f60:	b01d      	add	sp, #116	@ 0x74
 8029f62:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8029f66:	2340      	movs	r3, #64	@ 0x40
 8029f68:	616b      	str	r3, [r5, #20]
 8029f6a:	2300      	movs	r3, #0
 8029f6c:	9309      	str	r3, [sp, #36]	@ 0x24
 8029f6e:	2320      	movs	r3, #32
 8029f70:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
 8029f74:	f8cd 800c 	str.w	r8, [sp, #12]
 8029f78:	2330      	movs	r3, #48	@ 0x30
 8029f7a:	f8df 819c 	ldr.w	r8, [pc, #412]	@ 802a118 <_svfiprintf_r+0x1e4>
 8029f7e:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
 8029f82:	f04f 0901 	mov.w	r9, #1
 8029f86:	4623      	mov	r3, r4
 8029f88:	469a      	mov	sl, r3
 8029f8a:	f813 2b01 	ldrb.w	r2, [r3], #1
 8029f8e:	b10a      	cbz	r2, 8029f94 <_svfiprintf_r+0x60>
 8029f90:	2a25      	cmp	r2, #37	@ 0x25
 8029f92:	d1f9      	bne.n	8029f88 <_svfiprintf_r+0x54>
 8029f94:	ebba 0b04 	subs.w	fp, sl, r4
 8029f98:	d00b      	beq.n	8029fb2 <_svfiprintf_r+0x7e>
 8029f9a:	465b      	mov	r3, fp
 8029f9c:	4622      	mov	r2, r4
 8029f9e:	4629      	mov	r1, r5
 8029fa0:	4638      	mov	r0, r7
 8029fa2:	f7ff ff6b 	bl	8029e7c <__ssputs_r>
 8029fa6:	3001      	adds	r0, #1
 8029fa8:	f000 80a7 	beq.w	802a0fa <_svfiprintf_r+0x1c6>
 8029fac:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 8029fae:	445a      	add	r2, fp
 8029fb0:	9209      	str	r2, [sp, #36]	@ 0x24
 8029fb2:	f89a 3000 	ldrb.w	r3, [sl]
 8029fb6:	2b00      	cmp	r3, #0
 8029fb8:	f000 809f 	beq.w	802a0fa <_svfiprintf_r+0x1c6>
 8029fbc:	2300      	movs	r3, #0
 8029fbe:	f04f 32ff 	mov.w	r2, #4294967295
 8029fc2:	e9cd 2305 	strd	r2, r3, [sp, #20]
 8029fc6:	f10a 0a01 	add.w	sl, sl, #1
 8029fca:	9304      	str	r3, [sp, #16]
 8029fcc:	9307      	str	r3, [sp, #28]
 8029fce:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
 8029fd2:	931a      	str	r3, [sp, #104]	@ 0x68
 8029fd4:	4654      	mov	r4, sl
 8029fd6:	2205      	movs	r2, #5
 8029fd8:	f814 1b01 	ldrb.w	r1, [r4], #1
 8029fdc:	484e      	ldr	r0, [pc, #312]	@ (802a118 <_svfiprintf_r+0x1e4>)
 8029fde:	f7f6 f987 	bl	80202f0 <memchr>
 8029fe2:	9a04      	ldr	r2, [sp, #16]
 8029fe4:	b9d8      	cbnz	r0, 802a01e <_svfiprintf_r+0xea>
 8029fe6:	06d0      	lsls	r0, r2, #27
 8029fe8:	bf44      	itt	mi
 8029fea:	2320      	movmi	r3, #32
 8029fec:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 8029ff0:	0711      	lsls	r1, r2, #28
 8029ff2:	bf44      	itt	mi
 8029ff4:	232b      	movmi	r3, #43	@ 0x2b
 8029ff6:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 8029ffa:	f89a 3000 	ldrb.w	r3, [sl]
 8029ffe:	2b2a      	cmp	r3, #42	@ 0x2a
 802a000:	d015      	beq.n	802a02e <_svfiprintf_r+0xfa>
 802a002:	9a07      	ldr	r2, [sp, #28]
 802a004:	4654      	mov	r4, sl
 802a006:	2000      	movs	r0, #0
 802a008:	f04f 0c0a 	mov.w	ip, #10
 802a00c:	4621      	mov	r1, r4
 802a00e:	f811 3b01 	ldrb.w	r3, [r1], #1
 802a012:	3b30      	subs	r3, #48	@ 0x30
 802a014:	2b09      	cmp	r3, #9
 802a016:	d94b      	bls.n	802a0b0 <_svfiprintf_r+0x17c>
 802a018:	b1b0      	cbz	r0, 802a048 <_svfiprintf_r+0x114>
 802a01a:	9207      	str	r2, [sp, #28]
 802a01c:	e014      	b.n	802a048 <_svfiprintf_r+0x114>
 802a01e:	eba0 0308 	sub.w	r3, r0, r8
 802a022:	fa09 f303 	lsl.w	r3, r9, r3
 802a026:	4313      	orrs	r3, r2
 802a028:	9304      	str	r3, [sp, #16]
 802a02a:	46a2      	mov	sl, r4
 802a02c:	e7d2      	b.n	8029fd4 <_svfiprintf_r+0xa0>
 802a02e:	9b03      	ldr	r3, [sp, #12]
 802a030:	1d19      	adds	r1, r3, #4
 802a032:	681b      	ldr	r3, [r3, #0]
 802a034:	9103      	str	r1, [sp, #12]
 802a036:	2b00      	cmp	r3, #0
 802a038:	bfbb      	ittet	lt
 802a03a:	425b      	neglt	r3, r3
 802a03c:	f042 0202 	orrlt.w	r2, r2, #2
 802a040:	9307      	strge	r3, [sp, #28]
 802a042:	9307      	strlt	r3, [sp, #28]
 802a044:	bfb8      	it	lt
 802a046:	9204      	strlt	r2, [sp, #16]
 802a048:	7823      	ldrb	r3, [r4, #0]
 802a04a:	2b2e      	cmp	r3, #46	@ 0x2e
 802a04c:	d10a      	bne.n	802a064 <_svfiprintf_r+0x130>
 802a04e:	7863      	ldrb	r3, [r4, #1]
 802a050:	2b2a      	cmp	r3, #42	@ 0x2a
 802a052:	d132      	bne.n	802a0ba <_svfiprintf_r+0x186>
 802a054:	9b03      	ldr	r3, [sp, #12]
 802a056:	1d1a      	adds	r2, r3, #4
 802a058:	681b      	ldr	r3, [r3, #0]
 802a05a:	9203      	str	r2, [sp, #12]
 802a05c:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
 802a060:	3402      	adds	r4, #2
 802a062:	9305      	str	r3, [sp, #20]
 802a064:	f8df a0c0 	ldr.w	sl, [pc, #192]	@ 802a128 <_svfiprintf_r+0x1f4>
 802a068:	7821      	ldrb	r1, [r4, #0]
 802a06a:	2203      	movs	r2, #3
 802a06c:	4650      	mov	r0, sl
 802a06e:	f7f6 f93f 	bl	80202f0 <memchr>
 802a072:	b138      	cbz	r0, 802a084 <_svfiprintf_r+0x150>
 802a074:	9b04      	ldr	r3, [sp, #16]
 802a076:	eba0 000a 	sub.w	r0, r0, sl
 802a07a:	2240      	movs	r2, #64	@ 0x40
 802a07c:	4082      	lsls	r2, r0
 802a07e:	4313      	orrs	r3, r2
 802a080:	3401      	adds	r4, #1
 802a082:	9304      	str	r3, [sp, #16]
 802a084:	f814 1b01 	ldrb.w	r1, [r4], #1
 802a088:	4824      	ldr	r0, [pc, #144]	@ (802a11c <_svfiprintf_r+0x1e8>)
 802a08a:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
 802a08e:	2206      	movs	r2, #6
 802a090:	f7f6 f92e 	bl	80202f0 <memchr>
 802a094:	2800      	cmp	r0, #0
 802a096:	d036      	beq.n	802a106 <_svfiprintf_r+0x1d2>
 802a098:	4b21      	ldr	r3, [pc, #132]	@ (802a120 <_svfiprintf_r+0x1ec>)
 802a09a:	bb1b      	cbnz	r3, 802a0e4 <_svfiprintf_r+0x1b0>
 802a09c:	9b03      	ldr	r3, [sp, #12]
 802a09e:	3307      	adds	r3, #7
 802a0a0:	f023 0307 	bic.w	r3, r3, #7
 802a0a4:	3308      	adds	r3, #8
 802a0a6:	9303      	str	r3, [sp, #12]
 802a0a8:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 802a0aa:	4433      	add	r3, r6
 802a0ac:	9309      	str	r3, [sp, #36]	@ 0x24
 802a0ae:	e76a      	b.n	8029f86 <_svfiprintf_r+0x52>
 802a0b0:	fb0c 3202 	mla	r2, ip, r2, r3
 802a0b4:	460c      	mov	r4, r1
 802a0b6:	2001      	movs	r0, #1
 802a0b8:	e7a8      	b.n	802a00c <_svfiprintf_r+0xd8>
 802a0ba:	2300      	movs	r3, #0
 802a0bc:	3401      	adds	r4, #1
 802a0be:	9305      	str	r3, [sp, #20]
 802a0c0:	4619      	mov	r1, r3
 802a0c2:	f04f 0c0a 	mov.w	ip, #10
 802a0c6:	4620      	mov	r0, r4
 802a0c8:	f810 2b01 	ldrb.w	r2, [r0], #1
 802a0cc:	3a30      	subs	r2, #48	@ 0x30
 802a0ce:	2a09      	cmp	r2, #9
 802a0d0:	d903      	bls.n	802a0da <_svfiprintf_r+0x1a6>
 802a0d2:	2b00      	cmp	r3, #0
 802a0d4:	d0c6      	beq.n	802a064 <_svfiprintf_r+0x130>
 802a0d6:	9105      	str	r1, [sp, #20]
 802a0d8:	e7c4      	b.n	802a064 <_svfiprintf_r+0x130>
 802a0da:	fb0c 2101 	mla	r1, ip, r1, r2
 802a0de:	4604      	mov	r4, r0
 802a0e0:	2301      	movs	r3, #1
 802a0e2:	e7f0      	b.n	802a0c6 <_svfiprintf_r+0x192>
 802a0e4:	ab03      	add	r3, sp, #12
 802a0e6:	9300      	str	r3, [sp, #0]
 802a0e8:	462a      	mov	r2, r5
 802a0ea:	4b0e      	ldr	r3, [pc, #56]	@ (802a124 <_svfiprintf_r+0x1f0>)
 802a0ec:	a904      	add	r1, sp, #16
 802a0ee:	4638      	mov	r0, r7
 802a0f0:	f3af 8000 	nop.w
 802a0f4:	1c42      	adds	r2, r0, #1
 802a0f6:	4606      	mov	r6, r0
 802a0f8:	d1d6      	bne.n	802a0a8 <_svfiprintf_r+0x174>
 802a0fa:	89ab      	ldrh	r3, [r5, #12]
 802a0fc:	065b      	lsls	r3, r3, #25
 802a0fe:	f53f af2d 	bmi.w	8029f5c <_svfiprintf_r+0x28>
 802a102:	9809      	ldr	r0, [sp, #36]	@ 0x24
 802a104:	e72c      	b.n	8029f60 <_svfiprintf_r+0x2c>
 802a106:	ab03      	add	r3, sp, #12
 802a108:	9300      	str	r3, [sp, #0]
 802a10a:	462a      	mov	r2, r5
 802a10c:	4b05      	ldr	r3, [pc, #20]	@ (802a124 <_svfiprintf_r+0x1f0>)
 802a10e:	a904      	add	r1, sp, #16
 802a110:	4638      	mov	r0, r7
 802a112:	f000 f879 	bl	802a208 <_printf_i>
 802a116:	e7ed      	b.n	802a0f4 <_svfiprintf_r+0x1c0>
 802a118:	08042277 	.word	0x08042277
 802a11c:	08042281 	.word	0x08042281
 802a120:	00000000 	.word	0x00000000
 802a124:	08029e7d 	.word	0x08029e7d
 802a128:	0804227d 	.word	0x0804227d

0802a12c <_printf_common>:
 802a12c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 802a130:	4616      	mov	r6, r2
 802a132:	4698      	mov	r8, r3
 802a134:	688a      	ldr	r2, [r1, #8]
 802a136:	690b      	ldr	r3, [r1, #16]
 802a138:	f8dd 9020 	ldr.w	r9, [sp, #32]
 802a13c:	4293      	cmp	r3, r2
 802a13e:	bfb8      	it	lt
 802a140:	4613      	movlt	r3, r2
 802a142:	6033      	str	r3, [r6, #0]
 802a144:	f891 2043 	ldrb.w	r2, [r1, #67]	@ 0x43
 802a148:	4607      	mov	r7, r0
 802a14a:	460c      	mov	r4, r1
 802a14c:	b10a      	cbz	r2, 802a152 <_printf_common+0x26>
 802a14e:	3301      	adds	r3, #1
 802a150:	6033      	str	r3, [r6, #0]
 802a152:	6823      	ldr	r3, [r4, #0]
 802a154:	0699      	lsls	r1, r3, #26
 802a156:	bf42      	ittt	mi
 802a158:	6833      	ldrmi	r3, [r6, #0]
 802a15a:	3302      	addmi	r3, #2
 802a15c:	6033      	strmi	r3, [r6, #0]
 802a15e:	6825      	ldr	r5, [r4, #0]
 802a160:	f015 0506 	ands.w	r5, r5, #6
 802a164:	d106      	bne.n	802a174 <_printf_common+0x48>
 802a166:	f104 0a19 	add.w	sl, r4, #25
 802a16a:	68e3      	ldr	r3, [r4, #12]
 802a16c:	6832      	ldr	r2, [r6, #0]
 802a16e:	1a9b      	subs	r3, r3, r2
 802a170:	42ab      	cmp	r3, r5
 802a172:	dc26      	bgt.n	802a1c2 <_printf_common+0x96>
 802a174:	f894 3043 	ldrb.w	r3, [r4, #67]	@ 0x43
 802a178:	6822      	ldr	r2, [r4, #0]
 802a17a:	3b00      	subs	r3, #0
 802a17c:	bf18      	it	ne
 802a17e:	2301      	movne	r3, #1
 802a180:	0692      	lsls	r2, r2, #26
 802a182:	d42b      	bmi.n	802a1dc <_printf_common+0xb0>
 802a184:	f104 0243 	add.w	r2, r4, #67	@ 0x43
 802a188:	4641      	mov	r1, r8
 802a18a:	4638      	mov	r0, r7
 802a18c:	47c8      	blx	r9
 802a18e:	3001      	adds	r0, #1
 802a190:	d01e      	beq.n	802a1d0 <_printf_common+0xa4>
 802a192:	6823      	ldr	r3, [r4, #0]
 802a194:	6922      	ldr	r2, [r4, #16]
 802a196:	f003 0306 	and.w	r3, r3, #6
 802a19a:	2b04      	cmp	r3, #4
 802a19c:	bf02      	ittt	eq
 802a19e:	68e5      	ldreq	r5, [r4, #12]
 802a1a0:	6833      	ldreq	r3, [r6, #0]
 802a1a2:	1aed      	subeq	r5, r5, r3
 802a1a4:	68a3      	ldr	r3, [r4, #8]
 802a1a6:	bf0c      	ite	eq
 802a1a8:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 802a1ac:	2500      	movne	r5, #0
 802a1ae:	4293      	cmp	r3, r2
 802a1b0:	bfc4      	itt	gt
 802a1b2:	1a9b      	subgt	r3, r3, r2
 802a1b4:	18ed      	addgt	r5, r5, r3
 802a1b6:	2600      	movs	r6, #0
 802a1b8:	341a      	adds	r4, #26
 802a1ba:	42b5      	cmp	r5, r6
 802a1bc:	d11a      	bne.n	802a1f4 <_printf_common+0xc8>
 802a1be:	2000      	movs	r0, #0
 802a1c0:	e008      	b.n	802a1d4 <_printf_common+0xa8>
 802a1c2:	2301      	movs	r3, #1
 802a1c4:	4652      	mov	r2, sl
 802a1c6:	4641      	mov	r1, r8
 802a1c8:	4638      	mov	r0, r7
 802a1ca:	47c8      	blx	r9
 802a1cc:	3001      	adds	r0, #1
 802a1ce:	d103      	bne.n	802a1d8 <_printf_common+0xac>
 802a1d0:	f04f 30ff 	mov.w	r0, #4294967295
 802a1d4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 802a1d8:	3501      	adds	r5, #1
 802a1da:	e7c6      	b.n	802a16a <_printf_common+0x3e>
 802a1dc:	18e1      	adds	r1, r4, r3
 802a1de:	1c5a      	adds	r2, r3, #1
 802a1e0:	2030      	movs	r0, #48	@ 0x30
 802a1e2:	f881 0043 	strb.w	r0, [r1, #67]	@ 0x43
 802a1e6:	4422      	add	r2, r4
 802a1e8:	f894 1045 	ldrb.w	r1, [r4, #69]	@ 0x45
 802a1ec:	f882 1043 	strb.w	r1, [r2, #67]	@ 0x43
 802a1f0:	3302      	adds	r3, #2
 802a1f2:	e7c7      	b.n	802a184 <_printf_common+0x58>
 802a1f4:	2301      	movs	r3, #1
 802a1f6:	4622      	mov	r2, r4
 802a1f8:	4641      	mov	r1, r8
 802a1fa:	4638      	mov	r0, r7
 802a1fc:	47c8      	blx	r9
 802a1fe:	3001      	adds	r0, #1
 802a200:	d0e6      	beq.n	802a1d0 <_printf_common+0xa4>
 802a202:	3601      	adds	r6, #1
 802a204:	e7d9      	b.n	802a1ba <_printf_common+0x8e>
	...

0802a208 <_printf_i>:
 802a208:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 802a20c:	7e0f      	ldrb	r7, [r1, #24]
 802a20e:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
 802a210:	2f78      	cmp	r7, #120	@ 0x78
 802a212:	4691      	mov	r9, r2
 802a214:	4680      	mov	r8, r0
 802a216:	460c      	mov	r4, r1
 802a218:	469a      	mov	sl, r3
 802a21a:	f101 0243 	add.w	r2, r1, #67	@ 0x43
 802a21e:	d807      	bhi.n	802a230 <_printf_i+0x28>
 802a220:	2f62      	cmp	r7, #98	@ 0x62
 802a222:	d80a      	bhi.n	802a23a <_printf_i+0x32>
 802a224:	2f00      	cmp	r7, #0
 802a226:	f000 80d1 	beq.w	802a3cc <_printf_i+0x1c4>
 802a22a:	2f58      	cmp	r7, #88	@ 0x58
 802a22c:	f000 80b8 	beq.w	802a3a0 <_printf_i+0x198>
 802a230:	f104 0642 	add.w	r6, r4, #66	@ 0x42
 802a234:	f884 7042 	strb.w	r7, [r4, #66]	@ 0x42
 802a238:	e03a      	b.n	802a2b0 <_printf_i+0xa8>
 802a23a:	f1a7 0363 	sub.w	r3, r7, #99	@ 0x63
 802a23e:	2b15      	cmp	r3, #21
 802a240:	d8f6      	bhi.n	802a230 <_printf_i+0x28>
 802a242:	a101      	add	r1, pc, #4	@ (adr r1, 802a248 <_printf_i+0x40>)
 802a244:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 802a248:	0802a2a1 	.word	0x0802a2a1
 802a24c:	0802a2b5 	.word	0x0802a2b5
 802a250:	0802a231 	.word	0x0802a231
 802a254:	0802a231 	.word	0x0802a231
 802a258:	0802a231 	.word	0x0802a231
 802a25c:	0802a231 	.word	0x0802a231
 802a260:	0802a2b5 	.word	0x0802a2b5
 802a264:	0802a231 	.word	0x0802a231
 802a268:	0802a231 	.word	0x0802a231
 802a26c:	0802a231 	.word	0x0802a231
 802a270:	0802a231 	.word	0x0802a231
 802a274:	0802a3b3 	.word	0x0802a3b3
 802a278:	0802a2df 	.word	0x0802a2df
 802a27c:	0802a36d 	.word	0x0802a36d
 802a280:	0802a231 	.word	0x0802a231
 802a284:	0802a231 	.word	0x0802a231
 802a288:	0802a3d5 	.word	0x0802a3d5
 802a28c:	0802a231 	.word	0x0802a231
 802a290:	0802a2df 	.word	0x0802a2df
 802a294:	0802a231 	.word	0x0802a231
 802a298:	0802a231 	.word	0x0802a231
 802a29c:	0802a375 	.word	0x0802a375
 802a2a0:	6833      	ldr	r3, [r6, #0]
 802a2a2:	1d1a      	adds	r2, r3, #4
 802a2a4:	681b      	ldr	r3, [r3, #0]
 802a2a6:	6032      	str	r2, [r6, #0]
 802a2a8:	f104 0642 	add.w	r6, r4, #66	@ 0x42
 802a2ac:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
 802a2b0:	2301      	movs	r3, #1
 802a2b2:	e09c      	b.n	802a3ee <_printf_i+0x1e6>
 802a2b4:	6833      	ldr	r3, [r6, #0]
 802a2b6:	6820      	ldr	r0, [r4, #0]
 802a2b8:	1d19      	adds	r1, r3, #4
 802a2ba:	6031      	str	r1, [r6, #0]
 802a2bc:	0606      	lsls	r6, r0, #24
 802a2be:	d501      	bpl.n	802a2c4 <_printf_i+0xbc>
 802a2c0:	681d      	ldr	r5, [r3, #0]
 802a2c2:	e003      	b.n	802a2cc <_printf_i+0xc4>
 802a2c4:	0645      	lsls	r5, r0, #25
 802a2c6:	d5fb      	bpl.n	802a2c0 <_printf_i+0xb8>
 802a2c8:	f9b3 5000 	ldrsh.w	r5, [r3]
 802a2cc:	2d00      	cmp	r5, #0
 802a2ce:	da03      	bge.n	802a2d8 <_printf_i+0xd0>
 802a2d0:	232d      	movs	r3, #45	@ 0x2d
 802a2d2:	426d      	negs	r5, r5
 802a2d4:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 802a2d8:	4858      	ldr	r0, [pc, #352]	@ (802a43c <_printf_i+0x234>)
 802a2da:	230a      	movs	r3, #10
 802a2dc:	e011      	b.n	802a302 <_printf_i+0xfa>
 802a2de:	6821      	ldr	r1, [r4, #0]
 802a2e0:	6833      	ldr	r3, [r6, #0]
 802a2e2:	0608      	lsls	r0, r1, #24
 802a2e4:	f853 5b04 	ldr.w	r5, [r3], #4
 802a2e8:	d402      	bmi.n	802a2f0 <_printf_i+0xe8>
 802a2ea:	0649      	lsls	r1, r1, #25
 802a2ec:	bf48      	it	mi
 802a2ee:	b2ad      	uxthmi	r5, r5
 802a2f0:	2f6f      	cmp	r7, #111	@ 0x6f
 802a2f2:	4852      	ldr	r0, [pc, #328]	@ (802a43c <_printf_i+0x234>)
 802a2f4:	6033      	str	r3, [r6, #0]
 802a2f6:	bf14      	ite	ne
 802a2f8:	230a      	movne	r3, #10
 802a2fa:	2308      	moveq	r3, #8
 802a2fc:	2100      	movs	r1, #0
 802a2fe:	f884 1043 	strb.w	r1, [r4, #67]	@ 0x43
 802a302:	6866      	ldr	r6, [r4, #4]
 802a304:	60a6      	str	r6, [r4, #8]
 802a306:	2e00      	cmp	r6, #0
 802a308:	db05      	blt.n	802a316 <_printf_i+0x10e>
 802a30a:	6821      	ldr	r1, [r4, #0]
 802a30c:	432e      	orrs	r6, r5
 802a30e:	f021 0104 	bic.w	r1, r1, #4
 802a312:	6021      	str	r1, [r4, #0]
 802a314:	d04b      	beq.n	802a3ae <_printf_i+0x1a6>
 802a316:	4616      	mov	r6, r2
 802a318:	fbb5 f1f3 	udiv	r1, r5, r3
 802a31c:	fb03 5711 	mls	r7, r3, r1, r5
 802a320:	5dc7      	ldrb	r7, [r0, r7]
 802a322:	f806 7d01 	strb.w	r7, [r6, #-1]!
 802a326:	462f      	mov	r7, r5
 802a328:	42bb      	cmp	r3, r7
 802a32a:	460d      	mov	r5, r1
 802a32c:	d9f4      	bls.n	802a318 <_printf_i+0x110>
 802a32e:	2b08      	cmp	r3, #8
 802a330:	d10b      	bne.n	802a34a <_printf_i+0x142>
 802a332:	6823      	ldr	r3, [r4, #0]
 802a334:	07df      	lsls	r7, r3, #31
 802a336:	d508      	bpl.n	802a34a <_printf_i+0x142>
 802a338:	6923      	ldr	r3, [r4, #16]
 802a33a:	6861      	ldr	r1, [r4, #4]
 802a33c:	4299      	cmp	r1, r3
 802a33e:	bfde      	ittt	le
 802a340:	2330      	movle	r3, #48	@ 0x30
 802a342:	f806 3c01 	strble.w	r3, [r6, #-1]
 802a346:	f106 36ff 	addle.w	r6, r6, #4294967295
 802a34a:	1b92      	subs	r2, r2, r6
 802a34c:	6122      	str	r2, [r4, #16]
 802a34e:	f8cd a000 	str.w	sl, [sp]
 802a352:	464b      	mov	r3, r9
 802a354:	aa03      	add	r2, sp, #12
 802a356:	4621      	mov	r1, r4
 802a358:	4640      	mov	r0, r8
 802a35a:	f7ff fee7 	bl	802a12c <_printf_common>
 802a35e:	3001      	adds	r0, #1
 802a360:	d14a      	bne.n	802a3f8 <_printf_i+0x1f0>
 802a362:	f04f 30ff 	mov.w	r0, #4294967295
 802a366:	b004      	add	sp, #16
 802a368:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 802a36c:	6823      	ldr	r3, [r4, #0]
 802a36e:	f043 0320 	orr.w	r3, r3, #32
 802a372:	6023      	str	r3, [r4, #0]
 802a374:	4832      	ldr	r0, [pc, #200]	@ (802a440 <_printf_i+0x238>)
 802a376:	2778      	movs	r7, #120	@ 0x78
 802a378:	f884 7045 	strb.w	r7, [r4, #69]	@ 0x45
 802a37c:	6823      	ldr	r3, [r4, #0]
 802a37e:	6831      	ldr	r1, [r6, #0]
 802a380:	061f      	lsls	r7, r3, #24
 802a382:	f851 5b04 	ldr.w	r5, [r1], #4
 802a386:	d402      	bmi.n	802a38e <_printf_i+0x186>
 802a388:	065f      	lsls	r7, r3, #25
 802a38a:	bf48      	it	mi
 802a38c:	b2ad      	uxthmi	r5, r5
 802a38e:	6031      	str	r1, [r6, #0]
 802a390:	07d9      	lsls	r1, r3, #31
 802a392:	bf44      	itt	mi
 802a394:	f043 0320 	orrmi.w	r3, r3, #32
 802a398:	6023      	strmi	r3, [r4, #0]
 802a39a:	b11d      	cbz	r5, 802a3a4 <_printf_i+0x19c>
 802a39c:	2310      	movs	r3, #16
 802a39e:	e7ad      	b.n	802a2fc <_printf_i+0xf4>
 802a3a0:	4826      	ldr	r0, [pc, #152]	@ (802a43c <_printf_i+0x234>)
 802a3a2:	e7e9      	b.n	802a378 <_printf_i+0x170>
 802a3a4:	6823      	ldr	r3, [r4, #0]
 802a3a6:	f023 0320 	bic.w	r3, r3, #32
 802a3aa:	6023      	str	r3, [r4, #0]
 802a3ac:	e7f6      	b.n	802a39c <_printf_i+0x194>
 802a3ae:	4616      	mov	r6, r2
 802a3b0:	e7bd      	b.n	802a32e <_printf_i+0x126>
 802a3b2:	6833      	ldr	r3, [r6, #0]
 802a3b4:	6825      	ldr	r5, [r4, #0]
 802a3b6:	6961      	ldr	r1, [r4, #20]
 802a3b8:	1d18      	adds	r0, r3, #4
 802a3ba:	6030      	str	r0, [r6, #0]
 802a3bc:	062e      	lsls	r6, r5, #24
 802a3be:	681b      	ldr	r3, [r3, #0]
 802a3c0:	d501      	bpl.n	802a3c6 <_printf_i+0x1be>
 802a3c2:	6019      	str	r1, [r3, #0]
 802a3c4:	e002      	b.n	802a3cc <_printf_i+0x1c4>
 802a3c6:	0668      	lsls	r0, r5, #25
 802a3c8:	d5fb      	bpl.n	802a3c2 <_printf_i+0x1ba>
 802a3ca:	8019      	strh	r1, [r3, #0]
 802a3cc:	2300      	movs	r3, #0
 802a3ce:	6123      	str	r3, [r4, #16]
 802a3d0:	4616      	mov	r6, r2
 802a3d2:	e7bc      	b.n	802a34e <_printf_i+0x146>
 802a3d4:	6833      	ldr	r3, [r6, #0]
 802a3d6:	1d1a      	adds	r2, r3, #4
 802a3d8:	6032      	str	r2, [r6, #0]
 802a3da:	681e      	ldr	r6, [r3, #0]
 802a3dc:	6862      	ldr	r2, [r4, #4]
 802a3de:	2100      	movs	r1, #0
 802a3e0:	4630      	mov	r0, r6
 802a3e2:	f7f5 ff85 	bl	80202f0 <memchr>
 802a3e6:	b108      	cbz	r0, 802a3ec <_printf_i+0x1e4>
 802a3e8:	1b80      	subs	r0, r0, r6
 802a3ea:	6060      	str	r0, [r4, #4]
 802a3ec:	6863      	ldr	r3, [r4, #4]
 802a3ee:	6123      	str	r3, [r4, #16]
 802a3f0:	2300      	movs	r3, #0
 802a3f2:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 802a3f6:	e7aa      	b.n	802a34e <_printf_i+0x146>
 802a3f8:	6923      	ldr	r3, [r4, #16]
 802a3fa:	4632      	mov	r2, r6
 802a3fc:	4649      	mov	r1, r9
 802a3fe:	4640      	mov	r0, r8
 802a400:	47d0      	blx	sl
 802a402:	3001      	adds	r0, #1
 802a404:	d0ad      	beq.n	802a362 <_printf_i+0x15a>
 802a406:	6823      	ldr	r3, [r4, #0]
 802a408:	079b      	lsls	r3, r3, #30
 802a40a:	d413      	bmi.n	802a434 <_printf_i+0x22c>
 802a40c:	68e0      	ldr	r0, [r4, #12]
 802a40e:	9b03      	ldr	r3, [sp, #12]
 802a410:	4298      	cmp	r0, r3
 802a412:	bfb8      	it	lt
 802a414:	4618      	movlt	r0, r3
 802a416:	e7a6      	b.n	802a366 <_printf_i+0x15e>
 802a418:	2301      	movs	r3, #1
 802a41a:	4632      	mov	r2, r6
 802a41c:	4649      	mov	r1, r9
 802a41e:	4640      	mov	r0, r8
 802a420:	47d0      	blx	sl
 802a422:	3001      	adds	r0, #1
 802a424:	d09d      	beq.n	802a362 <_printf_i+0x15a>
 802a426:	3501      	adds	r5, #1
 802a428:	68e3      	ldr	r3, [r4, #12]
 802a42a:	9903      	ldr	r1, [sp, #12]
 802a42c:	1a5b      	subs	r3, r3, r1
 802a42e:	42ab      	cmp	r3, r5
 802a430:	dcf2      	bgt.n	802a418 <_printf_i+0x210>
 802a432:	e7eb      	b.n	802a40c <_printf_i+0x204>
 802a434:	2500      	movs	r5, #0
 802a436:	f104 0619 	add.w	r6, r4, #25
 802a43a:	e7f5      	b.n	802a428 <_printf_i+0x220>
 802a43c:	08042288 	.word	0x08042288
 802a440:	08042299 	.word	0x08042299

0802a444 <__sflush_r>:
 802a444:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
 802a448:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802a44c:	0716      	lsls	r6, r2, #28
 802a44e:	4605      	mov	r5, r0
 802a450:	460c      	mov	r4, r1
 802a452:	d454      	bmi.n	802a4fe <__sflush_r+0xba>
 802a454:	684b      	ldr	r3, [r1, #4]
 802a456:	2b00      	cmp	r3, #0
 802a458:	dc02      	bgt.n	802a460 <__sflush_r+0x1c>
 802a45a:	6c0b      	ldr	r3, [r1, #64]	@ 0x40
 802a45c:	2b00      	cmp	r3, #0
 802a45e:	dd48      	ble.n	802a4f2 <__sflush_r+0xae>
 802a460:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
 802a462:	2e00      	cmp	r6, #0
 802a464:	d045      	beq.n	802a4f2 <__sflush_r+0xae>
 802a466:	2300      	movs	r3, #0
 802a468:	f412 5280 	ands.w	r2, r2, #4096	@ 0x1000
 802a46c:	682f      	ldr	r7, [r5, #0]
 802a46e:	6a21      	ldr	r1, [r4, #32]
 802a470:	602b      	str	r3, [r5, #0]
 802a472:	d030      	beq.n	802a4d6 <__sflush_r+0x92>
 802a474:	6d62      	ldr	r2, [r4, #84]	@ 0x54
 802a476:	89a3      	ldrh	r3, [r4, #12]
 802a478:	0759      	lsls	r1, r3, #29
 802a47a:	d505      	bpl.n	802a488 <__sflush_r+0x44>
 802a47c:	6863      	ldr	r3, [r4, #4]
 802a47e:	1ad2      	subs	r2, r2, r3
 802a480:	6b63      	ldr	r3, [r4, #52]	@ 0x34
 802a482:	b10b      	cbz	r3, 802a488 <__sflush_r+0x44>
 802a484:	6c23      	ldr	r3, [r4, #64]	@ 0x40
 802a486:	1ad2      	subs	r2, r2, r3
 802a488:	2300      	movs	r3, #0
 802a48a:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
 802a48c:	6a21      	ldr	r1, [r4, #32]
 802a48e:	4628      	mov	r0, r5
 802a490:	47b0      	blx	r6
 802a492:	1c43      	adds	r3, r0, #1
 802a494:	89a3      	ldrh	r3, [r4, #12]
 802a496:	d106      	bne.n	802a4a6 <__sflush_r+0x62>
 802a498:	6829      	ldr	r1, [r5, #0]
 802a49a:	291d      	cmp	r1, #29
 802a49c:	d82b      	bhi.n	802a4f6 <__sflush_r+0xb2>
 802a49e:	4a2a      	ldr	r2, [pc, #168]	@ (802a548 <__sflush_r+0x104>)
 802a4a0:	40ca      	lsrs	r2, r1
 802a4a2:	07d6      	lsls	r6, r2, #31
 802a4a4:	d527      	bpl.n	802a4f6 <__sflush_r+0xb2>
 802a4a6:	2200      	movs	r2, #0
 802a4a8:	6062      	str	r2, [r4, #4]
 802a4aa:	04d9      	lsls	r1, r3, #19
 802a4ac:	6922      	ldr	r2, [r4, #16]
 802a4ae:	6022      	str	r2, [r4, #0]
 802a4b0:	d504      	bpl.n	802a4bc <__sflush_r+0x78>
 802a4b2:	1c42      	adds	r2, r0, #1
 802a4b4:	d101      	bne.n	802a4ba <__sflush_r+0x76>
 802a4b6:	682b      	ldr	r3, [r5, #0]
 802a4b8:	b903      	cbnz	r3, 802a4bc <__sflush_r+0x78>
 802a4ba:	6560      	str	r0, [r4, #84]	@ 0x54
 802a4bc:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 802a4be:	602f      	str	r7, [r5, #0]
 802a4c0:	b1b9      	cbz	r1, 802a4f2 <__sflush_r+0xae>
 802a4c2:	f104 0344 	add.w	r3, r4, #68	@ 0x44
 802a4c6:	4299      	cmp	r1, r3
 802a4c8:	d002      	beq.n	802a4d0 <__sflush_r+0x8c>
 802a4ca:	4628      	mov	r0, r5
 802a4cc:	f7ff fbd6 	bl	8029c7c <_free_r>
 802a4d0:	2300      	movs	r3, #0
 802a4d2:	6363      	str	r3, [r4, #52]	@ 0x34
 802a4d4:	e00d      	b.n	802a4f2 <__sflush_r+0xae>
 802a4d6:	2301      	movs	r3, #1
 802a4d8:	4628      	mov	r0, r5
 802a4da:	47b0      	blx	r6
 802a4dc:	4602      	mov	r2, r0
 802a4de:	1c50      	adds	r0, r2, #1
 802a4e0:	d1c9      	bne.n	802a476 <__sflush_r+0x32>
 802a4e2:	682b      	ldr	r3, [r5, #0]
 802a4e4:	2b00      	cmp	r3, #0
 802a4e6:	d0c6      	beq.n	802a476 <__sflush_r+0x32>
 802a4e8:	2b1d      	cmp	r3, #29
 802a4ea:	d001      	beq.n	802a4f0 <__sflush_r+0xac>
 802a4ec:	2b16      	cmp	r3, #22
 802a4ee:	d11e      	bne.n	802a52e <__sflush_r+0xea>
 802a4f0:	602f      	str	r7, [r5, #0]
 802a4f2:	2000      	movs	r0, #0
 802a4f4:	e022      	b.n	802a53c <__sflush_r+0xf8>
 802a4f6:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 802a4fa:	b21b      	sxth	r3, r3
 802a4fc:	e01b      	b.n	802a536 <__sflush_r+0xf2>
 802a4fe:	690f      	ldr	r7, [r1, #16]
 802a500:	2f00      	cmp	r7, #0
 802a502:	d0f6      	beq.n	802a4f2 <__sflush_r+0xae>
 802a504:	0793      	lsls	r3, r2, #30
 802a506:	680e      	ldr	r6, [r1, #0]
 802a508:	bf08      	it	eq
 802a50a:	694b      	ldreq	r3, [r1, #20]
 802a50c:	600f      	str	r7, [r1, #0]
 802a50e:	bf18      	it	ne
 802a510:	2300      	movne	r3, #0
 802a512:	eba6 0807 	sub.w	r8, r6, r7
 802a516:	608b      	str	r3, [r1, #8]
 802a518:	f1b8 0f00 	cmp.w	r8, #0
 802a51c:	dde9      	ble.n	802a4f2 <__sflush_r+0xae>
 802a51e:	6a21      	ldr	r1, [r4, #32]
 802a520:	6aa6      	ldr	r6, [r4, #40]	@ 0x28
 802a522:	4643      	mov	r3, r8
 802a524:	463a      	mov	r2, r7
 802a526:	4628      	mov	r0, r5
 802a528:	47b0      	blx	r6
 802a52a:	2800      	cmp	r0, #0
 802a52c:	dc08      	bgt.n	802a540 <__sflush_r+0xfc>
 802a52e:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 802a532:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 802a536:	81a3      	strh	r3, [r4, #12]
 802a538:	f04f 30ff 	mov.w	r0, #4294967295
 802a53c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802a540:	4407      	add	r7, r0
 802a542:	eba8 0800 	sub.w	r8, r8, r0
 802a546:	e7e7      	b.n	802a518 <__sflush_r+0xd4>
 802a548:	20400001 	.word	0x20400001

0802a54c <_fflush_r>:
 802a54c:	b538      	push	{r3, r4, r5, lr}
 802a54e:	690b      	ldr	r3, [r1, #16]
 802a550:	4605      	mov	r5, r0
 802a552:	460c      	mov	r4, r1
 802a554:	b913      	cbnz	r3, 802a55c <_fflush_r+0x10>
 802a556:	2500      	movs	r5, #0
 802a558:	4628      	mov	r0, r5
 802a55a:	bd38      	pop	{r3, r4, r5, pc}
 802a55c:	b118      	cbz	r0, 802a566 <_fflush_r+0x1a>
 802a55e:	6a03      	ldr	r3, [r0, #32]
 802a560:	b90b      	cbnz	r3, 802a566 <_fflush_r+0x1a>
 802a562:	f7ff f9e7 	bl	8029934 <__sinit>
 802a566:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 802a56a:	2b00      	cmp	r3, #0
 802a56c:	d0f3      	beq.n	802a556 <_fflush_r+0xa>
 802a56e:	6e62      	ldr	r2, [r4, #100]	@ 0x64
 802a570:	07d0      	lsls	r0, r2, #31
 802a572:	d404      	bmi.n	802a57e <_fflush_r+0x32>
 802a574:	0599      	lsls	r1, r3, #22
 802a576:	d402      	bmi.n	802a57e <_fflush_r+0x32>
 802a578:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 802a57a:	f7ff fb50 	bl	8029c1e <__retarget_lock_acquire_recursive>
 802a57e:	4628      	mov	r0, r5
 802a580:	4621      	mov	r1, r4
 802a582:	f7ff ff5f 	bl	802a444 <__sflush_r>
 802a586:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 802a588:	07da      	lsls	r2, r3, #31
 802a58a:	4605      	mov	r5, r0
 802a58c:	d4e4      	bmi.n	802a558 <_fflush_r+0xc>
 802a58e:	89a3      	ldrh	r3, [r4, #12]
 802a590:	059b      	lsls	r3, r3, #22
 802a592:	d4e1      	bmi.n	802a558 <_fflush_r+0xc>
 802a594:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 802a596:	f7ff fb43 	bl	8029c20 <__retarget_lock_release_recursive>
 802a59a:	e7dd      	b.n	802a558 <_fflush_r+0xc>

0802a59c <fiprintf>:
 802a59c:	b40e      	push	{r1, r2, r3}
 802a59e:	b503      	push	{r0, r1, lr}
 802a5a0:	4601      	mov	r1, r0
 802a5a2:	ab03      	add	r3, sp, #12
 802a5a4:	4805      	ldr	r0, [pc, #20]	@ (802a5bc <fiprintf+0x20>)
 802a5a6:	f853 2b04 	ldr.w	r2, [r3], #4
 802a5aa:	6800      	ldr	r0, [r0, #0]
 802a5ac:	9301      	str	r3, [sp, #4]
 802a5ae:	f000 f88f 	bl	802a6d0 <_vfiprintf_r>
 802a5b2:	b002      	add	sp, #8
 802a5b4:	f85d eb04 	ldr.w	lr, [sp], #4
 802a5b8:	b003      	add	sp, #12
 802a5ba:	4770      	bx	lr
 802a5bc:	20000140 	.word	0x20000140

0802a5c0 <memmove>:
 802a5c0:	4288      	cmp	r0, r1
 802a5c2:	b510      	push	{r4, lr}
 802a5c4:	eb01 0402 	add.w	r4, r1, r2
 802a5c8:	d902      	bls.n	802a5d0 <memmove+0x10>
 802a5ca:	4284      	cmp	r4, r0
 802a5cc:	4623      	mov	r3, r4
 802a5ce:	d807      	bhi.n	802a5e0 <memmove+0x20>
 802a5d0:	1e43      	subs	r3, r0, #1
 802a5d2:	42a1      	cmp	r1, r4
 802a5d4:	d008      	beq.n	802a5e8 <memmove+0x28>
 802a5d6:	f811 2b01 	ldrb.w	r2, [r1], #1
 802a5da:	f803 2f01 	strb.w	r2, [r3, #1]!
 802a5de:	e7f8      	b.n	802a5d2 <memmove+0x12>
 802a5e0:	4402      	add	r2, r0
 802a5e2:	4601      	mov	r1, r0
 802a5e4:	428a      	cmp	r2, r1
 802a5e6:	d100      	bne.n	802a5ea <memmove+0x2a>
 802a5e8:	bd10      	pop	{r4, pc}
 802a5ea:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 802a5ee:	f802 4d01 	strb.w	r4, [r2, #-1]!
 802a5f2:	e7f7      	b.n	802a5e4 <memmove+0x24>

0802a5f4 <_sbrk_r>:
 802a5f4:	b538      	push	{r3, r4, r5, lr}
 802a5f6:	4d06      	ldr	r5, [pc, #24]	@ (802a610 <_sbrk_r+0x1c>)
 802a5f8:	2300      	movs	r3, #0
 802a5fa:	4604      	mov	r4, r0
 802a5fc:	4608      	mov	r0, r1
 802a5fe:	602b      	str	r3, [r5, #0]
 802a600:	f7fd ffe2 	bl	80285c8 <_sbrk>
 802a604:	1c43      	adds	r3, r0, #1
 802a606:	d102      	bne.n	802a60e <_sbrk_r+0x1a>
 802a608:	682b      	ldr	r3, [r5, #0]
 802a60a:	b103      	cbz	r3, 802a60e <_sbrk_r+0x1a>
 802a60c:	6023      	str	r3, [r4, #0]
 802a60e:	bd38      	pop	{r3, r4, r5, pc}
 802a610:	20023fa8 	.word	0x20023fa8

0802a614 <abort>:
 802a614:	b508      	push	{r3, lr}
 802a616:	2006      	movs	r0, #6
 802a618:	f000 fa2e 	bl	802aa78 <raise>
 802a61c:	2001      	movs	r0, #1
 802a61e:	f7fd ffb1 	bl	8028584 <_exit>

0802a622 <_realloc_r>:
 802a622:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802a626:	4607      	mov	r7, r0
 802a628:	4614      	mov	r4, r2
 802a62a:	460d      	mov	r5, r1
 802a62c:	b921      	cbnz	r1, 802a638 <_realloc_r+0x16>
 802a62e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 802a632:	4611      	mov	r1, r2
 802a634:	f7ff bb96 	b.w	8029d64 <_malloc_r>
 802a638:	b92a      	cbnz	r2, 802a646 <_realloc_r+0x24>
 802a63a:	f7ff fb1f 	bl	8029c7c <_free_r>
 802a63e:	4625      	mov	r5, r4
 802a640:	4628      	mov	r0, r5
 802a642:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802a646:	f000 fa33 	bl	802aab0 <_malloc_usable_size_r>
 802a64a:	4284      	cmp	r4, r0
 802a64c:	4606      	mov	r6, r0
 802a64e:	d802      	bhi.n	802a656 <_realloc_r+0x34>
 802a650:	ebb4 0f50 	cmp.w	r4, r0, lsr #1
 802a654:	d8f4      	bhi.n	802a640 <_realloc_r+0x1e>
 802a656:	4621      	mov	r1, r4
 802a658:	4638      	mov	r0, r7
 802a65a:	f7ff fb83 	bl	8029d64 <_malloc_r>
 802a65e:	4680      	mov	r8, r0
 802a660:	b908      	cbnz	r0, 802a666 <_realloc_r+0x44>
 802a662:	4645      	mov	r5, r8
 802a664:	e7ec      	b.n	802a640 <_realloc_r+0x1e>
 802a666:	42b4      	cmp	r4, r6
 802a668:	4622      	mov	r2, r4
 802a66a:	4629      	mov	r1, r5
 802a66c:	bf28      	it	cs
 802a66e:	4632      	movcs	r2, r6
 802a670:	f7ff fad7 	bl	8029c22 <memcpy>
 802a674:	4629      	mov	r1, r5
 802a676:	4638      	mov	r0, r7
 802a678:	f7ff fb00 	bl	8029c7c <_free_r>
 802a67c:	e7f1      	b.n	802a662 <_realloc_r+0x40>

0802a67e <__sfputc_r>:
 802a67e:	6893      	ldr	r3, [r2, #8]
 802a680:	3b01      	subs	r3, #1
 802a682:	2b00      	cmp	r3, #0
 802a684:	b410      	push	{r4}
 802a686:	6093      	str	r3, [r2, #8]
 802a688:	da08      	bge.n	802a69c <__sfputc_r+0x1e>
 802a68a:	6994      	ldr	r4, [r2, #24]
 802a68c:	42a3      	cmp	r3, r4
 802a68e:	db01      	blt.n	802a694 <__sfputc_r+0x16>
 802a690:	290a      	cmp	r1, #10
 802a692:	d103      	bne.n	802a69c <__sfputc_r+0x1e>
 802a694:	f85d 4b04 	ldr.w	r4, [sp], #4
 802a698:	f000 b932 	b.w	802a900 <__swbuf_r>
 802a69c:	6813      	ldr	r3, [r2, #0]
 802a69e:	1c58      	adds	r0, r3, #1
 802a6a0:	6010      	str	r0, [r2, #0]
 802a6a2:	7019      	strb	r1, [r3, #0]
 802a6a4:	4608      	mov	r0, r1
 802a6a6:	f85d 4b04 	ldr.w	r4, [sp], #4
 802a6aa:	4770      	bx	lr

0802a6ac <__sfputs_r>:
 802a6ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802a6ae:	4606      	mov	r6, r0
 802a6b0:	460f      	mov	r7, r1
 802a6b2:	4614      	mov	r4, r2
 802a6b4:	18d5      	adds	r5, r2, r3
 802a6b6:	42ac      	cmp	r4, r5
 802a6b8:	d101      	bne.n	802a6be <__sfputs_r+0x12>
 802a6ba:	2000      	movs	r0, #0
 802a6bc:	e007      	b.n	802a6ce <__sfputs_r+0x22>
 802a6be:	f814 1b01 	ldrb.w	r1, [r4], #1
 802a6c2:	463a      	mov	r2, r7
 802a6c4:	4630      	mov	r0, r6
 802a6c6:	f7ff ffda 	bl	802a67e <__sfputc_r>
 802a6ca:	1c43      	adds	r3, r0, #1
 802a6cc:	d1f3      	bne.n	802a6b6 <__sfputs_r+0xa>
 802a6ce:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0802a6d0 <_vfiprintf_r>:
 802a6d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802a6d4:	460d      	mov	r5, r1
 802a6d6:	b09d      	sub	sp, #116	@ 0x74
 802a6d8:	4614      	mov	r4, r2
 802a6da:	4698      	mov	r8, r3
 802a6dc:	4606      	mov	r6, r0
 802a6de:	b118      	cbz	r0, 802a6e8 <_vfiprintf_r+0x18>
 802a6e0:	6a03      	ldr	r3, [r0, #32]
 802a6e2:	b90b      	cbnz	r3, 802a6e8 <_vfiprintf_r+0x18>
 802a6e4:	f7ff f926 	bl	8029934 <__sinit>
 802a6e8:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 802a6ea:	07d9      	lsls	r1, r3, #31
 802a6ec:	d405      	bmi.n	802a6fa <_vfiprintf_r+0x2a>
 802a6ee:	89ab      	ldrh	r3, [r5, #12]
 802a6f0:	059a      	lsls	r2, r3, #22
 802a6f2:	d402      	bmi.n	802a6fa <_vfiprintf_r+0x2a>
 802a6f4:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 802a6f6:	f7ff fa92 	bl	8029c1e <__retarget_lock_acquire_recursive>
 802a6fa:	89ab      	ldrh	r3, [r5, #12]
 802a6fc:	071b      	lsls	r3, r3, #28
 802a6fe:	d501      	bpl.n	802a704 <_vfiprintf_r+0x34>
 802a700:	692b      	ldr	r3, [r5, #16]
 802a702:	b99b      	cbnz	r3, 802a72c <_vfiprintf_r+0x5c>
 802a704:	4629      	mov	r1, r5
 802a706:	4630      	mov	r0, r6
 802a708:	f000 f938 	bl	802a97c <__swsetup_r>
 802a70c:	b170      	cbz	r0, 802a72c <_vfiprintf_r+0x5c>
 802a70e:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 802a710:	07dc      	lsls	r4, r3, #31
 802a712:	d504      	bpl.n	802a71e <_vfiprintf_r+0x4e>
 802a714:	f04f 30ff 	mov.w	r0, #4294967295
 802a718:	b01d      	add	sp, #116	@ 0x74
 802a71a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802a71e:	89ab      	ldrh	r3, [r5, #12]
 802a720:	0598      	lsls	r0, r3, #22
 802a722:	d4f7      	bmi.n	802a714 <_vfiprintf_r+0x44>
 802a724:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 802a726:	f7ff fa7b 	bl	8029c20 <__retarget_lock_release_recursive>
 802a72a:	e7f3      	b.n	802a714 <_vfiprintf_r+0x44>
 802a72c:	2300      	movs	r3, #0
 802a72e:	9309      	str	r3, [sp, #36]	@ 0x24
 802a730:	2320      	movs	r3, #32
 802a732:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
 802a736:	f8cd 800c 	str.w	r8, [sp, #12]
 802a73a:	2330      	movs	r3, #48	@ 0x30
 802a73c:	f8df 81ac 	ldr.w	r8, [pc, #428]	@ 802a8ec <_vfiprintf_r+0x21c>
 802a740:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
 802a744:	f04f 0901 	mov.w	r9, #1
 802a748:	4623      	mov	r3, r4
 802a74a:	469a      	mov	sl, r3
 802a74c:	f813 2b01 	ldrb.w	r2, [r3], #1
 802a750:	b10a      	cbz	r2, 802a756 <_vfiprintf_r+0x86>
 802a752:	2a25      	cmp	r2, #37	@ 0x25
 802a754:	d1f9      	bne.n	802a74a <_vfiprintf_r+0x7a>
 802a756:	ebba 0b04 	subs.w	fp, sl, r4
 802a75a:	d00b      	beq.n	802a774 <_vfiprintf_r+0xa4>
 802a75c:	465b      	mov	r3, fp
 802a75e:	4622      	mov	r2, r4
 802a760:	4629      	mov	r1, r5
 802a762:	4630      	mov	r0, r6
 802a764:	f7ff ffa2 	bl	802a6ac <__sfputs_r>
 802a768:	3001      	adds	r0, #1
 802a76a:	f000 80a7 	beq.w	802a8bc <_vfiprintf_r+0x1ec>
 802a76e:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 802a770:	445a      	add	r2, fp
 802a772:	9209      	str	r2, [sp, #36]	@ 0x24
 802a774:	f89a 3000 	ldrb.w	r3, [sl]
 802a778:	2b00      	cmp	r3, #0
 802a77a:	f000 809f 	beq.w	802a8bc <_vfiprintf_r+0x1ec>
 802a77e:	2300      	movs	r3, #0
 802a780:	f04f 32ff 	mov.w	r2, #4294967295
 802a784:	e9cd 2305 	strd	r2, r3, [sp, #20]
 802a788:	f10a 0a01 	add.w	sl, sl, #1
 802a78c:	9304      	str	r3, [sp, #16]
 802a78e:	9307      	str	r3, [sp, #28]
 802a790:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
 802a794:	931a      	str	r3, [sp, #104]	@ 0x68
 802a796:	4654      	mov	r4, sl
 802a798:	2205      	movs	r2, #5
 802a79a:	f814 1b01 	ldrb.w	r1, [r4], #1
 802a79e:	4853      	ldr	r0, [pc, #332]	@ (802a8ec <_vfiprintf_r+0x21c>)
 802a7a0:	f7f5 fda6 	bl	80202f0 <memchr>
 802a7a4:	9a04      	ldr	r2, [sp, #16]
 802a7a6:	b9d8      	cbnz	r0, 802a7e0 <_vfiprintf_r+0x110>
 802a7a8:	06d1      	lsls	r1, r2, #27
 802a7aa:	bf44      	itt	mi
 802a7ac:	2320      	movmi	r3, #32
 802a7ae:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 802a7b2:	0713      	lsls	r3, r2, #28
 802a7b4:	bf44      	itt	mi
 802a7b6:	232b      	movmi	r3, #43	@ 0x2b
 802a7b8:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 802a7bc:	f89a 3000 	ldrb.w	r3, [sl]
 802a7c0:	2b2a      	cmp	r3, #42	@ 0x2a
 802a7c2:	d015      	beq.n	802a7f0 <_vfiprintf_r+0x120>
 802a7c4:	9a07      	ldr	r2, [sp, #28]
 802a7c6:	4654      	mov	r4, sl
 802a7c8:	2000      	movs	r0, #0
 802a7ca:	f04f 0c0a 	mov.w	ip, #10
 802a7ce:	4621      	mov	r1, r4
 802a7d0:	f811 3b01 	ldrb.w	r3, [r1], #1
 802a7d4:	3b30      	subs	r3, #48	@ 0x30
 802a7d6:	2b09      	cmp	r3, #9
 802a7d8:	d94b      	bls.n	802a872 <_vfiprintf_r+0x1a2>
 802a7da:	b1b0      	cbz	r0, 802a80a <_vfiprintf_r+0x13a>
 802a7dc:	9207      	str	r2, [sp, #28]
 802a7de:	e014      	b.n	802a80a <_vfiprintf_r+0x13a>
 802a7e0:	eba0 0308 	sub.w	r3, r0, r8
 802a7e4:	fa09 f303 	lsl.w	r3, r9, r3
 802a7e8:	4313      	orrs	r3, r2
 802a7ea:	9304      	str	r3, [sp, #16]
 802a7ec:	46a2      	mov	sl, r4
 802a7ee:	e7d2      	b.n	802a796 <_vfiprintf_r+0xc6>
 802a7f0:	9b03      	ldr	r3, [sp, #12]
 802a7f2:	1d19      	adds	r1, r3, #4
 802a7f4:	681b      	ldr	r3, [r3, #0]
 802a7f6:	9103      	str	r1, [sp, #12]
 802a7f8:	2b00      	cmp	r3, #0
 802a7fa:	bfbb      	ittet	lt
 802a7fc:	425b      	neglt	r3, r3
 802a7fe:	f042 0202 	orrlt.w	r2, r2, #2
 802a802:	9307      	strge	r3, [sp, #28]
 802a804:	9307      	strlt	r3, [sp, #28]
 802a806:	bfb8      	it	lt
 802a808:	9204      	strlt	r2, [sp, #16]
 802a80a:	7823      	ldrb	r3, [r4, #0]
 802a80c:	2b2e      	cmp	r3, #46	@ 0x2e
 802a80e:	d10a      	bne.n	802a826 <_vfiprintf_r+0x156>
 802a810:	7863      	ldrb	r3, [r4, #1]
 802a812:	2b2a      	cmp	r3, #42	@ 0x2a
 802a814:	d132      	bne.n	802a87c <_vfiprintf_r+0x1ac>
 802a816:	9b03      	ldr	r3, [sp, #12]
 802a818:	1d1a      	adds	r2, r3, #4
 802a81a:	681b      	ldr	r3, [r3, #0]
 802a81c:	9203      	str	r2, [sp, #12]
 802a81e:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
 802a822:	3402      	adds	r4, #2
 802a824:	9305      	str	r3, [sp, #20]
 802a826:	f8df a0d4 	ldr.w	sl, [pc, #212]	@ 802a8fc <_vfiprintf_r+0x22c>
 802a82a:	7821      	ldrb	r1, [r4, #0]
 802a82c:	2203      	movs	r2, #3
 802a82e:	4650      	mov	r0, sl
 802a830:	f7f5 fd5e 	bl	80202f0 <memchr>
 802a834:	b138      	cbz	r0, 802a846 <_vfiprintf_r+0x176>
 802a836:	9b04      	ldr	r3, [sp, #16]
 802a838:	eba0 000a 	sub.w	r0, r0, sl
 802a83c:	2240      	movs	r2, #64	@ 0x40
 802a83e:	4082      	lsls	r2, r0
 802a840:	4313      	orrs	r3, r2
 802a842:	3401      	adds	r4, #1
 802a844:	9304      	str	r3, [sp, #16]
 802a846:	f814 1b01 	ldrb.w	r1, [r4], #1
 802a84a:	4829      	ldr	r0, [pc, #164]	@ (802a8f0 <_vfiprintf_r+0x220>)
 802a84c:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
 802a850:	2206      	movs	r2, #6
 802a852:	f7f5 fd4d 	bl	80202f0 <memchr>
 802a856:	2800      	cmp	r0, #0
 802a858:	d03f      	beq.n	802a8da <_vfiprintf_r+0x20a>
 802a85a:	4b26      	ldr	r3, [pc, #152]	@ (802a8f4 <_vfiprintf_r+0x224>)
 802a85c:	bb1b      	cbnz	r3, 802a8a6 <_vfiprintf_r+0x1d6>
 802a85e:	9b03      	ldr	r3, [sp, #12]
 802a860:	3307      	adds	r3, #7
 802a862:	f023 0307 	bic.w	r3, r3, #7
 802a866:	3308      	adds	r3, #8
 802a868:	9303      	str	r3, [sp, #12]
 802a86a:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 802a86c:	443b      	add	r3, r7
 802a86e:	9309      	str	r3, [sp, #36]	@ 0x24
 802a870:	e76a      	b.n	802a748 <_vfiprintf_r+0x78>
 802a872:	fb0c 3202 	mla	r2, ip, r2, r3
 802a876:	460c      	mov	r4, r1
 802a878:	2001      	movs	r0, #1
 802a87a:	e7a8      	b.n	802a7ce <_vfiprintf_r+0xfe>
 802a87c:	2300      	movs	r3, #0
 802a87e:	3401      	adds	r4, #1
 802a880:	9305      	str	r3, [sp, #20]
 802a882:	4619      	mov	r1, r3
 802a884:	f04f 0c0a 	mov.w	ip, #10
 802a888:	4620      	mov	r0, r4
 802a88a:	f810 2b01 	ldrb.w	r2, [r0], #1
 802a88e:	3a30      	subs	r2, #48	@ 0x30
 802a890:	2a09      	cmp	r2, #9
 802a892:	d903      	bls.n	802a89c <_vfiprintf_r+0x1cc>
 802a894:	2b00      	cmp	r3, #0
 802a896:	d0c6      	beq.n	802a826 <_vfiprintf_r+0x156>
 802a898:	9105      	str	r1, [sp, #20]
 802a89a:	e7c4      	b.n	802a826 <_vfiprintf_r+0x156>
 802a89c:	fb0c 2101 	mla	r1, ip, r1, r2
 802a8a0:	4604      	mov	r4, r0
 802a8a2:	2301      	movs	r3, #1
 802a8a4:	e7f0      	b.n	802a888 <_vfiprintf_r+0x1b8>
 802a8a6:	ab03      	add	r3, sp, #12
 802a8a8:	9300      	str	r3, [sp, #0]
 802a8aa:	462a      	mov	r2, r5
 802a8ac:	4b12      	ldr	r3, [pc, #72]	@ (802a8f8 <_vfiprintf_r+0x228>)
 802a8ae:	a904      	add	r1, sp, #16
 802a8b0:	4630      	mov	r0, r6
 802a8b2:	f3af 8000 	nop.w
 802a8b6:	4607      	mov	r7, r0
 802a8b8:	1c78      	adds	r0, r7, #1
 802a8ba:	d1d6      	bne.n	802a86a <_vfiprintf_r+0x19a>
 802a8bc:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 802a8be:	07d9      	lsls	r1, r3, #31
 802a8c0:	d405      	bmi.n	802a8ce <_vfiprintf_r+0x1fe>
 802a8c2:	89ab      	ldrh	r3, [r5, #12]
 802a8c4:	059a      	lsls	r2, r3, #22
 802a8c6:	d402      	bmi.n	802a8ce <_vfiprintf_r+0x1fe>
 802a8c8:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 802a8ca:	f7ff f9a9 	bl	8029c20 <__retarget_lock_release_recursive>
 802a8ce:	89ab      	ldrh	r3, [r5, #12]
 802a8d0:	065b      	lsls	r3, r3, #25
 802a8d2:	f53f af1f 	bmi.w	802a714 <_vfiprintf_r+0x44>
 802a8d6:	9809      	ldr	r0, [sp, #36]	@ 0x24
 802a8d8:	e71e      	b.n	802a718 <_vfiprintf_r+0x48>
 802a8da:	ab03      	add	r3, sp, #12
 802a8dc:	9300      	str	r3, [sp, #0]
 802a8de:	462a      	mov	r2, r5
 802a8e0:	4b05      	ldr	r3, [pc, #20]	@ (802a8f8 <_vfiprintf_r+0x228>)
 802a8e2:	a904      	add	r1, sp, #16
 802a8e4:	4630      	mov	r0, r6
 802a8e6:	f7ff fc8f 	bl	802a208 <_printf_i>
 802a8ea:	e7e4      	b.n	802a8b6 <_vfiprintf_r+0x1e6>
 802a8ec:	08042277 	.word	0x08042277
 802a8f0:	08042281 	.word	0x08042281
 802a8f4:	00000000 	.word	0x00000000
 802a8f8:	0802a6ad 	.word	0x0802a6ad
 802a8fc:	0804227d 	.word	0x0804227d

0802a900 <__swbuf_r>:
 802a900:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802a902:	460e      	mov	r6, r1
 802a904:	4614      	mov	r4, r2
 802a906:	4605      	mov	r5, r0
 802a908:	b118      	cbz	r0, 802a912 <__swbuf_r+0x12>
 802a90a:	6a03      	ldr	r3, [r0, #32]
 802a90c:	b90b      	cbnz	r3, 802a912 <__swbuf_r+0x12>
 802a90e:	f7ff f811 	bl	8029934 <__sinit>
 802a912:	69a3      	ldr	r3, [r4, #24]
 802a914:	60a3      	str	r3, [r4, #8]
 802a916:	89a3      	ldrh	r3, [r4, #12]
 802a918:	071a      	lsls	r2, r3, #28
 802a91a:	d501      	bpl.n	802a920 <__swbuf_r+0x20>
 802a91c:	6923      	ldr	r3, [r4, #16]
 802a91e:	b943      	cbnz	r3, 802a932 <__swbuf_r+0x32>
 802a920:	4621      	mov	r1, r4
 802a922:	4628      	mov	r0, r5
 802a924:	f000 f82a 	bl	802a97c <__swsetup_r>
 802a928:	b118      	cbz	r0, 802a932 <__swbuf_r+0x32>
 802a92a:	f04f 37ff 	mov.w	r7, #4294967295
 802a92e:	4638      	mov	r0, r7
 802a930:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 802a932:	6823      	ldr	r3, [r4, #0]
 802a934:	6922      	ldr	r2, [r4, #16]
 802a936:	1a98      	subs	r0, r3, r2
 802a938:	6963      	ldr	r3, [r4, #20]
 802a93a:	b2f6      	uxtb	r6, r6
 802a93c:	4283      	cmp	r3, r0
 802a93e:	4637      	mov	r7, r6
 802a940:	dc05      	bgt.n	802a94e <__swbuf_r+0x4e>
 802a942:	4621      	mov	r1, r4
 802a944:	4628      	mov	r0, r5
 802a946:	f7ff fe01 	bl	802a54c <_fflush_r>
 802a94a:	2800      	cmp	r0, #0
 802a94c:	d1ed      	bne.n	802a92a <__swbuf_r+0x2a>
 802a94e:	68a3      	ldr	r3, [r4, #8]
 802a950:	3b01      	subs	r3, #1
 802a952:	60a3      	str	r3, [r4, #8]
 802a954:	6823      	ldr	r3, [r4, #0]
 802a956:	1c5a      	adds	r2, r3, #1
 802a958:	6022      	str	r2, [r4, #0]
 802a95a:	701e      	strb	r6, [r3, #0]
 802a95c:	6962      	ldr	r2, [r4, #20]
 802a95e:	1c43      	adds	r3, r0, #1
 802a960:	429a      	cmp	r2, r3
 802a962:	d004      	beq.n	802a96e <__swbuf_r+0x6e>
 802a964:	89a3      	ldrh	r3, [r4, #12]
 802a966:	07db      	lsls	r3, r3, #31
 802a968:	d5e1      	bpl.n	802a92e <__swbuf_r+0x2e>
 802a96a:	2e0a      	cmp	r6, #10
 802a96c:	d1df      	bne.n	802a92e <__swbuf_r+0x2e>
 802a96e:	4621      	mov	r1, r4
 802a970:	4628      	mov	r0, r5
 802a972:	f7ff fdeb 	bl	802a54c <_fflush_r>
 802a976:	2800      	cmp	r0, #0
 802a978:	d0d9      	beq.n	802a92e <__swbuf_r+0x2e>
 802a97a:	e7d6      	b.n	802a92a <__swbuf_r+0x2a>

0802a97c <__swsetup_r>:
 802a97c:	b538      	push	{r3, r4, r5, lr}
 802a97e:	4b29      	ldr	r3, [pc, #164]	@ (802aa24 <__swsetup_r+0xa8>)
 802a980:	4605      	mov	r5, r0
 802a982:	6818      	ldr	r0, [r3, #0]
 802a984:	460c      	mov	r4, r1
 802a986:	b118      	cbz	r0, 802a990 <__swsetup_r+0x14>
 802a988:	6a03      	ldr	r3, [r0, #32]
 802a98a:	b90b      	cbnz	r3, 802a990 <__swsetup_r+0x14>
 802a98c:	f7fe ffd2 	bl	8029934 <__sinit>
 802a990:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 802a994:	0719      	lsls	r1, r3, #28
 802a996:	d422      	bmi.n	802a9de <__swsetup_r+0x62>
 802a998:	06da      	lsls	r2, r3, #27
 802a99a:	d407      	bmi.n	802a9ac <__swsetup_r+0x30>
 802a99c:	2209      	movs	r2, #9
 802a99e:	602a      	str	r2, [r5, #0]
 802a9a0:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 802a9a4:	81a3      	strh	r3, [r4, #12]
 802a9a6:	f04f 30ff 	mov.w	r0, #4294967295
 802a9aa:	e033      	b.n	802aa14 <__swsetup_r+0x98>
 802a9ac:	0758      	lsls	r0, r3, #29
 802a9ae:	d512      	bpl.n	802a9d6 <__swsetup_r+0x5a>
 802a9b0:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 802a9b2:	b141      	cbz	r1, 802a9c6 <__swsetup_r+0x4a>
 802a9b4:	f104 0344 	add.w	r3, r4, #68	@ 0x44
 802a9b8:	4299      	cmp	r1, r3
 802a9ba:	d002      	beq.n	802a9c2 <__swsetup_r+0x46>
 802a9bc:	4628      	mov	r0, r5
 802a9be:	f7ff f95d 	bl	8029c7c <_free_r>
 802a9c2:	2300      	movs	r3, #0
 802a9c4:	6363      	str	r3, [r4, #52]	@ 0x34
 802a9c6:	89a3      	ldrh	r3, [r4, #12]
 802a9c8:	f023 0324 	bic.w	r3, r3, #36	@ 0x24
 802a9cc:	81a3      	strh	r3, [r4, #12]
 802a9ce:	2300      	movs	r3, #0
 802a9d0:	6063      	str	r3, [r4, #4]
 802a9d2:	6923      	ldr	r3, [r4, #16]
 802a9d4:	6023      	str	r3, [r4, #0]
 802a9d6:	89a3      	ldrh	r3, [r4, #12]
 802a9d8:	f043 0308 	orr.w	r3, r3, #8
 802a9dc:	81a3      	strh	r3, [r4, #12]
 802a9de:	6923      	ldr	r3, [r4, #16]
 802a9e0:	b94b      	cbnz	r3, 802a9f6 <__swsetup_r+0x7a>
 802a9e2:	89a3      	ldrh	r3, [r4, #12]
 802a9e4:	f403 7320 	and.w	r3, r3, #640	@ 0x280
 802a9e8:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 802a9ec:	d003      	beq.n	802a9f6 <__swsetup_r+0x7a>
 802a9ee:	4621      	mov	r1, r4
 802a9f0:	4628      	mov	r0, r5
 802a9f2:	f000 f88b 	bl	802ab0c <__smakebuf_r>
 802a9f6:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 802a9fa:	f013 0201 	ands.w	r2, r3, #1
 802a9fe:	d00a      	beq.n	802aa16 <__swsetup_r+0x9a>
 802aa00:	2200      	movs	r2, #0
 802aa02:	60a2      	str	r2, [r4, #8]
 802aa04:	6962      	ldr	r2, [r4, #20]
 802aa06:	4252      	negs	r2, r2
 802aa08:	61a2      	str	r2, [r4, #24]
 802aa0a:	6922      	ldr	r2, [r4, #16]
 802aa0c:	b942      	cbnz	r2, 802aa20 <__swsetup_r+0xa4>
 802aa0e:	f013 0080 	ands.w	r0, r3, #128	@ 0x80
 802aa12:	d1c5      	bne.n	802a9a0 <__swsetup_r+0x24>
 802aa14:	bd38      	pop	{r3, r4, r5, pc}
 802aa16:	0799      	lsls	r1, r3, #30
 802aa18:	bf58      	it	pl
 802aa1a:	6962      	ldrpl	r2, [r4, #20]
 802aa1c:	60a2      	str	r2, [r4, #8]
 802aa1e:	e7f4      	b.n	802aa0a <__swsetup_r+0x8e>
 802aa20:	2000      	movs	r0, #0
 802aa22:	e7f7      	b.n	802aa14 <__swsetup_r+0x98>
 802aa24:	20000140 	.word	0x20000140

0802aa28 <_raise_r>:
 802aa28:	291f      	cmp	r1, #31
 802aa2a:	b538      	push	{r3, r4, r5, lr}
 802aa2c:	4605      	mov	r5, r0
 802aa2e:	460c      	mov	r4, r1
 802aa30:	d904      	bls.n	802aa3c <_raise_r+0x14>
 802aa32:	2316      	movs	r3, #22
 802aa34:	6003      	str	r3, [r0, #0]
 802aa36:	f04f 30ff 	mov.w	r0, #4294967295
 802aa3a:	bd38      	pop	{r3, r4, r5, pc}
 802aa3c:	6bc2      	ldr	r2, [r0, #60]	@ 0x3c
 802aa3e:	b112      	cbz	r2, 802aa46 <_raise_r+0x1e>
 802aa40:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
 802aa44:	b94b      	cbnz	r3, 802aa5a <_raise_r+0x32>
 802aa46:	4628      	mov	r0, r5
 802aa48:	f000 f830 	bl	802aaac <_getpid_r>
 802aa4c:	4622      	mov	r2, r4
 802aa4e:	4601      	mov	r1, r0
 802aa50:	4628      	mov	r0, r5
 802aa52:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 802aa56:	f000 b817 	b.w	802aa88 <_kill_r>
 802aa5a:	2b01      	cmp	r3, #1
 802aa5c:	d00a      	beq.n	802aa74 <_raise_r+0x4c>
 802aa5e:	1c59      	adds	r1, r3, #1
 802aa60:	d103      	bne.n	802aa6a <_raise_r+0x42>
 802aa62:	2316      	movs	r3, #22
 802aa64:	6003      	str	r3, [r0, #0]
 802aa66:	2001      	movs	r0, #1
 802aa68:	e7e7      	b.n	802aa3a <_raise_r+0x12>
 802aa6a:	2100      	movs	r1, #0
 802aa6c:	f842 1024 	str.w	r1, [r2, r4, lsl #2]
 802aa70:	4620      	mov	r0, r4
 802aa72:	4798      	blx	r3
 802aa74:	2000      	movs	r0, #0
 802aa76:	e7e0      	b.n	802aa3a <_raise_r+0x12>

0802aa78 <raise>:
 802aa78:	4b02      	ldr	r3, [pc, #8]	@ (802aa84 <raise+0xc>)
 802aa7a:	4601      	mov	r1, r0
 802aa7c:	6818      	ldr	r0, [r3, #0]
 802aa7e:	f7ff bfd3 	b.w	802aa28 <_raise_r>
 802aa82:	bf00      	nop
 802aa84:	20000140 	.word	0x20000140

0802aa88 <_kill_r>:
 802aa88:	b538      	push	{r3, r4, r5, lr}
 802aa8a:	4d07      	ldr	r5, [pc, #28]	@ (802aaa8 <_kill_r+0x20>)
 802aa8c:	2300      	movs	r3, #0
 802aa8e:	4604      	mov	r4, r0
 802aa90:	4608      	mov	r0, r1
 802aa92:	4611      	mov	r1, r2
 802aa94:	602b      	str	r3, [r5, #0]
 802aa96:	f7fd fd6d 	bl	8028574 <_kill>
 802aa9a:	1c43      	adds	r3, r0, #1
 802aa9c:	d102      	bne.n	802aaa4 <_kill_r+0x1c>
 802aa9e:	682b      	ldr	r3, [r5, #0]
 802aaa0:	b103      	cbz	r3, 802aaa4 <_kill_r+0x1c>
 802aaa2:	6023      	str	r3, [r4, #0]
 802aaa4:	bd38      	pop	{r3, r4, r5, pc}
 802aaa6:	bf00      	nop
 802aaa8:	20023fa8 	.word	0x20023fa8

0802aaac <_getpid_r>:
 802aaac:	f7fd bd60 	b.w	8028570 <_getpid>

0802aab0 <_malloc_usable_size_r>:
 802aab0:	f851 3c04 	ldr.w	r3, [r1, #-4]
 802aab4:	1f18      	subs	r0, r3, #4
 802aab6:	2b00      	cmp	r3, #0
 802aab8:	bfbc      	itt	lt
 802aaba:	580b      	ldrlt	r3, [r1, r0]
 802aabc:	18c0      	addlt	r0, r0, r3
 802aabe:	4770      	bx	lr

0802aac0 <__swhatbuf_r>:
 802aac0:	b570      	push	{r4, r5, r6, lr}
 802aac2:	460c      	mov	r4, r1
 802aac4:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 802aac8:	2900      	cmp	r1, #0
 802aaca:	b096      	sub	sp, #88	@ 0x58
 802aacc:	4615      	mov	r5, r2
 802aace:	461e      	mov	r6, r3
 802aad0:	da0d      	bge.n	802aaee <__swhatbuf_r+0x2e>
 802aad2:	89a3      	ldrh	r3, [r4, #12]
 802aad4:	f013 0f80 	tst.w	r3, #128	@ 0x80
 802aad8:	f04f 0100 	mov.w	r1, #0
 802aadc:	bf14      	ite	ne
 802aade:	2340      	movne	r3, #64	@ 0x40
 802aae0:	f44f 6380 	moveq.w	r3, #1024	@ 0x400
 802aae4:	2000      	movs	r0, #0
 802aae6:	6031      	str	r1, [r6, #0]
 802aae8:	602b      	str	r3, [r5, #0]
 802aaea:	b016      	add	sp, #88	@ 0x58
 802aaec:	bd70      	pop	{r4, r5, r6, pc}
 802aaee:	466a      	mov	r2, sp
 802aaf0:	f000 f848 	bl	802ab84 <_fstat_r>
 802aaf4:	2800      	cmp	r0, #0
 802aaf6:	dbec      	blt.n	802aad2 <__swhatbuf_r+0x12>
 802aaf8:	9901      	ldr	r1, [sp, #4]
 802aafa:	f401 4170 	and.w	r1, r1, #61440	@ 0xf000
 802aafe:	f5a1 5300 	sub.w	r3, r1, #8192	@ 0x2000
 802ab02:	4259      	negs	r1, r3
 802ab04:	4159      	adcs	r1, r3
 802ab06:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 802ab0a:	e7eb      	b.n	802aae4 <__swhatbuf_r+0x24>

0802ab0c <__smakebuf_r>:
 802ab0c:	898b      	ldrh	r3, [r1, #12]
 802ab0e:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 802ab10:	079d      	lsls	r5, r3, #30
 802ab12:	4606      	mov	r6, r0
 802ab14:	460c      	mov	r4, r1
 802ab16:	d507      	bpl.n	802ab28 <__smakebuf_r+0x1c>
 802ab18:	f104 0347 	add.w	r3, r4, #71	@ 0x47
 802ab1c:	6023      	str	r3, [r4, #0]
 802ab1e:	6123      	str	r3, [r4, #16]
 802ab20:	2301      	movs	r3, #1
 802ab22:	6163      	str	r3, [r4, #20]
 802ab24:	b003      	add	sp, #12
 802ab26:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802ab28:	ab01      	add	r3, sp, #4
 802ab2a:	466a      	mov	r2, sp
 802ab2c:	f7ff ffc8 	bl	802aac0 <__swhatbuf_r>
 802ab30:	9f00      	ldr	r7, [sp, #0]
 802ab32:	4605      	mov	r5, r0
 802ab34:	4639      	mov	r1, r7
 802ab36:	4630      	mov	r0, r6
 802ab38:	f7ff f914 	bl	8029d64 <_malloc_r>
 802ab3c:	b948      	cbnz	r0, 802ab52 <__smakebuf_r+0x46>
 802ab3e:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 802ab42:	059a      	lsls	r2, r3, #22
 802ab44:	d4ee      	bmi.n	802ab24 <__smakebuf_r+0x18>
 802ab46:	f023 0303 	bic.w	r3, r3, #3
 802ab4a:	f043 0302 	orr.w	r3, r3, #2
 802ab4e:	81a3      	strh	r3, [r4, #12]
 802ab50:	e7e2      	b.n	802ab18 <__smakebuf_r+0xc>
 802ab52:	89a3      	ldrh	r3, [r4, #12]
 802ab54:	6020      	str	r0, [r4, #0]
 802ab56:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 802ab5a:	81a3      	strh	r3, [r4, #12]
 802ab5c:	9b01      	ldr	r3, [sp, #4]
 802ab5e:	e9c4 0704 	strd	r0, r7, [r4, #16]
 802ab62:	b15b      	cbz	r3, 802ab7c <__smakebuf_r+0x70>
 802ab64:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 802ab68:	4630      	mov	r0, r6
 802ab6a:	f000 f81d 	bl	802aba8 <_isatty_r>
 802ab6e:	b128      	cbz	r0, 802ab7c <__smakebuf_r+0x70>
 802ab70:	89a3      	ldrh	r3, [r4, #12]
 802ab72:	f023 0303 	bic.w	r3, r3, #3
 802ab76:	f043 0301 	orr.w	r3, r3, #1
 802ab7a:	81a3      	strh	r3, [r4, #12]
 802ab7c:	89a3      	ldrh	r3, [r4, #12]
 802ab7e:	431d      	orrs	r5, r3
 802ab80:	81a5      	strh	r5, [r4, #12]
 802ab82:	e7cf      	b.n	802ab24 <__smakebuf_r+0x18>

0802ab84 <_fstat_r>:
 802ab84:	b538      	push	{r3, r4, r5, lr}
 802ab86:	4d07      	ldr	r5, [pc, #28]	@ (802aba4 <_fstat_r+0x20>)
 802ab88:	2300      	movs	r3, #0
 802ab8a:	4604      	mov	r4, r0
 802ab8c:	4608      	mov	r0, r1
 802ab8e:	4611      	mov	r1, r2
 802ab90:	602b      	str	r3, [r5, #0]
 802ab92:	f7fd fd39 	bl	8028608 <_fstat>
 802ab96:	1c43      	adds	r3, r0, #1
 802ab98:	d102      	bne.n	802aba0 <_fstat_r+0x1c>
 802ab9a:	682b      	ldr	r3, [r5, #0]
 802ab9c:	b103      	cbz	r3, 802aba0 <_fstat_r+0x1c>
 802ab9e:	6023      	str	r3, [r4, #0]
 802aba0:	bd38      	pop	{r3, r4, r5, pc}
 802aba2:	bf00      	nop
 802aba4:	20023fa8 	.word	0x20023fa8

0802aba8 <_isatty_r>:
 802aba8:	b538      	push	{r3, r4, r5, lr}
 802abaa:	4d06      	ldr	r5, [pc, #24]	@ (802abc4 <_isatty_r+0x1c>)
 802abac:	2300      	movs	r3, #0
 802abae:	4604      	mov	r4, r0
 802abb0:	4608      	mov	r0, r1
 802abb2:	602b      	str	r3, [r5, #0]
 802abb4:	f7fd fd2e 	bl	8028614 <_isatty>
 802abb8:	1c43      	adds	r3, r0, #1
 802abba:	d102      	bne.n	802abc2 <_isatty_r+0x1a>
 802abbc:	682b      	ldr	r3, [r5, #0]
 802abbe:	b103      	cbz	r3, 802abc2 <_isatty_r+0x1a>
 802abc0:	6023      	str	r3, [r4, #0]
 802abc2:	bd38      	pop	{r3, r4, r5, pc}
 802abc4:	20023fa8 	.word	0x20023fa8

0802abc8 <floor>:
 802abc8:	ec51 0b10 	vmov	r0, r1, d0
 802abcc:	f3c1 530a 	ubfx	r3, r1, #20, #11
 802abd0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802abd4:	f2a3 36ff 	subw	r6, r3, #1023	@ 0x3ff
 802abd8:	2e13      	cmp	r6, #19
 802abda:	460c      	mov	r4, r1
 802abdc:	4605      	mov	r5, r0
 802abde:	4680      	mov	r8, r0
 802abe0:	dc34      	bgt.n	802ac4c <floor+0x84>
 802abe2:	2e00      	cmp	r6, #0
 802abe4:	da17      	bge.n	802ac16 <floor+0x4e>
 802abe6:	a332      	add	r3, pc, #200	@ (adr r3, 802acb0 <floor+0xe8>)
 802abe8:	e9d3 2300 	ldrd	r2, r3, [r3]
 802abec:	f7f5 fbd6 	bl	802039c <__adddf3>
 802abf0:	2200      	movs	r2, #0
 802abf2:	2300      	movs	r3, #0
 802abf4:	f7f6 f818 	bl	8020c28 <__aeabi_dcmpgt>
 802abf8:	b150      	cbz	r0, 802ac10 <floor+0x48>
 802abfa:	2c00      	cmp	r4, #0
 802abfc:	da55      	bge.n	802acaa <floor+0xe2>
 802abfe:	f024 4400 	bic.w	r4, r4, #2147483648	@ 0x80000000
 802ac02:	432c      	orrs	r4, r5
 802ac04:	2500      	movs	r5, #0
 802ac06:	42ac      	cmp	r4, r5
 802ac08:	4c2b      	ldr	r4, [pc, #172]	@ (802acb8 <floor+0xf0>)
 802ac0a:	bf08      	it	eq
 802ac0c:	f04f 4400 	moveq.w	r4, #2147483648	@ 0x80000000
 802ac10:	4621      	mov	r1, r4
 802ac12:	4628      	mov	r0, r5
 802ac14:	e023      	b.n	802ac5e <floor+0x96>
 802ac16:	4f29      	ldr	r7, [pc, #164]	@ (802acbc <floor+0xf4>)
 802ac18:	4137      	asrs	r7, r6
 802ac1a:	ea01 0307 	and.w	r3, r1, r7
 802ac1e:	4303      	orrs	r3, r0
 802ac20:	d01d      	beq.n	802ac5e <floor+0x96>
 802ac22:	a323      	add	r3, pc, #140	@ (adr r3, 802acb0 <floor+0xe8>)
 802ac24:	e9d3 2300 	ldrd	r2, r3, [r3]
 802ac28:	f7f5 fbb8 	bl	802039c <__adddf3>
 802ac2c:	2200      	movs	r2, #0
 802ac2e:	2300      	movs	r3, #0
 802ac30:	f7f5 fffa 	bl	8020c28 <__aeabi_dcmpgt>
 802ac34:	2800      	cmp	r0, #0
 802ac36:	d0eb      	beq.n	802ac10 <floor+0x48>
 802ac38:	2c00      	cmp	r4, #0
 802ac3a:	bfbe      	ittt	lt
 802ac3c:	f44f 1380 	movlt.w	r3, #1048576	@ 0x100000
 802ac40:	4133      	asrlt	r3, r6
 802ac42:	18e4      	addlt	r4, r4, r3
 802ac44:	ea24 0407 	bic.w	r4, r4, r7
 802ac48:	2500      	movs	r5, #0
 802ac4a:	e7e1      	b.n	802ac10 <floor+0x48>
 802ac4c:	2e33      	cmp	r6, #51	@ 0x33
 802ac4e:	dd0a      	ble.n	802ac66 <floor+0x9e>
 802ac50:	f5b6 6f80 	cmp.w	r6, #1024	@ 0x400
 802ac54:	d103      	bne.n	802ac5e <floor+0x96>
 802ac56:	4602      	mov	r2, r0
 802ac58:	460b      	mov	r3, r1
 802ac5a:	f7f5 fb9f 	bl	802039c <__adddf3>
 802ac5e:	ec41 0b10 	vmov	d0, r0, r1
 802ac62:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802ac66:	f2a3 4313 	subw	r3, r3, #1043	@ 0x413
 802ac6a:	f04f 37ff 	mov.w	r7, #4294967295
 802ac6e:	40df      	lsrs	r7, r3
 802ac70:	4207      	tst	r7, r0
 802ac72:	d0f4      	beq.n	802ac5e <floor+0x96>
 802ac74:	a30e      	add	r3, pc, #56	@ (adr r3, 802acb0 <floor+0xe8>)
 802ac76:	e9d3 2300 	ldrd	r2, r3, [r3]
 802ac7a:	f7f5 fb8f 	bl	802039c <__adddf3>
 802ac7e:	2200      	movs	r2, #0
 802ac80:	2300      	movs	r3, #0
 802ac82:	f7f5 ffd1 	bl	8020c28 <__aeabi_dcmpgt>
 802ac86:	2800      	cmp	r0, #0
 802ac88:	d0c2      	beq.n	802ac10 <floor+0x48>
 802ac8a:	2c00      	cmp	r4, #0
 802ac8c:	da0a      	bge.n	802aca4 <floor+0xdc>
 802ac8e:	2e14      	cmp	r6, #20
 802ac90:	d101      	bne.n	802ac96 <floor+0xce>
 802ac92:	3401      	adds	r4, #1
 802ac94:	e006      	b.n	802aca4 <floor+0xdc>
 802ac96:	f1c6 0634 	rsb	r6, r6, #52	@ 0x34
 802ac9a:	2301      	movs	r3, #1
 802ac9c:	40b3      	lsls	r3, r6
 802ac9e:	441d      	add	r5, r3
 802aca0:	4545      	cmp	r5, r8
 802aca2:	d3f6      	bcc.n	802ac92 <floor+0xca>
 802aca4:	ea25 0507 	bic.w	r5, r5, r7
 802aca8:	e7b2      	b.n	802ac10 <floor+0x48>
 802acaa:	2500      	movs	r5, #0
 802acac:	462c      	mov	r4, r5
 802acae:	e7af      	b.n	802ac10 <floor+0x48>
 802acb0:	8800759c 	.word	0x8800759c
 802acb4:	7e37e43c 	.word	0x7e37e43c
 802acb8:	bff00000 	.word	0xbff00000
 802acbc:	000fffff 	.word	0x000fffff

0802acc0 <_init>:
 802acc0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802acc2:	bf00      	nop
 802acc4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 802acc6:	bc08      	pop	{r3}
 802acc8:	469e      	mov	lr, r3
 802acca:	4770      	bx	lr

0802accc <_fini>:
 802accc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802acce:	bf00      	nop
 802acd0:	bcf8      	pop	{r3, r4, r5, r6, r7}
 802acd2:	bc08      	pop	{r3}
 802acd4:	469e      	mov	lr, r3
 802acd6:	4770      	bx	lr
